---
title: 嵌入式生活小常识
sticky: 100
tag: 嵌入式
date: 2024-07-31
categories: 嵌入式
index_img: https://s2.loli.net/2024/08/15/VGghwBmsxZQ56EU.jpg
---

# 嵌入式生活小常识

## 1.VScode不能使用搜狗输入法

Ubuntu的应用市场下载的code，安装的VSCode是snap的削减版本，不支持中文。

阉割版的在Linux里面巨卡，而且还会出现各种bug，拒绝使用

解决办法：卸载后重新安装官方版本。

```
//首先先卸载vscode
sudo snap remove code

//从官网下载号deb文件包后，执行下面命令进行安装
sudo dpkg -i xxxxx
```

## 2.VM虚拟机和主机无法复制粘贴

安装VM-tools工具，虽然他有时候会坏，如果出现用了一段时间还不行，记得重新来一遍

```
sudo apt-get autoremove open-vm-tools
sudo apt-get install open-vm-tools
sudo apt-get install open-vm-tools-desktop
```

## 3.尽量少用root模式

使用root模式会出现很多程序无法运行的情况，因为你是在root环境下编译的，你必须使用root权限才可以执行

所以尽量不要进入root模式执行任务和操作各种任务

```
//权限不够时
sudo xxxxxxxxx

//进入root模式
su -
```

## 4.vscode自动保存

打开vscode，找到左下角的齿轮，点击之后选择设置

在搜索框中输入`Auto save`，之后会出现`File：Auto save`的选择，后面有四种选项，选择afterDelay就可以了，然后下面会出现多少毫秒进行保存，如果你不是1s中上千行的，500ms足够了。

```
off
这个不用多说，就是没有自动保存。
afterDelay
这个是在多少毫秒后自动保存。
onFocusChange
这个是编辑器失去焦点的时候，才会保存。也就是鼠标在编辑器之外的区域按下左键才会保存。
onWindowChange
这个是窗口失去焦点的时候，才会保存。也就是鼠标在整个VScode软件之外的地方点下左键才会保存。
```

## 5.Linux某个进程卡死

使用CTRL+C是常规的结束进程，但有时候并不能实现，会出现卡死的情况

如果遇到卡死情况可以CTRL+Z，先挂起进程，当然也可以直接从其他地方打开进程，然后在终端输入

```
//查找所有运行的进程和进程号
ps -aux

//通过进程号杀死这个进程
kill [process ID]
```

## 6.Linux系统各进程应用交互

<img src="https://s2.loli.net/2024/08/09/9siHtpvEgmK4CI8.png" alt="image.png" style="zoom:67%;" />

## 7.如何解决python执行pip出现 File“「stdin」的问题

其主要原因是由于pip是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能

pip是在直接在cmd中运行的，不需要进入到python中运行

解决的方法是关闭当前cmd窗口，重新进入，不需要进入python，直接输入pip命令就可以.

## 8.宝藏激活软件

进入该网站：[JETBRA.IN CHECKER | IPFS](https://3.jetbra.in/)

点击ipfs.io进入另一个网站[Some keys for testing - jetbra.in (ipfs.io)](https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/)

然后点击最上面蓝色的jetbra.zip进行下载，下载完之后，进入.\jetbra\jetbra\scripts该目录下，双击执行install-current-user.vbs，点击执行

等待10-20s之后，等到跳出done的弹窗后，再回到[Some keys for testing - jetbra.in (ipfs.io)](https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/)网页，找到所需软件，复制激活码输入

即可完成软件的激活，一般是两年时间，过期了重新激活就行

## 9.Linux系统构建C/C++编译

首先安装vscode的不同环境版本：https://code.visualstudio.com/

VScode官方教程，图文并茂：https://vscode.js.cn/docs/cpp/config-linux

之后在vscode的插件栏安装两个插件：C/C++和Code Runner

代码编辑完成后还不能直接运行。还需要配置两个json文件。

```
tasks.json 用来是设置指令编译代码。
launch.json 设置执行环境来执行代码。（如果不设置每次点击调试的时候都需要手动选择debugger）
```

新建.vscode文件夹，在文件夹里面新建两个文件，分别是tasks.json和launch.json，然后填入该代码即可运行c文件了

#### tasks.json

```
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "shell",
      "label": "C/C++: g++ build active file",
      "command": "/usr/bin/g++",
      "args": ["-g", "${file}", "-o", "${fileDirname}/${fileBasenameNoExtension}"],
      "options": {
        "cwd": "/usr/bin"
      },
      "problemMatcher": ["$gcc"],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Task generated by Debugger."
    }
  ]
}
```

#### launch.json

```
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "C/C++: g++ build and debug active file",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}/${fileBasenameNoExtension}",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "C/C++: g++ build active file"
    }
  ]
}
```

## 10.CH340和CP2102的区别

我们再使用单片机连接电脑的时候，需要注意芯片的串口转USB协议，而340和CP2102就是两种不同的协议

稳定性与速度上来说，CP2102的要好一些，而CH340，一般的使用是可以的，电路也简单

CP2102支持高速率传输，并且更加稳定，而CH340在高速传输时会有几率出现问题，但是成本低，并且应用范围更广

## 11.结构体指针和结构体变量的区别

结构体指针

```
struct Example {
    int node;
};

struct Example *ex;

ex->node = 10;
```

结构体变量

```
struct Example {
    int node;
};

struct Example ex;

ex.node = 10;
```

两个的访问形式不同，第一个是动态内存，数据是放在常量区，而指针放在栈上，所占用空间比较小，第二个是全部都在栈上，但是占用空间比较大

如果空间比较大，要求速度比较快，可以定义结构体变量，如果空间小，速度要求不是很快，可以使用指针结构体

## 12.静态函数和动态函数的区别

#### 静态函数

**效率高**：由于内存位置固定，访问速度较快。

**简单**：不需要动态分配和释放内存，管理简单。

#### 动态函数

**灵活性高**：可以在运行时动态加载和卸载函数，适应不同的需求。

**节省资源**：只在需要时加载和使用函数，避免了不必要的内存消耗。

## 13.进程隐藏如何查找

```
Ctrl+Z - 暂停进程并放入后台

jobs - 显示当前暂停的进程

bg N 使第N个任务在后台中止

fg N 使第N个任务在前台运行

bg, fg 不带 N 时表示对最后一个进程操作
```

## 14.进程查找

```
//根据名字查找
ps -ef | grep XXX

//查看所有静态进程
ps

//查看所有动态进程
top
```

## 15.什么时候分配内存

在写程序的时候，老是遇到有些需要分配内存，有些不需要分配内存，分配内存的都在堆上，不分配的都在栈上，栈是函数结束后自动释放，而堆需要手动释放，否则就会出现内存泄漏

我们常见函数的返回值也是在栈上的，因为返回后直接取值即可，不需要跨函数、跨线程操作

如何区别，啥时候使用呢，其实就看你这个数据在函数结束之后，里面的数据还要不要，会不会保留给其他函数或者线程使用，如果要的话，就需要分配内存，如果不要，则无需分配内存

## 16.内存对齐问题

内存块因为是以字节为单位，所以有时候7位6位，都会被系统认定为8位，所以会导致数据出现问题，因此，在结构体或者一些整块段的一定要考虑内存对齐，否则数据会出现丢失，比如下面的两个结构体

```
typedef struct
{
    long mtype;             // 消息类型，为正整数。用于区分不同类型的消息
    uint32_t origin;        // 消息来源的标识
    uint32_t buffNum;       // 命令标识
    size_t buffLen;         // 消息数据的实际长度
    uint8_t buffStr[DATA_LEN]; // 消息数据的缓冲区
} Msgbuff_t;

typedef struct
{
    long mtype;             // 消息类型，为正整数。用于区分不同类型的消息
    uint32_t origin;        // 消息来源的标识
    uint32_t buffNum;       // 命令标识
    uint8_t buffStr[DATA_LEN]; // 消息数据的缓冲区
    size_t buffLen;         // 消息数据的实际长度
} Msgbuff_t;
```

这两个结构体看似一样，但是输出的时候，就会出现不一样的结果了，第一个是正常输出的，因为内存对齐的时候，以靠近的为主，正好前四个的内存块为8、4、4、8，内存的分布是正常的，但是如果是第二个，假设DATA_LEN是100，那么就会出现buffLen前面会填充其他的字节，从而导致数据错乱

## 17.VScode乱码情况

```
打开VScode。
按下快捷键Ctrl+,（或选择菜单栏的“文件”->“首选项”->“设置”）。
在搜索框中输入“encoding”。
找到“Files: Encoding”选项，确保它设置为“UTF-8”。
如果需要，还可以设置“Editor: Detect Indentation”为“false”，以防止VScode自动检测并更改缩进。
```

