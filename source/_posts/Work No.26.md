---
title: Makefile文件
tag: C/C++
date: 2024-08-14
categories: C/C++编译
index_img: https://s2.loli.net/2024/08/14/Fd2frTmakCOvXUl.jpg
---

# Makefile文件

## 单Makefile文件编译

这个文件可以将c文件编译成机器可以解读的文件，使用GCC进行编译，所以使用前，必须保证有GCC环境

这个文件其实是将GCC编译过程编程一个可执行脚本，然后执行该脚本，完成一系列操作

#### 多个C文件生成多个可执行文件（多个main函数）

该文件的作用是编译同一文件下的所有C文件，每个文件夹都会生成一个可执行文件，放在哪个文件夹，就执行哪个文件夹的编译

```
# 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。
CC = gcc

# 定义编译选项：
# -Wall：启用所有常见的编译警告。
# -g：生成调试信息，用于调试程序。
CFLAGS = -Wall -g

# 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件
# $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表
SRCS = $(wildcard *.c)

# 生成与源文件同名的可执行文件列表：
# 这里，%.c 被替换为 %，即去掉 .c 扩展名。
# $(SRCS:.c=) 会将 SRCS 中所有的 .c 文件名的扩展名去掉，得到可执行文件名。
EXES = $(SRCS:.c=)

# 默认目标：'all' 目标是 Makefile 的默认目标。
# 如果运行 `make` 而不指定目标，默认会执行 'all' 目标。
# 这个目标依赖于所有的可执行文件名。
all: $(EXES)

# 规则：如何从源文件生成可执行文件。
# %: %.c 是一个模式规则：
# - $@ 表示目标文件（即可执行文件名）。
# - $< 表示第一个依赖文件（即源文件）。
# 这条规则定义了如何编译单个 C 文件生成与之同名的可执行文件。
$(EXES): %: %.c

# 使用 gcc 编译源文件，生成同名的可执行文件。
	$(CC) $(CFLAGS) -o $@ $<

# 编译完成后，输出生成的可执行文件的名称。
# @ 使这条命令不在命令行中显示，只显示输出的结果。
	@echo "Compiled $@"

# 清理目标：'clean' 是一个伪目标，用于删除所有生成的可执行文件。
# 这是为了保持工作目录的清洁，并且通常用在重新编译前。
clean:

# 删除所有在 EXES 中定义的可执行文件。
	rm -f $(EXES)

# .PHONY 是一个特殊的标志，用于声明 'all' 和 'clean' 目标是伪目标。
# 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。
.PHONY: all clean
```

#### 多个C文件生成一个可执行文件（只有一个main函数）

下面的代码是一个文件夹所有c文件只生成一个可执行文件

```
# 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。
CC = gcc

# 定义编译选项：
# -Wall：启用所有常见的编译警告。
# -g：生成调试信息，用于调试程序。
CFLAGS = -Wall -g

# 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件
# $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表
SRCS = $(wildcard *.c)

# 生成与当前目录同名的可执行文件名
# 使用 notdir 和 basename 函数提取当前目录名并生成对应的可执行文件名
EXE = $(notdir $(CURDIR))

# 默认目标：'all' 目标是 Makefile 的默认目标。
# 如果运行 `make` 而不指定目标，默认会执行 'all' 目标。
# 这个目标依赖于生成的可执行文件。
all: $(EXE)

# 规则：如何从源文件生成可执行文件。
# $@ 表示目标文件（即可执行文件名）。
# $^ 表示所有的依赖文件（即所有的源文件）。
$(EXE): $(SRCS)

# 使用 gcc 编译源文件，生成一个与文件夹同名的可执行文件。
	$(CC) $(CFLAGS) -o $@ $^

# 编译完成后，输出生成的可执行文件的名称。
# @ 使这条命令不在命令行中显示，只显示输出的结果。
	@echo "Compiled $@"

# 清理目标：'clean' 是一个伪目标，用于删除生成的可执行文件。
# 这是为了保持工作目录的清洁，并且通常用在重新编译前。
clean:

# 删除生成的可执行文件。
	rm -f $(EXE)

# .PHONY 是一个特殊的标志，用于声明 'all' 和 'clean' 目标是伪目标。
# 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。
.PHONY: all clean
```

## 多文件夹的Makefile编译

上面的makefile只能编译一个文件夹，如果我想在主文件夹编译所有文件夹，就需要写一个总的Makefile来对所有的文件夹进行调用

假设我的文件框架如下

```
project/
├── Makefile
├── src/
│   ├── file1.c
│   ├── file2.c
│   └── Makefile
├── lib/
│   ├── file3.c
│   └── Makefile
└── include/
    └── file4.c
```

所以主文件夹的Makefile文件内容如下

```
# 主Makefile

# 定义子目录的变量
# 这里 SUBDIRS 包含了所有需要编译的子目录，并将它们分行排列以便清晰展示
SUBDIRS = \
    src \
    lib \
    include

# 默认目标是编译所有子目录
# 当用户只输入 `make` 而不指定具体目标时，`all` 目标会被执行
all: $(SUBDIRS)

# 对于每个子目录，调用 `make` 命令并进入该目录 (`-C` 选项)
# 这会在每个子目录中执行它们自己的 `Makefile`
$(SUBDIRS):
	$(MAKE) -C $@

# 清理所有子目录的目标
# 这里定义了 `clean` 目标，当用户运行 `make clean` 时会被执行
# 这个目标会遍历所有子目录，并在每个子目录中执行 `make clean`
clean:
# 遍历所有子目录,在每个子目录中执行 `make clean`
	for dir in $(SUBDIRS); do \
		$(MAKE) -C $$dir clean; \
	done

# 伪目标声明
# .PHONY 是一个特殊的伪目标声明，表示 `all`, `clean`, `$(SUBDIRS)` 等目标不对应实际文件
# 即使当前目录下存在名为 `all` 或 `clean` 的文件，它们也不会被作为目标，而是执行与之对应的命令
.PHONY: all clean $(SUBDIRS)
```

完成这个编写之后呢，就可以在主文件或者子文件夹随便执行编译

## 文件编译操作

完成该文件创建和内容编写，就可以开始执行，执行前先清除原有的编译文件

```
make clean
```

再执行编译文件

```
make
```

最后输出一个可执行的脚本，输入即可执行

```
./<name>
```
