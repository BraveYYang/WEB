---
title: C语言内存分配学习
tag: C/C++
date: 2024-08-07
categories: C/C++
index_img: https://s2.loli.net/2024/08/02/BsDplXmnL3YjeQ7.jpg
---

# C语言内存分配学习

## 感谢博主：

[C语言：内存分配---栈区、堆区、全局区、常量区和代码区_c 内存布局-CSDN博客](https://blog.csdn.net/MQ0522/article/details/114823770)

[7-代码区 | 常量区 | 静态区(全局区) | 堆区 | 栈区 - Darren_pty - 博客园 (cnblogs.com)](https://www.cnblogs.com/darren-pty/p/14241169.html)

## 内存基础知识

C语言中，内存主要分为5个区，分别为栈区、堆区、全局/静态存储区、常量存储区、代码区。

栈区存放局部变量和函数，动态分配在堆上，由程序员负责释放。全局变量和静态变量存储在静态存储区，常量存储在常量区，代码区存放二进制代码。

<img src="https://s2.loli.net/2024/08/07/BYJIcUkN4OLtf76.png" alt="image.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/08/07/DS3xisJWTjr86lN.png" alt="image.png" style="zoom:45%;" />

## 栈区

栈区由编译器自动分配释放，由操作系统自动管理，**无须手动管理**。

栈区上的内容只在函数范围内存在，**当函数运行结束，这些内容也会自动被销毁**。

栈区按内存地址由高到低方向生长，其最大大小由编译时确定，**速度快，但自由性差，最大空间不大**。

但是对于栈来讲，一般都是有一定的空间大小的，默认的栈空间大小是1M（听博主诌了一个，反正就是很小）

栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出

栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

**栈区是先进后出原则**，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。先进后出的定义是比较有趣的，因为栈区主要为函数的和函数范围的调用，函数套函数套函数套n个函数之后，要释放内存，就可以从最后面的函数开始一个一个往外出，所以就形成先进后出

**临时创建的局部变量和const定义的局部变量存放在栈区。**

函数调用和返回时，其**入口参数和返回值存放在栈区。**

**局部变量不要定义的太大，**不然占用非常大的栈区空间，会导致栈溢出；

栈用于函数嵌套调用、中断切换时保存和恢复现场数据。调用函数不要有深层次的调用，调用函数的过程中栈区会不停的存储函数的一些相关的变量、地址之类的，如果有深层次函数递归的需要，尽量采用别的方式去替代它；

## 堆区

堆区由**程序员分配内存和释放**，系统不自动回收，所以一定要记得**申请了就要释放，以免溢出**。

堆区按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。

 C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。

一般来讲在 32 位系统下，**堆内存可以达到4G的空间**，从这个角度来看堆内存几乎是没有什么限制的。

对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。

释放的时候只能释放一次，不要重复释放，因为释放后的内存可能会去做别的事情，重复释放会出现问题，释放完后让这个指针最好指向空地址，避免下次用这个指针的时候出现地址错误。

系统提供了四个库函数来实现内存的动态分配：

（1）malloc(size) 在内存的动态存储区中分配一个长度为size的连续空间。

（2）calloc(n,size) 在内存的动态存储区中分配n个长度为size的连续空间。

（3）free(p) 释放指针变量p做指向的动态空间。

（4）realloc(p,size) 将指针变量p指向的动态空间大小改变为size。

## 全局静态区（static）

通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。

全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

## 常量区

**字符串**、**数字**等常量存放在常量区。

**const修饰的全局变量**存放在常量区。

程序运行期间，**常量**区的内容不可以被修改，程序结束后由系统释放。

## 代码区

程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。

字符串常量和define定义的常量也有可能存放在代码区。

表示程序所占用 FLASH 的大小，即代码区（FLASH）；

## 定义演示

```
int  a=0;   全局初始化区    

char *p1;   全局未初始化区    
int  main()    
{    
  int  b; //栈    
  char  s[]="abc"; //栈    
  char  *p2; //栈    
  char  *p3="123456"; //123456/0在常量区，p3在栈上。    

  static int c =0；//全局（静态）初始化区    
  p1 =  (char  *)malloc(10);  //分配得来得10和20字节的区域就在堆区
  p2  = (char  *)malloc(20);       
  strcpy(p3,"123456"); //123456/0放在常量区，编译器可能会将它与p3所指向的"123456"  优化成一个地方。    
} 
```

## RAM和ROM

#### RAM是“Random Access Memory”的缩写，被译为随机存储器。

根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种。

动态随机存储器DRAM的存储单元以电容的电荷来表示数据，有电荷代表1，无电荷代表0， 但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，因此它需要定期刷新操作，这就是“动态(Dynamic)”一词所形容的特性。 刷新操作会对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，藉此来保证数据的正确性。

静态随机存储器SRAM的存储单元以锁存器来存储数据，这种电路结构不需要定时刷新充电，就能保持状态(当然，如果断电了，数据还是会丢失的)，所以这种存储器被称为“静态(Static)”RAM。

#### ROM是“Read Only Memory”的缩写，意为只能读的存储器。

EEPROM(Electrically Erasable Programmable ROM)是电可擦除存储器。 EEPROM可以重复擦写，它的擦除和写入都是直接使用电路控制， 不需要再使用外部设备来擦写。而且可以按字节为单位修改数据，无需整个芯片擦除。现在主要使用的ROM芯片都是EEPROM。

FLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多， 且在擦除时，一般以多个字节为单位。

















