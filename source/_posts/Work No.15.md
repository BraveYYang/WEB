---
title: C语言结构体学习
tag: C/C++
date: 2024-08-05
categories: C/C++
index_img: https://s2.loli.net/2024/08/02/huNLZglFzj65MmO.jpg
---

# C语言结构体学习

## 感谢博主：

[C语言详解：结构体_c语言结构体语法-CSDN博客](https://blog.csdn.net/yourfriendyo/article/details/119544221)

[C语言结构体（struct）最全的讲解（万字干货）_struct a *b(const char *name)-CSDN博客](https://blog.csdn.net/lyh290188/article/details/104326450)

## 结构体理论知识

结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。

研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。

**结构体的大小不是结构体元素单纯相加就行的**，因为我们现在主流的计算机使用的都是32Bit字长的CPU，**对这类型的CPU取4个字节的数要比取一个字节要高效**，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是**内存对齐**的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。**程序员可以通过预编译命令#pragmapack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。**

```
struct S1
{
	char c1;
	int i;
	char c2
};

struct S2
{
	char c1;
	char c2;
	int i;
};
```

`S1`和`S2`类型的成员一样，但是`S1`和`S2`所占用的空间不一样，`S2`相较于`S1`所占空间较小。

**所以，让占用空间小的成员尽量集中在一起，这样会使整个内存空间变小**

在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。

在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。

在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。

## 结构体声明

使用匿名结构体类型创建变量就**只能在变量列表中创建，而且只能一次**，不能在`main()`函数中创建变量了

```
//匿名结构体类型，不完全声明
struct
{
	char c;
	int i;
	double d;
}s1,s2;//匿名结构体类型创建变量的唯一方式，就是在变量列表中创建
```

首先使用关键字struct，它表示接下来是一个结构体。在结构体声明中，struct book所起到的作用就像int等基础数据类型名作用一样。

后面是一个可选的标志（student），它是用来引用该结构体的快速标记。

接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；

在结束花括号后的分号表示结构体设计定义的结束

封号后面额外添加使用字符例如CXSW，这个变量就包含了其student结构体中的所有元素

```
struct tag {//tag 是结构体标签。
    member-list//member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。
    member-list
    member-list  
    ...
} variable-list ;//variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。

struct tag variable-list;//等效于上面定义
```

## 结构体初始化

结构体变量的**初始化**有2种方式，但是也有区别：

在结构体变量的创建时，用`{}`进行初始化。此时必须严格按声明中成员变量的顺序来初始化

```
struct Stu
{
 char name[20];//名字
 int age;//年龄
 char sex[5];//性别
 char id[20];//学号
};

struct Stu s = { "张三", 20, "男", "20230818001" };
```

或者在结构体后直接定义

```
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};
```

用`{.成员变量 = , .成员变量 = }`(使用到`.`操作符)来初始化变量。

```
struct Stu
{
 char name[20];//名字
 int age;//年龄
 char sex[5];//性别
 char id[20];//学号
};

struct Stu s2 = { .age = 18, .name = "lisi", .id = "20230818002", .sex = "⼥" };
```

**浮点数在内存中有可能是不能精确保存的。**那根据这一点，在我们对浮点数进行比较大小时，我们就不能简单地对2个数据进行 `==`是否相等的判断，而是有**一定的误差**。

## 结构体的引用

结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

```
//此结构体的声明包含了其他的结构体
struct COMPLEX
{
    char string[100];
    struct SIMPLE a;
};

//此结构体的声明包含了指向自己类型的指针
struct NODE
{
    char string[100];
    struct NODE *next_node;
};
```

在结构中包含一个类型为该结构本身的成员

```
//错误的定义
struct Node//定义了一个节点。节点本身要包涵自己的数据，和指向下一节点
{
 	int data;
 	struct Node next;//“next”使用未定义的 struct“Node”,这是错误的写法
};
```

这个结构体类型的大小我们是否可以得出来,通过`sizeof(struct Node)`分析可以知道因为**一个结构体中再包含一个同类型的结构体变量**，这样会使得结构体的大小**无穷大**，这是不合理的。

```
//正确的定义
struct Node//定义了一个节点。节点本身要包涵，自己的数据和指向下一节点的指针
{
 	int data;//数据域,大小为4个字节
 	struct Node* next;//指针域，大小为4或8个字节
};
```

我们需要定义一个指针类型，准确的指向所需要的位置，这样的结构体大小是可以进行计算的，就不会出现错误

## typedef 重定义结构体

该结构体就有了两种创建变量的方式`struct human man`和`hu man`都行，只是将`struct human`重新取个名字叫`hu`。本质上还是类型是不占用空间的，只有创建变量时才会开辟空间。当然使用`typedef`就不能在声明结构体的后面直接创建全局变量了。

```
typedef struct human
{
	char name[20];
	int age;
	char sex[10];
	char id[20];
}hu;
int main() {
    //1.
	struct human man;
	//2.
    hu man;
	return 0;
}

```

## 结构体访问

有的时候有可能我们得到的是一个指向该结构体的指针。这时候我们就需要操作符`->`，同样也是两个操作数，`->`是专门在访问结构体时使用指针的方法，更高效。

```
struct S {
	int a;
	char c;
	double d;
};
struct T {
	struct S s;
	char name[20];
	int num;
};

struct T t = { {10, 'x', 1.00}, "yourfriendyo", 21 };
struct T* pt = &t;
printf("%d %c %lf %s %d\n", pt->s.a, pt->s.c, pt->s.d, pt->name, pt->num);
```

## 结构体的位段

位段就是限制结构体里面每个参数所要占用的字节，比如一个变量`age`表示一个人的年龄，设定1-100岁，**那么给int变量占4个字节就有点浪费空间了，那么我们可以限制一下**。`位段`可以在一定程度上减少空间的浪费

```
struct A1
{
 int _a:2;//数字部分表示变量只占多少个2进制位，也就是占多少比特位
 int _b:5;
 int _c:10;
 int _d:30;
 int _e:50;//这一行是错误的，int类型的比特位数就只有32位，50超出了限制，会报错
};

struct A2
{
 int _a;
 int _b;
 int _c;
 int _d;
};


int main()
{
	printf("%zd\n",sizeof(struct A1));//结果为8
	printf("%zd\n",sizeof(struct A2));//结果为16
	return 0;
}
```

## 枚举

枚举就是一一列举，把所有可能的值都按照顺序罗列，其实也就是统一的宏定义，而且不需要从1输到100，他会自己安装顺序进行排序，并且如果在中间进行取值定义，后面的值也会发送改变，可以从下面看出来整体的变化，**修改了初始值的常量**开始后面的枚举常量表示的数字都递增+1，前面的保持不变

```
enum Sex//性别
{
	//该枚举类型的三种可能取值
	//它们都是常量，被称为枚举常量,默认从0开始，递增+1
 	MALE,//0
 	FEMALE,//1
 	SECRET//2
};
enum Sex//性别
{
	
 	MALE=7,//7
 	FEMALE=9,//9
 	SECRET=6//6
};
enum Sex//性别
{
	
 	MALE,//0
 	FEMALE=8,//8
 	SECRET//9
};
```

并且，枚举也遵循typedef的重定义，可以利用变量进行对其中的值进行输入或者调整

```
typedef enum {
	X,
	Y,
    SIZE
}t;
```

