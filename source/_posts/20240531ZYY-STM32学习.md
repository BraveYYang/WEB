---
title: STM32学习第一天
tag: STM32
time: 2024/07/23
categories: 单片机
---

# 20240531ZYY-STM32学习

## STM32固件库整体结构

 	1-汇编编写的启动文件
 	startup_stm32f10x_hd.s:设置堆栈指针、设置PC指针、初始化中断向量表、配置系统时钟、调用c库函数_main最终去到c的世界
 	
 	2-时钟配置文件
 	system_stm32f10x.c:把外部时钟HSE=8M，经过PLL倍频为72M。
 	
 	3-外设相关的
 	stm32f10x.h:实现了内核之外的外设的寄存器映射xxx:GPIO、USRAT、I2c、SPI、FSMC
 	stm32f10x_xx.c:外设的驱动函数库文件
 	stm32f10x_xx.h:存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库函数的声明
 	
 	4-内核相关的
 	CMSIs - Cortex 微控制器软件接口标准
 	core_cm3.h:实现了内核里面外设的寄存器映射
 	core_cm3.c
 	NVIC(嵌套向量中断控制器)、sysTick(系统滴答定时器)
 	
 	ST公司裁剪后的内核文件
 	misc.h
 	misc.c
 	
 	5-头文件的配置文件
 	stm32f10x_conf.h:头文件的头文件
 	/ / stm32f10x_usart.h
 	/ / stm32f10x_i2c.h
 	/ / stm32f10x_spi.h
 	/ / stm32f10x_adc.h
 	/ / stm32f10x_fsmc.h
 	
 	6-专门存放中断服务函数的c文件
 	stm32f10x_it.c
 	stm32f10x_it.h
 	
 	中断服务函数你可以随意放在其他的地方，并不是一定要放在stm32f10x_it.c
 	
 	#include "stm32f10x.h"//相当于51单片机中的#include <reg51.h>
 	int main (void)
 	{
 		//来到这里的时候，系统的时钟已经被配置成72M
 	}

### 文件设置

#### 1.设置创建项目文件夹，并在文件夹内设置四个文件

#### ①Libraries：

```
内核相关文件（core_cm3.c、core_cm3.h）

启动文件（startup_stm32f10x_hd）

时钟配置文件（system_stm32f10x.c、system_stm32f10x.h）

外设文件（stm32f10x.h和固件库h.c文件）
```

#### ②Project

```
KEIL工程文件

输出HEX文件，用于准备烧录
```

#### ③User

```
用户程序放置

main.c文件
```

#### ④Doc

```
README.md文档
```

#### 2.打开工程，创建五个文件夹

```
STARTUP：导入启动文件

CMSIS：导入内核文件和时钟配置文件

FWLIB：导入固件库

USER：导入main.c文件和用户文件

DOC：导入README文件
```

#### 3.所有设计到头文件的文件夹配置到系统环境中

#### 4.开始编译全文件

## 程序逻辑

#### 1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件

#### bsp_led.c

主要用来构建所需程序的函数体（比如配置、驱动等等）

#include "bsp_led.h"用来调用各种东西

#### bsp_led.h

主要用来给bsp_led.c文件提供库函数支持

以及bsp_led.c所需的宏定义，都可以放在该文件夹中

将bsp_led.c中的函数放入

采用#ifndef和#endif的方式，实现头文件的判断编译，防止多次编译报错

```
#ifndef __BSP_LED_H
#define __BSP_LED_H

#include "stm32f10x.h"

#define GPIO_G_PIN         GPIO_Pin_0
#define GPIO_G_PORT        GPIOB
#define GPIO_G_CLK         RCC_APB2Periph_GPIOB

void delay(uint32_t count);
void LED_GPIO_Config(void);

#endif /* __BSP_LED_H */
```

#### 2.在主函数中调用#include "bsp_led.h"即可使用bsp_led.c中编写的各类函数

## GPIO设置

```
//定义关键字
GPIO_InitTypeDef  GPIO_InitStruct;

//选择引脚，将硬件部分定义成宏，方便移植
#define GPIO_G_PIN         GPIO_Pin_0
GPIO_InitStruct.GPIO_Pin = GPIO_G_PIN;

//选择输出方式
GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;

//选择速度
GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;

//配置引脚
GPIO_Init(GPIO_G_PORT,&GPIO_InitStruct);

//启动时钟
RCC_APB2PeriphClockCmd(GPIO_G_CLK, ENABLE);
```

## 中断使用

### 内部中断NVIC

配置过程中，首先初始化 NVIC_InitTypeDef 结构体，配置内部中断线、配置中断优先级分组，设置抢占优先级和子优先级，使能中断请求，最后写入初始化结构体。

在启动文件 startup_stm32f10x_hd.s 中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在 stm32f10x_it.c 这个库文件中。

NVIC_IROChannel：用来设置中断源，不同的中断中断源不一样

系统就在中断向量表中找不到中断服务函数的入口，直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。

NVIC_PriorityGroupConfig 是整个程序中只需要设置一次，多次设置无效，他只是一种配置方式，具体的分类有主优先级和子优先级有关，他只是提供不同的组合方式，需要根据项目需求进行设计

从代码布局逻辑来说,NVIC_PriorityGroupConfig 适合放在 main() 函数中。

```
	//定义结构体
	NVIC_InitTypeDef  NVIC_InitStruct;
	
	//NVIC初始化
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup);//配置组优先级（0，1，2，3，4，5）
	NVIC_InitStruct.NVIC_IRQChannel = KEY_INT_EXTI_IRQ;//配置内部中断线
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = PreemptionPriority;//配置抢占优先级
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = SubPriority;//配置子优先级
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//使能中断通道
	NVIC_Init(&NVIC_InitStruct);//将结构体进行定义
```

### 外部中断EXTI

EXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的 20 个中断/事件线。每个中断/事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。 EXTI 可以实现对每个中断/事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。

所以EXTI的配置，首先需要中断结构体初始化、打开AFIO中断线管理器的时钟、配置中断/事件线（20条）、选择中断屏蔽器输入位，并使能、选择中断/事件触发类型、选择上升沿或下降沿检测，最后写入初始化结构体

```
//定义结构体
	GPIO_InitTypeDef  GPIO_InitStruct;
	EXTI_InitTypeDef  EXTI_InitStruct;
	
	//配置中断优先级
	EXTI_NVIC_Config();
	
	//按键引脚初始化
	RCC_APB2PeriphClockCmd(KEY_INT_GPIO_CLK, ENABLE);//打开按键时钟
	GPIO_InitStruct.GPIO_Pin = KEY_INT_GPIO_PIN;//按键引脚定义
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;//选择输入输出模式（浮空输入）
	GPIO_Init(KEY_INT_GPIO_PORT,&GPIO_InitStruct);//将结构体进行定义
	
	//中断配置初始化
	RCC_APB2PeriphClockCmd(KEY_INT_EXTI_CLK, ENABLE);//打开AFIO时钟
	GPIO_EXTILineConfig(KEY_INT_EXTI_PORTSOURCE, KEY_INT_EXTI_PINSOURCE);//产生中断的事件线（Px0属于Line0，Px1属于Line1...）
	
	EXTI_InitStruct.EXTI_Line = KEY_INT_EXTI_LINE;//中断屏蔽器输入位的选择，以供EXTI_LineCmd精准使能
	EXTI_InitStruct.EXTI_LineCmd = ENABLE;//中断屏蔽器使能（控制中断接受IMR/EMR）
	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;//选择触发类型（中断触发和事件触发）
	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;//选择模式（上升沿和下降沿）
	EXTI_Init(&EXTI_InitStruct);//将结构体进行定义
```

前面 4 个线路有单独的中断函数，后面 5 至 9 和 10 至 15 线路使用 复用的思想思考，区分出什么是可以唯一标识的，什么是复用的，EXTI_Lines 在寄存器中都是一一对应状态标位, 中断函数复用，**因此在 EXTI9_5_IRQHandler 和 EXTI15_10_IRQHandler 的中断函数里面使用多次EXTI_GetITStatus 函数来判断出线路。**  

```
	if(EXTI_GetITStatus(EXTI_Line10) != RESET)
	{
		LED_TOGGLE;
	}
	if(EXTI_GetITStatus(EXTI_Line14) != RESET)
	{
		LED_TOGGLE;
	}
```

## 时钟SysTick

时钟一共有五个部分，重装载寄存器、递减计数器、时钟源、时钟中断控制器、校准数值寄存器（用不到）

![SysTick.png](https://s2.loli.net/2024/07/27/mbKvAFMpZEVXnd4.png)

#### 重装载寄存器 LOAD

作用就是当递减计数器递减到零时，重新装载计数器，再次进行递减计数

#### 递减计数器 VAL

读取时会返回该递减值，如果在该位写入1，则会清理，同时也会清除时钟中断控制器里面的COUNTFLAG

#### 时钟源

提供递减计数器工作的动力源，有外部晶振提供

#### 时钟中断控制器

```
16-COUNTFLAG：如果上次读取该寄存器后，再递减到1，则该位置为1

2-CLKSOURCE：时钟源选择，0=AHB/8=72/8=9M，1=AHB=72M

1-TICKINT：递减计数器到零时发出异常请求

0-ENABLE：控制器的使能位
```

#### 代码Demo

```
#include "bsp_systick.h"

#if 0

static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{ 
	//判断ticks传入的值是否大于 2^24，如果大于则返回错误值
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
  
	//初始化寄存器reload的值                                  
  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
	
	//配置时钟中断优先级，1左移四个位，再减1，配置的是15，最低等级
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  
	//初始化count的值为0
	SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
	
	//时钟配置成72M，使能中断，使能systick
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
                   SysTick_CTRL_TICKINT_Msk   | 
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
  return (0);                                                  /* Function successful */
}

#endif

void SysTick_Delay_us(uint32_t us)
{
	uint32_t i;
	
	//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒
	SysTick_Config(72);
	
	for(i=0;i<us;i++)//进行输入值的循环，循环结束则退出
	{
		while (!((SysTick -> CTRL) & (1<<16)));//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环
	}
	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//将使能位关闭，停止计时，退出循环
}

void SysTick_Delay_ms(uint32_t ms)
{
	uint32_t j;
	
	//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒
	SysTick_Config(72000);

	
	for(j=0;j<ms;j++)//进行输入值的循环，循环结束则退出
	{
		while (!((SysTick -> CTRL) & (1<<16)));//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环
	}
	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//将使能位关闭，停止计时，退出循环
}

```

## 通信

串行通信：串行是一次性发一个数据过去，所以一般就两根线，一个收一个发，传输距离远，抗干扰能力强，例如UART、IIC、SPI...

并行通信：并行是一次性发多个数据，多根线同时发，传输速度快，但是抗干扰能力弱，传输距离短，例如SDIO(4根线)、FSMC(8根线)...

全双工：可以同时收发数据

半双工：不可以同时收发数据，需要收完再发或者发完再收

单工：只能进行收或者发数据，无法同时进行

同步传输：同步是有时钟信号的，只有时钟使能的时候，信号才有用，但是对时钟要求高，时钟的方波不能有尖峰等

异步传输：有通讯起始位、通讯内容主题、数据校验位、通信停止位

比特率：每秒钟传输二进制位数，bit/s

波特率：每秒钟传输码元个数

码元：要传输的信息

RS232：+15V传输0，-15V传输1，需要DB9接口，使用电平转换芯片，用于工业设备的直接通信，能够利用高电平防止静电干扰





## 其他

### 资源

keil软件芯片包：[Arm Keil | Keil STM32F1xx_DFP](https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/)

### 报错

Reason: Pack [schema](https://so.csdn.net/so/search?q=schema&spm=1001.2101.3001.7020) version ‘1.4.0’ is not supported. Maximum supported [version](https://so.csdn.net/so/search?q=version&spm=1001.2101.3001.7020) is’1.3’. Please update to a newer version of MDK-ARM. 使用keil5 MDK安装芯片包时出错（软件版本过低）

![image-20240531210625344.png](https://s2.loli.net/2024/07/25/HgserB9cVJfObdM.png)

#### 解决方案

根据弹窗的内容我们可知我们需要对MDK进行升级，在升级时我们直接覆盖安装。

官方下载渠道：https://www.keil.com/download/product/
填写相关信息便可进行下载。

破解keil出现出现you are not logged in as an administrator....的问题，请退出软件，右击软件图标，以管理员身份运行，重新进行安装操作！然后就安装成功了！
