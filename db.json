{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/Image/image-20240724153741084.png","path":"Image/image-20240724153741084.png","modified":0,"renderable":0},{"_id":"source/Image/image-20240724154427037.png","path":"Image/image-20240724154427037.png","modified":0,"renderable":0},{"_id":"source/Image/image-20240724154237430.png","path":"Image/image-20240724154237430.png","modified":0,"renderable":0},{"_id":"source/Image/image-20240724162639684.png","path":"Image/image-20240724162639684.png","modified":0,"renderable":0},{"_id":"source/Image/image-20240724155135615.png","path":"Image/image-20240724155135615.png","modified":0,"renderable":0},{"_id":"source/Image/image-20240724161404111.png","path":"Image/image-20240724161404111.png","modified":0,"renderable":0},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1}],"Cache":[{"_id":"source/Image/image-20240724153741084.png","hash":"f081610bccd4b7aeaa2f570adc438917765cc952","modified":1722389741283},{"_id":"source/Image/image-20240724154427037.png","hash":"2f95444cbb2285a578131ce272065a1c1aea7af9","modified":1722389741283},{"_id":"source/about/index.md","hash":"0d75ac7ef7eb986751e14f8f936adef22f6f1e83","modified":1722389741293},{"_id":"source/Image/image-20240724154237430.png","hash":"98d3dee917bd9d23fbeb8260c9e5c08cf8c0eecc","modified":1722389741283},{"_id":"source/_posts/20231204ZYY-Markdown用法.md","hash":"5636f6bc789545932f2c3dfe5dbaabda7957f6c9","modified":1722396632407},{"_id":"source/_posts/20231204ZYY-电气路设计.md","hash":"dd37e724a779dc1249db217fac9f8b0aaf8045f1","modified":1722396757888},{"_id":"source/Image/image-20240724161404111.png","hash":"b3f3ba5f0832da3a250f777a0bde4726a95cae70","modified":1722389741283},{"_id":"source/_posts/20231204ZYY-文献检索.md","hash":"fc7d791198212c638dea1f16a58f1b49f20d5600","modified":1722570798960},{"_id":"source/_posts/20240201ZYY-控制工程学习笔记.md","hash":"378d6e6fb0b3294d9d9b242c903a3c504a96bf16","modified":1722857633987},{"_id":"source/_posts/20240529ZYY-1_TCP通信.md","hash":"f5f55514b98e81af91b8543d4b3ef7d074230d37","modified":1722396716854},{"_id":"source/_posts/20240319ZYY-FOC无刷电机控制.md","hash":"f8d19e10f37e2775af70a49f611ae95ea3fa7092","modified":1723195069181},{"_id":"source/_posts/STM32固件库及工程文件概念.md","hash":"bd38986e55490aa8e4aaa8fa2370a82c8f7c0b1f","modified":1722396814039},{"_id":"source/_posts/20240429ZYY-Hi3861开发.md","hash":"e6d6b4f5ffe5a204e32a1c299294ce1d91edb47a","modified":1722396720809},{"_id":"source/_posts/20231204ZYY-如何制作一份优秀的路演PPT.md","hash":"ba4e1f8245e26cadcc19e3683a5dbd49b249456e","modified":1722396752669},{"_id":"source/_posts/STM32的中断使用.md","hash":"d9a39317f3b65adfd3463ee1fae8d3e7b53d70ee","modified":1722396825871},{"_id":"source/_posts/STM32的USART发送测试.md","hash":"1b1c414be6437aaeb6775dd0bbe0dd2d959899d7","modified":1722473739078},{"_id":"source/_posts/STM32的时钟学习.md","hash":"03982f9579ca4cd7d781cc87bc65498a30e0c454","modified":1722396829967},{"_id":"source/_posts/Work No.1.md","hash":"99d7afeba8dc649f977aefcd86387ee31d9349c9","modified":1722396809311},{"_id":"source/_posts/Work No.6.md","hash":"3d5f0b0b070a88180f93462a2f8e907588d23dbc","modified":1722396776525},{"_id":"source/_posts/STM32程序逻辑及GPIO使用.md","hash":"5fa15aac60ddccb15e01e8fae6f29491e272a9ec","modified":1722397529577},{"_id":"source/_posts/Work No.7.md","hash":"e3a0a6e299cdf64bfd57e7ccb39fa2eb5dad21de","modified":1722396787117},{"_id":"source/_posts/Work No.4.md","hash":"f449d0f5939a7a3c1a5094dd809cea337c4c5406","modified":1722396800887},{"_id":"source/_posts/Work No.8.md","hash":"bca438c26f54bd41d7fa867362f8343ccdb4a07f","modified":1722396764866},{"_id":"source/_posts/Work No.5.md","hash":"299faf12910ffd3c6d3df422c38fb4553de42f5c","modified":1725244287866},{"_id":"source/Image/image-20240724155135615.png","hash":"3feb9a270e960d70a209ad4edf77bdcc17e2aaf8","modified":1722389741283},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1722389741313},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1722389741293},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1722389741293},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1722389741296},{"_id":"themes/fluid/README_en.md","hash":"d4b5e8505710ff96363be4cf6be0dbbe27db6d1c","modified":1722389741296},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1722389741296},{"_id":"themes/fluid/README.md","hash":"8cb27280346eae05984de91f79562a38a7549398","modified":1722389741296},{"_id":"themes/fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1722389741296},{"_id":"themes/fluid/_config.yml","hash":"6d26be71075b0fb793081ea32292c00f155a30a3","modified":1723521657566},{"_id":"themes/fluid/package.json","hash":"3138d23e7d9b23ef758818bb903d0c7f96f6fec1","modified":1722389741306},{"_id":"themes/fluid/languages/de.yml","hash":"c52ce73a291fa50953edbd11c1dfb1cc7cab52c2","modified":1722389741296},{"_id":"themes/fluid/languages/es.yml","hash":"7fcd16cd363f1a166a3270c23c0660eff7475744","modified":1722389741296},{"_id":"themes/fluid/languages/en.yml","hash":"2839da328f197cf90cafdf2b538fcd027ab6cfba","modified":1722389741296},{"_id":"themes/fluid/languages/eo.yml","hash":"76d2920b49c8d2489c37514489545d0fc4eac834","modified":1722389741296},{"_id":"themes/fluid/languages/ru.yml","hash":"02d8ad186a2d52c20b76b35f406a728c6486f820","modified":1722389741296},{"_id":"themes/fluid/languages/ja.yml","hash":"411aa49e2e8dea90a6d8cc2dc92f264609ea273b","modified":1722389741296},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"aac765cccef9f9044c4a88941fd01ba1883178fc","modified":1722389741296},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"ac4a812679df9550cda05295149a3f329af21d7e","modified":1722389741296},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"676b3ee8a16d796b4a898a9e5be2f52c372055ed","modified":1722389741296},{"_id":"themes/fluid/layout/404.ejs","hash":"c49974dcbda02fe720498398e9778826335459c0","modified":1722389741296},{"_id":"themes/fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1722389741296},{"_id":"themes/fluid/layout/about.ejs","hash":"bd3ede2a5f45c5256cf8f883bb8fcca645834869","modified":1722389741296},{"_id":"themes/fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1722389741296},{"_id":"themes/fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1722389741296},{"_id":"themes/fluid/layout/index.ejs","hash":"dde1f6a27c8d09c38850a691089937f181b6c035","modified":1722389741296},{"_id":"themes/fluid/layout/layout.ejs","hash":"d4ffeb7eff398dea154340794bd277f75ddeedef","modified":1722389741296},{"_id":"themes/fluid/layout/post.ejs","hash":"c8da695dc1b01b715909ae6f1052ccaebdf9db4c","modified":1722389741296},{"_id":"themes/fluid/layout/links.ejs","hash":"fbed4b3d1e475b3de9d8ce05362abcc658a53408","modified":1722389741296},{"_id":"themes/fluid/layout/page.ejs","hash":"8ba210724c023d45a4564415762f3da299bd1d0e","modified":1722389741296},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1722389741306},{"_id":"themes/fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1722389741296},{"_id":"themes/fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1722389741306},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"fea63a9a5c3befd8783705eed09adf1b596a6203","modified":1722389741296},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1722389741296},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7d7c1e5a1da6b4f7be6685beb4798ec76d5efd31","modified":1722389741296},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"07e24578c25fcaca94618fd86569887dadf7a276","modified":1722389741296},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1722389741296},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1722389741296},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1722389741306},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1722389741306},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1722389741296},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"67637461e3f94f9e9675369eb7ff015355d9ec54","modified":1722389741306},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"fc31c7c6692424af1e08cd5e273a5a5814f9c577","modified":1722389741296},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bc9ba08d1d871394ee1c3a1cc2f21dc343f515a","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1722389741306},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"dcdbe1698a6ee61f741c29ef560f859f66ffa32c","modified":1722389741296},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"14a207a7d4e329382ab5d4e1da1ef85ff043daba","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"3b67d50050158423c8fa47f1de6aedcfe916637b","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"0bb33314aa5cfe326ab9bb14b545e343e4db4193","modified":1722389741306},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"f57be245e6e7228673e1dec3a3477e731492c5c1","modified":1722389741306},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"3fb72d3c2224c32d861a6e8a85e78a8b67e6a244","modified":1722389741306},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"3550976efc94500284795f13485f5a1765fc120b","modified":1722389741306},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"33427308ca29f1d76336c83e704571c9de75df02","modified":1722389741306},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"0a883fd4834db4c070bbe5f07bb3f3599d01f3d6","modified":1722389741306},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1722389741306},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1722389741306},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"a93e2603021ad38714e870399767bea24e7cbe3e","modified":1722389741306},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1722389741306},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e300ec4ee6c63464859ab000e987bf8dd7db4025","modified":1722389741306},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1722389741306},{"_id":"themes/fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1722389741306},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1722389741306},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"474b00a57f43dbe7bc2876d637ece4214d016c06","modified":1722389741306},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1722389741306},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1722389741306},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"0c14869e15f7dc615c8353765569644238f38f2d","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"1ce9094faec6204949cdaf604aaf9200787e4218","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"70646e7f7a7684e12b298cd8a36fbea2814c3635","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"0289f61834fd21a8f958f8e18b395a989b285682","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"52b8954ae0eff5eb66a3841b37f144336b8f0866","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"3668304d08c48b68d532532921a12069a2736150","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"b5cd435b27f090939b6051bef41a38a3376044ac","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"89fc9f663a1091911b79ab9697c09446d16184f9","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1722389741296},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1722389741313},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1722389741313},{"_id":"themes/fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1722389741313},{"_id":"themes/fluid/source/js/boot.js","hash":"33bb7c8255d2e3c93a1bea8c9221399b3a868a63","modified":1722389741313},{"_id":"themes/fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1722389741313},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1722389741313},{"_id":"themes/fluid/source/js/color-schema.js","hash":"87f6d16dd685da56982925798e12b47d056e9e6e","modified":1722389741313},{"_id":"themes/fluid/source/js/events.js","hash":"fc94b4d640a1440fd9a5a46342971b42aa0fa3f6","modified":1722389741313},{"_id":"themes/fluid/source/js/local-search.js","hash":"491021125d2579e841c83f36d3ab790d1eab9d1e","modified":1722389741313},{"_id":"themes/fluid/source/js/leancloud.js","hash":"e9ad1b5659f0af867174687daa0ecf4375e40b75","modified":1722389741313},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1722389741313},{"_id":"themes/fluid/source/js/plugins.js","hash":"753c2cf95f2659fef80277b895f4da10c8888c72","modified":1722389741313},{"_id":"themes/fluid/source/js/utils.js","hash":"9d0423db40a787f3b19968205b9ed92a848c9153","modified":1722389741313},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1722389741313},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1722389741313},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1722389741313},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1722389741313},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1722389741306},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"9b1934c61dc78622a07da554413f6ad31854576d","modified":1722389741306},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da987411ae4a4e6896a9b8af1fce6209192af28e","modified":1722389741306},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"d103e4bf612b2445bb136712d57b81e784a313e2","modified":1722389741306},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1722389741306},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1722389741306},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1722389741306},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"d400e5721af28cefecaf50b46c82dcdde4cda4a8","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"66995ec9dab10ed35c2a775010c447113c6848d4","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"938eb60413ae8af83ffeaba4d85df88387cdd5be","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"99fe072ec17e83332325b3c59464bd39ea1f5a96","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"a84d8dcb44f5f6289ef09db4d02ab14de72c2c87","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"ed2348bd9f56d19836b508c52ce9cc9122471f51","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"6e0f0095e1cb1c0d89b6697ebcd33656b4e3e14c","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"e5219b14410066bf8ab491379aca797304b4a914","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"8a4ea62c46f9a75c94096a27b2d3f5c10a2f82e5","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"018cab52ff696a6c78ebc01e10237a90a0c33603","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"03c7c69fbb1754fdccfa18671aac23b8637b869e","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"d0f06fb482e3a8f9a53dfd94c4e4a65a43f1ff34","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"110e45e2d3433178f00f482adc863110f90c46d6","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"acc72c3284fe906a4505132c3d9a4720d80e6fcb","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"551ffae43844925beb099c85a9e6d8d9fcbf8086","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"42850952e8f5858497fe774c2aff87b6563ab01e","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"cef058fd6f33651118b5bdaa3c814757f5c82154","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"e026955c454ec57bbbb7e9b7d800db90564fc6af","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"f0cb813cd03642c9b68cff8b6669f73a61dd10f8","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1722389741296},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1722389741296},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"9ea66cf79f1e4356b6b402bc3dc5fb55c9862f1f","modified":1722389741313},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"1b1eb4c8e163a5d909e86da76ef778948e0e0b77","modified":1722389741296},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1722389741306},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"f35415bd86b5c26fbc71728048d9e1481263554f","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"66d5b045c0e54001d3c98c5901d72590fe08acc4","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"571bd018e914bd0f7c5f89df874b5937937e5fa6","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"bac20c8fb20276b08972df5ecc7a5850a72393f4","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"d73cccb65eaa804910884df17442e34736b3f4fb","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"2d12f23b46d0ce07ae810bc4f5635c490a098fa4","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"adbb056bbcbdefecec441e5444c30c5777b5e2ae","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"31c64c3fae4a0fc4747d8afeb72f7a9667c5326c","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1722389741313},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"80301db38e448e40e88bb34d0128628b0809b243","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e6f5921ff9009c1853e7db30c482bc1682433ed9","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"5563abb10a40e2f8ece8e521763fe67c6e6bc12b","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"f4ae7cbf2f10f459de7864f8e642553b587df889","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1722389741306},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1722389741313},{"_id":"source/Image/image-20240724162639684.png","hash":"2d2977ccaebb8f224bef769a56afd8e462aec7cf","modified":1722389741283},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1722389741313},{"_id":"public/local-search.xml","hash":"30ceae927ff8988e3eceb08e803da7891864e257","modified":1728350709030},{"_id":"public/about/index.html","hash":"371f23ebd7353bd2d3ea1b4555e11696a1e46e51","modified":1723118724772},{"_id":"public/2024/07/31/Work No.8/index.html","hash":"6b209a5b0bd1810655f753db367f53c228a27f28","modified":1723119081500},{"_id":"public/2024/07/30/STM32的USART发送测试/index.html","hash":"c27f21b2f9dffeda1f6821da98e4579761a5fc1a","modified":1725245092697},{"_id":"public/2024/07/26/Work No.7/index.html","hash":"96781c688c197f2e9277215877e5af568ab9cb6c","modified":1723119081500},{"_id":"public/2024/07/25/STM32的时钟学习/index.html","hash":"a6b474805d4ae673e19557d76586a7ebf9fb85ec","modified":1722397498053},{"_id":"public/2024/07/24/Work No.4/index.html","hash":"74cc80c0ff1987e84d437f74733d42cda3e657f6","modified":1722397498053},{"_id":"public/2024/07/23/STM32的中断使用/index.html","hash":"1b6faa643ad52a28e2a92e8b41218eec9646b73b","modified":1722397498053},{"_id":"public/2024/07/23/Work No.6/index.html","hash":"cdc8634b7bed49ff4025fa4425310ea074e4639c","modified":1722397498053},{"_id":"public/2024/07/19/Work No.5/index.html","hash":"c9c4da7024bf8ba91d654eb31f1d284c5f487a63","modified":1725245092697},{"_id":"public/2024/07/10/STM32程序逻辑及GPIO使用/index.html","hash":"618a9cca4efa0b7684a57946f9278f996bbe64ee","modified":1722397534879},{"_id":"public/2024/07/09/Work No.1/index.html","hash":"8395a05ea1a5a7b6883e91604a3da9df14813e5f","modified":1722397498053},{"_id":"public/2024/06/30/STM32固件库及工程文件概念/index.html","hash":"dc9de6fcb8b7a0ee64a11bb95b9efa8511099370","modified":1722397498053},{"_id":"public/2024/05/27/20240529ZYY-1_TCP通信/index.html","hash":"9a9d4b769e94c533e5745792360fe7b809b144ab","modified":1722397498053},{"_id":"public/2024/05/17/20240429ZYY-Hi3861开发/index.html","hash":"0d64608511865d487b2e1732da7562bbf41afd48","modified":1722397498053},{"_id":"public/2024/04/15/20240319ZYY-FOC无刷电机控制/index.html","hash":"01373c7d4c9ee6a2e55581d78175c814d717fe41","modified":1723195074918},{"_id":"public/2024/01/26/20240201ZYY-控制工程学习笔记/index.html","hash":"191a1faa8acdffecab68213d08bb42d8e21a5374","modified":1722857678517},{"_id":"public/2023/11/30/20231204ZYY-Markdown用法/index.html","hash":"8f2995c9b601084768a9f079ee7b7b0be0acbc32","modified":1722397498053},{"_id":"public/2023/11/26/20231204ZYY-电气路设计/index.html","hash":"cbdf5250f5adb9e6ab4ba379fa39bd9d747f9d14","modified":1722397498053},{"_id":"public/2023/11/10/20231204ZYY-如何制作一份优秀的路演PPT/index.html","hash":"09648691a57e0433608e0a9b4250516dfcede34d","modified":1722397498053},{"_id":"public/2023/10/26/20231204ZYY-文献检索/index.html","hash":"ae1b8a5785770abe07b27679b720d67735229d8b","modified":1722570845184},{"_id":"public/archives/index.html","hash":"eb0a3e1b0676def9e678093db665d6a8fbd38cba","modified":1728350709030},{"_id":"public/archives/page/2/index.html","hash":"1943a011599ea8fd2b89cbb396275b3df9f7ecd2","modified":1728350709030},{"_id":"public/archives/2023/index.html","hash":"d0208cdbcb01f7b03c9583583a0432039b8c7ab0","modified":1728350709030},{"_id":"public/archives/2023/10/index.html","hash":"efb6b741d8835dc5d5e0378d2a064501d462535d","modified":1728350709030},{"_id":"public/archives/2023/11/index.html","hash":"e49c6a30519ec6282fb34a051f6340423bbae846","modified":1728350709030},{"_id":"public/archives/2024/index.html","hash":"72180b8b9e9c062e6d2c7995425dc5f127a9d35e","modified":1728350709030},{"_id":"public/archives/2024/01/index.html","hash":"4d50fb2d9348ccb66ff6d63c53c993cd4f31c54b","modified":1728350709030},{"_id":"public/archives/2024/page/2/index.html","hash":"143aa63105ddf4de82c1da0f9972a879e190595a","modified":1728350709030},{"_id":"public/archives/2024/04/index.html","hash":"ed838c054730f7525095cc1cafca059d7466d3c2","modified":1728350709030},{"_id":"public/archives/2024/05/index.html","hash":"02a13c7270a484c651d4cea670357a90ce0ff2ca","modified":1728350709030},{"_id":"public/archives/2024/06/index.html","hash":"79e4613c0b3d4275161ead0341dbc3f6bfe73316","modified":1728350709030},{"_id":"public/archives/2024/07/index.html","hash":"adfd511898492d072aaf7d974e8e263cd11465d6","modified":1728350709030},{"_id":"public/categories/路演文书/index.html","hash":"efbe0c5cf44060e50ba30bf94da9eddbbd38270f","modified":1722397498053},{"_id":"public/categories/信息检索/index.html","hash":"b0e022e7f004fb1ee1cf550c814f42a18fb32f28","modified":1722397498053},{"_id":"public/categories/控制设计/index.html","hash":"5fb466bca2fc91cc11630847aa9dd0db1fec545a","modified":1722397498053},{"_id":"public/categories/Linux/index.html","hash":"5d7e93d8950b8a54e8c9d1d87fc6b72da590a6e9","modified":1723194239536},{"_id":"public/categories/STM32/index.html","hash":"8db653ad32d3a26893cae0a014c693bf062279eb","modified":1728350709030},{"_id":"public/categories/单片机/index.html","hash":"9f736c4e7239aa4d79d945227f82f8652c549d2f","modified":1722397498053},{"_id":"public/categories/Github/index.html","hash":"80e8ef5420a8fc55a6ff8c6827667ed34dd23c71","modified":1722397498053},{"_id":"public/categories/Git/index.html","hash":"5d9a61c4941df611ba267d6a0edd01685a37f4eb","modified":1722397498053},{"_id":"public/categories/3D打印机/index.html","hash":"4a7e41e0a94ca02a941b75534c2b409441a3f140","modified":1722397498053},{"_id":"public/categories/C-C/index.html","hash":"5115e83b09f7429023a8483506c626f5c7a2aa3f","modified":1723194094396},{"_id":"public/tags/文献检索/index.html","hash":"a0da26dd1e87413340e3fcf29a608152515f6ef1","modified":1722397498053},{"_id":"public/tags/Markdown/index.html","hash":"fd73aa2e126ef9240e4172126de80ed40e8151e4","modified":1722397498053},{"_id":"public/tags/控制工程/index.html","hash":"f5bfeb7a42fbeffd0b10da2f4ff6c43f406b9404","modified":1722397498053},{"_id":"public/tags/无刷电机控制/index.html","hash":"9f4a2a4877354066130fd89f3a954ddf3f023a61","modified":1722397498053},{"_id":"public/tags/TCP/index.html","hash":"45d336cbe600421daf82cad2d76a60a4af559229","modified":1722397498053},{"_id":"public/tags/固件库/index.html","hash":"d3e43283a85fc66213d331fce78314c9c97b0f5f","modified":1722397498053},{"_id":"public/tags/控制设计/index.html","hash":"d03b2e857197cf0585a2327e8680e69235491d0d","modified":1722397498053},{"_id":"public/tags/PPT/index.html","hash":"a1473bf1a8e960e59aeb63b5936ee39b103e37c9","modified":1722397498053},{"_id":"public/tags/中断函数/index.html","hash":"23aef7eb69b492a7e25f2ef956f1e12cfa45b9e6","modified":1722397498053},{"_id":"public/tags/Hi3861/index.html","hash":"4598996d990d9aee8e470c1a93f20316de0b0ca4","modified":1722397498053},{"_id":"public/tags/Systick/index.html","hash":"6022dc381cecc6944cf9eb57a02e7af5acfc7203","modified":1722397498053},{"_id":"public/tags/USART/index.html","hash":"c8b027a9ef3c8cb71ea83fed944b32db8452f691","modified":1723119081500},{"_id":"public/tags/Linux/index.html","hash":"18c3f34d41bb20205e872d6f3b15b850f521fffb","modified":1722397498053},{"_id":"public/tags/Github-Pages/index.html","hash":"86994330511d2fdb950a92a3f814cc1fb46509ca","modified":1722397498053},{"_id":"public/tags/Gcode/index.html","hash":"266077a9d329865bed1c306a0314f59279ec81bc","modified":1722397498053},{"_id":"public/tags/GPIO/index.html","hash":"5bc54197d87577aba515445e946bddf7f6b84ba1","modified":1722397498053},{"_id":"public/tags/3D打印机/index.html","hash":"0a5a57b589a66c215bc9c22a5529dc23fe1f1f9e","modified":1722397498053},{"_id":"public/index.html","hash":"acd0834cbdcdfb51c68f771e0098079f79676bc7","modified":1728350709030},{"_id":"public/tags/git/index.html","hash":"a1af4040c6a1404396adf4f8566c26144a74b657","modified":1722397498053},{"_id":"public/tags/C-C/index.html","hash":"e757fb45cfa0828f01732fae413ad1b1cfa2d46b","modified":1725262952728},{"_id":"public/404.html","hash":"6c032462de925f30ae20154171270be3b56721bd","modified":1722397498053},{"_id":"public/page/2/index.html","hash":"31e77cc66d64a19020373eec5d8684d0adca48fa","modified":1728350709030},{"_id":"public/tags/index.html","hash":"fd3d1dcfc779a9082ed55d7cde5b1d6b0b7b2af7","modified":1728350709030},{"_id":"public/categories/index.html","hash":"448c83b679b6c9ef59008f4770c8a4e9ff23bed3","modified":1728350709030},{"_id":"public/links/index.html","hash":"ab3f3d7e0934bb7df76bc9ba5829b6836be9ae2d","modified":1722397498053},{"_id":"public/Image/image-20240724154237430.png","hash":"98d3dee917bd9d23fbeb8260c9e5c08cf8c0eecc","modified":1722396329445},{"_id":"public/Image/image-20240724153741084.png","hash":"f081610bccd4b7aeaa2f570adc438917765cc952","modified":1722396329445},{"_id":"public/Image/image-20240724154427037.png","hash":"2f95444cbb2285a578131ce272065a1c1aea7af9","modified":1722396329445},{"_id":"public/Image/image-20240724161404111.png","hash":"b3f3ba5f0832da3a250f777a0bde4726a95cae70","modified":1722396329445},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1722396329445},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1722396329445},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1722396329445},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1722396329445},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1722396329445},{"_id":"public/Image/image-20240724155135615.png","hash":"3feb9a270e960d70a209ad4edf77bdcc17e2aaf8","modified":1722396329445},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1722396329445},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1722396329445},{"_id":"public/css/main.css","hash":"05bd160751996591ea1f886764c1bcc5b78629ac","modified":1722396329445},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1722396329445},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1722396329445},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1722396329445},{"_id":"public/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1722396329445},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1722396329445},{"_id":"public/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1722396329445},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1722396329445},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1722396329445},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1722396329445},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1722396329445},{"_id":"public/Image/image-20240724162639684.png","hash":"2d2977ccaebb8f224bef769a56afd8e462aec7cf","modified":1722396329445},{"_id":"source/_posts/STM32的USART接收测试.md","hash":"84461cfd9c83478525ef467e887ccb7305abb155","modified":1722473692489},{"_id":"public/archives/2024/07/page/2/index.html","hash":"83208be02b150dc2bc9d1ea5f2877f44e9e5498a","modified":1728350709030},{"_id":"public/2024/07/31/STM32的USART接收测试/index.html","hash":"e531b77b28498388c91da555f1953aa9d99af677","modified":1725245092697},{"_id":"source/_posts/Work No.12.md","hash":"09bc3dd8fb0ec7aa86b02cddf257fe9c1e146aa7","modified":1722510849075},{"_id":"public/2024/08/01/Work No.12/index.html","hash":"0c3c6c0723ef88b4357c582a1afb07204cf6da51","modified":1722570845184},{"_id":"public/archives/2024/08/index.html","hash":"2739baee4db8e9464163362936860eae4ddfe064","modified":1728350709030},{"_id":"public/tags/Json/index.html","hash":"82ee68dafa028c7e720c733c2f5abcb294fe2605","modified":1722513917027},{"_id":"public/archives/page/3/index.html","hash":"fb4b25cb5288bcb74ecd821270bbade6d29a25db","modified":1728350709030},{"_id":"public/page/3/index.html","hash":"f7db0cbd1f4683b02c37ad6281c8bc21439c28ad","modified":1728350709030},{"_id":"source/_posts/Work No.13.md","hash":"42312af1980e820a20191b633a253890a2d827ee","modified":1723176347759},{"_id":"public/2024/08/02/Work No.13/index.html","hash":"4e53c35cb4e289871659588bf4dd16b4bc60647c","modified":1723194094396},{"_id":"source/_posts/Work No.14.md","hash":"8c693c1ffea0a450386069663451259605e02bbf","modified":1723176331973},{"_id":"source/_posts/Work No.15.md","hash":"e233dd2a37917316cd3b00d7949d96b8938b1d4a","modified":1723176319845},{"_id":"public/2024/08/05/Work No.14/index.html","hash":"4a1d4f0ffeba7dd549730e1096dc29f61c153e35","modified":1723194094396},{"_id":"public/2024/08/05/Work No.15/index.html","hash":"b24ab6a7162e2546b07569eea6ace85755e09dec","modified":1723194094396},{"_id":"source/_posts/Work No.16.md","hash":"7206b0a64f8ef9ebf8dcc16c2b6bf2fe986767a1","modified":1725244969047},{"_id":"public/2024/08/06/Work No.16/index.html","hash":"85cbcf5063ed9e4e9a9a9a9d7236f56024479f04","modified":1725245092697},{"_id":"public/archives/2024/page/3/index.html","hash":"22d14d834a7dca7b66da71861f9ffa2b058e375a","modified":1728350709030},{"_id":"source/_posts/Work No.18.md","hash":"4657e3fd10afd17ef07ee971f4ddd5065f538ff0","modified":1723176237175},{"_id":"source/_posts/Work No.20.md","hash":"aabbfa066075834ce08b67313bd963fe3c2dafa2","modified":1725245052135},{"_id":"source/_posts/Work No.19.md","hash":"6f288086379ab3aacdf127f5a321a19af078dfba","modified":1723186046040},{"_id":"source/_posts/Work No.17.md","hash":"72696a0514a875a2cc77252a9a8e31e61ccd802c","modified":1723194200220},{"_id":"public/2024/08/09/Work No.19/index.html","hash":"d06a879e570223e91439c30552df0341b384f3b3","modified":1723194239536},{"_id":"public/2024/08/09/Work No.17/index.html","hash":"52c419b1b890b31ad11165b96ee588f394982b8a","modified":1723521364875},{"_id":"public/2024/08/09/Work No.20/index.html","hash":"4d791cac9de6def07c91cf70c5f05e57c9e3b69b","modified":1725245092697},{"_id":"public/2024/08/07/Work No.18/index.html","hash":"6f10f5ec4987b408a163d4c7691ddf491bb233a3","modified":1723465654711},{"_id":"public/tags/进程和线程/index.html","hash":"8adaee6b6d1cfb4773f6413203789b8980423872","modified":1723194239536},{"_id":"public/tags/消息队列/index.html","hash":"2ec12b71471185df1dbd9e8af5de594d0aa396fa","modified":1723194094396},{"_id":"public/tags/信号signal/index.html","hash":"dcfe13b6a50f20c729edd262b844f670b2f5f8d6","modified":1723194094396},{"_id":"source/_posts/Work No.21.md","hash":"3f9de3908a1532e04df85a275e5f4abb61cc7a70","modified":1723521465462},{"_id":"source/_posts/STM32的DMA收发.md","hash":"69a301e776b8340902d30bed7485b45607601c6f","modified":1723465619316},{"_id":"source/_posts/Work No.22.md","hash":"a851f9507896ab117e99dec9d279e761e5a07e26","modified":1723521287408},{"_id":"public/2024/08/12/Work No.21/index.html","hash":"0ef01e6ee15b30062111d79a35ee2cfb7ad27f78","modified":1723521487461},{"_id":"public/2024/08/12/Work No.22/index.html","hash":"a1ebbca3bc0f9042c233066eb2737c9f364e86f5","modified":1723521487461},{"_id":"public/2024/08/08/STM32的DMA收发/index.html","hash":"6ff2c4631ac9d6c8565542b6af641a68a6f23ea3","modified":1723465654711},{"_id":"public/archives/page/4/index.html","hash":"74ec1700999dbe5e3dcb8368e65eba414a45340e","modified":1728350709030},{"_id":"public/archives/2024/08/page/2/index.html","hash":"eaa491c84c222cb7f979aa2151c88e8dd51a37a5","modified":1728350709030},{"_id":"public/categories/Python/index.html","hash":"1e73dfc7cca98461320c31a9f389374a87cbc757","modified":1728350709030},{"_id":"public/tags/DMA数据传输/index.html","hash":"c12d7d04c26d23d90ffd9fe9a7cfdb781081a211","modified":1723465654711},{"_id":"public/tags/Python/index.html","hash":"5825f72e0d4056fec99092f82947e73c2737c3f2","modified":1728350709030},{"_id":"public/page/4/index.html","hash":"ba65356b86290d448c99958260bd183f526092d0","modified":1728350709030},{"_id":"source/_posts/Work No.23.md","hash":"59048ab5f74cf049e4900251832d3d14e29b650d","modified":1723521253710},{"_id":"source/_posts/Work No.24.md","hash":"79ecf0aa217049daff008c2a78cf7f0579c66d3f","modified":1723521239635},{"_id":"public/2024/08/13/Work No.23/index.html","hash":"37a2a1aad297adeeb52f5741e35390bdbd24edee","modified":1723640500543},{"_id":"public/2024/08/13/Work No.24/index.html","hash":"927f40522cc682b92243aa2fb4e41f1ce31f45e5","modified":1723521487461},{"_id":"source/_posts/Work No.26.md","hash":"336f5b8e1353c65bb504669e15280b93b08f0df1","modified":1723684392617},{"_id":"public/2024/08/14/Work No.26/index.html","hash":"b4fe43fd0c5e87e455a5261f97c28532514d0ba2","modified":1725261921576},{"_id":"public/categories/C-C-编译/index.html","hash":"3e25217f9d2d65828b35a901b224dfb55d82e045","modified":1723640500543},{"_id":"public/archives/2024/page/4/index.html","hash":"8c9b868ee65252056af7b10ecdda9518f850ae36","modified":1728350709030},{"_id":"source/_posts/嵌入式生活小常识.md","hash":"9ea3a843eb6154fd15a3f8b728dce55dc6a87d2a","modified":1728054302165},{"_id":"source/_posts/STM32的I2C学习.md","hash":"99300994b17b70a379c6c5fd8c6d11f5e2b88db5","modified":1725245311650},{"_id":"public/2024/08/18/STM32的I2C学习/index.html","hash":"c4a75375d0b3b376553cddafa2135495bd8af6fb","modified":1725262952728},{"_id":"public/2024/07/31/嵌入式生活小常识/index.html","hash":"97254e4d8bc538413959caa9086625e96ff0baef","modified":1728350709030},{"_id":"public/categories/嵌入式/index.html","hash":"74493b7f71483c9bb298b51bfc44dc5b527afa47","modified":1725245092697},{"_id":"public/tags/I2C/index.html","hash":"5f66617f06e995b4fe4df9610b6ec1b63b343420","modified":1725245092697},{"_id":"public/tags/嵌入式/index.html","hash":"fc4a1daa2004a2050d9ad1605161de91d11df4fd","modified":1725245092697},{"_id":"source/_posts/Work No.28.md","hash":"d4d5673749518f29ef7034860cdb2c58d99458cd","modified":1725262944052},{"_id":"source/_posts/Work No.27.md","hash":"c17a976a8dce9bc71da3e229dc4ed0b2e3be5671","modified":1725261899464},{"_id":"public/2024/08/28/Work No.28/index.html","hash":"416f63cf567ee1cfe7eb71cb22b4011f2bce68db","modified":1725442399925},{"_id":"public/2024/08/15/Work No.27/index.html","hash":"1449de6c760bd0a1045d7a397fdf03f853c28ef3","modified":1725261921576},{"_id":"public/categories/Socket通信/index.html","hash":"6c30dde0afa839c07e438b7f6b1066b476a836db","modified":1725261921576},{"_id":"public/categories/protobuf通信/index.html","hash":"377b08c993b6635cbdcf0e6fe9704f8fa6dc2a99","modified":1725262952728},{"_id":"source/_posts/STM32的SPI学习.md","hash":"e9da985808e531e042c1c6c6a252069e5e805b43","modified":1725442372857},{"_id":"source/_posts/VScode+platformIO编译STM32标准库.md","hash":"02b7ed6f142cdb8493ca0fe3bbd0883ee9ae3e3b","modified":1725442241260},{"_id":"public/2024/09/04/VScode+platformIO编译STM32标准库/index.html","hash":"8dc7de4886bfc565b193ac41a3e54e52227af19d","modified":1728350709030},{"_id":"public/2024/08/30/STM32的SPI学习/index.html","hash":"d5b16754e8f06f1eb15a48dc886043e7c171be32","modified":1725442399925},{"_id":"public/archives/page/5/index.html","hash":"34573f36e03341902d6fb38d7f809132a95f5a62","modified":1728350709030},{"_id":"public/archives/2024/09/index.html","hash":"9761779eae9a69d71d2dffeb1cc8af013f1aaa8e","modified":1728350709030},{"_id":"public/page/5/index.html","hash":"6815c92edab09933bfc0bc3daddbbb2c46da3568","modified":1728350709030},{"_id":"public/tags/VScode/index.html","hash":"83e2b4f284a7d78f4fa0bbd8243756422f97e363","modified":1725442399925},{"_id":"public/tags/SPI/index.html","hash":"e6139e422ad3880436eea303011b1be939d4cbc2","modified":1728350709030},{"_id":"source/_posts/STM32的ADC学习.md","hash":"365d7452db2f3577e6118b31761ba57b1ed64de0","modified":1726388965672},{"_id":"source/_posts/20240529ZYY-DShot协议.md","hash":"277aad999eb129266d58b8468642041c310d09f2","modified":1727658191046},{"_id":"source/_posts/STM32的TIM学习.md","hash":"fa8a7f4a6686ac7eb96ccaef1a8a901e48133cae","modified":1728350446563},{"_id":"source/_posts/Work No.29.md","hash":"5d21fa2f00b7bdb501aee58d658e7e025eb3a79d","modified":1726373622623},{"_id":"public/2024/09/29/20240529ZYY-DShot协议/index.html","hash":"8614331c4dc270c0d8984910e1cd0b1779de224e","modified":1728350709030},{"_id":"public/2024/09/12/STM32的ADC学习/index.html","hash":"05bfccf7fa35e2bfa29cc58d01bf3f132e656f24","modified":1728350709030},{"_id":"public/2024/09/12/STM32的TIM学习/index.html","hash":"8cccd97ca775c065cbf56b1b5a7fc64a6a39ad82","modified":1728350709030},{"_id":"public/2024/09/14/Work No.29/index.html","hash":"410abbc54769873aa128900041613921c7d96b10","modified":1728350709030},{"_id":"public/archives/2024/page/5/index.html","hash":"344b8a7f952f5fbaf9dfb223e7866dd1efafc052","modified":1728350709030},{"_id":"public/tags/DShot协议/index.html","hash":"1b21d897646ed0006c7c42f64821b5198c3135e4","modified":1728350709030},{"_id":"public/tags/TIM/index.html","hash":"e8fdc3dfb7d1be1ddc412f4b7852acd0b1c02eb1","modified":1728350709030},{"_id":"public/categories/STM32/page/2/index.html","hash":"f48984a58312018cbcc17e8165732b35a5b7b831","modified":1728350709030},{"_id":"public/categories/Fly/index.html","hash":"7910184880457801468c031b7d7bf5e842cc3876","modified":1728350709030}],"Category":[{"name":"信息检索","_id":"clz9aaxq50003ygfb6efwbudn"},{"name":"路演文书","_id":"clz9aaxq80008ygfbenqlgo2s"},{"name":"控制设计","_id":"clz9aaxqa000eygfb56ry3lxo"},{"name":"Linux","_id":"clz9aaxqb000kygfb41n4ajve"},{"name":"STM32","_id":"clz9aaxqf000wygfbfa6o0ea7"},{"name":"单片机","_id":"clz9aaxqj001fygfbbrxwgas1"},{"name":"Github","_id":"clz9aaxqk001rygfbdugqgdz2"},{"name":"3D打印机","_id":"clz9aaxql001wygfb7cxggv0j"},{"name":"Git","_id":"clz9aaxqm0022ygfb7asbbzjh"},{"name":"C/C++","_id":"clz9aaxqp002hygfb2yep95qw"},{"name":"Python","_id":"clzqyyajl0003b0fbhrqzav53"},{"name":"C/C++编译","_id":"clztv1uid0001sgfb5uqah2gy"},{"name":"嵌入式","_id":"cm0kedtpv0005psfbdcxkctwu"},{"name":"Socket通信","_id":"cm0koeivs0002z0fb4aiw8tdv"},{"name":"protobuf通信","_id":"cm0koeivv0005z0fbg1jj91d1"},{"name":"Fly","_id":"cm1zrdyqf0002p8fba8sq0h26"}],"Data":[],"Page":[{"title":"about","date":"2024-07-24T07:02:45.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-07-24 15:02:45\nlayout: about\n---\n","updated":"2024-07-31T01:35:41.293Z","path":"about/index.html","comments":1,"_id":"clz9aaxq00000ygfb5alc1a7p","content":"","excerpt":"","more":""}],"Post":[{"title":"文献检索","date":"2023-10-25T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/gBHt9n2hwTjor4x.png","_content":"\n# 文献检索\n\n- ### 翻译软件\n\n  - Mate Translate（网站翻译插件）\n\n  - 搜狗文档翻译\n\n  - 有道学生认证翻译\n\n- ### 检索技巧\n\n  - 关键词+literature review（综述后缀搜索）\n\n  - 知网摘要批量导出\n\n- ### 资源网站\n\n  - [资源下载 - 理工酷 (ligongku.com)](https://www.ligongku.com/invite/28243)（资料下载）\n\n  - [电力网 - 最具影响力的电力行业门户网站 (chinapower.com.cn)](http://www.chinapower.com.cn/)（资料下载）\n\n  - [国际能源网-能源全产业链服务平台，服务全球能源企业！ (in-en.com)](https://www.in-en.com/)（资料下载）\n\n  - [麻省理工科技评论-发现改变世界的新兴科技 (mittrchina.com)](https://www.mittrchina.com/news)（前沿科技网站）\n\n  - [OECD Statistics](https://stats.oecd.org/)（数据网站）\n\n- ### 关键词检索引擎\n\n  - 学校WEBVPN：[WEBVPN系统 (zzuli.edu.cn)](https://webvpn.zzuli.edu.cn/login)\n\n  - [Paper Digest – Sci-Tech knowledge graph & text analysis platform for scientific literature tracking, summarization and search](https://www.paperdigest.org/)（文献检索引擎）\n\n  - [Zenodo - Research. Shared.](https://zenodo.org/)（文献检索引擎）\n\n  - [Home - Springer](https://link.springer.com/)（文献检索引擎）\n\n  - [ProQuest | 更好的研究，更好的学习，更好的见解。](https://www.proquest.com/)（文献检索引擎）\n\n  - [谷歌学术镜像_Google学术搜索导航@思谋学术 (scmor.com)](https://ac.scmor.com/)（谷歌学术镜像）\n\n  - [虫部落快搜-Google 学术搜索 - 快搜 - 谷歌搜索 (chongbuluo.cn)](http://www.chongbuluo.cn/)（检索引擎大合集）\n\n- ### 文献检索引擎\n\n  - [Sci论文期刊检索|文献检索求助互助 - Sci-Hub|Scidown](https://www.scidown.cn/)（文献检索引擎）\n\n- ### AI检索\n\n  - [Connected Papers | Find and explore academic papers](https://www.connectedpapers.com/)（强烈推荐，AI关联文献）\n\n  - [Paper Digest (paper-digest.com)](https://www.paper-digest.com/)（AI读论文）","source":"_posts/20231204ZYY-文献检索.md","raw":"---\ntitle: 文献检索\ntag: 文献检索\ndate: 2023-10-26\ncategories: 信息检索\nindex_img: https://s2.loli.net/2024/07/31/gBHt9n2hwTjor4x.png\n---\n\n# 文献检索\n\n- ### 翻译软件\n\n  - Mate Translate（网站翻译插件）\n\n  - 搜狗文档翻译\n\n  - 有道学生认证翻译\n\n- ### 检索技巧\n\n  - 关键词+literature review（综述后缀搜索）\n\n  - 知网摘要批量导出\n\n- ### 资源网站\n\n  - [资源下载 - 理工酷 (ligongku.com)](https://www.ligongku.com/invite/28243)（资料下载）\n\n  - [电力网 - 最具影响力的电力行业门户网站 (chinapower.com.cn)](http://www.chinapower.com.cn/)（资料下载）\n\n  - [国际能源网-能源全产业链服务平台，服务全球能源企业！ (in-en.com)](https://www.in-en.com/)（资料下载）\n\n  - [麻省理工科技评论-发现改变世界的新兴科技 (mittrchina.com)](https://www.mittrchina.com/news)（前沿科技网站）\n\n  - [OECD Statistics](https://stats.oecd.org/)（数据网站）\n\n- ### 关键词检索引擎\n\n  - 学校WEBVPN：[WEBVPN系统 (zzuli.edu.cn)](https://webvpn.zzuli.edu.cn/login)\n\n  - [Paper Digest – Sci-Tech knowledge graph & text analysis platform for scientific literature tracking, summarization and search](https://www.paperdigest.org/)（文献检索引擎）\n\n  - [Zenodo - Research. Shared.](https://zenodo.org/)（文献检索引擎）\n\n  - [Home - Springer](https://link.springer.com/)（文献检索引擎）\n\n  - [ProQuest | 更好的研究，更好的学习，更好的见解。](https://www.proquest.com/)（文献检索引擎）\n\n  - [谷歌学术镜像_Google学术搜索导航@思谋学术 (scmor.com)](https://ac.scmor.com/)（谷歌学术镜像）\n\n  - [虫部落快搜-Google 学术搜索 - 快搜 - 谷歌搜索 (chongbuluo.cn)](http://www.chongbuluo.cn/)（检索引擎大合集）\n\n- ### 文献检索引擎\n\n  - [Sci论文期刊检索|文献检索求助互助 - Sci-Hub|Scidown](https://www.scidown.cn/)（文献检索引擎）\n\n- ### AI检索\n\n  - [Connected Papers | Find and explore academic papers](https://www.connectedpapers.com/)（强烈推荐，AI关联文献）\n\n  - [Paper Digest (paper-digest.com)](https://www.paper-digest.com/)（AI读论文）","slug":"20231204ZYY-文献检索","published":1,"updated":"2024-08-02T03:53:18.960Z","_id":"clz9aaxq20001ygfbdiol74ia","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"文献检索\"><a href=\"#文献检索\" class=\"headerlink\" title=\"文献检索\"></a>文献检索</h1><ul>\n<li><h3 id=\"翻译软件\"><a href=\"#翻译软件\" class=\"headerlink\" title=\"翻译软件\"></a>翻译软件</h3><ul>\n<li><p>Mate Translate（网站翻译插件）</p>\n</li>\n<li><p>搜狗文档翻译</p>\n</li>\n<li><p>有道学生认证翻译</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"检索技巧\"><a href=\"#检索技巧\" class=\"headerlink\" title=\"检索技巧\"></a>检索技巧</h3><ul>\n<li><p>关键词+literature review（综述后缀搜索）</p>\n</li>\n<li><p>知网摘要批量导出</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"资源网站\"><a href=\"#资源网站\" class=\"headerlink\" title=\"资源网站\"></a>资源网站</h3><ul>\n<li><p><a href=\"https://www.ligongku.com/invite/28243\">资源下载 - 理工酷 (ligongku.com)</a>（资料下载）</p>\n</li>\n<li><p><a href=\"http://www.chinapower.com.cn/\">电力网 - 最具影响力的电力行业门户网站 (chinapower.com.cn)</a>（资料下载）</p>\n</li>\n<li><p><a href=\"https://www.in-en.com/\">国际能源网-能源全产业链服务平台，服务全球能源企业！ (in-en.com)</a>（资料下载）</p>\n</li>\n<li><p><a href=\"https://www.mittrchina.com/news\">麻省理工科技评论-发现改变世界的新兴科技 (mittrchina.com)</a>（前沿科技网站）</p>\n</li>\n<li><p><a href=\"https://stats.oecd.org/\">OECD Statistics</a>（数据网站）</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"关键词检索引擎\"><a href=\"#关键词检索引擎\" class=\"headerlink\" title=\"关键词检索引擎\"></a>关键词检索引擎</h3><ul>\n<li><p>学校WEBVPN：<a href=\"https://webvpn.zzuli.edu.cn/login\">WEBVPN系统 (zzuli.edu.cn)</a></p>\n</li>\n<li><p><a href=\"https://www.paperdigest.org/\">Paper Digest – Sci-Tech knowledge graph &amp; text analysis platform for scientific literature tracking, summarization and search</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://zenodo.org/\">Zenodo - Research. Shared.</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://link.springer.com/\">Home - Springer</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://www.proquest.com/\">ProQuest | 更好的研究，更好的学习，更好的见解。</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://ac.scmor.com/\">谷歌学术镜像_Google学术搜索导航@思谋学术 (scmor.com)</a>（谷歌学术镜像）</p>\n</li>\n<li><p><a href=\"http://www.chongbuluo.cn/\">虫部落快搜-Google 学术搜索 - 快搜 - 谷歌搜索 (chongbuluo.cn)</a>（检索引擎大合集）</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"文献检索引擎\"><a href=\"#文献检索引擎\" class=\"headerlink\" title=\"文献检索引擎\"></a>文献检索引擎</h3><ul>\n<li><a href=\"https://www.scidown.cn/\">Sci论文期刊检索|文献检索求助互助 - Sci-Hub|Scidown</a>（文献检索引擎）</li>\n</ul>\n</li>\n<li><h3 id=\"AI检索\"><a href=\"#AI检索\" class=\"headerlink\" title=\"AI检索\"></a>AI检索</h3><ul>\n<li><p><a href=\"https://www.connectedpapers.com/\">Connected Papers | Find and explore academic papers</a>（强烈推荐，AI关联文献）</p>\n</li>\n<li><p><a href=\"https://www.paper-digest.com/\">Paper Digest (paper-digest.com)</a>（AI读论文）</p>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"文献检索\"><a href=\"#文献检索\" class=\"headerlink\" title=\"文献检索\"></a>文献检索</h1><ul>\n<li><h3 id=\"翻译软件\"><a href=\"#翻译软件\" class=\"headerlink\" title=\"翻译软件\"></a>翻译软件</h3><ul>\n<li><p>Mate Translate（网站翻译插件）</p>\n</li>\n<li><p>搜狗文档翻译</p>\n</li>\n<li><p>有道学生认证翻译</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"检索技巧\"><a href=\"#检索技巧\" class=\"headerlink\" title=\"检索技巧\"></a>检索技巧</h3><ul>\n<li><p>关键词+literature review（综述后缀搜索）</p>\n</li>\n<li><p>知网摘要批量导出</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"资源网站\"><a href=\"#资源网站\" class=\"headerlink\" title=\"资源网站\"></a>资源网站</h3><ul>\n<li><p><a href=\"https://www.ligongku.com/invite/28243\">资源下载 - 理工酷 (ligongku.com)</a>（资料下载）</p>\n</li>\n<li><p><a href=\"http://www.chinapower.com.cn/\">电力网 - 最具影响力的电力行业门户网站 (chinapower.com.cn)</a>（资料下载）</p>\n</li>\n<li><p><a href=\"https://www.in-en.com/\">国际能源网-能源全产业链服务平台，服务全球能源企业！ (in-en.com)</a>（资料下载）</p>\n</li>\n<li><p><a href=\"https://www.mittrchina.com/news\">麻省理工科技评论-发现改变世界的新兴科技 (mittrchina.com)</a>（前沿科技网站）</p>\n</li>\n<li><p><a href=\"https://stats.oecd.org/\">OECD Statistics</a>（数据网站）</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"关键词检索引擎\"><a href=\"#关键词检索引擎\" class=\"headerlink\" title=\"关键词检索引擎\"></a>关键词检索引擎</h3><ul>\n<li><p>学校WEBVPN：<a href=\"https://webvpn.zzuli.edu.cn/login\">WEBVPN系统 (zzuli.edu.cn)</a></p>\n</li>\n<li><p><a href=\"https://www.paperdigest.org/\">Paper Digest – Sci-Tech knowledge graph &amp; text analysis platform for scientific literature tracking, summarization and search</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://zenodo.org/\">Zenodo - Research. Shared.</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://link.springer.com/\">Home - Springer</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://www.proquest.com/\">ProQuest | 更好的研究，更好的学习，更好的见解。</a>（文献检索引擎）</p>\n</li>\n<li><p><a href=\"https://ac.scmor.com/\">谷歌学术镜像_Google学术搜索导航@思谋学术 (scmor.com)</a>（谷歌学术镜像）</p>\n</li>\n<li><p><a href=\"http://www.chongbuluo.cn/\">虫部落快搜-Google 学术搜索 - 快搜 - 谷歌搜索 (chongbuluo.cn)</a>（检索引擎大合集）</p>\n</li>\n</ul>\n</li>\n<li><h3 id=\"文献检索引擎\"><a href=\"#文献检索引擎\" class=\"headerlink\" title=\"文献检索引擎\"></a>文献检索引擎</h3><ul>\n<li><a href=\"https://www.scidown.cn/\">Sci论文期刊检索|文献检索求助互助 - Sci-Hub|Scidown</a>（文献检索引擎）</li>\n</ul>\n</li>\n<li><h3 id=\"AI检索\"><a href=\"#AI检索\" class=\"headerlink\" title=\"AI检索\"></a>AI检索</h3><ul>\n<li><p><a href=\"https://www.connectedpapers.com/\">Connected Papers | Find and explore academic papers</a>（强烈推荐，AI关联文献）</p>\n</li>\n<li><p><a href=\"https://www.paper-digest.com/\">Paper Digest (paper-digest.com)</a>（AI读论文）</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Markdown用法","date":"2023-11-29T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/btPWQGIsOfFRi8C.jpg","_content":"\n# Markdown用法\n- 要写一个好看的文档，格式和各种引用非常重要，Markdown作为开发过程中的记录文件，也是目前应用最广泛的一个格式，因此开篇先分享一下基本用法。\n- 这边主要分享几种最常规的使用方法，主要有标题、换行、强调、代码块、分割线、链接、图片、表格这8种非常常用的用法，其余请参照[官方网站](https://markdown.com.cn)\n## 1.标题\n- 一级标题：`# ZYY 1`\n- 二级标题：`## ZYY 2`\n- 三级标题：`### ZYY 3`\n- 最简单的解释就是，**n个#代表n级标题**，空格之后加上标题就行\n## 2.换行\n- 句子末尾加上 `<br>` 或者 `两个空格+Enter键`\n```\nexample1：ZYY <br>\nexample2：ZYY(Space*2+Enter，括号和汉字自动忽视)\n```\n- **最好用的还是2个空格+Enter键**，但是你看不见它到底有没有换行，所以 `<br>` 这个是比较直观的，但是打字速度就慢了\n## 3.强调\n- 粗体（Bold）： `**ZYY** 或者 __ZYY__`\n- 斜体（Italic）： `*ZYY* 或者 _ZYY_`\n- 粗斜体： `***ZYY*** 或者 ___ZYY___`\n```\nexample1：ZZZ **YYY** YYY  或者ZZZ __YYY__ YYY\nexample2：ZZZ *YYY* YYY  或者ZZZ _YYY_ YYY\nexample3：ZZZ ***YYY*** YYY  或者ZZZ ___YYY___ YYY\n```\n- 这个没啥特殊要求，两种方法都可以，**但是最好每种符号的前后都加上空格，不然有些会失灵**\n## 4.代码块 and 代码\n```\n代码： ` + ` 单个反引号做开头，单个反引号做结尾，中间就是特殊的代码区\n代码块：``` + ``` 用三个反引号做开头，三个反引号做结尾，中间就是代码块\n\nexample1： ZZZ `YYY` YYY\n```\n- 这个代码块挺好用的，**特别是想要强调说一些事情的时候，可以给他框出来**，我上面的所有例子都是用代码块罗列的，清晰明了，代码块不一定写代码\n## 5.分割线\n-  `*** 或者 --- 或者 ___`\n```\nexample1： ***\nexample2： ---\nexample3： ___\n```\n- 就会出现一个非常丑的线，**这三根线的类型是一样的，不管用哪个都是一根线**\n## 6.链接\n- 链接： `[超链接显示名](超链接地址 \"超链接title\")`\n- 直接上网址或者email地址：<链接地址>\n```\nexample1：ZZZ [YYY](https://github.com/BraveYiYang) YYY\nexample2：ZZZ [YYY](https://github.com/BraveYiYang \"Brave\") YYY\nexample3：<https://github.com/BraveYiYang>\n```\n- 这个还是很好用的，中括号里面的是你可以随便定义，然后把你小括号的链接赋值在你中括号的定义里面，小括号的双引号里面是你鼠标放上去，他会显示出来你的小标签\n## 7.图片\n- 插入图片： `[![图片alt](图片链接 \"图片title\")](超链接)`\n```\nexample1：![ZYY](/ZYY/Z.jpg)\nexample2：![ZYY](/ZYY/Z.jpg \"Brave\")\nexample3：[![ZYY](/ZYY/Z.jpg \"Brave\")](https://github.com/BraveYiYang)\n```\n- 这个图片的用处是很多的，我们可以随心所欲的插入图片，**图文并茂**\n## 8.表格\n-  | 表示表格的线，用他来固定列数，几行就是表格的几行，\n- --- 来定义标题行，而且每一列的 --- 数量不一样代表每一列的长度也不一样\n- :--- 表示左对齐 ---: 表示右对齐 :---: 表示居中对齐\n```\nexample1：\n| Syntax      | Description |\n| ----------- | ----------- |\n| Header      | Title       |\n| Paragraph   | Text        |\nexample2：\n| Syntax | Description |\n| --- | ----------- |\n| Header | Title |\n| Paragraph | Text |\nexample3：\n| Syntax      | Description | Test Text     |\n| :---        |    :----:   |          ---: |\n| Header      | Title       | Here's this   |\n| Paragraph   | Text        | And more      |\n```\n- **表格其实不是很常用，但是也是算作是一个基本的使用方法**\n# 总结\n- **markdown的使用方法其实不难，而且也很容易入门，只不过没有那么直观，但是大家用习惯之后，就非常容易上手，所以鼓励大家多使用，熟能生巧，多练才会掌握的快！**","source":"_posts/20231204ZYY-Markdown用法.md","raw":"---\ntitle: Markdown用法\ntag: Markdown\ndate: 2023-11-30\ncategories: 路演文书\nindex_img: https://s2.loli.net/2024/07/31/btPWQGIsOfFRi8C.jpg\n---\n\n# Markdown用法\n- 要写一个好看的文档，格式和各种引用非常重要，Markdown作为开发过程中的记录文件，也是目前应用最广泛的一个格式，因此开篇先分享一下基本用法。\n- 这边主要分享几种最常规的使用方法，主要有标题、换行、强调、代码块、分割线、链接、图片、表格这8种非常常用的用法，其余请参照[官方网站](https://markdown.com.cn)\n## 1.标题\n- 一级标题：`# ZYY 1`\n- 二级标题：`## ZYY 2`\n- 三级标题：`### ZYY 3`\n- 最简单的解释就是，**n个#代表n级标题**，空格之后加上标题就行\n## 2.换行\n- 句子末尾加上 `<br>` 或者 `两个空格+Enter键`\n```\nexample1：ZYY <br>\nexample2：ZYY(Space*2+Enter，括号和汉字自动忽视)\n```\n- **最好用的还是2个空格+Enter键**，但是你看不见它到底有没有换行，所以 `<br>` 这个是比较直观的，但是打字速度就慢了\n## 3.强调\n- 粗体（Bold）： `**ZYY** 或者 __ZYY__`\n- 斜体（Italic）： `*ZYY* 或者 _ZYY_`\n- 粗斜体： `***ZYY*** 或者 ___ZYY___`\n```\nexample1：ZZZ **YYY** YYY  或者ZZZ __YYY__ YYY\nexample2：ZZZ *YYY* YYY  或者ZZZ _YYY_ YYY\nexample3：ZZZ ***YYY*** YYY  或者ZZZ ___YYY___ YYY\n```\n- 这个没啥特殊要求，两种方法都可以，**但是最好每种符号的前后都加上空格，不然有些会失灵**\n## 4.代码块 and 代码\n```\n代码： ` + ` 单个反引号做开头，单个反引号做结尾，中间就是特殊的代码区\n代码块：``` + ``` 用三个反引号做开头，三个反引号做结尾，中间就是代码块\n\nexample1： ZZZ `YYY` YYY\n```\n- 这个代码块挺好用的，**特别是想要强调说一些事情的时候，可以给他框出来**，我上面的所有例子都是用代码块罗列的，清晰明了，代码块不一定写代码\n## 5.分割线\n-  `*** 或者 --- 或者 ___`\n```\nexample1： ***\nexample2： ---\nexample3： ___\n```\n- 就会出现一个非常丑的线，**这三根线的类型是一样的，不管用哪个都是一根线**\n## 6.链接\n- 链接： `[超链接显示名](超链接地址 \"超链接title\")`\n- 直接上网址或者email地址：<链接地址>\n```\nexample1：ZZZ [YYY](https://github.com/BraveYiYang) YYY\nexample2：ZZZ [YYY](https://github.com/BraveYiYang \"Brave\") YYY\nexample3：<https://github.com/BraveYiYang>\n```\n- 这个还是很好用的，中括号里面的是你可以随便定义，然后把你小括号的链接赋值在你中括号的定义里面，小括号的双引号里面是你鼠标放上去，他会显示出来你的小标签\n## 7.图片\n- 插入图片： `[![图片alt](图片链接 \"图片title\")](超链接)`\n```\nexample1：![ZYY](/ZYY/Z.jpg)\nexample2：![ZYY](/ZYY/Z.jpg \"Brave\")\nexample3：[![ZYY](/ZYY/Z.jpg \"Brave\")](https://github.com/BraveYiYang)\n```\n- 这个图片的用处是很多的，我们可以随心所欲的插入图片，**图文并茂**\n## 8.表格\n-  | 表示表格的线，用他来固定列数，几行就是表格的几行，\n- --- 来定义标题行，而且每一列的 --- 数量不一样代表每一列的长度也不一样\n- :--- 表示左对齐 ---: 表示右对齐 :---: 表示居中对齐\n```\nexample1：\n| Syntax      | Description |\n| ----------- | ----------- |\n| Header      | Title       |\n| Paragraph   | Text        |\nexample2：\n| Syntax | Description |\n| --- | ----------- |\n| Header | Title |\n| Paragraph | Text |\nexample3：\n| Syntax      | Description | Test Text     |\n| :---        |    :----:   |          ---: |\n| Header      | Title       | Here's this   |\n| Paragraph   | Text        | And more      |\n```\n- **表格其实不是很常用，但是也是算作是一个基本的使用方法**\n# 总结\n- **markdown的使用方法其实不难，而且也很容易入门，只不过没有那么直观，但是大家用习惯之后，就非常容易上手，所以鼓励大家多使用，熟能生巧，多练才会掌握的快！**","slug":"20231204ZYY-Markdown用法","published":1,"updated":"2024-07-31T03:30:32.407Z","_id":"clz9aaxq40002ygfbgdx5dy2c","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Markdown用法\"><a href=\"#Markdown用法\" class=\"headerlink\" title=\"Markdown用法\"></a>Markdown用法</h1><ul>\n<li>要写一个好看的文档，格式和各种引用非常重要，Markdown作为开发过程中的记录文件，也是目前应用最广泛的一个格式，因此开篇先分享一下基本用法。</li>\n<li>这边主要分享几种最常规的使用方法，主要有标题、换行、强调、代码块、分割线、链接、图片、表格这8种非常常用的用法，其余请参照<a href=\"https://markdown.com.cn/\">官方网站</a></li>\n</ul>\n<h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h2><ul>\n<li>一级标题：<code># ZYY 1</code></li>\n<li>二级标题：<code>## ZYY 2</code></li>\n<li>三级标题：<code>### ZYY 3</code></li>\n<li>最简单的解释就是，<strong>n个#代表n级标题</strong>，空格之后加上标题就行</li>\n</ul>\n<h2 id=\"2-换行\"><a href=\"#2-换行\" class=\"headerlink\" title=\"2.换行\"></a>2.换行</h2><ul>\n<li>句子末尾加上 <code>&lt;br&gt;</code> 或者 <code>两个空格+Enter键</code><figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">example1</span>：<span class=\"hljs-variable\">ZYY</span> &lt;<span class=\"hljs-variable\">br</span>&gt;<br><span class=\"hljs-variable\">example2</span>：<span class=\"hljs-function\"><span class=\"hljs-title\">ZYY</span>(<span class=\"hljs-variable\">Space</span>*<span class=\"hljs-number\">2</span>+<span class=\"hljs-variable\">Enter</span>，括号和汉字自动忽视)</span><br></code></pre></td></tr></table></figure></li>\n<li><strong>最好用的还是2个空格+Enter键</strong>，但是你看不见它到底有没有换行，所以 <code>&lt;br&gt;</code> 这个是比较直观的，但是打字速度就慢了</li>\n</ul>\n<h2 id=\"3-强调\"><a href=\"#3-强调\" class=\"headerlink\" title=\"3.强调\"></a>3.强调</h2><ul>\n<li>粗体（Bold）： <code>**ZYY** 或者 __ZYY__</code></li>\n<li>斜体（Italic）： <code>*ZYY* 或者 _ZYY_</code></li>\n<li>粗斜体： <code>***ZYY*** 或者 ___ZYY___</code><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">example1：ZZZ <span class=\"hljs-strong\">**YYY**</span> YYY  或者ZZZ <span class=\"hljs-emphasis\">__YYY__</span> YYY<br>example2：ZZZ <span class=\"hljs-strong\">*YYY*</span> YYY  或者ZZZ <span class=\"hljs-emphasis\">_YYY_</span> YYY<br>example3：ZZZ <span class=\"hljs-strong\">***YYY**</span>* YYY  或者ZZZ <span class=\"hljs-emphasis\">___YYY__</span>_ YYY<br></code></pre></td></tr></table></figure></li>\n<li>这个没啥特殊要求，两种方法都可以，<strong>但是最好每种符号的前后都加上空格，不然有些会失灵</strong></li>\n</ul>\n<h2 id=\"4-代码块-and-代码\"><a href=\"#4-代码块-and-代码\" class=\"headerlink\" title=\"4.代码块 and 代码\"></a>4.代码块 and 代码</h2><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">代码： ` + ` 单个反引号做开头，单个反引号做结尾，中间就是特殊的代码区<br>代码块：``` + ``` 用三个反引号做开头，三个反引号做结尾，中间就是代码块<br><br>example1： ZZZ `YYY` YYY<br></code></pre></td></tr></table></figure>\n<ul>\n<li>这个代码块挺好用的，<strong>特别是想要强调说一些事情的时候，可以给他框出来</strong>，我上面的所有例子都是用代码块罗列的，清晰明了，代码块不一定写代码</li>\n</ul>\n<h2 id=\"5-分割线\"><a href=\"#5-分割线\" class=\"headerlink\" title=\"5.分割线\"></a>5.分割线</h2><ul>\n<li><code>*** 或者 --- 或者 ___</code><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">example1： <span class=\"hljs-strong\">***</span><br>example2： ---<br>example3： <span class=\"hljs-emphasis\">___</span><br></code></pre></td></tr></table></figure></li>\n<li>就会出现一个非常丑的线，<strong>这三根线的类型是一样的，不管用哪个都是一根线</strong></li>\n</ul>\n<h2 id=\"6-链接\"><a href=\"#6-链接\" class=\"headerlink\" title=\"6.链接\"></a>6.链接</h2><ul>\n<li>链接： <code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></li>\n<li>直接上网址或者email地址：&lt;链接地址&gt;<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">example1</span>：<span class=\"hljs-selector-tag\">ZZZ</span> <span class=\"hljs-selector-attr\">[YYY]</span>(<span class=\"hljs-attribute\">https</span>:<span class=\"hljs-comment\">//github.com/BraveYiYang) YYY</span><br>example2：ZZZ [YYY](<span class=\"hljs-attribute\">https</span>:<span class=\"hljs-comment\">//github.com/BraveYiYang &quot;Brave&quot;) YYY</span><br>example3：&lt;<span class=\"hljs-attribute\">https</span>:<span class=\"hljs-comment\">//github.com/BraveYiYang&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li>这个还是很好用的，中括号里面的是你可以随便定义，然后把你小括号的链接赋值在你中括号的定义里面，小括号的双引号里面是你鼠标放上去，他会显示出来你的小标签</li>\n</ul>\n<h2 id=\"7-图片\"><a href=\"#7-图片\" class=\"headerlink\" title=\"7.图片\"></a>7.图片</h2><ul>\n<li>插入图片： <code>[![图片alt](图片链接 &quot;图片title&quot;)](超链接)</code><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">example1：!<span class=\"hljs-selector-attr\">[ZYY]</span>(/ZYY/Z.jpg)<br>example2：!<span class=\"hljs-selector-attr\">[ZYY]</span>(/ZYY/Z<span class=\"hljs-selector-class\">.jpg</span> <span class=\"hljs-string\">&quot;Brave&quot;</span>)<br>example3：<span class=\"hljs-selector-attr\">[![ZYY]</span>(/ZYY/Z<span class=\"hljs-selector-class\">.jpg</span> <span class=\"hljs-string\">&quot;Brave&quot;</span>)](https:<span class=\"hljs-comment\">//github.com/BraveYiYang)</span><br></code></pre></td></tr></table></figure></li>\n<li>这个图片的用处是很多的，我们可以随心所欲的插入图片，<strong>图文并茂</strong></li>\n</ul>\n<h2 id=\"8-表格\"><a href=\"#8-表格\" class=\"headerlink\" title=\"8.表格\"></a>8.表格</h2><ul>\n<li>| 表示表格的线，用他来固定列数，几行就是表格的几行，</li>\n<li>— 来定义标题行，而且每一列的 — 数量不一样代表每一列的长度也不一样</li>\n<li>:— 表示左对齐 —: 表示右对齐 :—: 表示居中对齐<figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gherkin\">example1：<br>|<span class=\"hljs-string\"> Syntax      </span>|<span class=\"hljs-string\"> Description </span>|<br>|<span class=\"hljs-string\"> ----------- </span>|<span class=\"hljs-string\"> ----------- </span>|<br>|<span class=\"hljs-string\"> Header      </span>|<span class=\"hljs-string\"> Title       </span>|<br>|<span class=\"hljs-string\"> Paragraph   </span>|<span class=\"hljs-string\"> Text        </span>|<br>example2：<br>|<span class=\"hljs-string\"> Syntax </span>|<span class=\"hljs-string\"> Description </span>|<br>|<span class=\"hljs-string\"> --- </span>|<span class=\"hljs-string\"> ----------- </span>|<br>|<span class=\"hljs-string\"> Header </span>|<span class=\"hljs-string\"> Title </span>|<br>|<span class=\"hljs-string\"> Paragraph </span>|<span class=\"hljs-string\"> Text </span>|<br>example3：<br>|<span class=\"hljs-string\"> Syntax      </span>|<span class=\"hljs-string\"> Description </span>|<span class=\"hljs-string\"> Test Text     </span>|<br>|<span class=\"hljs-string\"> :---        </span>|<span class=\"hljs-string\">    :----:   </span>|<span class=\"hljs-string\">          ---: </span>|<br>|<span class=\"hljs-string\"> Header      </span>|<span class=\"hljs-string\"> Title       </span>|<span class=\"hljs-string\"> Here&#x27;s this   </span>|<br>|<span class=\"hljs-string\"> Paragraph   </span>|<span class=\"hljs-string\"> Text        </span>|<span class=\"hljs-string\"> And more      </span>|<br></code></pre></td></tr></table></figure></li>\n<li><strong>表格其实不是很常用，但是也是算作是一个基本的使用方法</strong></li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><strong>markdown的使用方法其实不难，而且也很容易入门，只不过没有那么直观，但是大家用习惯之后，就非常容易上手，所以鼓励大家多使用，熟能生巧，多练才会掌握的快！</strong></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"Markdown用法\"><a href=\"#Markdown用法\" class=\"headerlink\" title=\"Markdown用法\"></a>Markdown用法</h1><ul>\n<li>要写一个好看的文档，格式和各种引用非常重要，Markdown作为开发过程中的记录文件，也是目前应用最广泛的一个格式，因此开篇先分享一下基本用法。</li>\n<li>这边主要分享几种最常规的使用方法，主要有标题、换行、强调、代码块、分割线、链接、图片、表格这8种非常常用的用法，其余请参照<a href=\"https://markdown.com.cn/\">官方网站</a></li>\n</ul>\n<h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h2><ul>\n<li>一级标题：<code># ZYY 1</code></li>\n<li>二级标题：<code>## ZYY 2</code></li>\n<li>三级标题：<code>### ZYY 3</code></li>\n<li>最简单的解释就是，<strong>n个#代表n级标题</strong>，空格之后加上标题就行</li>\n</ul>\n<h2 id=\"2-换行\"><a href=\"#2-换行\" class=\"headerlink\" title=\"2.换行\"></a>2.换行</h2><ul>\n<li>句子末尾加上 <code>&lt;br&gt;</code> 或者 <code>两个空格+Enter键</code><figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">example1</span>：<span class=\"hljs-variable\">ZYY</span> &lt;<span class=\"hljs-variable\">br</span>&gt;<br><span class=\"hljs-variable\">example2</span>：<span class=\"hljs-function\"><span class=\"hljs-title\">ZYY</span>(<span class=\"hljs-variable\">Space</span>*<span class=\"hljs-number\">2</span>+<span class=\"hljs-variable\">Enter</span>，括号和汉字自动忽视)</span><br></code></pre></td></tr></table></figure></li>\n<li><strong>最好用的还是2个空格+Enter键</strong>，但是你看不见它到底有没有换行，所以 <code>&lt;br&gt;</code> 这个是比较直观的，但是打字速度就慢了</li>\n</ul>\n<h2 id=\"3-强调\"><a href=\"#3-强调\" class=\"headerlink\" title=\"3.强调\"></a>3.强调</h2><ul>\n<li>粗体（Bold）： <code>**ZYY** 或者 __ZYY__</code></li>\n<li>斜体（Italic）： <code>*ZYY* 或者 _ZYY_</code></li>\n<li>粗斜体： <code>***ZYY*** 或者 ___ZYY___</code><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">example1：ZZZ <span class=\"hljs-strong\">**YYY**</span> YYY  或者ZZZ <span class=\"hljs-emphasis\">__YYY__</span> YYY<br>example2：ZZZ <span class=\"hljs-strong\">*YYY*</span> YYY  或者ZZZ <span class=\"hljs-emphasis\">_YYY_</span> YYY<br>example3：ZZZ <span class=\"hljs-strong\">***YYY**</span>* YYY  或者ZZZ <span class=\"hljs-emphasis\">___YYY__</span>_ YYY<br></code></pre></td></tr></table></figure></li>\n<li>这个没啥特殊要求，两种方法都可以，<strong>但是最好每种符号的前后都加上空格，不然有些会失灵</strong></li>\n</ul>\n<h2 id=\"4-代码块-and-代码\"><a href=\"#4-代码块-and-代码\" class=\"headerlink\" title=\"4.代码块 and 代码\"></a>4.代码块 and 代码</h2><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">代码： ` + ` 单个反引号做开头，单个反引号做结尾，中间就是特殊的代码区<br>代码块：``` + ``` 用三个反引号做开头，三个反引号做结尾，中间就是代码块<br><br>example1： ZZZ `YYY` YYY<br></code></pre></td></tr></table></figure>\n<ul>\n<li>这个代码块挺好用的，<strong>特别是想要强调说一些事情的时候，可以给他框出来</strong>，我上面的所有例子都是用代码块罗列的，清晰明了，代码块不一定写代码</li>\n</ul>\n<h2 id=\"5-分割线\"><a href=\"#5-分割线\" class=\"headerlink\" title=\"5.分割线\"></a>5.分割线</h2><ul>\n<li><code>*** 或者 --- 或者 ___</code><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">example1： <span class=\"hljs-strong\">***</span><br>example2： ---<br>example3： <span class=\"hljs-emphasis\">___</span><br></code></pre></td></tr></table></figure></li>\n<li>就会出现一个非常丑的线，<strong>这三根线的类型是一样的，不管用哪个都是一根线</strong></li>\n</ul>\n<h2 id=\"6-链接\"><a href=\"#6-链接\" class=\"headerlink\" title=\"6.链接\"></a>6.链接</h2><ul>\n<li>链接： <code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></li>\n<li>直接上网址或者email地址：&lt;链接地址&gt;<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">example1</span>：<span class=\"hljs-selector-tag\">ZZZ</span> <span class=\"hljs-selector-attr\">[YYY]</span>(<span class=\"hljs-attribute\">https</span>:<span class=\"hljs-comment\">//github.com/BraveYiYang) YYY</span><br>example2：ZZZ [YYY](<span class=\"hljs-attribute\">https</span>:<span class=\"hljs-comment\">//github.com/BraveYiYang &quot;Brave&quot;) YYY</span><br>example3：&lt;<span class=\"hljs-attribute\">https</span>:<span class=\"hljs-comment\">//github.com/BraveYiYang&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li>这个还是很好用的，中括号里面的是你可以随便定义，然后把你小括号的链接赋值在你中括号的定义里面，小括号的双引号里面是你鼠标放上去，他会显示出来你的小标签</li>\n</ul>\n<h2 id=\"7-图片\"><a href=\"#7-图片\" class=\"headerlink\" title=\"7.图片\"></a>7.图片</h2><ul>\n<li>插入图片： <code>[![图片alt](图片链接 &quot;图片title&quot;)](超链接)</code><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">example1：!<span class=\"hljs-selector-attr\">[ZYY]</span>(/ZYY/Z.jpg)<br>example2：!<span class=\"hljs-selector-attr\">[ZYY]</span>(/ZYY/Z<span class=\"hljs-selector-class\">.jpg</span> <span class=\"hljs-string\">&quot;Brave&quot;</span>)<br>example3：<span class=\"hljs-selector-attr\">[![ZYY]</span>(/ZYY/Z<span class=\"hljs-selector-class\">.jpg</span> <span class=\"hljs-string\">&quot;Brave&quot;</span>)](https:<span class=\"hljs-comment\">//github.com/BraveYiYang)</span><br></code></pre></td></tr></table></figure></li>\n<li>这个图片的用处是很多的，我们可以随心所欲的插入图片，<strong>图文并茂</strong></li>\n</ul>\n<h2 id=\"8-表格\"><a href=\"#8-表格\" class=\"headerlink\" title=\"8.表格\"></a>8.表格</h2><ul>\n<li>| 表示表格的线，用他来固定列数，几行就是表格的几行，</li>\n<li>— 来定义标题行，而且每一列的 — 数量不一样代表每一列的长度也不一样</li>\n<li>:— 表示左对齐 —: 表示右对齐 :—: 表示居中对齐<figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gherkin\">example1：<br>|<span class=\"hljs-string\"> Syntax      </span>|<span class=\"hljs-string\"> Description </span>|<br>|<span class=\"hljs-string\"> ----------- </span>|<span class=\"hljs-string\"> ----------- </span>|<br>|<span class=\"hljs-string\"> Header      </span>|<span class=\"hljs-string\"> Title       </span>|<br>|<span class=\"hljs-string\"> Paragraph   </span>|<span class=\"hljs-string\"> Text        </span>|<br>example2：<br>|<span class=\"hljs-string\"> Syntax </span>|<span class=\"hljs-string\"> Description </span>|<br>|<span class=\"hljs-string\"> --- </span>|<span class=\"hljs-string\"> ----------- </span>|<br>|<span class=\"hljs-string\"> Header </span>|<span class=\"hljs-string\"> Title </span>|<br>|<span class=\"hljs-string\"> Paragraph </span>|<span class=\"hljs-string\"> Text </span>|<br>example3：<br>|<span class=\"hljs-string\"> Syntax      </span>|<span class=\"hljs-string\"> Description </span>|<span class=\"hljs-string\"> Test Text     </span>|<br>|<span class=\"hljs-string\"> :---        </span>|<span class=\"hljs-string\">    :----:   </span>|<span class=\"hljs-string\">          ---: </span>|<br>|<span class=\"hljs-string\"> Header      </span>|<span class=\"hljs-string\"> Title       </span>|<span class=\"hljs-string\"> Here&#x27;s this   </span>|<br>|<span class=\"hljs-string\"> Paragraph   </span>|<span class=\"hljs-string\"> Text        </span>|<span class=\"hljs-string\"> And more      </span>|<br></code></pre></td></tr></table></figure></li>\n<li><strong>表格其实不是很常用，但是也是算作是一个基本的使用方法</strong></li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li><strong>markdown的使用方法其实不难，而且也很容易入门，只不过没有那么直观，但是大家用习惯之后，就非常容易上手，所以鼓励大家多使用，熟能生巧，多练才会掌握的快！</strong></li>\n</ul>\n"},{"title":"控制工程学习笔记","date":"2024-01-25T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/6SYgJTyZevuQcIE.png","_content":"\n# 控制工程学习笔记\n\n- 【学习路径】动力学方程-拉普拉斯变换-PID-卡尔曼滤波-bode+奈奎斯特图\n\n## **1 学习资料**\n\n- 【怎么学习经典控制（结合MATLAB）】https://zhuanlan.zhihu.com/p/266048048\n- 【物理量解释】[转动惯量到底是个什么物理量_转动惯量类比-CSDN博客](https://blog.csdn.net/qq_38422317/article/details/108460482)\n- 【常用的微分，求导和积分公式大总结】[数学之美：常用的微分，求导和积分公式大总结_微积分求导公式-CSDN博客](https://blog.csdn.net/wfei101/article/details/82431442)\n- 【倒立摆建模控制系统设计】[线性系统大作业——1.一阶倒立摆建模与控制系统设计_一阶倒立摆系统的建模仿真与控制-CSDN博客](https://blog.csdn.net/qq_42731705/article/details/122464642)\n- 【小车动态模型设计Matlab】[J_H_Li投稿视频-J_H_Li视频分享-哔哩哔哩视频 (bilibili.com)](https://space.bilibili.com/1134403370/video)\n- 【如何使用Typora编辑数学公式】[如何使用Typora编辑数学公式](https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=打开Typora选择数学模块 点击“段落”—>“公式块”,快捷键Ctrl%2BShift%2Bm 在两个%24中间直接编辑公式)\n- 【由拉普拉斯变换到传递函数】[由拉普拉斯变换到传递函数 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/146769901)\n- 【如何给文科生解释傅里叶变换】[如何给文科生解释傅里叶变换？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/48305950)\n- 【超级直观！！！】[直观の数学 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/c_1041689010053341184)\n- 【一阶倒立摆的PID控制和LQR控制】[一阶倒立摆的PID控制和LQR控制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/54071212)\n- 【拉普拉斯变换】[拉普拉斯变换 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/拉普拉斯变换#)\n- 【LQR算法】https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1\n- 【simulink快捷键】[Simulink建模与仿真学习笔记之常用快捷操作（快捷键）_simulink快捷键-CSDN博客](https://blog.csdn.net/booksyhay/article/details/88129359)\n\n![image-20240131111616891.png](https://s2.loli.net/2024/07/25/K2CbOEa8XyjN9Io.png)\n\n## 2 动力学方程求解\n\n### 2.1 什么是动力学方程\n\n- 动力学方程（Differential Equations of Motion），也称为运动方程，是描述物体运动的数学方程。这些方程通常是微分方程，用来描述物体的位置、速度、加速度等随时间的变化关系。**动力学方程是经典力学的基础，它们揭示了物体受到的力和运动状态之间的关系。**\n\n### 2.2 建立倒立摆动力学方程步骤\n\n#### **①牛顿第二定律**\n\n- **【确定世界坐标】**世界坐标设立不同，求解结果不同\n- **【确定反馈量、控制量和控制目标】**获得需要设置的传感器和控制对象以及实现目标\n- **【分析系统受力情况】**分析系统位移和转动的情况以及所受外力情况\n- **【罗列涉及物理量】**罗列所有已知的量，并确定质心\n- **【分析受力情况】**根据位移和转动情况，列各个子系统的受力\n- **【合并公式求出动力学方程】**合并子系统受力，求出总系统的动力学方程\n\n#### **②拉格朗日定理**\n\n- **【确定世界坐标】**世界坐标设立不同，求解结果不同\n- **【确定反馈量、控制量和控制目标】**获得需要设置的传感器和控制对象以及实现目标\n- **【分析系统受力情况】**分析系统位移和转动的情况以及所受外力情况\n- **【罗列涉及物理量】**罗列所有已知的量，并确定质心\n- **【列举拉格朗日方程】**罗列拉格朗日表达式\n- **【求解拉格朗日方程】**多少个变量，求解多少个拉格朗日方程，分析所有系统的总动能（由于速度产生的动能，竖直方向也可能存在，除重力势能之外的所有力）、总势能（重力势能），并根据拉格朗日公式进行求解，求出动力学方程\n- **【合并得出动力学方程】**合并变量式，得到总系统的动力学方程\n\n### 2.3 求解案例过程\n\n![image-20240202100715483.png](https://s2.loli.net/2024/07/25/J3nAMrF8SgCkzZ5.png)\n\n#### **①牛顿第二定律求解**\n\n![image-20240203181633034.png](https://s2.loli.net/2024/07/25/tJMUe8F5PoNnumL.png)\n\n#### **②拉格朗日定理** \n\n![image-20240203121952572.png](https://s2.loli.net/2024/07/25/2Pg6zReWbKABMTu.png)\n\n### 2.4 线性化处理\n\n倒立摆的动力学方程通常是非线性的，但在某些应用中，为了进行控制设计或分析，可以对动力学方程进行线性化。线性化的目的是获得一个简化的线性系统，以便应用线性控制理论。\n\n小角度近似 sin(*θ*)≈*θ* 是一种在角度较小的情况下进行近似的数学技巧，它通常用于简化非线性系统的分析和求解。这个近似的合理性来源于正弦函数在零附近的泰勒级数展开。\n\n![image-20240203181307595.png](https://s2.loli.net/2024/07/25/VwCkGBTNlHUOQp1.png)\n\n![image-20240203181739601.png](https://s2.loli.net/2024/07/25/EnfWpyGBqP1txgF.png)\n\n## 3 拉普拉斯变换求传递函数\n\n拉普拉斯变换是一种数学工具，用于将一个函数从时域（通常是时间域）转换到复频域。拉普拉斯变换的好处之一是它可以将微分方程转换成代数方程，从而简化了问题的求解。\n\n物理上可实现的信号总有相对应的拉氏变换（根据拉普拉斯的存在定义可得）\n\n拉普拉斯变换通常更适用于线性系统和线性微分方程。当面对非线性常微分方程时，使用拉普拉斯变换可能会变得更加困难，因为拉普拉斯变换的一些性质和简便性主要基于线性系统的性质，有时可以尝试将非线性问题线性化\n\n### 3.1 拉氏变换定义\n\n![image-20240205132357835.png](https://s2.loli.net/2024/07/25/FzdD1hvwgUOriQf.png)\n\n### 3.2 拉氏逆变换定义\n\n![image-20240205132336647.png](https://s2.loli.net/2024/07/25/Ikbf73zKeJ1VLSN.png)\n\n### 3.3 拉普拉斯各类定理\n\n![image-20240205133019691.png](https://s2.loli.net/2024/07/25/LnF38Jj7eR1cE6o.png)\n\n### 3.4 常用拉氏变换公式\n\n![image-20240205171104326.png](https://s2.loli.net/2024/07/25/O9zh1y8KqlYjbDH.png)\n\n![image-20240205171210118.png](https://s2.loli.net/2024/07/25/8LqcGhTnJNzOPIR.png)\n\n### 3.5 复频域好处\n\n- **频率响应分析：** 复频域提供了对系统对不同频率输入信号的响应更清晰的视角。通过分析系统在复频域中的行为，可以得到频率响应信息，即系统对不同频率成分的放大或衰减程度。这对于了解系统的频率特性和选择适当的滤波器或控制器非常有帮助。\n\n- **稳定性分析：** 复频域分析对于评估系统的稳定性至关重要。通过观察系统在复频域中的极点（pole）和零点（zero），可以得知系统的稳定性信息。例如，在控制系统中，稳定性分析可以通过查看系统的极点位置来判断系统的稳定性和相应的性能。\n\n- **传递函数表示：** 复频域中，系统的行为可以通过传递函数（Transfer Function）更简洁地表示。传递函数是输出与输入的拉普拉斯变换之比，对于线性时不变系统，它在复频域提供了对系统的完整描述。\n\n- **频域设计：** 复频域分析对于在设计中选择合适的控制器或滤波器参数非常有用。通过在频域中分析性能要求和系统响应，可以更好地调整系统以满足指定的性能规范。\n\n- **去除时域中的复杂性：** 在复频域中分析系统可能会使分析更简便。例如，复频域分析可以通过拉普拉斯变换将微分方程转换为代数方程，从而减少问题的复杂性。\n\n### 3.6 案例求解\n\n![image-20240205191534825.png](https://s2.loli.net/2024/07/25/4LZuYacRPtHSbkW.png)\n\n### 3.7 传递函数求解\n\n![image-20240210115216577.png](https://s2.loli.net/2024/07/25/u8FnNmArfQo7HRS.png)\n\n## 4 知识点总结\n\n- **【分析力】**小车水平位移、竖直位移，摆杆转动、水平位移、竖直位移\n\n- **【拉格朗日建模】**小车受到外力，摆杆没有受到外力，小车的变量是位移，摆杆的变量是角度，所以一共两个方程，摆杆右边等于零\n\n- **【线性化】**消去三角函数，利用约等假设进行消除\n- **【转动惯量定义】**转动惯量（也称为转动惯性、惯性矩）是描述物体对绕轴旋转的难度或惯性程度的物理量。它与物体的质量分布和形状有关，是旋转运动中的重要参量。\n- **【势能定义】**势能是物体由于位置而具有的能量，它与物体的位置和相互作用力有关。势能通常用符号 *U* 表示\n- **【动能定义】**动能是物体由于运动而具有的能量，它与物体的质量和速度有关。动能通常用符号 *T* 表示\n- **【系统总动能】**摆杆动能需要考虑竖直方向具有速度的运动，除重力做功之外，支撑力也有做功\n\n- **【转动惯量正反】**顺时针为正、逆时针为副\n- 【**线性化处理**】如果两个变量的关系可以通过直线来表示，且满足以下两个条件：1.比例性，变量的变化是成比例的。2.叠加性，两个或多个影响因素的效应可以相加。\n- **【傅里叶变换】**傅里叶变换的内涵，就是满足一定条件的函数可以表示成三角函数(正弦和/或余弦函数)或者它们的积分的线性组合。","source":"_posts/20240201ZYY-控制工程学习笔记.md","raw":"---\ntitle: 控制工程学习笔记\ntag: 控制工程\ndate: 2024-01-26\ncategories: 控制设计\nindex_img: https://s2.loli.net/2024/07/31/6SYgJTyZevuQcIE.png\n---\n\n# 控制工程学习笔记\n\n- 【学习路径】动力学方程-拉普拉斯变换-PID-卡尔曼滤波-bode+奈奎斯特图\n\n## **1 学习资料**\n\n- 【怎么学习经典控制（结合MATLAB）】https://zhuanlan.zhihu.com/p/266048048\n- 【物理量解释】[转动惯量到底是个什么物理量_转动惯量类比-CSDN博客](https://blog.csdn.net/qq_38422317/article/details/108460482)\n- 【常用的微分，求导和积分公式大总结】[数学之美：常用的微分，求导和积分公式大总结_微积分求导公式-CSDN博客](https://blog.csdn.net/wfei101/article/details/82431442)\n- 【倒立摆建模控制系统设计】[线性系统大作业——1.一阶倒立摆建模与控制系统设计_一阶倒立摆系统的建模仿真与控制-CSDN博客](https://blog.csdn.net/qq_42731705/article/details/122464642)\n- 【小车动态模型设计Matlab】[J_H_Li投稿视频-J_H_Li视频分享-哔哩哔哩视频 (bilibili.com)](https://space.bilibili.com/1134403370/video)\n- 【如何使用Typora编辑数学公式】[如何使用Typora编辑数学公式](https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=打开Typora选择数学模块 点击“段落”—>“公式块”,快捷键Ctrl%2BShift%2Bm 在两个%24中间直接编辑公式)\n- 【由拉普拉斯变换到传递函数】[由拉普拉斯变换到传递函数 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/146769901)\n- 【如何给文科生解释傅里叶变换】[如何给文科生解释傅里叶变换？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/48305950)\n- 【超级直观！！！】[直观の数学 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/c_1041689010053341184)\n- 【一阶倒立摆的PID控制和LQR控制】[一阶倒立摆的PID控制和LQR控制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/54071212)\n- 【拉普拉斯变换】[拉普拉斯变换 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/拉普拉斯变换#)\n- 【LQR算法】https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1\n- 【simulink快捷键】[Simulink建模与仿真学习笔记之常用快捷操作（快捷键）_simulink快捷键-CSDN博客](https://blog.csdn.net/booksyhay/article/details/88129359)\n\n![image-20240131111616891.png](https://s2.loli.net/2024/07/25/K2CbOEa8XyjN9Io.png)\n\n## 2 动力学方程求解\n\n### 2.1 什么是动力学方程\n\n- 动力学方程（Differential Equations of Motion），也称为运动方程，是描述物体运动的数学方程。这些方程通常是微分方程，用来描述物体的位置、速度、加速度等随时间的变化关系。**动力学方程是经典力学的基础，它们揭示了物体受到的力和运动状态之间的关系。**\n\n### 2.2 建立倒立摆动力学方程步骤\n\n#### **①牛顿第二定律**\n\n- **【确定世界坐标】**世界坐标设立不同，求解结果不同\n- **【确定反馈量、控制量和控制目标】**获得需要设置的传感器和控制对象以及实现目标\n- **【分析系统受力情况】**分析系统位移和转动的情况以及所受外力情况\n- **【罗列涉及物理量】**罗列所有已知的量，并确定质心\n- **【分析受力情况】**根据位移和转动情况，列各个子系统的受力\n- **【合并公式求出动力学方程】**合并子系统受力，求出总系统的动力学方程\n\n#### **②拉格朗日定理**\n\n- **【确定世界坐标】**世界坐标设立不同，求解结果不同\n- **【确定反馈量、控制量和控制目标】**获得需要设置的传感器和控制对象以及实现目标\n- **【分析系统受力情况】**分析系统位移和转动的情况以及所受外力情况\n- **【罗列涉及物理量】**罗列所有已知的量，并确定质心\n- **【列举拉格朗日方程】**罗列拉格朗日表达式\n- **【求解拉格朗日方程】**多少个变量，求解多少个拉格朗日方程，分析所有系统的总动能（由于速度产生的动能，竖直方向也可能存在，除重力势能之外的所有力）、总势能（重力势能），并根据拉格朗日公式进行求解，求出动力学方程\n- **【合并得出动力学方程】**合并变量式，得到总系统的动力学方程\n\n### 2.3 求解案例过程\n\n![image-20240202100715483.png](https://s2.loli.net/2024/07/25/J3nAMrF8SgCkzZ5.png)\n\n#### **①牛顿第二定律求解**\n\n![image-20240203181633034.png](https://s2.loli.net/2024/07/25/tJMUe8F5PoNnumL.png)\n\n#### **②拉格朗日定理** \n\n![image-20240203121952572.png](https://s2.loli.net/2024/07/25/2Pg6zReWbKABMTu.png)\n\n### 2.4 线性化处理\n\n倒立摆的动力学方程通常是非线性的，但在某些应用中，为了进行控制设计或分析，可以对动力学方程进行线性化。线性化的目的是获得一个简化的线性系统，以便应用线性控制理论。\n\n小角度近似 sin(*θ*)≈*θ* 是一种在角度较小的情况下进行近似的数学技巧，它通常用于简化非线性系统的分析和求解。这个近似的合理性来源于正弦函数在零附近的泰勒级数展开。\n\n![image-20240203181307595.png](https://s2.loli.net/2024/07/25/VwCkGBTNlHUOQp1.png)\n\n![image-20240203181739601.png](https://s2.loli.net/2024/07/25/EnfWpyGBqP1txgF.png)\n\n## 3 拉普拉斯变换求传递函数\n\n拉普拉斯变换是一种数学工具，用于将一个函数从时域（通常是时间域）转换到复频域。拉普拉斯变换的好处之一是它可以将微分方程转换成代数方程，从而简化了问题的求解。\n\n物理上可实现的信号总有相对应的拉氏变换（根据拉普拉斯的存在定义可得）\n\n拉普拉斯变换通常更适用于线性系统和线性微分方程。当面对非线性常微分方程时，使用拉普拉斯变换可能会变得更加困难，因为拉普拉斯变换的一些性质和简便性主要基于线性系统的性质，有时可以尝试将非线性问题线性化\n\n### 3.1 拉氏变换定义\n\n![image-20240205132357835.png](https://s2.loli.net/2024/07/25/FzdD1hvwgUOriQf.png)\n\n### 3.2 拉氏逆变换定义\n\n![image-20240205132336647.png](https://s2.loli.net/2024/07/25/Ikbf73zKeJ1VLSN.png)\n\n### 3.3 拉普拉斯各类定理\n\n![image-20240205133019691.png](https://s2.loli.net/2024/07/25/LnF38Jj7eR1cE6o.png)\n\n### 3.4 常用拉氏变换公式\n\n![image-20240205171104326.png](https://s2.loli.net/2024/07/25/O9zh1y8KqlYjbDH.png)\n\n![image-20240205171210118.png](https://s2.loli.net/2024/07/25/8LqcGhTnJNzOPIR.png)\n\n### 3.5 复频域好处\n\n- **频率响应分析：** 复频域提供了对系统对不同频率输入信号的响应更清晰的视角。通过分析系统在复频域中的行为，可以得到频率响应信息，即系统对不同频率成分的放大或衰减程度。这对于了解系统的频率特性和选择适当的滤波器或控制器非常有帮助。\n\n- **稳定性分析：** 复频域分析对于评估系统的稳定性至关重要。通过观察系统在复频域中的极点（pole）和零点（zero），可以得知系统的稳定性信息。例如，在控制系统中，稳定性分析可以通过查看系统的极点位置来判断系统的稳定性和相应的性能。\n\n- **传递函数表示：** 复频域中，系统的行为可以通过传递函数（Transfer Function）更简洁地表示。传递函数是输出与输入的拉普拉斯变换之比，对于线性时不变系统，它在复频域提供了对系统的完整描述。\n\n- **频域设计：** 复频域分析对于在设计中选择合适的控制器或滤波器参数非常有用。通过在频域中分析性能要求和系统响应，可以更好地调整系统以满足指定的性能规范。\n\n- **去除时域中的复杂性：** 在复频域中分析系统可能会使分析更简便。例如，复频域分析可以通过拉普拉斯变换将微分方程转换为代数方程，从而减少问题的复杂性。\n\n### 3.6 案例求解\n\n![image-20240205191534825.png](https://s2.loli.net/2024/07/25/4LZuYacRPtHSbkW.png)\n\n### 3.7 传递函数求解\n\n![image-20240210115216577.png](https://s2.loli.net/2024/07/25/u8FnNmArfQo7HRS.png)\n\n## 4 知识点总结\n\n- **【分析力】**小车水平位移、竖直位移，摆杆转动、水平位移、竖直位移\n\n- **【拉格朗日建模】**小车受到外力，摆杆没有受到外力，小车的变量是位移，摆杆的变量是角度，所以一共两个方程，摆杆右边等于零\n\n- **【线性化】**消去三角函数，利用约等假设进行消除\n- **【转动惯量定义】**转动惯量（也称为转动惯性、惯性矩）是描述物体对绕轴旋转的难度或惯性程度的物理量。它与物体的质量分布和形状有关，是旋转运动中的重要参量。\n- **【势能定义】**势能是物体由于位置而具有的能量，它与物体的位置和相互作用力有关。势能通常用符号 *U* 表示\n- **【动能定义】**动能是物体由于运动而具有的能量，它与物体的质量和速度有关。动能通常用符号 *T* 表示\n- **【系统总动能】**摆杆动能需要考虑竖直方向具有速度的运动，除重力做功之外，支撑力也有做功\n\n- **【转动惯量正反】**顺时针为正、逆时针为副\n- 【**线性化处理**】如果两个变量的关系可以通过直线来表示，且满足以下两个条件：1.比例性，变量的变化是成比例的。2.叠加性，两个或多个影响因素的效应可以相加。\n- **【傅里叶变换】**傅里叶变换的内涵，就是满足一定条件的函数可以表示成三角函数(正弦和/或余弦函数)或者它们的积分的线性组合。","slug":"20240201ZYY-控制工程学习笔记","published":1,"updated":"2024-08-05T11:33:53.987Z","_id":"clz9aaxq60005ygfbaq7s29hk","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"控制工程学习笔记\"><a href=\"#控制工程学习笔记\" class=\"headerlink\" title=\"控制工程学习笔记\"></a>控制工程学习笔记</h1><ul>\n<li>【学习路径】动力学方程-拉普拉斯变换-PID-卡尔曼滤波-bode+奈奎斯特图</li>\n</ul>\n<h2 id=\"1-学习资料\"><a href=\"#1-学习资料\" class=\"headerlink\" title=\"1 学习资料\"></a><strong>1 学习资料</strong></h2><ul>\n<li>【怎么学习经典控制（结合MATLAB）】<a href=\"https://zhuanlan.zhihu.com/p/266048048\">https://zhuanlan.zhihu.com/p/266048048</a></li>\n<li>【物理量解释】<a href=\"https://blog.csdn.net/qq_38422317/article/details/108460482\">转动惯量到底是个什么物理量_转动惯量类比-CSDN博客</a></li>\n<li>【常用的微分，求导和积分公式大总结】<a href=\"https://blog.csdn.net/wfei101/article/details/82431442\">数学之美：常用的微分，求导和积分公式大总结_微积分求导公式-CSDN博客</a></li>\n<li>【倒立摆建模控制系统设计】<a href=\"https://blog.csdn.net/qq_42731705/article/details/122464642\">线性系统大作业——1.一阶倒立摆建模与控制系统设计_一阶倒立摆系统的建模仿真与控制-CSDN博客</a></li>\n<li>【小车动态模型设计Matlab】<a href=\"https://space.bilibili.com/1134403370/video\">J_H_Li投稿视频-J_H_Li视频分享-哔哩哔哩视频 (bilibili.com)</a></li>\n<li>【如何使用Typora编辑数学公式】[如何使用Typora编辑数学公式](<a href=\"https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=%E6%89%93%E5%BC%80Typora%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9D%97\">https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=打开Typora选择数学模块</a> 点击“段落”—&gt;“公式块”,快捷键Ctrl%2BShift%2Bm 在两个%24中间直接编辑公式)</li>\n<li>【由拉普拉斯变换到传递函数】<a href=\"https://zhuanlan.zhihu.com/p/146769901\">由拉普拉斯变换到传递函数 - 知乎 (zhihu.com)</a></li>\n<li>【如何给文科生解释傅里叶变换】<a href=\"https://zhuanlan.zhihu.com/p/48305950\">如何给文科生解释傅里叶变换？ - 知乎 (zhihu.com)</a></li>\n<li>【超级直观！！！】<a href=\"https://zhuanlan.zhihu.com/c_1041689010053341184\">直观の数学 - 知乎 (zhihu.com)</a></li>\n<li>【一阶倒立摆的PID控制和LQR控制】<a href=\"https://zhuanlan.zhihu.com/p/54071212\">一阶倒立摆的PID控制和LQR控制 - 知乎 (zhihu.com)</a></li>\n<li>【拉普拉斯变换】<a href=\"https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2#\">拉普拉斯变换 - 维基百科，自由的百科全书 (wikipedia.org)</a></li>\n<li>【LQR算法】<a href=\"https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1\">https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1</a></li>\n<li>【simulink快捷键】<a href=\"https://blog.csdn.net/booksyhay/article/details/88129359\">Simulink建模与仿真学习笔记之常用快捷操作（快捷键）_simulink快捷键-CSDN博客</a></li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/25/K2CbOEa8XyjN9Io.png\" alt=\"image-20240131111616891.png\"></p>\n<h2 id=\"2-动力学方程求解\"><a href=\"#2-动力学方程求解\" class=\"headerlink\" title=\"2 动力学方程求解\"></a>2 动力学方程求解</h2><h3 id=\"2-1-什么是动力学方程\"><a href=\"#2-1-什么是动力学方程\" class=\"headerlink\" title=\"2.1 什么是动力学方程\"></a>2.1 什么是动力学方程</h3><ul>\n<li>动力学方程（Differential Equations of Motion），也称为运动方程，是描述物体运动的数学方程。这些方程通常是微分方程，用来描述物体的位置、速度、加速度等随时间的变化关系。<strong>动力学方程是经典力学的基础，它们揭示了物体受到的力和运动状态之间的关系。</strong></li>\n</ul>\n<h3 id=\"2-2-建立倒立摆动力学方程步骤\"><a href=\"#2-2-建立倒立摆动力学方程步骤\" class=\"headerlink\" title=\"2.2 建立倒立摆动力学方程步骤\"></a>2.2 建立倒立摆动力学方程步骤</h3><h4 id=\"①牛顿第二定律\"><a href=\"#①牛顿第二定律\" class=\"headerlink\" title=\"①牛顿第二定律\"></a><strong>①牛顿第二定律</strong></h4><ul>\n<li><strong>【确定世界坐标】</strong>世界坐标设立不同，求解结果不同</li>\n<li><strong>【确定反馈量、控制量和控制目标】</strong>获得需要设置的传感器和控制对象以及实现目标</li>\n<li><strong>【分析系统受力情况】</strong>分析系统位移和转动的情况以及所受外力情况</li>\n<li><strong>【罗列涉及物理量】</strong>罗列所有已知的量，并确定质心</li>\n<li><strong>【分析受力情况】</strong>根据位移和转动情况，列各个子系统的受力</li>\n<li><strong>【合并公式求出动力学方程】</strong>合并子系统受力，求出总系统的动力学方程</li>\n</ul>\n<h4 id=\"②拉格朗日定理\"><a href=\"#②拉格朗日定理\" class=\"headerlink\" title=\"②拉格朗日定理\"></a><strong>②拉格朗日定理</strong></h4><ul>\n<li><strong>【确定世界坐标】</strong>世界坐标设立不同，求解结果不同</li>\n<li><strong>【确定反馈量、控制量和控制目标】</strong>获得需要设置的传感器和控制对象以及实现目标</li>\n<li><strong>【分析系统受力情况】</strong>分析系统位移和转动的情况以及所受外力情况</li>\n<li><strong>【罗列涉及物理量】</strong>罗列所有已知的量，并确定质心</li>\n<li><strong>【列举拉格朗日方程】</strong>罗列拉格朗日表达式</li>\n<li><strong>【求解拉格朗日方程】</strong>多少个变量，求解多少个拉格朗日方程，分析所有系统的总动能（由于速度产生的动能，竖直方向也可能存在，除重力势能之外的所有力）、总势能（重力势能），并根据拉格朗日公式进行求解，求出动力学方程</li>\n<li><strong>【合并得出动力学方程】</strong>合并变量式，得到总系统的动力学方程</li>\n</ul>\n<h3 id=\"2-3-求解案例过程\"><a href=\"#2-3-求解案例过程\" class=\"headerlink\" title=\"2.3 求解案例过程\"></a>2.3 求解案例过程</h3><p><img src=\"https://s2.loli.net/2024/07/25/J3nAMrF8SgCkzZ5.png\" alt=\"image-20240202100715483.png\"></p>\n<h4 id=\"①牛顿第二定律求解\"><a href=\"#①牛顿第二定律求解\" class=\"headerlink\" title=\"①牛顿第二定律求解\"></a><strong>①牛顿第二定律求解</strong></h4><p><img src=\"https://s2.loli.net/2024/07/25/tJMUe8F5PoNnumL.png\" alt=\"image-20240203181633034.png\"></p>\n<h4 id=\"②拉格朗日定理-1\"><a href=\"#②拉格朗日定理-1\" class=\"headerlink\" title=\"②拉格朗日定理\"></a><strong>②拉格朗日定理</strong></h4><p><img src=\"https://s2.loli.net/2024/07/25/2Pg6zReWbKABMTu.png\" alt=\"image-20240203121952572.png\"></p>\n<h3 id=\"2-4-线性化处理\"><a href=\"#2-4-线性化处理\" class=\"headerlink\" title=\"2.4 线性化处理\"></a>2.4 线性化处理</h3><p>倒立摆的动力学方程通常是非线性的，但在某些应用中，为了进行控制设计或分析，可以对动力学方程进行线性化。线性化的目的是获得一个简化的线性系统，以便应用线性控制理论。</p>\n<p>小角度近似 sin(<em>θ</em>)≈<em>θ</em> 是一种在角度较小的情况下进行近似的数学技巧，它通常用于简化非线性系统的分析和求解。这个近似的合理性来源于正弦函数在零附近的泰勒级数展开。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/VwCkGBTNlHUOQp1.png\" alt=\"image-20240203181307595.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/EnfWpyGBqP1txgF.png\" alt=\"image-20240203181739601.png\"></p>\n<h2 id=\"3-拉普拉斯变换求传递函数\"><a href=\"#3-拉普拉斯变换求传递函数\" class=\"headerlink\" title=\"3 拉普拉斯变换求传递函数\"></a>3 拉普拉斯变换求传递函数</h2><p>拉普拉斯变换是一种数学工具，用于将一个函数从时域（通常是时间域）转换到复频域。拉普拉斯变换的好处之一是它可以将微分方程转换成代数方程，从而简化了问题的求解。</p>\n<p>物理上可实现的信号总有相对应的拉氏变换（根据拉普拉斯的存在定义可得）</p>\n<p>拉普拉斯变换通常更适用于线性系统和线性微分方程。当面对非线性常微分方程时，使用拉普拉斯变换可能会变得更加困难，因为拉普拉斯变换的一些性质和简便性主要基于线性系统的性质，有时可以尝试将非线性问题线性化</p>\n<h3 id=\"3-1-拉氏变换定义\"><a href=\"#3-1-拉氏变换定义\" class=\"headerlink\" title=\"3.1 拉氏变换定义\"></a>3.1 拉氏变换定义</h3><p><img src=\"https://s2.loli.net/2024/07/25/FzdD1hvwgUOriQf.png\" alt=\"image-20240205132357835.png\"></p>\n<h3 id=\"3-2-拉氏逆变换定义\"><a href=\"#3-2-拉氏逆变换定义\" class=\"headerlink\" title=\"3.2 拉氏逆变换定义\"></a>3.2 拉氏逆变换定义</h3><p><img src=\"https://s2.loli.net/2024/07/25/Ikbf73zKeJ1VLSN.png\" alt=\"image-20240205132336647.png\"></p>\n<h3 id=\"3-3-拉普拉斯各类定理\"><a href=\"#3-3-拉普拉斯各类定理\" class=\"headerlink\" title=\"3.3 拉普拉斯各类定理\"></a>3.3 拉普拉斯各类定理</h3><p><img src=\"https://s2.loli.net/2024/07/25/LnF38Jj7eR1cE6o.png\" alt=\"image-20240205133019691.png\"></p>\n<h3 id=\"3-4-常用拉氏变换公式\"><a href=\"#3-4-常用拉氏变换公式\" class=\"headerlink\" title=\"3.4 常用拉氏变换公式\"></a>3.4 常用拉氏变换公式</h3><p><img src=\"https://s2.loli.net/2024/07/25/O9zh1y8KqlYjbDH.png\" alt=\"image-20240205171104326.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/8LqcGhTnJNzOPIR.png\" alt=\"image-20240205171210118.png\"></p>\n<h3 id=\"3-5-复频域好处\"><a href=\"#3-5-复频域好处\" class=\"headerlink\" title=\"3.5 复频域好处\"></a>3.5 复频域好处</h3><ul>\n<li><p><strong>频率响应分析：</strong> 复频域提供了对系统对不同频率输入信号的响应更清晰的视角。通过分析系统在复频域中的行为，可以得到频率响应信息，即系统对不同频率成分的放大或衰减程度。这对于了解系统的频率特性和选择适当的滤波器或控制器非常有帮助。</p>\n</li>\n<li><p><strong>稳定性分析：</strong> 复频域分析对于评估系统的稳定性至关重要。通过观察系统在复频域中的极点（pole）和零点（zero），可以得知系统的稳定性信息。例如，在控制系统中，稳定性分析可以通过查看系统的极点位置来判断系统的稳定性和相应的性能。</p>\n</li>\n<li><p><strong>传递函数表示：</strong> 复频域中，系统的行为可以通过传递函数（Transfer Function）更简洁地表示。传递函数是输出与输入的拉普拉斯变换之比，对于线性时不变系统，它在复频域提供了对系统的完整描述。</p>\n</li>\n<li><p><strong>频域设计：</strong> 复频域分析对于在设计中选择合适的控制器或滤波器参数非常有用。通过在频域中分析性能要求和系统响应，可以更好地调整系统以满足指定的性能规范。</p>\n</li>\n<li><p><strong>去除时域中的复杂性：</strong> 在复频域中分析系统可能会使分析更简便。例如，复频域分析可以通过拉普拉斯变换将微分方程转换为代数方程，从而减少问题的复杂性。</p>\n</li>\n</ul>\n<h3 id=\"3-6-案例求解\"><a href=\"#3-6-案例求解\" class=\"headerlink\" title=\"3.6 案例求解\"></a>3.6 案例求解</h3><p><img src=\"https://s2.loli.net/2024/07/25/4LZuYacRPtHSbkW.png\" alt=\"image-20240205191534825.png\"></p>\n<h3 id=\"3-7-传递函数求解\"><a href=\"#3-7-传递函数求解\" class=\"headerlink\" title=\"3.7 传递函数求解\"></a>3.7 传递函数求解</h3><p><img src=\"https://s2.loli.net/2024/07/25/u8FnNmArfQo7HRS.png\" alt=\"image-20240210115216577.png\"></p>\n<h2 id=\"4-知识点总结\"><a href=\"#4-知识点总结\" class=\"headerlink\" title=\"4 知识点总结\"></a>4 知识点总结</h2><ul>\n<li><p><strong>【分析力】</strong>小车水平位移、竖直位移，摆杆转动、水平位移、竖直位移</p>\n</li>\n<li><p><strong>【拉格朗日建模】</strong>小车受到外力，摆杆没有受到外力，小车的变量是位移，摆杆的变量是角度，所以一共两个方程，摆杆右边等于零</p>\n</li>\n<li><p><strong>【线性化】</strong>消去三角函数，利用约等假设进行消除</p>\n</li>\n<li><p><strong>【转动惯量定义】</strong>转动惯量（也称为转动惯性、惯性矩）是描述物体对绕轴旋转的难度或惯性程度的物理量。它与物体的质量分布和形状有关，是旋转运动中的重要参量。</p>\n</li>\n<li><p><strong>【势能定义】</strong>势能是物体由于位置而具有的能量，它与物体的位置和相互作用力有关。势能通常用符号 <em>U</em> 表示</p>\n</li>\n<li><p><strong>【动能定义】</strong>动能是物体由于运动而具有的能量，它与物体的质量和速度有关。动能通常用符号 <em>T</em> 表示</p>\n</li>\n<li><p><strong>【系统总动能】</strong>摆杆动能需要考虑竖直方向具有速度的运动，除重力做功之外，支撑力也有做功</p>\n</li>\n<li><p><strong>【转动惯量正反】</strong>顺时针为正、逆时针为副</p>\n</li>\n<li><p>【<strong>线性化处理</strong>】如果两个变量的关系可以通过直线来表示，且满足以下两个条件：1.比例性，变量的变化是成比例的。2.叠加性，两个或多个影响因素的效应可以相加。</p>\n</li>\n<li><p><strong>【傅里叶变换】</strong>傅里叶变换的内涵，就是满足一定条件的函数可以表示成三角函数(正弦和&#x2F;或余弦函数)或者它们的积分的线性组合。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"控制工程学习笔记\"><a href=\"#控制工程学习笔记\" class=\"headerlink\" title=\"控制工程学习笔记\"></a>控制工程学习笔记</h1><ul>\n<li>【学习路径】动力学方程-拉普拉斯变换-PID-卡尔曼滤波-bode+奈奎斯特图</li>\n</ul>\n<h2 id=\"1-学习资料\"><a href=\"#1-学习资料\" class=\"headerlink\" title=\"1 学习资料\"></a><strong>1 学习资料</strong></h2><ul>\n<li>【怎么学习经典控制（结合MATLAB）】<a href=\"https://zhuanlan.zhihu.com/p/266048048\">https://zhuanlan.zhihu.com/p/266048048</a></li>\n<li>【物理量解释】<a href=\"https://blog.csdn.net/qq_38422317/article/details/108460482\">转动惯量到底是个什么物理量_转动惯量类比-CSDN博客</a></li>\n<li>【常用的微分，求导和积分公式大总结】<a href=\"https://blog.csdn.net/wfei101/article/details/82431442\">数学之美：常用的微分，求导和积分公式大总结_微积分求导公式-CSDN博客</a></li>\n<li>【倒立摆建模控制系统设计】<a href=\"https://blog.csdn.net/qq_42731705/article/details/122464642\">线性系统大作业——1.一阶倒立摆建模与控制系统设计_一阶倒立摆系统的建模仿真与控制-CSDN博客</a></li>\n<li>【小车动态模型设计Matlab】<a href=\"https://space.bilibili.com/1134403370/video\">J_H_Li投稿视频-J_H_Li视频分享-哔哩哔哩视频 (bilibili.com)</a></li>\n<li>【如何使用Typora编辑数学公式】[如何使用Typora编辑数学公式](<a href=\"https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=%E6%89%93%E5%BC%80Typora%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9D%97\">https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=打开Typora选择数学模块</a> 点击“段落”—&gt;“公式块”,快捷键Ctrl%2BShift%2Bm 在两个%24中间直接编辑公式)</li>\n<li>【由拉普拉斯变换到传递函数】<a href=\"https://zhuanlan.zhihu.com/p/146769901\">由拉普拉斯变换到传递函数 - 知乎 (zhihu.com)</a></li>\n<li>【如何给文科生解释傅里叶变换】<a href=\"https://zhuanlan.zhihu.com/p/48305950\">如何给文科生解释傅里叶变换？ - 知乎 (zhihu.com)</a></li>\n<li>【超级直观！！！】<a href=\"https://zhuanlan.zhihu.com/c_1041689010053341184\">直观の数学 - 知乎 (zhihu.com)</a></li>\n<li>【一阶倒立摆的PID控制和LQR控制】<a href=\"https://zhuanlan.zhihu.com/p/54071212\">一阶倒立摆的PID控制和LQR控制 - 知乎 (zhihu.com)</a></li>\n<li>【拉普拉斯变换】<a href=\"https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2#\">拉普拉斯变换 - 维基百科，自由的百科全书 (wikipedia.org)</a></li>\n<li>【LQR算法】<a href=\"https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1\">https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1</a></li>\n<li>【simulink快捷键】<a href=\"https://blog.csdn.net/booksyhay/article/details/88129359\">Simulink建模与仿真学习笔记之常用快捷操作（快捷键）_simulink快捷键-CSDN博客</a></li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/25/K2CbOEa8XyjN9Io.png\" alt=\"image-20240131111616891.png\"></p>\n<h2 id=\"2-动力学方程求解\"><a href=\"#2-动力学方程求解\" class=\"headerlink\" title=\"2 动力学方程求解\"></a>2 动力学方程求解</h2><h3 id=\"2-1-什么是动力学方程\"><a href=\"#2-1-什么是动力学方程\" class=\"headerlink\" title=\"2.1 什么是动力学方程\"></a>2.1 什么是动力学方程</h3><ul>\n<li>动力学方程（Differential Equations of Motion），也称为运动方程，是描述物体运动的数学方程。这些方程通常是微分方程，用来描述物体的位置、速度、加速度等随时间的变化关系。<strong>动力学方程是经典力学的基础，它们揭示了物体受到的力和运动状态之间的关系。</strong></li>\n</ul>\n<h3 id=\"2-2-建立倒立摆动力学方程步骤\"><a href=\"#2-2-建立倒立摆动力学方程步骤\" class=\"headerlink\" title=\"2.2 建立倒立摆动力学方程步骤\"></a>2.2 建立倒立摆动力学方程步骤</h3><h4 id=\"①牛顿第二定律\"><a href=\"#①牛顿第二定律\" class=\"headerlink\" title=\"①牛顿第二定律\"></a><strong>①牛顿第二定律</strong></h4><ul>\n<li><strong>【确定世界坐标】</strong>世界坐标设立不同，求解结果不同</li>\n<li><strong>【确定反馈量、控制量和控制目标】</strong>获得需要设置的传感器和控制对象以及实现目标</li>\n<li><strong>【分析系统受力情况】</strong>分析系统位移和转动的情况以及所受外力情况</li>\n<li><strong>【罗列涉及物理量】</strong>罗列所有已知的量，并确定质心</li>\n<li><strong>【分析受力情况】</strong>根据位移和转动情况，列各个子系统的受力</li>\n<li><strong>【合并公式求出动力学方程】</strong>合并子系统受力，求出总系统的动力学方程</li>\n</ul>\n<h4 id=\"②拉格朗日定理\"><a href=\"#②拉格朗日定理\" class=\"headerlink\" title=\"②拉格朗日定理\"></a><strong>②拉格朗日定理</strong></h4><ul>\n<li><strong>【确定世界坐标】</strong>世界坐标设立不同，求解结果不同</li>\n<li><strong>【确定反馈量、控制量和控制目标】</strong>获得需要设置的传感器和控制对象以及实现目标</li>\n<li><strong>【分析系统受力情况】</strong>分析系统位移和转动的情况以及所受外力情况</li>\n<li><strong>【罗列涉及物理量】</strong>罗列所有已知的量，并确定质心</li>\n<li><strong>【列举拉格朗日方程】</strong>罗列拉格朗日表达式</li>\n<li><strong>【求解拉格朗日方程】</strong>多少个变量，求解多少个拉格朗日方程，分析所有系统的总动能（由于速度产生的动能，竖直方向也可能存在，除重力势能之外的所有力）、总势能（重力势能），并根据拉格朗日公式进行求解，求出动力学方程</li>\n<li><strong>【合并得出动力学方程】</strong>合并变量式，得到总系统的动力学方程</li>\n</ul>\n<h3 id=\"2-3-求解案例过程\"><a href=\"#2-3-求解案例过程\" class=\"headerlink\" title=\"2.3 求解案例过程\"></a>2.3 求解案例过程</h3><p><img src=\"https://s2.loli.net/2024/07/25/J3nAMrF8SgCkzZ5.png\" alt=\"image-20240202100715483.png\"></p>\n<h4 id=\"①牛顿第二定律求解\"><a href=\"#①牛顿第二定律求解\" class=\"headerlink\" title=\"①牛顿第二定律求解\"></a><strong>①牛顿第二定律求解</strong></h4><p><img src=\"https://s2.loli.net/2024/07/25/tJMUe8F5PoNnumL.png\" alt=\"image-20240203181633034.png\"></p>\n<h4 id=\"②拉格朗日定理-1\"><a href=\"#②拉格朗日定理-1\" class=\"headerlink\" title=\"②拉格朗日定理\"></a><strong>②拉格朗日定理</strong></h4><p><img src=\"https://s2.loli.net/2024/07/25/2Pg6zReWbKABMTu.png\" alt=\"image-20240203121952572.png\"></p>\n<h3 id=\"2-4-线性化处理\"><a href=\"#2-4-线性化处理\" class=\"headerlink\" title=\"2.4 线性化处理\"></a>2.4 线性化处理</h3><p>倒立摆的动力学方程通常是非线性的，但在某些应用中，为了进行控制设计或分析，可以对动力学方程进行线性化。线性化的目的是获得一个简化的线性系统，以便应用线性控制理论。</p>\n<p>小角度近似 sin(<em>θ</em>)≈<em>θ</em> 是一种在角度较小的情况下进行近似的数学技巧，它通常用于简化非线性系统的分析和求解。这个近似的合理性来源于正弦函数在零附近的泰勒级数展开。</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/VwCkGBTNlHUOQp1.png\" alt=\"image-20240203181307595.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/EnfWpyGBqP1txgF.png\" alt=\"image-20240203181739601.png\"></p>\n<h2 id=\"3-拉普拉斯变换求传递函数\"><a href=\"#3-拉普拉斯变换求传递函数\" class=\"headerlink\" title=\"3 拉普拉斯变换求传递函数\"></a>3 拉普拉斯变换求传递函数</h2><p>拉普拉斯变换是一种数学工具，用于将一个函数从时域（通常是时间域）转换到复频域。拉普拉斯变换的好处之一是它可以将微分方程转换成代数方程，从而简化了问题的求解。</p>\n<p>物理上可实现的信号总有相对应的拉氏变换（根据拉普拉斯的存在定义可得）</p>\n<p>拉普拉斯变换通常更适用于线性系统和线性微分方程。当面对非线性常微分方程时，使用拉普拉斯变换可能会变得更加困难，因为拉普拉斯变换的一些性质和简便性主要基于线性系统的性质，有时可以尝试将非线性问题线性化</p>\n<h3 id=\"3-1-拉氏变换定义\"><a href=\"#3-1-拉氏变换定义\" class=\"headerlink\" title=\"3.1 拉氏变换定义\"></a>3.1 拉氏变换定义</h3><p><img src=\"https://s2.loli.net/2024/07/25/FzdD1hvwgUOriQf.png\" alt=\"image-20240205132357835.png\"></p>\n<h3 id=\"3-2-拉氏逆变换定义\"><a href=\"#3-2-拉氏逆变换定义\" class=\"headerlink\" title=\"3.2 拉氏逆变换定义\"></a>3.2 拉氏逆变换定义</h3><p><img src=\"https://s2.loli.net/2024/07/25/Ikbf73zKeJ1VLSN.png\" alt=\"image-20240205132336647.png\"></p>\n<h3 id=\"3-3-拉普拉斯各类定理\"><a href=\"#3-3-拉普拉斯各类定理\" class=\"headerlink\" title=\"3.3 拉普拉斯各类定理\"></a>3.3 拉普拉斯各类定理</h3><p><img src=\"https://s2.loli.net/2024/07/25/LnF38Jj7eR1cE6o.png\" alt=\"image-20240205133019691.png\"></p>\n<h3 id=\"3-4-常用拉氏变换公式\"><a href=\"#3-4-常用拉氏变换公式\" class=\"headerlink\" title=\"3.4 常用拉氏变换公式\"></a>3.4 常用拉氏变换公式</h3><p><img src=\"https://s2.loli.net/2024/07/25/O9zh1y8KqlYjbDH.png\" alt=\"image-20240205171104326.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/07/25/8LqcGhTnJNzOPIR.png\" alt=\"image-20240205171210118.png\"></p>\n<h3 id=\"3-5-复频域好处\"><a href=\"#3-5-复频域好处\" class=\"headerlink\" title=\"3.5 复频域好处\"></a>3.5 复频域好处</h3><ul>\n<li><p><strong>频率响应分析：</strong> 复频域提供了对系统对不同频率输入信号的响应更清晰的视角。通过分析系统在复频域中的行为，可以得到频率响应信息，即系统对不同频率成分的放大或衰减程度。这对于了解系统的频率特性和选择适当的滤波器或控制器非常有帮助。</p>\n</li>\n<li><p><strong>稳定性分析：</strong> 复频域分析对于评估系统的稳定性至关重要。通过观察系统在复频域中的极点（pole）和零点（zero），可以得知系统的稳定性信息。例如，在控制系统中，稳定性分析可以通过查看系统的极点位置来判断系统的稳定性和相应的性能。</p>\n</li>\n<li><p><strong>传递函数表示：</strong> 复频域中，系统的行为可以通过传递函数（Transfer Function）更简洁地表示。传递函数是输出与输入的拉普拉斯变换之比，对于线性时不变系统，它在复频域提供了对系统的完整描述。</p>\n</li>\n<li><p><strong>频域设计：</strong> 复频域分析对于在设计中选择合适的控制器或滤波器参数非常有用。通过在频域中分析性能要求和系统响应，可以更好地调整系统以满足指定的性能规范。</p>\n</li>\n<li><p><strong>去除时域中的复杂性：</strong> 在复频域中分析系统可能会使分析更简便。例如，复频域分析可以通过拉普拉斯变换将微分方程转换为代数方程，从而减少问题的复杂性。</p>\n</li>\n</ul>\n<h3 id=\"3-6-案例求解\"><a href=\"#3-6-案例求解\" class=\"headerlink\" title=\"3.6 案例求解\"></a>3.6 案例求解</h3><p><img src=\"https://s2.loli.net/2024/07/25/4LZuYacRPtHSbkW.png\" alt=\"image-20240205191534825.png\"></p>\n<h3 id=\"3-7-传递函数求解\"><a href=\"#3-7-传递函数求解\" class=\"headerlink\" title=\"3.7 传递函数求解\"></a>3.7 传递函数求解</h3><p><img src=\"https://s2.loli.net/2024/07/25/u8FnNmArfQo7HRS.png\" alt=\"image-20240210115216577.png\"></p>\n<h2 id=\"4-知识点总结\"><a href=\"#4-知识点总结\" class=\"headerlink\" title=\"4 知识点总结\"></a>4 知识点总结</h2><ul>\n<li><p><strong>【分析力】</strong>小车水平位移、竖直位移，摆杆转动、水平位移、竖直位移</p>\n</li>\n<li><p><strong>【拉格朗日建模】</strong>小车受到外力，摆杆没有受到外力，小车的变量是位移，摆杆的变量是角度，所以一共两个方程，摆杆右边等于零</p>\n</li>\n<li><p><strong>【线性化】</strong>消去三角函数，利用约等假设进行消除</p>\n</li>\n<li><p><strong>【转动惯量定义】</strong>转动惯量（也称为转动惯性、惯性矩）是描述物体对绕轴旋转的难度或惯性程度的物理量。它与物体的质量分布和形状有关，是旋转运动中的重要参量。</p>\n</li>\n<li><p><strong>【势能定义】</strong>势能是物体由于位置而具有的能量，它与物体的位置和相互作用力有关。势能通常用符号 <em>U</em> 表示</p>\n</li>\n<li><p><strong>【动能定义】</strong>动能是物体由于运动而具有的能量，它与物体的质量和速度有关。动能通常用符号 <em>T</em> 表示</p>\n</li>\n<li><p><strong>【系统总动能】</strong>摆杆动能需要考虑竖直方向具有速度的运动，除重力做功之外，支撑力也有做功</p>\n</li>\n<li><p><strong>【转动惯量正反】</strong>顺时针为正、逆时针为副</p>\n</li>\n<li><p>【<strong>线性化处理</strong>】如果两个变量的关系可以通过直线来表示，且满足以下两个条件：1.比例性，变量的变化是成比例的。2.叠加性，两个或多个影响因素的效应可以相加。</p>\n</li>\n<li><p><strong>【傅里叶变换】</strong>傅里叶变换的内涵，就是满足一定条件的函数可以表示成三角函数(正弦和&#x2F;或余弦函数)或者它们的积分的线性组合。</p>\n</li>\n</ul>\n"},{"title":"TCP通信","date":"2024-05-26T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/DQMUe6zjrwvlNAn.jpg","_content":"\n# TCP通信\n\n## 一、QT服务端构建\n\n- 该模块将采用上位机作为服务端，下位机作为客户端进行连接，前提需要保证服务端、客户端处于同一局域网内，处于同一个端口号，IPv4地址一样，服务端的IPv4需要查阅该电脑本身IP，无法进行修改，选用默认方式。\n\n### ①TCP的概念\n\n- 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。消息是没有边界的，所以无论消息大小都可以进行传输。消息是有序的，当前一个消息没有收到，即使先收到了后面的字节，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。\n\n- TCP传输里面，需要Socket，上位机需要设置Socket，就好像找了一把锁，下位机需要上报Socket，就好像插上钥匙开锁，如果一样，那就可以进行连接，Socket：由IP地址和端口号组成\n\n### ②代码实现\n\n- 首先在mainwindow.h头文件函数里面添加所需头文件，如果报错，检查配置环境是否缺失，问网上教程，不赘述。之后还需要定义TCP通信对象，用于数据的读取和调用。\n\n```\n//TCP服务端\n#include <QTcpServer>\n#include <QTcpSocket>\n\n//创建TCP通讯对象\nQTcpSocket *socket;\nQTcpServer *server;\n```\n\n- 之后在mainwindow.cpp主函数里面进行TCP的初始化定义，将头文件定义的对象指向接下来要读取的函数，并采用connect函数，将新的客户端于newConnection_SLOT()槽函数连接\n\n```\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    \n\t//TCP通讯定义\n    socket = new QTcpSocket();\n    server = new QTcpServer();\n\n    //信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据\n    connect(server,SIGNAL(newConnection()),this,SLOT(newConnection_SLOT()));\n    \n}\n```\n\n- newConnection_SLOT()槽函数用于初始化设置，并监听客户端信息，如果接收到缓存信息，触发readyRead_SLOT()槽函数进行数据的读取和打印\n\n```\nvoid MainWindow::newConnection_SLOT()//定义TCP\n{\n    socket = server->nextPendingConnection(); //获取已经连接的客户端套接字\n    connect(socket,SIGNAL(readyRead()),this,SLOT(readyRead_SLOT()));//如果socket中有缓存消息，触发槽函数\n}\n```\n\n- readyRead_SLOT()函数主要进行读取客户端发来的缓存消息，并写入Receive_text当中\n\n```\nvoid MainWindow::readyRead_SLOT()//接收消息并显示到接收框\n{\n    qDebug() << \"Server Received!\";\n    QString buffer;\n    //读取缓冲区数据\n    buffer = socket->readAll();\n    if(!buffer.isEmpty())\n    {\n        //刷新显示\n        ui->Receive_text->appendPlainText(buffer);\n    }\n}\n```\n\n- 该类型函数配置完，基本上可以实现监听、读写功能，但是缺少用户对它的触发，所以再编写一个触发函数，按下on_Monitor_OPEN_clicked(bool checked)函数，既可以将PORT_TEXT文本中用户定义的端口号写入socket中，并进行发送，如果未连接成功，将按键复位。如果连接成功，再次点击该按钮，则停止监听，断开TCP连接。\n\n```\nvoid MainWindow::on_Monitor_OPEN_clicked(bool checked)//打开TCP监听\n{\n    if(checked)\n    {\n        int port = ui->PORT_TEXT->text().toUInt();\n        //如果未监听到\n        if(!server->listen(QHostAddress::Any, port))\n        {\n            qDebug() << server->errorString();\n            //连接失败，再次点击则重新连接，将checked恢复为true\n            ui->Monitor_OPEN->toggle();\n            return;\n        }\n        qDebug() << \"Listen Successfully! Message from port:\" << port;\n        //修改按钮文字\n        ui->Monitor_OPEN->setText(\"停止监听\");\n        //发送键使能\n        ui->Send_Button->setEnabled(true);\n    }\n    else\n    {\n         qDebug() << \"Stop Listening!\";\n        //如果已经连接则断开连接\n        if(socket->state() == QAbstractSocket::ConnectedState)\n        {\n            //断开连接\n            socket->disconnectFromHost();\n        }\n        //关闭倾听服务\n        server->close();\n        //修改按钮文字&发送键静默\n        ui->Monitor_OPEN->setText(\"开始监听\");\n        ui->Send_Button->setEnabled(false);\n    }\n}\n```\n\n## 二、TCP服务端-客户端通信\n\n- 基于上述设置后，用户就可以根据自己的想法去定义端口号，并随时打开和关闭监听端口，我们还需要设置一些Debug窗口来进行发送和接收内容的打印及调试。首先在mainwindow.h头文件函数里面添加所需头文件。\n\n```\n//文本编辑\n#include <QLineEdit>\n```\n\n- 之后撰写发送槽函数，该槽函数主要是读取输入框的内容，写入socket中，并利用socket->write()函数，将内容通过TCP通信传输到下位机当中，并利用 socket->flush()函数刷新重置缓冲区\n\n```\nvoid MainWindow::on_Send_Button_clicked()//发送数据\n{\n\t//主要用于调试\n    qDebug() << \"Server Send: \" << ui->Send_text->toPlainText().toLatin1();\n    //将输入框的内容写入socket缓冲区\n    socket->write(ui->Send_text->toPlainText().toLatin1());\n    //刷新socket缓冲区\n    socket->flush();\n}\n```\n\n- 而后定义两个简单的槽函数，利用clear()函数对发送区和接收区进行清空\n\n```\nvoid MainWindow::on_Receive_CLEAR_clicked()//回收框清屏\n{\n    ui->Receive_text->clear();\n}\n\nvoid MainWindow::on_Send_CLEAR_clicked()//发送框清屏\n{\n    ui->Send_text->clear();\n}\n```","source":"_posts/20240529ZYY-1_TCP通信.md","raw":"---\ntitle: TCP通信\ntag: TCP\ndate: 2024-05-27\ncategories: Linux\nindex_img: https://s2.loli.net/2024/07/31/DQMUe6zjrwvlNAn.jpg\n---\n\n# TCP通信\n\n## 一、QT服务端构建\n\n- 该模块将采用上位机作为服务端，下位机作为客户端进行连接，前提需要保证服务端、客户端处于同一局域网内，处于同一个端口号，IPv4地址一样，服务端的IPv4需要查阅该电脑本身IP，无法进行修改，选用默认方式。\n\n### ①TCP的概念\n\n- 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。消息是没有边界的，所以无论消息大小都可以进行传输。消息是有序的，当前一个消息没有收到，即使先收到了后面的字节，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。\n\n- TCP传输里面，需要Socket，上位机需要设置Socket，就好像找了一把锁，下位机需要上报Socket，就好像插上钥匙开锁，如果一样，那就可以进行连接，Socket：由IP地址和端口号组成\n\n### ②代码实现\n\n- 首先在mainwindow.h头文件函数里面添加所需头文件，如果报错，检查配置环境是否缺失，问网上教程，不赘述。之后还需要定义TCP通信对象，用于数据的读取和调用。\n\n```\n//TCP服务端\n#include <QTcpServer>\n#include <QTcpSocket>\n\n//创建TCP通讯对象\nQTcpSocket *socket;\nQTcpServer *server;\n```\n\n- 之后在mainwindow.cpp主函数里面进行TCP的初始化定义，将头文件定义的对象指向接下来要读取的函数，并采用connect函数，将新的客户端于newConnection_SLOT()槽函数连接\n\n```\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    \n\t//TCP通讯定义\n    socket = new QTcpSocket();\n    server = new QTcpServer();\n\n    //信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据\n    connect(server,SIGNAL(newConnection()),this,SLOT(newConnection_SLOT()));\n    \n}\n```\n\n- newConnection_SLOT()槽函数用于初始化设置，并监听客户端信息，如果接收到缓存信息，触发readyRead_SLOT()槽函数进行数据的读取和打印\n\n```\nvoid MainWindow::newConnection_SLOT()//定义TCP\n{\n    socket = server->nextPendingConnection(); //获取已经连接的客户端套接字\n    connect(socket,SIGNAL(readyRead()),this,SLOT(readyRead_SLOT()));//如果socket中有缓存消息，触发槽函数\n}\n```\n\n- readyRead_SLOT()函数主要进行读取客户端发来的缓存消息，并写入Receive_text当中\n\n```\nvoid MainWindow::readyRead_SLOT()//接收消息并显示到接收框\n{\n    qDebug() << \"Server Received!\";\n    QString buffer;\n    //读取缓冲区数据\n    buffer = socket->readAll();\n    if(!buffer.isEmpty())\n    {\n        //刷新显示\n        ui->Receive_text->appendPlainText(buffer);\n    }\n}\n```\n\n- 该类型函数配置完，基本上可以实现监听、读写功能，但是缺少用户对它的触发，所以再编写一个触发函数，按下on_Monitor_OPEN_clicked(bool checked)函数，既可以将PORT_TEXT文本中用户定义的端口号写入socket中，并进行发送，如果未连接成功，将按键复位。如果连接成功，再次点击该按钮，则停止监听，断开TCP连接。\n\n```\nvoid MainWindow::on_Monitor_OPEN_clicked(bool checked)//打开TCP监听\n{\n    if(checked)\n    {\n        int port = ui->PORT_TEXT->text().toUInt();\n        //如果未监听到\n        if(!server->listen(QHostAddress::Any, port))\n        {\n            qDebug() << server->errorString();\n            //连接失败，再次点击则重新连接，将checked恢复为true\n            ui->Monitor_OPEN->toggle();\n            return;\n        }\n        qDebug() << \"Listen Successfully! Message from port:\" << port;\n        //修改按钮文字\n        ui->Monitor_OPEN->setText(\"停止监听\");\n        //发送键使能\n        ui->Send_Button->setEnabled(true);\n    }\n    else\n    {\n         qDebug() << \"Stop Listening!\";\n        //如果已经连接则断开连接\n        if(socket->state() == QAbstractSocket::ConnectedState)\n        {\n            //断开连接\n            socket->disconnectFromHost();\n        }\n        //关闭倾听服务\n        server->close();\n        //修改按钮文字&发送键静默\n        ui->Monitor_OPEN->setText(\"开始监听\");\n        ui->Send_Button->setEnabled(false);\n    }\n}\n```\n\n## 二、TCP服务端-客户端通信\n\n- 基于上述设置后，用户就可以根据自己的想法去定义端口号，并随时打开和关闭监听端口，我们还需要设置一些Debug窗口来进行发送和接收内容的打印及调试。首先在mainwindow.h头文件函数里面添加所需头文件。\n\n```\n//文本编辑\n#include <QLineEdit>\n```\n\n- 之后撰写发送槽函数，该槽函数主要是读取输入框的内容，写入socket中，并利用socket->write()函数，将内容通过TCP通信传输到下位机当中，并利用 socket->flush()函数刷新重置缓冲区\n\n```\nvoid MainWindow::on_Send_Button_clicked()//发送数据\n{\n\t//主要用于调试\n    qDebug() << \"Server Send: \" << ui->Send_text->toPlainText().toLatin1();\n    //将输入框的内容写入socket缓冲区\n    socket->write(ui->Send_text->toPlainText().toLatin1());\n    //刷新socket缓冲区\n    socket->flush();\n}\n```\n\n- 而后定义两个简单的槽函数，利用clear()函数对发送区和接收区进行清空\n\n```\nvoid MainWindow::on_Receive_CLEAR_clicked()//回收框清屏\n{\n    ui->Receive_text->clear();\n}\n\nvoid MainWindow::on_Send_CLEAR_clicked()//发送框清屏\n{\n    ui->Send_text->clear();\n}\n```","slug":"20240529ZYY-1_TCP通信","published":1,"updated":"2024-07-31T03:31:56.854Z","_id":"clz9aaxq70006ygfbh18o74eb","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"TCP通信\"><a href=\"#TCP通信\" class=\"headerlink\" title=\"TCP通信\"></a>TCP通信</h1><h2 id=\"一、QT服务端构建\"><a href=\"#一、QT服务端构建\" class=\"headerlink\" title=\"一、QT服务端构建\"></a>一、QT服务端构建</h2><ul>\n<li>该模块将采用上位机作为服务端，下位机作为客户端进行连接，前提需要保证服务端、客户端处于同一局域网内，处于同一个端口号，IPv4地址一样，服务端的IPv4需要查阅该电脑本身IP，无法进行修改，选用默认方式。</li>\n</ul>\n<h3 id=\"①TCP的概念\"><a href=\"#①TCP的概念\" class=\"headerlink\" title=\"①TCP的概念\"></a>①TCP的概念</h3><ul>\n<li><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。消息是没有边界的，所以无论消息大小都可以进行传输。消息是有序的，当前一个消息没有收到，即使先收到了后面的字节，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。</p>\n</li>\n<li><p>TCP传输里面，需要Socket，上位机需要设置Socket，就好像找了一把锁，下位机需要上报Socket，就好像插上钥匙开锁，如果一样，那就可以进行连接，Socket：由IP地址和端口号组成</p>\n</li>\n</ul>\n<h3 id=\"②代码实现\"><a href=\"#②代码实现\" class=\"headerlink\" title=\"②代码实现\"></a>②代码实现</h3><ul>\n<li>首先在mainwindow.h头文件函数里面添加所需头文件，如果报错，检查配置环境是否缺失，问网上教程，不赘述。之后还需要定义TCP通信对象，用于数据的读取和调用。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//TCP服务端</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QTcpServer&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QTcpSocket&gt;</span></span><br><br><span class=\"hljs-comment\">//创建TCP通讯对象</span><br>QTcpSocket *socket;<br>QTcpServer *server;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>之后在mainwindow.cpp主函数里面进行TCP的初始化定义，将头文件定义的对象指向接下来要读取的函数，并采用connect函数，将新的客户端于newConnection_SLOT()槽函数连接</li>\n</ul>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>    , ui(<span class=\"hljs-keyword\">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class=\"hljs-keyword\">this</span>);<br>    <br>\t<span class=\"hljs-comment\">//TCP通讯定义</span><br>    socket = <span class=\"hljs-keyword\">new</span> QTcpSocket();<br>    <span class=\"hljs-keyword\">server</span> = <span class=\"hljs-keyword\">new</span> QTcpServer();<br><br>    <span class=\"hljs-comment\">//信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据</span><br>    connect(<span class=\"hljs-keyword\">server</span>,SIGNAL(newConnection()),<span class=\"hljs-keyword\">this</span>,SLOT(newConnection_SLOT()));<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>newConnection_SLOT()槽函数用于初始化设置，并监听客户端信息，如果接收到缓存信息，触发readyRead_SLOT()槽函数进行数据的读取和打印</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">MainWindow::newConnection_SLOT</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//定义TCP</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    socket = server-&gt;<span class=\"hljs-built_in\">nextPendingConnection</span>(); <span class=\"hljs-comment\">//获取已经连接的客户端套接字</span><br>    <span class=\"hljs-built_in\">connect</span>(socket,<span class=\"hljs-built_in\">SIGNAL</span>(<span class=\"hljs-built_in\">readyRead</span>()),<span class=\"hljs-keyword\">this</span>,<span class=\"hljs-built_in\">SLOT</span>(<span class=\"hljs-built_in\">readyRead_SLOT</span>()));<span class=\"hljs-comment\">//如果socket中有缓存消息，触发槽函数</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>readyRead_SLOT()函数主要进行读取客户端发来的缓存消息，并写入Receive_text当中</li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">void</span> MainWindow::readyRead_SLOT()<span class=\"hljs-comment\">//接收消息并显示到接收框</span><br>&#123;<br>    qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Server Received!&quot;</span>;<br>    QString <span class=\"hljs-built_in\">buffer</span>;<br>    <span class=\"hljs-comment\">//读取缓冲区数据</span><br>    <span class=\"hljs-built_in\">buffer</span> = socket-&gt;readAll();<br>    <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-built_in\">buffer</span>.<span class=\"hljs-built_in\">isEmpty</span>())<br>    &#123;<br>        <span class=\"hljs-comment\">//刷新显示</span><br>        ui-&gt;Receive_text-&gt;appendPlainText(<span class=\"hljs-built_in\">buffer</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>该类型函数配置完，基本上可以实现监听、读写功能，但是缺少用户对它的触发，所以再编写一个触发函数，按下on_Monitor_OPEN_clicked(bool checked)函数，既可以将PORT_TEXT文本中用户定义的端口号写入socket中，并进行发送，如果未连接成功，将按键复位。如果连接成功，再次点击该按钮，则停止监听，断开TCP连接。</li>\n</ul>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs zephir\">void MainWindow::on_Monitor_OPEN_clicked(<span class=\"hljs-keyword\">bool</span> checked)<span class=\"hljs-comment\">//打开TCP监听</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(checked)<br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> port = ui-&gt;PORT_TEXT-&gt;text().toUInt();<br>        <span class=\"hljs-comment\">//如果未监听到</span><br>        <span class=\"hljs-keyword\">if</span>(!server-&gt;listen(QHostAddress::Any, port))<br>        &#123;<br>            qDebug() &lt;&lt; server-&gt;errorString();<br>            <span class=\"hljs-comment\">//连接失败，再次点击则重新连接，将checked恢复为true</span><br>            ui-&gt;Monitor_OPEN-&gt;toggle();<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Listen Successfully! Message from port:&quot;</span> &lt;&lt; port;<br>        <span class=\"hljs-comment\">//修改按钮文字</span><br>        ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;停止监听&quot;</span>);<br>        <span class=\"hljs-comment\">//发送键使能</span><br>        ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">true</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>         qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Stop Listening!&quot;</span>;<br>        <span class=\"hljs-comment\">//如果已经连接则断开连接</span><br>        <span class=\"hljs-keyword\">if</span>(socket-&gt;state() == QAbstractSocket::ConnectedState)<br>        &#123;<br>            <span class=\"hljs-comment\">//断开连接</span><br>            socket-&gt;disconnectFromHost();<br>        &#125;<br>        <span class=\"hljs-comment\">//关闭倾听服务</span><br>        server-&gt;close();<br>        <span class=\"hljs-comment\">//修改按钮文字&amp;发送键静默</span><br>        ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;开始监听&quot;</span>);<br>        ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、TCP服务端-客户端通信\"><a href=\"#二、TCP服务端-客户端通信\" class=\"headerlink\" title=\"二、TCP服务端-客户端通信\"></a>二、TCP服务端-客户端通信</h2><ul>\n<li>基于上述设置后，用户就可以根据自己的想法去定义端口号，并随时打开和关闭监听端口，我们还需要设置一些Debug窗口来进行发送和接收内容的打印及调试。首先在mainwindow.h头文件函数里面添加所需头文件。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//文本编辑</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QLineEdit&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>之后撰写发送槽函数，该槽函数主要是读取输入框的内容，写入socket中，并利用socket-&gt;write()函数，将内容通过TCP通信传输到下位机当中，并利用 socket-&gt;flush()函数刷新重置缓冲区</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">void MainWindow::on_Send_Button_clicked()<span class=\"hljs-comment\">//发送数据</span><br>&#123;<br>\t<span class=\"hljs-comment\">//主要用于调试</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">qDebug</span>() &lt;&lt; &quot;Server Send: &quot; &lt;&lt; ui-&gt;</span>S<span class=\"hljs-function\"><span class=\"hljs-title\">end_text</span>-&gt;</span>toPlainText().toLatin1();<br>    <span class=\"hljs-comment\">//将输入框的内容写入socket缓冲区</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">socket</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">write</span>(ui-&gt;</span>S<span class=\"hljs-function\"><span class=\"hljs-title\">end_text</span>-&gt;</span>toPlainText().toLatin1());<br>    <span class=\"hljs-comment\">//刷新socket缓冲区</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">socket</span>-&gt;</span>flush();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>而后定义两个简单的槽函数，利用clear()函数对发送区和接收区进行清空</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">void MainWindow::on_Receive_CLEAR_clicked()<span class=\"hljs-comment\">//回收框清屏</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">ui</span>-&gt;</span>R<span class=\"hljs-function\"><span class=\"hljs-title\">eceive_text</span>-&gt;</span>clear();<br>&#125;<br><br>void MainWindow::on_Send_CLEAR_clicked()<span class=\"hljs-comment\">//发送框清屏</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">ui</span>-&gt;</span>S<span class=\"hljs-function\"><span class=\"hljs-title\">end_text</span>-&gt;</span>clear();<br>&#125;<br></code></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"TCP通信\"><a href=\"#TCP通信\" class=\"headerlink\" title=\"TCP通信\"></a>TCP通信</h1><h2 id=\"一、QT服务端构建\"><a href=\"#一、QT服务端构建\" class=\"headerlink\" title=\"一、QT服务端构建\"></a>一、QT服务端构建</h2><ul>\n<li>该模块将采用上位机作为服务端，下位机作为客户端进行连接，前提需要保证服务端、客户端处于同一局域网内，处于同一个端口号，IPv4地址一样，服务端的IPv4需要查阅该电脑本身IP，无法进行修改，选用默认方式。</li>\n</ul>\n<h3 id=\"①TCP的概念\"><a href=\"#①TCP的概念\" class=\"headerlink\" title=\"①TCP的概念\"></a>①TCP的概念</h3><ul>\n<li><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。消息是没有边界的，所以无论消息大小都可以进行传输。消息是有序的，当前一个消息没有收到，即使先收到了后面的字节，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。</p>\n</li>\n<li><p>TCP传输里面，需要Socket，上位机需要设置Socket，就好像找了一把锁，下位机需要上报Socket，就好像插上钥匙开锁，如果一样，那就可以进行连接，Socket：由IP地址和端口号组成</p>\n</li>\n</ul>\n<h3 id=\"②代码实现\"><a href=\"#②代码实现\" class=\"headerlink\" title=\"②代码实现\"></a>②代码实现</h3><ul>\n<li>首先在mainwindow.h头文件函数里面添加所需头文件，如果报错，检查配置环境是否缺失，问网上教程，不赘述。之后还需要定义TCP通信对象，用于数据的读取和调用。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//TCP服务端</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QTcpServer&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QTcpSocket&gt;</span></span><br><br><span class=\"hljs-comment\">//创建TCP通讯对象</span><br>QTcpSocket *socket;<br>QTcpServer *server;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>之后在mainwindow.cpp主函数里面进行TCP的初始化定义，将头文件定义的对象指向接下来要读取的函数，并采用connect函数，将新的客户端于newConnection_SLOT()槽函数连接</li>\n</ul>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>    , ui(<span class=\"hljs-keyword\">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class=\"hljs-keyword\">this</span>);<br>    <br>\t<span class=\"hljs-comment\">//TCP通讯定义</span><br>    socket = <span class=\"hljs-keyword\">new</span> QTcpSocket();<br>    <span class=\"hljs-keyword\">server</span> = <span class=\"hljs-keyword\">new</span> QTcpServer();<br><br>    <span class=\"hljs-comment\">//信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据</span><br>    connect(<span class=\"hljs-keyword\">server</span>,SIGNAL(newConnection()),<span class=\"hljs-keyword\">this</span>,SLOT(newConnection_SLOT()));<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>newConnection_SLOT()槽函数用于初始化设置，并监听客户端信息，如果接收到缓存信息，触发readyRead_SLOT()槽函数进行数据的读取和打印</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">MainWindow::newConnection_SLOT</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//定义TCP</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    socket = server-&gt;<span class=\"hljs-built_in\">nextPendingConnection</span>(); <span class=\"hljs-comment\">//获取已经连接的客户端套接字</span><br>    <span class=\"hljs-built_in\">connect</span>(socket,<span class=\"hljs-built_in\">SIGNAL</span>(<span class=\"hljs-built_in\">readyRead</span>()),<span class=\"hljs-keyword\">this</span>,<span class=\"hljs-built_in\">SLOT</span>(<span class=\"hljs-built_in\">readyRead_SLOT</span>()));<span class=\"hljs-comment\">//如果socket中有缓存消息，触发槽函数</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>readyRead_SLOT()函数主要进行读取客户端发来的缓存消息，并写入Receive_text当中</li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">void</span> MainWindow::readyRead_SLOT()<span class=\"hljs-comment\">//接收消息并显示到接收框</span><br>&#123;<br>    qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Server Received!&quot;</span>;<br>    QString <span class=\"hljs-built_in\">buffer</span>;<br>    <span class=\"hljs-comment\">//读取缓冲区数据</span><br>    <span class=\"hljs-built_in\">buffer</span> = socket-&gt;readAll();<br>    <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-built_in\">buffer</span>.<span class=\"hljs-built_in\">isEmpty</span>())<br>    &#123;<br>        <span class=\"hljs-comment\">//刷新显示</span><br>        ui-&gt;Receive_text-&gt;appendPlainText(<span class=\"hljs-built_in\">buffer</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>该类型函数配置完，基本上可以实现监听、读写功能，但是缺少用户对它的触发，所以再编写一个触发函数，按下on_Monitor_OPEN_clicked(bool checked)函数，既可以将PORT_TEXT文本中用户定义的端口号写入socket中，并进行发送，如果未连接成功，将按键复位。如果连接成功，再次点击该按钮，则停止监听，断开TCP连接。</li>\n</ul>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs zephir\">void MainWindow::on_Monitor_OPEN_clicked(<span class=\"hljs-keyword\">bool</span> checked)<span class=\"hljs-comment\">//打开TCP监听</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(checked)<br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> port = ui-&gt;PORT_TEXT-&gt;text().toUInt();<br>        <span class=\"hljs-comment\">//如果未监听到</span><br>        <span class=\"hljs-keyword\">if</span>(!server-&gt;listen(QHostAddress::Any, port))<br>        &#123;<br>            qDebug() &lt;&lt; server-&gt;errorString();<br>            <span class=\"hljs-comment\">//连接失败，再次点击则重新连接，将checked恢复为true</span><br>            ui-&gt;Monitor_OPEN-&gt;toggle();<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Listen Successfully! Message from port:&quot;</span> &lt;&lt; port;<br>        <span class=\"hljs-comment\">//修改按钮文字</span><br>        ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;停止监听&quot;</span>);<br>        <span class=\"hljs-comment\">//发送键使能</span><br>        ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">true</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>         qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Stop Listening!&quot;</span>;<br>        <span class=\"hljs-comment\">//如果已经连接则断开连接</span><br>        <span class=\"hljs-keyword\">if</span>(socket-&gt;state() == QAbstractSocket::ConnectedState)<br>        &#123;<br>            <span class=\"hljs-comment\">//断开连接</span><br>            socket-&gt;disconnectFromHost();<br>        &#125;<br>        <span class=\"hljs-comment\">//关闭倾听服务</span><br>        server-&gt;close();<br>        <span class=\"hljs-comment\">//修改按钮文字&amp;发送键静默</span><br>        ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;开始监听&quot;</span>);<br>        ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、TCP服务端-客户端通信\"><a href=\"#二、TCP服务端-客户端通信\" class=\"headerlink\" title=\"二、TCP服务端-客户端通信\"></a>二、TCP服务端-客户端通信</h2><ul>\n<li>基于上述设置后，用户就可以根据自己的想法去定义端口号，并随时打开和关闭监听端口，我们还需要设置一些Debug窗口来进行发送和接收内容的打印及调试。首先在mainwindow.h头文件函数里面添加所需头文件。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//文本编辑</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QLineEdit&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>之后撰写发送槽函数，该槽函数主要是读取输入框的内容，写入socket中，并利用socket-&gt;write()函数，将内容通过TCP通信传输到下位机当中，并利用 socket-&gt;flush()函数刷新重置缓冲区</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">void MainWindow::on_Send_Button_clicked()<span class=\"hljs-comment\">//发送数据</span><br>&#123;<br>\t<span class=\"hljs-comment\">//主要用于调试</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">qDebug</span>() &lt;&lt; &quot;Server Send: &quot; &lt;&lt; ui-&gt;</span>S<span class=\"hljs-function\"><span class=\"hljs-title\">end_text</span>-&gt;</span>toPlainText().toLatin1();<br>    <span class=\"hljs-comment\">//将输入框的内容写入socket缓冲区</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">socket</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">write</span>(ui-&gt;</span>S<span class=\"hljs-function\"><span class=\"hljs-title\">end_text</span>-&gt;</span>toPlainText().toLatin1());<br>    <span class=\"hljs-comment\">//刷新socket缓冲区</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">socket</span>-&gt;</span>flush();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>而后定义两个简单的槽函数，利用clear()函数对发送区和接收区进行清空</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">void MainWindow::on_Receive_CLEAR_clicked()<span class=\"hljs-comment\">//回收框清屏</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">ui</span>-&gt;</span>R<span class=\"hljs-function\"><span class=\"hljs-title\">eceive_text</span>-&gt;</span>clear();<br>&#125;<br><br>void MainWindow::on_Send_CLEAR_clicked()<span class=\"hljs-comment\">//发送框清屏</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">ui</span>-&gt;</span>S<span class=\"hljs-function\"><span class=\"hljs-title\">end_text</span>-&gt;</span>clear();<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"FOC无刷电机控制","date":"2024-04-14T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/xwD9NPQfFvp2JZ4.png","_content":"\n# FOC无刷电机控制\n\n## 一、无刷电机基本理解\n\n基本的航模无刷电机结构图如下图所示，**分为前盖，中盖，后盖，磁铁，硅钢片，漆包线、轴承和转轴组成**。\n\n![image.png](https://s2.loli.net/2024/08/09/uCg7fVhUXoATPwI.png)\n\n### 1.可以直接把电机分为定子部分和转子部分：\n\n- **定子**就是有线圈绕组，固定不动的部分；\n- **转子**就是电机旋转的部分，用于输出电机的转动和扭矩。\n\n### 2.内外旋转类型区分：\n\n- **内转子无刷电机**就是转子在内部，轴进行旋转；\n- **外转子无刷电机**就是转子在外面，外壳进行旋转。\n\n- 而**直流无刷电机的驱动**，就是依靠**改变电机定子线圈的电流交变频率和波形，在定子周围形成磁场，驱动转子永磁体转动**，进而带动电机转起来。\n\n### 3.**无刷电机跟有刷电机的区别**\n\n- 顾名思义就是**无刷电机没有了有刷电机里的电刷**。因此它**不能够如同有刷电机那样采用机械结构就可以进行电流的换向**， 而是必须通过采用如MOS这样的器件实现**电子换向**。\n\n![image.png](https://s2.loli.net/2024/08/09/ndxDrgWQ6ebqKJM.png)\n\n![image.png](https://s2.loli.net/2024/08/09/uo7YtVxUW3ClqPb.png)\n\n![image.png](https://s2.loli.net/2024/08/09/aIR8mpnKhHzBVxs.png)\n\n- **对电机的控制实际上就是对MOS管开关规律的控制**。而MOS管的开关规律是需要用到单片机程序进行控制的，因此这就引出了我们的**FOC控制算法，FOC控制就是一种对电机运动模型进行抽象化和简化，进而有规律控制各个MOS管开关和通断的过程**。\n\n## 二、克拉克变换\n\n### 1.克拉克变换基本含义\n\n- 交替开关的MOS管可以实现电机的转动，而这些交替开关的MOS管是以极其快的速度在周期性进行的，把这些周期性的开启和关断过程联系起来，并且对其各个相进行单独观察，就可以得到三个相A、B、C的电流随时间变换的曲线，如下图所示，他们之间存在120°的相位差。换一个角度来思考此问题，实际上，我们只要能够**控制这个相位差为120°的sin状波形，就能够实现针对电机的控制**。\n\n![image.png](https://s2.loli.net/2024/08/09/hpZdnCAlOw29TyY.png)\n\n- **克拉克变换，实际上就是降维解耦的过程，把难以辨明和控制的三相相位差120°电机波形降维为两维矢量**。\n\n- **第一就是把三相随时间变换的，相位差为120°的电流波形抽象化为三个间隔120°的矢量**。\n\n- **第二就是利用三角函数对矢量进行降维，降维到两个坐标轴**，从此复杂的三相变化问题就降解为了α-β坐标轴的坐标上的数值变化问题。\n\n![image.png](https://s2.loli.net/2024/08/09/SzEKf6bxdrqjNHO.png)\n\n![image.png](https://s2.loli.net/2024/08/09/ARyrBNmfgD9a4Cz.png)\n\n- 上图中，左边是我们把三相120度相位差的sin状波形抽象化为矢量之后的样子，而右边就是我们需要**把这三个矢量进行投影的坐标轴。只要我们把三个矢量都投影到坐标轴上，那么，一个三矢量问题就变成一个二维坐标平面问题**。\n\n### 2.克拉克变换推导公式\n\n- **克拉克变换的第一步，作投影**\n\n- 针对α-β坐标系中α轴，有：\n\n<img src=\"https://s2.loli.net/2024/07/25/YO6LurHIQkSfV21.png\" alt=\"image-20240318150726168.png\"  />\n\n\n\n- 针对α-β坐标系中β轴，有：\n\n<img src=\"https://s2.loli.net/2024/07/25/ZUyTqOcmRVtHSe7.png\" alt=\"image-20240318150741335.png\"  />\n\n\n\n- 把上面的投影结果列成矩阵形式，有：\n\n<img src=\"https://s2.loli.net/2024/07/25/xR4twW1ynvGp2ou.png\" alt=\"image-20240318150755362.png\"  />\n\n\n\n### 3.克拉克变换的等辐值形式\n\n- 何为等幅值变换？用α相电流输入1A电流的特例来举例，当电流输入时候，根据基尔霍夫电流定律（电路中任一个节点上，在任意时刻，流入节点的电流之和等于流出节点的电流之和，如下图），有：\n\n<img src=\"https://s2.loli.net/2024/07/25/fSHMDIEoRj4JsOl.png\" alt=\"image-20240318151006334.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/1bvRp6E8T3Q5dPk.png\" alt=\"image-20240318152249217.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/esquFgkWVyZpf4c.png\" alt=\"image-20240318152309335.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/58PAe2iML9I1uDW.png\" alt=\"image-20240319174421088.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/qxy9OB8GJH2frNj.png\" alt=\"image-20240319174945752.png\"  />\n\n\n\n- 在式子中，我们消去了变量Ic，这是因为由于基尔霍夫电流定律的存在，我们并不需要知道所有三相电流，我们只需要知道两相电流就能够求解得到另外一相的电流，反映在硬件上，**我们就可以省去一路的电流传感器！节省了成本！**\n\n### 4.克拉克逆变换\n\n<img src=\"https://s2.loli.net/2024/07/25/eYjA7Q6pOFBVcNo.png\" alt=\"image-20240319175252143.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/Rbtm5MOlFEc8k1d.png\" alt=\"image-20240319175403342.png\"  />\n\n\n\n### 5.克拉克变换总结\n\n- 克拉克变换首先将**三相电流转换成两维度的矢量电流**，因此我们就可以通过**控制两维度的矢量电流来表达三项电流的变换情况**，并且通过等幅值变换，我们就可以将**电流进行消项，之后又可以消去一路Ic，优化处理速度**；\n\n- 而克拉克逆变换的目的是我们通**过需求的两项矢量电流来反向求解三相电流，并且来控制无刷电机驱动。**\n\n## 三、帕克变换\n\n### 1.帕克变换基本定义\n\n- 通过克拉克变换之后，我们就将三相电路降阶至二维矢量电流，但是电流和电机旋转角度的关系是未知的，还需要将这个理论和旋转电机对应起来，也就是**建立电机旋转时的数学模型**，这就是帕克变换的目的。\n- 其实整个帕克变换的思路很简单，首先，我们把电机的定子t线圈上固定一个Iα−Iβ坐标系，这时候，我在坐标系的右边放上一个转子，如下图右边所示，如果此时转子被吸引且不动，那么在Iα−Iβ坐标系中就一定有一个Iα和Iβ值是能够对应转子现在的状态的\n\n![image.png](https://s2.loli.net/2024/08/09/oY7XVyjzhFJaStm.png)\n\n![image.png](https://s2.loli.net/2024/08/09/RxUjsCvoWF9LcKB.png)\n\n### 2.帕克变换推导公式\n\n- 根据上图，可以推导Iα−Iβ坐标系于Iq−Id坐标系的关系，这也就是帕克变换：\n\n![image-20240320174459687.png](https://s2.loli.net/2024/07/25/fahwsKAl9RnDUr6.png)\n\n- 在实际的情况中，电角度是可以根据传感器求解得出，因此，我们只需要控制Iq和Id的电流，就可以控制无刷电机的旋转，而我们可以将Id设置成0，因此，我们只需要一个Iq的电流，就可以控制电机旋转。\n\n## 四、推导原理总结\n\n![image.png](https://s2.loli.net/2024/08/09/rcElGWZyYFukLQb.png)\n\n- **电机想要旋转，就需要三相电流相互作用，而三项电流可以通过克拉克变换转成二维的矢量，而这个二维的矢量通过和转子的电角度建立关系，即可得出控制的电流Iq（Id默认为0），因此我们仅仅只需要通过设定Iq就可以控制电机进行旋转。**\n\n## 五、电压形式转换\n\n- 因为单片机的控制都是**基于电压进行控制**，包括PWM的控制，也是通过控制电压进行设定，因此我们需要将电流转换成电压形式，**而电压和电流的转换可以直接等于，因为等号两边都需要除以电阻，可以直接消项。**\n\n<img src=\"https://s2.loli.net/2024/07/25/GQ3qP7uYbaWCotK.png\" alt=\"image-20240320180833702.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2024/07/25/ZwqigGLHyDB9tFb.png\" alt=\"image-20240320181038012.png\" style=\"zoom:50%;\" />\n\n## 六、电角度于机械角度\n\n<img src=\"https://s2.loli.net/2024/07/25/IqfPkovwQDlSTR9.png\" alt=\"image-20240320182308979.png\"  />\n\n<img src=\"https://s2.loli.net/2024/07/25/76QqI34TyP5rozm.png\" alt=\"image-20240320182250898.png\"  />\n\n- **极对数：是N极和S极的对数数量**\n\n- **电角度：电角度是定子电流矢量与转子磁极矢量之间的夹角**\n\n- **机械角度：电机旋转一圈的空间几何角度，旋转一圈为360度**\n- 如果只是刚刚的一级对电机，那么的机械角度转一圈，相位的一个周期是能够和机械角度一一对应的，此时电角度=机械角度；但是，如果是多级电机，那么机械角度转一圈，相位的周期可能是很多个。\n\n","source":"_posts/20240319ZYY-FOC无刷电机控制.md","raw":"---\ntitle: FOC无刷电机控制\ntag: 无刷电机控制\ndate: 2024-04-15\ncategories: 控制设计\nindex_img: https://s2.loli.net/2024/07/31/xwD9NPQfFvp2JZ4.png\n---\n\n# FOC无刷电机控制\n\n## 一、无刷电机基本理解\n\n基本的航模无刷电机结构图如下图所示，**分为前盖，中盖，后盖，磁铁，硅钢片，漆包线、轴承和转轴组成**。\n\n![image.png](https://s2.loli.net/2024/08/09/uCg7fVhUXoATPwI.png)\n\n### 1.可以直接把电机分为定子部分和转子部分：\n\n- **定子**就是有线圈绕组，固定不动的部分；\n- **转子**就是电机旋转的部分，用于输出电机的转动和扭矩。\n\n### 2.内外旋转类型区分：\n\n- **内转子无刷电机**就是转子在内部，轴进行旋转；\n- **外转子无刷电机**就是转子在外面，外壳进行旋转。\n\n- 而**直流无刷电机的驱动**，就是依靠**改变电机定子线圈的电流交变频率和波形，在定子周围形成磁场，驱动转子永磁体转动**，进而带动电机转起来。\n\n### 3.**无刷电机跟有刷电机的区别**\n\n- 顾名思义就是**无刷电机没有了有刷电机里的电刷**。因此它**不能够如同有刷电机那样采用机械结构就可以进行电流的换向**， 而是必须通过采用如MOS这样的器件实现**电子换向**。\n\n![image.png](https://s2.loli.net/2024/08/09/ndxDrgWQ6ebqKJM.png)\n\n![image.png](https://s2.loli.net/2024/08/09/uo7YtVxUW3ClqPb.png)\n\n![image.png](https://s2.loli.net/2024/08/09/aIR8mpnKhHzBVxs.png)\n\n- **对电机的控制实际上就是对MOS管开关规律的控制**。而MOS管的开关规律是需要用到单片机程序进行控制的，因此这就引出了我们的**FOC控制算法，FOC控制就是一种对电机运动模型进行抽象化和简化，进而有规律控制各个MOS管开关和通断的过程**。\n\n## 二、克拉克变换\n\n### 1.克拉克变换基本含义\n\n- 交替开关的MOS管可以实现电机的转动，而这些交替开关的MOS管是以极其快的速度在周期性进行的，把这些周期性的开启和关断过程联系起来，并且对其各个相进行单独观察，就可以得到三个相A、B、C的电流随时间变换的曲线，如下图所示，他们之间存在120°的相位差。换一个角度来思考此问题，实际上，我们只要能够**控制这个相位差为120°的sin状波形，就能够实现针对电机的控制**。\n\n![image.png](https://s2.loli.net/2024/08/09/hpZdnCAlOw29TyY.png)\n\n- **克拉克变换，实际上就是降维解耦的过程，把难以辨明和控制的三相相位差120°电机波形降维为两维矢量**。\n\n- **第一就是把三相随时间变换的，相位差为120°的电流波形抽象化为三个间隔120°的矢量**。\n\n- **第二就是利用三角函数对矢量进行降维，降维到两个坐标轴**，从此复杂的三相变化问题就降解为了α-β坐标轴的坐标上的数值变化问题。\n\n![image.png](https://s2.loli.net/2024/08/09/SzEKf6bxdrqjNHO.png)\n\n![image.png](https://s2.loli.net/2024/08/09/ARyrBNmfgD9a4Cz.png)\n\n- 上图中，左边是我们把三相120度相位差的sin状波形抽象化为矢量之后的样子，而右边就是我们需要**把这三个矢量进行投影的坐标轴。只要我们把三个矢量都投影到坐标轴上，那么，一个三矢量问题就变成一个二维坐标平面问题**。\n\n### 2.克拉克变换推导公式\n\n- **克拉克变换的第一步，作投影**\n\n- 针对α-β坐标系中α轴，有：\n\n<img src=\"https://s2.loli.net/2024/07/25/YO6LurHIQkSfV21.png\" alt=\"image-20240318150726168.png\"  />\n\n\n\n- 针对α-β坐标系中β轴，有：\n\n<img src=\"https://s2.loli.net/2024/07/25/ZUyTqOcmRVtHSe7.png\" alt=\"image-20240318150741335.png\"  />\n\n\n\n- 把上面的投影结果列成矩阵形式，有：\n\n<img src=\"https://s2.loli.net/2024/07/25/xR4twW1ynvGp2ou.png\" alt=\"image-20240318150755362.png\"  />\n\n\n\n### 3.克拉克变换的等辐值形式\n\n- 何为等幅值变换？用α相电流输入1A电流的特例来举例，当电流输入时候，根据基尔霍夫电流定律（电路中任一个节点上，在任意时刻，流入节点的电流之和等于流出节点的电流之和，如下图），有：\n\n<img src=\"https://s2.loli.net/2024/07/25/fSHMDIEoRj4JsOl.png\" alt=\"image-20240318151006334.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/1bvRp6E8T3Q5dPk.png\" alt=\"image-20240318152249217.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/esquFgkWVyZpf4c.png\" alt=\"image-20240318152309335.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/58PAe2iML9I1uDW.png\" alt=\"image-20240319174421088.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/qxy9OB8GJH2frNj.png\" alt=\"image-20240319174945752.png\"  />\n\n\n\n- 在式子中，我们消去了变量Ic，这是因为由于基尔霍夫电流定律的存在，我们并不需要知道所有三相电流，我们只需要知道两相电流就能够求解得到另外一相的电流，反映在硬件上，**我们就可以省去一路的电流传感器！节省了成本！**\n\n### 4.克拉克逆变换\n\n<img src=\"https://s2.loli.net/2024/07/25/eYjA7Q6pOFBVcNo.png\" alt=\"image-20240319175252143.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/Rbtm5MOlFEc8k1d.png\" alt=\"image-20240319175403342.png\"  />\n\n\n\n### 5.克拉克变换总结\n\n- 克拉克变换首先将**三相电流转换成两维度的矢量电流**，因此我们就可以通过**控制两维度的矢量电流来表达三项电流的变换情况**，并且通过等幅值变换，我们就可以将**电流进行消项，之后又可以消去一路Ic，优化处理速度**；\n\n- 而克拉克逆变换的目的是我们通**过需求的两项矢量电流来反向求解三相电流，并且来控制无刷电机驱动。**\n\n## 三、帕克变换\n\n### 1.帕克变换基本定义\n\n- 通过克拉克变换之后，我们就将三相电路降阶至二维矢量电流，但是电流和电机旋转角度的关系是未知的，还需要将这个理论和旋转电机对应起来，也就是**建立电机旋转时的数学模型**，这就是帕克变换的目的。\n- 其实整个帕克变换的思路很简单，首先，我们把电机的定子t线圈上固定一个Iα−Iβ坐标系，这时候，我在坐标系的右边放上一个转子，如下图右边所示，如果此时转子被吸引且不动，那么在Iα−Iβ坐标系中就一定有一个Iα和Iβ值是能够对应转子现在的状态的\n\n![image.png](https://s2.loli.net/2024/08/09/oY7XVyjzhFJaStm.png)\n\n![image.png](https://s2.loli.net/2024/08/09/RxUjsCvoWF9LcKB.png)\n\n### 2.帕克变换推导公式\n\n- 根据上图，可以推导Iα−Iβ坐标系于Iq−Id坐标系的关系，这也就是帕克变换：\n\n![image-20240320174459687.png](https://s2.loli.net/2024/07/25/fahwsKAl9RnDUr6.png)\n\n- 在实际的情况中，电角度是可以根据传感器求解得出，因此，我们只需要控制Iq和Id的电流，就可以控制无刷电机的旋转，而我们可以将Id设置成0，因此，我们只需要一个Iq的电流，就可以控制电机旋转。\n\n## 四、推导原理总结\n\n![image.png](https://s2.loli.net/2024/08/09/rcElGWZyYFukLQb.png)\n\n- **电机想要旋转，就需要三相电流相互作用，而三项电流可以通过克拉克变换转成二维的矢量，而这个二维的矢量通过和转子的电角度建立关系，即可得出控制的电流Iq（Id默认为0），因此我们仅仅只需要通过设定Iq就可以控制电机进行旋转。**\n\n## 五、电压形式转换\n\n- 因为单片机的控制都是**基于电压进行控制**，包括PWM的控制，也是通过控制电压进行设定，因此我们需要将电流转换成电压形式，**而电压和电流的转换可以直接等于，因为等号两边都需要除以电阻，可以直接消项。**\n\n<img src=\"https://s2.loli.net/2024/07/25/GQ3qP7uYbaWCotK.png\" alt=\"image-20240320180833702.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2024/07/25/ZwqigGLHyDB9tFb.png\" alt=\"image-20240320181038012.png\" style=\"zoom:50%;\" />\n\n## 六、电角度于机械角度\n\n<img src=\"https://s2.loli.net/2024/07/25/IqfPkovwQDlSTR9.png\" alt=\"image-20240320182308979.png\"  />\n\n<img src=\"https://s2.loli.net/2024/07/25/76QqI34TyP5rozm.png\" alt=\"image-20240320182250898.png\"  />\n\n- **极对数：是N极和S极的对数数量**\n\n- **电角度：电角度是定子电流矢量与转子磁极矢量之间的夹角**\n\n- **机械角度：电机旋转一圈的空间几何角度，旋转一圈为360度**\n- 如果只是刚刚的一级对电机，那么的机械角度转一圈，相位的一个周期是能够和机械角度一一对应的，此时电角度=机械角度；但是，如果是多级电机，那么机械角度转一圈，相位的周期可能是很多个。\n\n","slug":"20240319ZYY-FOC无刷电机控制","published":1,"updated":"2024-08-09T09:17:49.181Z","_id":"clz9aaxq80007ygfbg5z5gi1j","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"FOC无刷电机控制\"><a href=\"#FOC无刷电机控制\" class=\"headerlink\" title=\"FOC无刷电机控制\"></a>FOC无刷电机控制</h1><h2 id=\"一、无刷电机基本理解\"><a href=\"#一、无刷电机基本理解\" class=\"headerlink\" title=\"一、无刷电机基本理解\"></a>一、无刷电机基本理解</h2><p>基本的航模无刷电机结构图如下图所示，<strong>分为前盖，中盖，后盖，磁铁，硅钢片，漆包线、轴承和转轴组成</strong>。</p>\n<p><img src=\"https://s2.loli.net/2024/08/09/uCg7fVhUXoATPwI.png\" alt=\"image.png\"></p>\n<h3 id=\"1-可以直接把电机分为定子部分和转子部分：\"><a href=\"#1-可以直接把电机分为定子部分和转子部分：\" class=\"headerlink\" title=\"1.可以直接把电机分为定子部分和转子部分：\"></a>1.可以直接把电机分为定子部分和转子部分：</h3><ul>\n<li><strong>定子</strong>就是有线圈绕组，固定不动的部分；</li>\n<li><strong>转子</strong>就是电机旋转的部分，用于输出电机的转动和扭矩。</li>\n</ul>\n<h3 id=\"2-内外旋转类型区分：\"><a href=\"#2-内外旋转类型区分：\" class=\"headerlink\" title=\"2.内外旋转类型区分：\"></a>2.内外旋转类型区分：</h3><ul>\n<li><p><strong>内转子无刷电机</strong>就是转子在内部，轴进行旋转；</p>\n</li>\n<li><p><strong>外转子无刷电机</strong>就是转子在外面，外壳进行旋转。</p>\n</li>\n<li><p>而<strong>直流无刷电机的驱动</strong>，就是依靠<strong>改变电机定子线圈的电流交变频率和波形，在定子周围形成磁场，驱动转子永磁体转动</strong>，进而带动电机转起来。</p>\n</li>\n</ul>\n<h3 id=\"3-无刷电机跟有刷电机的区别\"><a href=\"#3-无刷电机跟有刷电机的区别\" class=\"headerlink\" title=\"3.无刷电机跟有刷电机的区别\"></a>3.<strong>无刷电机跟有刷电机的区别</strong></h3><ul>\n<li>顾名思义就是<strong>无刷电机没有了有刷电机里的电刷</strong>。因此它<strong>不能够如同有刷电机那样采用机械结构就可以进行电流的换向</strong>， 而是必须通过采用如MOS这样的器件实现<strong>电子换向</strong>。</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/ndxDrgWQ6ebqKJM.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/uo7YtVxUW3ClqPb.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/aIR8mpnKhHzBVxs.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>对电机的控制实际上就是对MOS管开关规律的控制</strong>。而MOS管的开关规律是需要用到单片机程序进行控制的，因此这就引出了我们的<strong>FOC控制算法，FOC控制就是一种对电机运动模型进行抽象化和简化，进而有规律控制各个MOS管开关和通断的过程</strong>。</li>\n</ul>\n<h2 id=\"二、克拉克变换\"><a href=\"#二、克拉克变换\" class=\"headerlink\" title=\"二、克拉克变换\"></a>二、克拉克变换</h2><h3 id=\"1-克拉克变换基本含义\"><a href=\"#1-克拉克变换基本含义\" class=\"headerlink\" title=\"1.克拉克变换基本含义\"></a>1.克拉克变换基本含义</h3><ul>\n<li>交替开关的MOS管可以实现电机的转动，而这些交替开关的MOS管是以极其快的速度在周期性进行的，把这些周期性的开启和关断过程联系起来，并且对其各个相进行单独观察，就可以得到三个相A、B、C的电流随时间变换的曲线，如下图所示，他们之间存在120°的相位差。换一个角度来思考此问题，实际上，我们只要能够<strong>控制这个相位差为120°的sin状波形，就能够实现针对电机的控制</strong>。</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/hpZdnCAlOw29TyY.png\" alt=\"image.png\"></p>\n<ul>\n<li><p><strong>克拉克变换，实际上就是降维解耦的过程，把难以辨明和控制的三相相位差120°电机波形降维为两维矢量</strong>。</p>\n</li>\n<li><p><strong>第一就是把三相随时间变换的，相位差为120°的电流波形抽象化为三个间隔120°的矢量</strong>。</p>\n</li>\n<li><p><strong>第二就是利用三角函数对矢量进行降维，降维到两个坐标轴</strong>，从此复杂的三相变化问题就降解为了α-β坐标轴的坐标上的数值变化问题。</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/SzEKf6bxdrqjNHO.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/ARyrBNmfgD9a4Cz.png\" alt=\"image.png\"></p>\n<ul>\n<li>上图中，左边是我们把三相120度相位差的sin状波形抽象化为矢量之后的样子，而右边就是我们需要<strong>把这三个矢量进行投影的坐标轴。只要我们把三个矢量都投影到坐标轴上，那么，一个三矢量问题就变成一个二维坐标平面问题</strong>。</li>\n</ul>\n<h3 id=\"2-克拉克变换推导公式\"><a href=\"#2-克拉克变换推导公式\" class=\"headerlink\" title=\"2.克拉克变换推导公式\"></a>2.克拉克变换推导公式</h3><ul>\n<li><p><strong>克拉克变换的第一步，作投影</strong></p>\n</li>\n<li><p>针对α-β坐标系中α轴，有：</p>\n</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/YO6LurHIQkSfV21.png\" alt=\"image-20240318150726168.png\"  />\n\n\n\n<ul>\n<li>针对α-β坐标系中β轴，有：</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/ZUyTqOcmRVtHSe7.png\" alt=\"image-20240318150741335.png\"  />\n\n\n\n<ul>\n<li>把上面的投影结果列成矩阵形式，有：</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/xR4twW1ynvGp2ou.png\" alt=\"image-20240318150755362.png\"  />\n\n\n\n<h3 id=\"3-克拉克变换的等辐值形式\"><a href=\"#3-克拉克变换的等辐值形式\" class=\"headerlink\" title=\"3.克拉克变换的等辐值形式\"></a>3.克拉克变换的等辐值形式</h3><ul>\n<li>何为等幅值变换？用α相电流输入1A电流的特例来举例，当电流输入时候，根据基尔霍夫电流定律（电路中任一个节点上，在任意时刻，流入节点的电流之和等于流出节点的电流之和，如下图），有：</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/fSHMDIEoRj4JsOl.png\" alt=\"image-20240318151006334.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/1bvRp6E8T3Q5dPk.png\" alt=\"image-20240318152249217.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/esquFgkWVyZpf4c.png\" alt=\"image-20240318152309335.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/58PAe2iML9I1uDW.png\" alt=\"image-20240319174421088.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/qxy9OB8GJH2frNj.png\" alt=\"image-20240319174945752.png\"  />\n\n\n\n<ul>\n<li>在式子中，我们消去了变量Ic，这是因为由于基尔霍夫电流定律的存在，我们并不需要知道所有三相电流，我们只需要知道两相电流就能够求解得到另外一相的电流，反映在硬件上，<strong>我们就可以省去一路的电流传感器！节省了成本！</strong></li>\n</ul>\n<h3 id=\"4-克拉克逆变换\"><a href=\"#4-克拉克逆变换\" class=\"headerlink\" title=\"4.克拉克逆变换\"></a>4.克拉克逆变换</h3><img src=\"https://s2.loli.net/2024/07/25/eYjA7Q6pOFBVcNo.png\" alt=\"image-20240319175252143.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/Rbtm5MOlFEc8k1d.png\" alt=\"image-20240319175403342.png\"  />\n\n\n\n<h3 id=\"5-克拉克变换总结\"><a href=\"#5-克拉克变换总结\" class=\"headerlink\" title=\"5.克拉克变换总结\"></a>5.克拉克变换总结</h3><ul>\n<li><p>克拉克变换首先将<strong>三相电流转换成两维度的矢量电流</strong>，因此我们就可以通过<strong>控制两维度的矢量电流来表达三项电流的变换情况</strong>，并且通过等幅值变换，我们就可以将<strong>电流进行消项，之后又可以消去一路Ic，优化处理速度</strong>；</p>\n</li>\n<li><p>而克拉克逆变换的目的是我们通<strong>过需求的两项矢量电流来反向求解三相电流，并且来控制无刷电机驱动。</strong></p>\n</li>\n</ul>\n<h2 id=\"三、帕克变换\"><a href=\"#三、帕克变换\" class=\"headerlink\" title=\"三、帕克变换\"></a>三、帕克变换</h2><h3 id=\"1-帕克变换基本定义\"><a href=\"#1-帕克变换基本定义\" class=\"headerlink\" title=\"1.帕克变换基本定义\"></a>1.帕克变换基本定义</h3><ul>\n<li>通过克拉克变换之后，我们就将三相电路降阶至二维矢量电流，但是电流和电机旋转角度的关系是未知的，还需要将这个理论和旋转电机对应起来，也就是<strong>建立电机旋转时的数学模型</strong>，这就是帕克变换的目的。</li>\n<li>其实整个帕克变换的思路很简单，首先，我们把电机的定子t线圈上固定一个Iα−Iβ坐标系，这时候，我在坐标系的右边放上一个转子，如下图右边所示，如果此时转子被吸引且不动，那么在Iα−Iβ坐标系中就一定有一个Iα和Iβ值是能够对应转子现在的状态的</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/oY7XVyjzhFJaStm.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/RxUjsCvoWF9LcKB.png\" alt=\"image.png\"></p>\n<h3 id=\"2-帕克变换推导公式\"><a href=\"#2-帕克变换推导公式\" class=\"headerlink\" title=\"2.帕克变换推导公式\"></a>2.帕克变换推导公式</h3><ul>\n<li>根据上图，可以推导Iα−Iβ坐标系于Iq−Id坐标系的关系，这也就是帕克变换：</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/25/fahwsKAl9RnDUr6.png\" alt=\"image-20240320174459687.png\"></p>\n<ul>\n<li>在实际的情况中，电角度是可以根据传感器求解得出，因此，我们只需要控制Iq和Id的电流，就可以控制无刷电机的旋转，而我们可以将Id设置成0，因此，我们只需要一个Iq的电流，就可以控制电机旋转。</li>\n</ul>\n<h2 id=\"四、推导原理总结\"><a href=\"#四、推导原理总结\" class=\"headerlink\" title=\"四、推导原理总结\"></a>四、推导原理总结</h2><p><img src=\"https://s2.loli.net/2024/08/09/rcElGWZyYFukLQb.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>电机想要旋转，就需要三相电流相互作用，而三项电流可以通过克拉克变换转成二维的矢量，而这个二维的矢量通过和转子的电角度建立关系，即可得出控制的电流Iq（Id默认为0），因此我们仅仅只需要通过设定Iq就可以控制电机进行旋转。</strong></li>\n</ul>\n<h2 id=\"五、电压形式转换\"><a href=\"#五、电压形式转换\" class=\"headerlink\" title=\"五、电压形式转换\"></a>五、电压形式转换</h2><ul>\n<li>因为单片机的控制都是<strong>基于电压进行控制</strong>，包括PWM的控制，也是通过控制电压进行设定，因此我们需要将电流转换成电压形式，<strong>而电压和电流的转换可以直接等于，因为等号两边都需要除以电阻，可以直接消项。</strong></li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/GQ3qP7uYbaWCotK.png\" alt=\"image-20240320180833702.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2024/07/25/ZwqigGLHyDB9tFb.png\" alt=\"image-20240320181038012.png\" style=\"zoom:50%;\" />\n\n<h2 id=\"六、电角度于机械角度\"><a href=\"#六、电角度于机械角度\" class=\"headerlink\" title=\"六、电角度于机械角度\"></a>六、电角度于机械角度</h2><img src=\"https://s2.loli.net/2024/07/25/IqfPkovwQDlSTR9.png\" alt=\"image-20240320182308979.png\"  />\n\n<img src=\"https://s2.loli.net/2024/07/25/76QqI34TyP5rozm.png\" alt=\"image-20240320182250898.png\"  />\n\n<ul>\n<li><p><strong>极对数：是N极和S极的对数数量</strong></p>\n</li>\n<li><p><strong>电角度：电角度是定子电流矢量与转子磁极矢量之间的夹角</strong></p>\n</li>\n<li><p><strong>机械角度：电机旋转一圈的空间几何角度，旋转一圈为360度</strong></p>\n</li>\n<li><p>如果只是刚刚的一级对电机，那么的机械角度转一圈，相位的一个周期是能够和机械角度一一对应的，此时电角度&#x3D;机械角度；但是，如果是多级电机，那么机械角度转一圈，相位的周期可能是很多个。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"FOC无刷电机控制\"><a href=\"#FOC无刷电机控制\" class=\"headerlink\" title=\"FOC无刷电机控制\"></a>FOC无刷电机控制</h1><h2 id=\"一、无刷电机基本理解\"><a href=\"#一、无刷电机基本理解\" class=\"headerlink\" title=\"一、无刷电机基本理解\"></a>一、无刷电机基本理解</h2><p>基本的航模无刷电机结构图如下图所示，<strong>分为前盖，中盖，后盖，磁铁，硅钢片，漆包线、轴承和转轴组成</strong>。</p>\n<p><img src=\"https://s2.loli.net/2024/08/09/uCg7fVhUXoATPwI.png\" alt=\"image.png\"></p>\n<h3 id=\"1-可以直接把电机分为定子部分和转子部分：\"><a href=\"#1-可以直接把电机分为定子部分和转子部分：\" class=\"headerlink\" title=\"1.可以直接把电机分为定子部分和转子部分：\"></a>1.可以直接把电机分为定子部分和转子部分：</h3><ul>\n<li><strong>定子</strong>就是有线圈绕组，固定不动的部分；</li>\n<li><strong>转子</strong>就是电机旋转的部分，用于输出电机的转动和扭矩。</li>\n</ul>\n<h3 id=\"2-内外旋转类型区分：\"><a href=\"#2-内外旋转类型区分：\" class=\"headerlink\" title=\"2.内外旋转类型区分：\"></a>2.内外旋转类型区分：</h3><ul>\n<li><p><strong>内转子无刷电机</strong>就是转子在内部，轴进行旋转；</p>\n</li>\n<li><p><strong>外转子无刷电机</strong>就是转子在外面，外壳进行旋转。</p>\n</li>\n<li><p>而<strong>直流无刷电机的驱动</strong>，就是依靠<strong>改变电机定子线圈的电流交变频率和波形，在定子周围形成磁场，驱动转子永磁体转动</strong>，进而带动电机转起来。</p>\n</li>\n</ul>\n<h3 id=\"3-无刷电机跟有刷电机的区别\"><a href=\"#3-无刷电机跟有刷电机的区别\" class=\"headerlink\" title=\"3.无刷电机跟有刷电机的区别\"></a>3.<strong>无刷电机跟有刷电机的区别</strong></h3><ul>\n<li>顾名思义就是<strong>无刷电机没有了有刷电机里的电刷</strong>。因此它<strong>不能够如同有刷电机那样采用机械结构就可以进行电流的换向</strong>， 而是必须通过采用如MOS这样的器件实现<strong>电子换向</strong>。</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/ndxDrgWQ6ebqKJM.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/uo7YtVxUW3ClqPb.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/aIR8mpnKhHzBVxs.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>对电机的控制实际上就是对MOS管开关规律的控制</strong>。而MOS管的开关规律是需要用到单片机程序进行控制的，因此这就引出了我们的<strong>FOC控制算法，FOC控制就是一种对电机运动模型进行抽象化和简化，进而有规律控制各个MOS管开关和通断的过程</strong>。</li>\n</ul>\n<h2 id=\"二、克拉克变换\"><a href=\"#二、克拉克变换\" class=\"headerlink\" title=\"二、克拉克变换\"></a>二、克拉克变换</h2><h3 id=\"1-克拉克变换基本含义\"><a href=\"#1-克拉克变换基本含义\" class=\"headerlink\" title=\"1.克拉克变换基本含义\"></a>1.克拉克变换基本含义</h3><ul>\n<li>交替开关的MOS管可以实现电机的转动，而这些交替开关的MOS管是以极其快的速度在周期性进行的，把这些周期性的开启和关断过程联系起来，并且对其各个相进行单独观察，就可以得到三个相A、B、C的电流随时间变换的曲线，如下图所示，他们之间存在120°的相位差。换一个角度来思考此问题，实际上，我们只要能够<strong>控制这个相位差为120°的sin状波形，就能够实现针对电机的控制</strong>。</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/hpZdnCAlOw29TyY.png\" alt=\"image.png\"></p>\n<ul>\n<li><p><strong>克拉克变换，实际上就是降维解耦的过程，把难以辨明和控制的三相相位差120°电机波形降维为两维矢量</strong>。</p>\n</li>\n<li><p><strong>第一就是把三相随时间变换的，相位差为120°的电流波形抽象化为三个间隔120°的矢量</strong>。</p>\n</li>\n<li><p><strong>第二就是利用三角函数对矢量进行降维，降维到两个坐标轴</strong>，从此复杂的三相变化问题就降解为了α-β坐标轴的坐标上的数值变化问题。</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/SzEKf6bxdrqjNHO.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/ARyrBNmfgD9a4Cz.png\" alt=\"image.png\"></p>\n<ul>\n<li>上图中，左边是我们把三相120度相位差的sin状波形抽象化为矢量之后的样子，而右边就是我们需要<strong>把这三个矢量进行投影的坐标轴。只要我们把三个矢量都投影到坐标轴上，那么，一个三矢量问题就变成一个二维坐标平面问题</strong>。</li>\n</ul>\n<h3 id=\"2-克拉克变换推导公式\"><a href=\"#2-克拉克变换推导公式\" class=\"headerlink\" title=\"2.克拉克变换推导公式\"></a>2.克拉克变换推导公式</h3><ul>\n<li><p><strong>克拉克变换的第一步，作投影</strong></p>\n</li>\n<li><p>针对α-β坐标系中α轴，有：</p>\n</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/YO6LurHIQkSfV21.png\" alt=\"image-20240318150726168.png\"  />\n\n\n\n<ul>\n<li>针对α-β坐标系中β轴，有：</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/ZUyTqOcmRVtHSe7.png\" alt=\"image-20240318150741335.png\"  />\n\n\n\n<ul>\n<li>把上面的投影结果列成矩阵形式，有：</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/xR4twW1ynvGp2ou.png\" alt=\"image-20240318150755362.png\"  />\n\n\n\n<h3 id=\"3-克拉克变换的等辐值形式\"><a href=\"#3-克拉克变换的等辐值形式\" class=\"headerlink\" title=\"3.克拉克变换的等辐值形式\"></a>3.克拉克变换的等辐值形式</h3><ul>\n<li>何为等幅值变换？用α相电流输入1A电流的特例来举例，当电流输入时候，根据基尔霍夫电流定律（电路中任一个节点上，在任意时刻，流入节点的电流之和等于流出节点的电流之和，如下图），有：</li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/fSHMDIEoRj4JsOl.png\" alt=\"image-20240318151006334.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/1bvRp6E8T3Q5dPk.png\" alt=\"image-20240318152249217.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/esquFgkWVyZpf4c.png\" alt=\"image-20240318152309335.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/58PAe2iML9I1uDW.png\" alt=\"image-20240319174421088.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/qxy9OB8GJH2frNj.png\" alt=\"image-20240319174945752.png\"  />\n\n\n\n<ul>\n<li>在式子中，我们消去了变量Ic，这是因为由于基尔霍夫电流定律的存在，我们并不需要知道所有三相电流，我们只需要知道两相电流就能够求解得到另外一相的电流，反映在硬件上，<strong>我们就可以省去一路的电流传感器！节省了成本！</strong></li>\n</ul>\n<h3 id=\"4-克拉克逆变换\"><a href=\"#4-克拉克逆变换\" class=\"headerlink\" title=\"4.克拉克逆变换\"></a>4.克拉克逆变换</h3><img src=\"https://s2.loli.net/2024/07/25/eYjA7Q6pOFBVcNo.png\" alt=\"image-20240319175252143.png\"  />\n\n\n\n<img src=\"https://s2.loli.net/2024/07/25/Rbtm5MOlFEc8k1d.png\" alt=\"image-20240319175403342.png\"  />\n\n\n\n<h3 id=\"5-克拉克变换总结\"><a href=\"#5-克拉克变换总结\" class=\"headerlink\" title=\"5.克拉克变换总结\"></a>5.克拉克变换总结</h3><ul>\n<li><p>克拉克变换首先将<strong>三相电流转换成两维度的矢量电流</strong>，因此我们就可以通过<strong>控制两维度的矢量电流来表达三项电流的变换情况</strong>，并且通过等幅值变换，我们就可以将<strong>电流进行消项，之后又可以消去一路Ic，优化处理速度</strong>；</p>\n</li>\n<li><p>而克拉克逆变换的目的是我们通<strong>过需求的两项矢量电流来反向求解三相电流，并且来控制无刷电机驱动。</strong></p>\n</li>\n</ul>\n<h2 id=\"三、帕克变换\"><a href=\"#三、帕克变换\" class=\"headerlink\" title=\"三、帕克变换\"></a>三、帕克变换</h2><h3 id=\"1-帕克变换基本定义\"><a href=\"#1-帕克变换基本定义\" class=\"headerlink\" title=\"1.帕克变换基本定义\"></a>1.帕克变换基本定义</h3><ul>\n<li>通过克拉克变换之后，我们就将三相电路降阶至二维矢量电流，但是电流和电机旋转角度的关系是未知的，还需要将这个理论和旋转电机对应起来，也就是<strong>建立电机旋转时的数学模型</strong>，这就是帕克变换的目的。</li>\n<li>其实整个帕克变换的思路很简单，首先，我们把电机的定子t线圈上固定一个Iα−Iβ坐标系，这时候，我在坐标系的右边放上一个转子，如下图右边所示，如果此时转子被吸引且不动，那么在Iα−Iβ坐标系中就一定有一个Iα和Iβ值是能够对应转子现在的状态的</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/08/09/oY7XVyjzhFJaStm.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/08/09/RxUjsCvoWF9LcKB.png\" alt=\"image.png\"></p>\n<h3 id=\"2-帕克变换推导公式\"><a href=\"#2-帕克变换推导公式\" class=\"headerlink\" title=\"2.帕克变换推导公式\"></a>2.帕克变换推导公式</h3><ul>\n<li>根据上图，可以推导Iα−Iβ坐标系于Iq−Id坐标系的关系，这也就是帕克变换：</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/07/25/fahwsKAl9RnDUr6.png\" alt=\"image-20240320174459687.png\"></p>\n<ul>\n<li>在实际的情况中，电角度是可以根据传感器求解得出，因此，我们只需要控制Iq和Id的电流，就可以控制无刷电机的旋转，而我们可以将Id设置成0，因此，我们只需要一个Iq的电流，就可以控制电机旋转。</li>\n</ul>\n<h2 id=\"四、推导原理总结\"><a href=\"#四、推导原理总结\" class=\"headerlink\" title=\"四、推导原理总结\"></a>四、推导原理总结</h2><p><img src=\"https://s2.loli.net/2024/08/09/rcElGWZyYFukLQb.png\" alt=\"image.png\"></p>\n<ul>\n<li><strong>电机想要旋转，就需要三相电流相互作用，而三项电流可以通过克拉克变换转成二维的矢量，而这个二维的矢量通过和转子的电角度建立关系，即可得出控制的电流Iq（Id默认为0），因此我们仅仅只需要通过设定Iq就可以控制电机进行旋转。</strong></li>\n</ul>\n<h2 id=\"五、电压形式转换\"><a href=\"#五、电压形式转换\" class=\"headerlink\" title=\"五、电压形式转换\"></a>五、电压形式转换</h2><ul>\n<li>因为单片机的控制都是<strong>基于电压进行控制</strong>，包括PWM的控制，也是通过控制电压进行设定，因此我们需要将电流转换成电压形式，<strong>而电压和电流的转换可以直接等于，因为等号两边都需要除以电阻，可以直接消项。</strong></li>\n</ul>\n<img src=\"https://s2.loli.net/2024/07/25/GQ3qP7uYbaWCotK.png\" alt=\"image-20240320180833702.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2024/07/25/ZwqigGLHyDB9tFb.png\" alt=\"image-20240320181038012.png\" style=\"zoom:50%;\" />\n\n<h2 id=\"六、电角度于机械角度\"><a href=\"#六、电角度于机械角度\" class=\"headerlink\" title=\"六、电角度于机械角度\"></a>六、电角度于机械角度</h2><img src=\"https://s2.loli.net/2024/07/25/IqfPkovwQDlSTR9.png\" alt=\"image-20240320182308979.png\"  />\n\n<img src=\"https://s2.loli.net/2024/07/25/76QqI34TyP5rozm.png\" alt=\"image-20240320182250898.png\"  />\n\n<ul>\n<li><p><strong>极对数：是N极和S极的对数数量</strong></p>\n</li>\n<li><p><strong>电角度：电角度是定子电流矢量与转子磁极矢量之间的夹角</strong></p>\n</li>\n<li><p><strong>机械角度：电机旋转一圈的空间几何角度，旋转一圈为360度</strong></p>\n</li>\n<li><p>如果只是刚刚的一级对电机，那么的机械角度转一圈，相位的一个周期是能够和机械角度一一对应的，此时电角度&#x3D;机械角度；但是，如果是多级电机，那么机械角度转一圈，相位的周期可能是很多个。</p>\n</li>\n</ul>\n"},{"title":"STM32固件库及工程文件概念","date":"2024-06-29T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/KWuMZw2shPzoXiy.jpg","_content":"\n# STM32固件库及工程文件概念\n\n## STM32固件库整体结构\n\n \t1-汇编编写的启动文件\n \tstartup_stm32f10x_hd.s:设置堆栈指针、设置PC指针、初始化中断向量表、配置系统时钟、调用c库函数_main最终去到c的世界\n \t\n \t2-时钟配置文件\n \tsystem_stm32f10x.c:把外部时钟HSE=8M，经过PLL倍频为72M。\n \t\n \t3-外设相关的\n \tstm32f10x.h:实现了内核之外的外设的寄存器映射xxx:GPIO、USRAT、I2c、SPI、FSMC\n \tstm32f10x_xx.c:外设的驱动函数库文件\n \tstm32f10x_xx.h:存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库函数的声明\n \t\n \t4-内核相关的\n \tCMSIs - Cortex 微控制器软件接口标准\n \tcore_cm3.h:实现了内核里面外设的寄存器映射\n \tcore_cm3.c\n \tNVIC(嵌套向量中断控制器)、sysTick(系统滴答定时器)\n \t\n \tST公司裁剪后的内核文件\n \tmisc.h\n \tmisc.c\n \t\n \t5-头文件的配置文件\n \tstm32f10x_conf.h:头文件的头文件\n \t/ / stm32f10x_usart.h\n \t/ / stm32f10x_i2c.h\n \t/ / stm32f10x_spi.h\n \t/ / stm32f10x_adc.h\n \t/ / stm32f10x_fsmc.h\n \t\n \t6-专门存放中断服务函数的c文件\n \tstm32f10x_it.c\n \tstm32f10x_it.h\n \t\n \t中断服务函数你可以随意放在其他的地方，并不是一定要放在stm32f10x_it.c\n \t\n \t#include \"stm32f10x.h\"//相当于51单片机中的#include <reg51.h>\n \tint main (void)\n \t{\n \t\t//来到这里的时候，系统的时钟已经被配置成72M\n \t}\n\n### 文件设置\n\n#### 1.设置创建项目文件夹，并在文件夹内设置四个文件\n\n#### ①Libraries：\n\n```\n内核相关文件（core_cm3.c、core_cm3.h）\n\n启动文件（startup_stm32f10x_hd）\n\n时钟配置文件（system_stm32f10x.c、system_stm32f10x.h）\n\n外设文件（stm32f10x.h和固件库h.c文件）\n```\n\n#### ②Project\n\n```\nKEIL工程文件\n\n输出HEX文件，用于准备烧录\n```\n\n#### ③User\n\n```\n用户程序放置\n\nmain.c文件\n```\n\n#### ④Doc\n\n```\nREADME.md文档\n```\n\n#### 2.打开工程，创建五个文件夹\n\n```\nSTARTUP：导入启动文件\n\nCMSIS：导入内核文件和时钟配置文件\n\nFWLIB：导入固件库\n\nUSER：导入main.c文件和用户文件\n\nDOC：导入README文件\n```\n\n#### 3.所有设计到头文件的文件夹配置到系统环境中\n\n#### 4.开始编译全文件\n\n## 其他\n\n### 资源\n\nkeil软件芯片包：[Arm Keil | Keil STM32F1xx_DFP](https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/)\n\n### 报错\n\nReason: Pack [schema](https://so.csdn.net/so/search?q=schema&spm=1001.2101.3001.7020) version ‘1.4.0’ is not supported. Maximum supported [version](https://so.csdn.net/so/search?q=version&spm=1001.2101.3001.7020) is’1.3’. Please update to a newer version of MDK-ARM. 使用keil5 MDK安装芯片包时出错（软件版本过低）\n\n![image-20240531210625344.png](https://s2.loli.net/2024/07/25/HgserB9cVJfObdM.png)\n\n#### 解决方案\n\n根据弹窗的内容我们可知我们需要对MDK进行升级，在升级时我们直接覆盖安装。\n\n官方下载渠道：https://www.keil.com/download/product/\n填写相关信息便可进行下载。\n\n破解keil出现出现you are not logged in as an administrator....的问题，请退出软件，右击软件图标，以管理员身份运行，重新进行安装操作！然后就安装成功了！\n","source":"_posts/STM32固件库及工程文件概念.md","raw":"---\ntitle: STM32固件库及工程文件概念\ntag: 固件库\ndate: 2024-06-30\ncategories: STM32\nindex_img: https://s2.loli.net/2024/07/31/KWuMZw2shPzoXiy.jpg\n---\n\n# STM32固件库及工程文件概念\n\n## STM32固件库整体结构\n\n \t1-汇编编写的启动文件\n \tstartup_stm32f10x_hd.s:设置堆栈指针、设置PC指针、初始化中断向量表、配置系统时钟、调用c库函数_main最终去到c的世界\n \t\n \t2-时钟配置文件\n \tsystem_stm32f10x.c:把外部时钟HSE=8M，经过PLL倍频为72M。\n \t\n \t3-外设相关的\n \tstm32f10x.h:实现了内核之外的外设的寄存器映射xxx:GPIO、USRAT、I2c、SPI、FSMC\n \tstm32f10x_xx.c:外设的驱动函数库文件\n \tstm32f10x_xx.h:存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库函数的声明\n \t\n \t4-内核相关的\n \tCMSIs - Cortex 微控制器软件接口标准\n \tcore_cm3.h:实现了内核里面外设的寄存器映射\n \tcore_cm3.c\n \tNVIC(嵌套向量中断控制器)、sysTick(系统滴答定时器)\n \t\n \tST公司裁剪后的内核文件\n \tmisc.h\n \tmisc.c\n \t\n \t5-头文件的配置文件\n \tstm32f10x_conf.h:头文件的头文件\n \t/ / stm32f10x_usart.h\n \t/ / stm32f10x_i2c.h\n \t/ / stm32f10x_spi.h\n \t/ / stm32f10x_adc.h\n \t/ / stm32f10x_fsmc.h\n \t\n \t6-专门存放中断服务函数的c文件\n \tstm32f10x_it.c\n \tstm32f10x_it.h\n \t\n \t中断服务函数你可以随意放在其他的地方，并不是一定要放在stm32f10x_it.c\n \t\n \t#include \"stm32f10x.h\"//相当于51单片机中的#include <reg51.h>\n \tint main (void)\n \t{\n \t\t//来到这里的时候，系统的时钟已经被配置成72M\n \t}\n\n### 文件设置\n\n#### 1.设置创建项目文件夹，并在文件夹内设置四个文件\n\n#### ①Libraries：\n\n```\n内核相关文件（core_cm3.c、core_cm3.h）\n\n启动文件（startup_stm32f10x_hd）\n\n时钟配置文件（system_stm32f10x.c、system_stm32f10x.h）\n\n外设文件（stm32f10x.h和固件库h.c文件）\n```\n\n#### ②Project\n\n```\nKEIL工程文件\n\n输出HEX文件，用于准备烧录\n```\n\n#### ③User\n\n```\n用户程序放置\n\nmain.c文件\n```\n\n#### ④Doc\n\n```\nREADME.md文档\n```\n\n#### 2.打开工程，创建五个文件夹\n\n```\nSTARTUP：导入启动文件\n\nCMSIS：导入内核文件和时钟配置文件\n\nFWLIB：导入固件库\n\nUSER：导入main.c文件和用户文件\n\nDOC：导入README文件\n```\n\n#### 3.所有设计到头文件的文件夹配置到系统环境中\n\n#### 4.开始编译全文件\n\n## 其他\n\n### 资源\n\nkeil软件芯片包：[Arm Keil | Keil STM32F1xx_DFP](https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/)\n\n### 报错\n\nReason: Pack [schema](https://so.csdn.net/so/search?q=schema&spm=1001.2101.3001.7020) version ‘1.4.0’ is not supported. Maximum supported [version](https://so.csdn.net/so/search?q=version&spm=1001.2101.3001.7020) is’1.3’. Please update to a newer version of MDK-ARM. 使用keil5 MDK安装芯片包时出错（软件版本过低）\n\n![image-20240531210625344.png](https://s2.loli.net/2024/07/25/HgserB9cVJfObdM.png)\n\n#### 解决方案\n\n根据弹窗的内容我们可知我们需要对MDK进行升级，在升级时我们直接覆盖安装。\n\n官方下载渠道：https://www.keil.com/download/product/\n填写相关信息便可进行下载。\n\n破解keil出现出现you are not logged in as an administrator....的问题，请退出软件，右击软件图标，以管理员身份运行，重新进行安装操作！然后就安装成功了！\n","slug":"STM32固件库及工程文件概念","published":1,"updated":"2024-07-31T03:33:34.039Z","_id":"clz9aaxq9000bygfb67xc7t64","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"STM32固件库及工程文件概念\"><a href=\"#STM32固件库及工程文件概念\" class=\"headerlink\" title=\"STM32固件库及工程文件概念\"></a>STM32固件库及工程文件概念</h1><h2 id=\"STM32固件库整体结构\"><a href=\"#STM32固件库整体结构\" class=\"headerlink\" title=\"STM32固件库整体结构\"></a>STM32固件库整体结构</h2><pre><code class=\"hljs\"> 1-汇编编写的启动文件\n startup_stm32f10x_hd.s:设置堆栈指针、设置PC指针、初始化中断向量表、配置系统时钟、调用c库函数_main最终去到c的世界\n \n 2-时钟配置文件\n system_stm32f10x.c:把外部时钟HSE=8M，经过PLL倍频为72M。\n \n 3-外设相关的\n stm32f10x.h:实现了内核之外的外设的寄存器映射xxx:GPIO、USRAT、I2c、SPI、FSMC\n stm32f10x_xx.c:外设的驱动函数库文件\n stm32f10x_xx.h:存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库函数的声明\n \n 4-内核相关的\n CMSIs - Cortex 微控制器软件接口标准\n core_cm3.h:实现了内核里面外设的寄存器映射\n core_cm3.c\n NVIC(嵌套向量中断控制器)、sysTick(系统滴答定时器)\n \n ST公司裁剪后的内核文件\n misc.h\n misc.c\n \n 5-头文件的配置文件\n stm32f10x_conf.h:头文件的头文件\n / / stm32f10x_usart.h\n / / stm32f10x_i2c.h\n / / stm32f10x_spi.h\n / / stm32f10x_adc.h\n / / stm32f10x_fsmc.h\n \n 6-专门存放中断服务函数的c文件\n stm32f10x_it.c\n stm32f10x_it.h\n \n 中断服务函数你可以随意放在其他的地方，并不是一定要放在stm32f10x_it.c\n \n #include &quot;stm32f10x.h&quot;//相当于51单片机中的#include &lt;reg51.h&gt;\n int main (void)\n &#123;\n     //来到这里的时候，系统的时钟已经被配置成72M\n &#125;\n</code></pre>\n<h3 id=\"文件设置\"><a href=\"#文件设置\" class=\"headerlink\" title=\"文件设置\"></a>文件设置</h3><h4 id=\"1-设置创建项目文件夹，并在文件夹内设置四个文件\"><a href=\"#1-设置创建项目文件夹，并在文件夹内设置四个文件\" class=\"headerlink\" title=\"1.设置创建项目文件夹，并在文件夹内设置四个文件\"></a>1.设置创建项目文件夹，并在文件夹内设置四个文件</h4><h4 id=\"①Libraries：\"><a href=\"#①Libraries：\" class=\"headerlink\" title=\"①Libraries：\"></a>①Libraries：</h4><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">内核相关文件（core_c<span class=\"hljs-name\">m3.</span>c、core_c<span class=\"hljs-name\">m3.</span>h）<br><br>启动文件（startup_st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x_hd）<br><br>时钟配置文件（system_st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x.c、system_st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x.h）<br><br>外设文件（st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x.h和固件库h.c文件）<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"②Project\"><a href=\"#②Project\" class=\"headerlink\" title=\"②Project\"></a>②Project</h4><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autoit\">KEIL工程文件<br><br>输出<span class=\"hljs-built_in\">HEX</span>文件，用于准备烧录<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"③User\"><a href=\"#③User\" class=\"headerlink\" title=\"③User\"></a>③User</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">用户程序放置<br><br><span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span>文件<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"④Doc\"><a href=\"#④Doc\" class=\"headerlink\" title=\"④Doc\"></a>④Doc</h4><figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dos\">README.<span class=\"hljs-built_in\">md</span>文档<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-打开工程，创建五个文件夹\"><a href=\"#2-打开工程，创建五个文件夹\" class=\"headerlink\" title=\"2.打开工程，创建五个文件夹\"></a>2.打开工程，创建五个文件夹</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">STARTUP：导入启动文件<br><br>CMSIS：导入内核文件和时钟配置文件<br><br>FWLIB：导入固件库<br><br>USER：导入<span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span>文件和用户文件<br><br>DOC：导入README文件<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-所有设计到头文件的文件夹配置到系统环境中\"><a href=\"#3-所有设计到头文件的文件夹配置到系统环境中\" class=\"headerlink\" title=\"3.所有设计到头文件的文件夹配置到系统环境中\"></a>3.所有设计到头文件的文件夹配置到系统环境中</h4><h4 id=\"4-开始编译全文件\"><a href=\"#4-开始编译全文件\" class=\"headerlink\" title=\"4.开始编译全文件\"></a>4.开始编译全文件</h4><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h3><p>keil软件芯片包：<a href=\"https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/\">Arm Keil | Keil STM32F1xx_DFP</a></p>\n<h3 id=\"报错\"><a href=\"#报错\" class=\"headerlink\" title=\"报错\"></a>报错</h3><p>Reason: Pack <a href=\"https://so.csdn.net/so/search?q=schema&spm=1001.2101.3001.7020\">schema</a> version ‘1.4.0’ is not supported. Maximum supported <a href=\"https://so.csdn.net/so/search?q=version&spm=1001.2101.3001.7020\">version</a> is’1.3’. Please update to a newer version of MDK-ARM. 使用keil5 MDK安装芯片包时出错（软件版本过低）</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/HgserB9cVJfObdM.png\" alt=\"image-20240531210625344.png\"></p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>根据弹窗的内容我们可知我们需要对MDK进行升级，在升级时我们直接覆盖安装。</p>\n<p>官方下载渠道：<a href=\"https://www.keil.com/download/product/\">https://www.keil.com/download/product/</a><br>填写相关信息便可进行下载。</p>\n<p>破解keil出现出现you are not logged in as an administrator….的问题，请退出软件，右击软件图标，以管理员身份运行，重新进行安装操作！然后就安装成功了！</p>\n","excerpt":"","more":"<h1 id=\"STM32固件库及工程文件概念\"><a href=\"#STM32固件库及工程文件概念\" class=\"headerlink\" title=\"STM32固件库及工程文件概念\"></a>STM32固件库及工程文件概念</h1><h2 id=\"STM32固件库整体结构\"><a href=\"#STM32固件库整体结构\" class=\"headerlink\" title=\"STM32固件库整体结构\"></a>STM32固件库整体结构</h2><pre><code> 1-汇编编写的启动文件\n startup_stm32f10x_hd.s:设置堆栈指针、设置PC指针、初始化中断向量表、配置系统时钟、调用c库函数_main最终去到c的世界\n \n 2-时钟配置文件\n system_stm32f10x.c:把外部时钟HSE=8M，经过PLL倍频为72M。\n \n 3-外设相关的\n stm32f10x.h:实现了内核之外的外设的寄存器映射xxx:GPIO、USRAT、I2c、SPI、FSMC\n stm32f10x_xx.c:外设的驱动函数库文件\n stm32f10x_xx.h:存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库函数的声明\n \n 4-内核相关的\n CMSIs - Cortex 微控制器软件接口标准\n core_cm3.h:实现了内核里面外设的寄存器映射\n core_cm3.c\n NVIC(嵌套向量中断控制器)、sysTick(系统滴答定时器)\n \n ST公司裁剪后的内核文件\n misc.h\n misc.c\n \n 5-头文件的配置文件\n stm32f10x_conf.h:头文件的头文件\n / / stm32f10x_usart.h\n / / stm32f10x_i2c.h\n / / stm32f10x_spi.h\n / / stm32f10x_adc.h\n / / stm32f10x_fsmc.h\n \n 6-专门存放中断服务函数的c文件\n stm32f10x_it.c\n stm32f10x_it.h\n \n 中断服务函数你可以随意放在其他的地方，并不是一定要放在stm32f10x_it.c\n \n #include &quot;stm32f10x.h&quot;//相当于51单片机中的#include &lt;reg51.h&gt;\n int main (void)\n &#123;\n     //来到这里的时候，系统的时钟已经被配置成72M\n &#125;\n</code></pre>\n<h3 id=\"文件设置\"><a href=\"#文件设置\" class=\"headerlink\" title=\"文件设置\"></a>文件设置</h3><h4 id=\"1-设置创建项目文件夹，并在文件夹内设置四个文件\"><a href=\"#1-设置创建项目文件夹，并在文件夹内设置四个文件\" class=\"headerlink\" title=\"1.设置创建项目文件夹，并在文件夹内设置四个文件\"></a>1.设置创建项目文件夹，并在文件夹内设置四个文件</h4><h4 id=\"①Libraries：\"><a href=\"#①Libraries：\" class=\"headerlink\" title=\"①Libraries：\"></a>①Libraries：</h4><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">内核相关文件（core_c<span class=\"hljs-name\">m3.</span>c、core_c<span class=\"hljs-name\">m3.</span>h）<br><br>启动文件（startup_st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x_hd）<br><br>时钟配置文件（system_st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x.c、system_st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x.h）<br><br>外设文件（st<span class=\"hljs-name\">m32</span>f<span class=\"hljs-number\">10</span>x.h和固件库h.c文件）<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"②Project\"><a href=\"#②Project\" class=\"headerlink\" title=\"②Project\"></a>②Project</h4><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autoit\">KEIL工程文件<br><br>输出<span class=\"hljs-built_in\">HEX</span>文件，用于准备烧录<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"③User\"><a href=\"#③User\" class=\"headerlink\" title=\"③User\"></a>③User</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">用户程序放置<br><br><span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span>文件<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"④Doc\"><a href=\"#④Doc\" class=\"headerlink\" title=\"④Doc\"></a>④Doc</h4><figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dos\">README.<span class=\"hljs-built_in\">md</span>文档<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-打开工程，创建五个文件夹\"><a href=\"#2-打开工程，创建五个文件夹\" class=\"headerlink\" title=\"2.打开工程，创建五个文件夹\"></a>2.打开工程，创建五个文件夹</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">STARTUP：导入启动文件<br><br>CMSIS：导入内核文件和时钟配置文件<br><br>FWLIB：导入固件库<br><br>USER：导入<span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span>文件和用户文件<br><br>DOC：导入README文件<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-所有设计到头文件的文件夹配置到系统环境中\"><a href=\"#3-所有设计到头文件的文件夹配置到系统环境中\" class=\"headerlink\" title=\"3.所有设计到头文件的文件夹配置到系统环境中\"></a>3.所有设计到头文件的文件夹配置到系统环境中</h4><h4 id=\"4-开始编译全文件\"><a href=\"#4-开始编译全文件\" class=\"headerlink\" title=\"4.开始编译全文件\"></a>4.开始编译全文件</h4><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h3><p>keil软件芯片包：<a href=\"https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/\">Arm Keil | Keil STM32F1xx_DFP</a></p>\n<h3 id=\"报错\"><a href=\"#报错\" class=\"headerlink\" title=\"报错\"></a>报错</h3><p>Reason: Pack <a href=\"https://so.csdn.net/so/search?q=schema&spm=1001.2101.3001.7020\">schema</a> version ‘1.4.0’ is not supported. Maximum supported <a href=\"https://so.csdn.net/so/search?q=version&spm=1001.2101.3001.7020\">version</a> is’1.3’. Please update to a newer version of MDK-ARM. 使用keil5 MDK安装芯片包时出错（软件版本过低）</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/HgserB9cVJfObdM.png\" alt=\"image-20240531210625344.png\"></p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>根据弹窗的内容我们可知我们需要对MDK进行升级，在升级时我们直接覆盖安装。</p>\n<p>官方下载渠道：<a href=\"https://www.keil.com/download/product/\">https://www.keil.com/download/product/</a><br>填写相关信息便可进行下载。</p>\n<p>破解keil出现出现you are not logged in as an administrator….的问题，请退出软件，右击软件图标，以管理员身份运行，重新进行安装操作！然后就安装成功了！</p>\n"},{"title":"电气路控制设计","date":"2023-11-25T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/zVGW8v4spCNUdT9.jpg","_content":"\n# 电气路控制设计\n- **一个简单的气动控制一共分为四大步：**\n  - 第一步是进行**气路仿真**，然后确定气路控制的逻辑性；\n  - 第二步**编写控制程序**，将气路仿真得出的逻辑结果以控制代码的形式进行书写；\n  - 第三步**设计气路控制板**，因为很多电磁阀根本无法直接通过单片机进行驱动，因此我们需要借助外部电源的力量，就需要制作外围电路，来完成小马拉大车的效果；\n  - 第四步进行实际的**气路连接并控制**，连线的话就需要根据之前的仿真图来进行气路的连线，测试当然也是要基于第二步的控制代码来进行；\n- 所以要想做好一个完整的气路控制，这四步少一步不行，不要因为很麻烦而去省略其中一步，当你在排查气路问题的时候，会让你抓狂的\n\n## 1.设计需求假设\n\n- 示例：现在要设计一个机械臂的抬升，使用了一个双作用气缸，该气缸能够通过控制实现伸长和收缩\n\n## 2.气路仿真\n\n- 气路仿真最好用的还是FuildSim，这款软件是费斯托公司提供用户进行气路仿真，用法简单，操作容易，因此我这边仿真都是采用了这个软件进行仿真\n- 构建仿真原理图，这个软件的详细操作请看**FuildSim**专栏帖子，这边不进行详细介绍，下面是我构建的简易气路图，这个气路图里面包含了1个双作用气缸，3个电磁阀，1个气泵，1个节流阀，节流阀的作用是控制气流量来控制气缸伸缩的用时，这里面**我给电磁阀进行了编号，这个编号非常重要，而且后续接线以及编写代码，必须要按这个编号严格进行，减少错误，甚至后续测试的时候，必须在电磁阀上面贴上编号**\n\n![气路图](https://picss.sunbangyan.cn/2023/11/29/f271e8d8706ef9ac62eaab4025ec81f3.jpeg)\n\n- 开始进行仿真，这次的目的是要实现一个双作用气缸的伸长和收缩控制，开始仿真后，得出控制顺序为：\n  - 伸长：打开DCF3，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF3，归为所有电磁阀，达到伸长控制**（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）**；\n\n  ![气缸伸长](https://picdm.sunbangyan.cn/2023/11/29/f3526be0094237b34f961ecf2d2b9e04.jpeg)\n\n  \n\n  - 缩回：打开DCF2，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF2，归为所有电磁阀，达到伸长控制**（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）**；\n\n  ![气缸缩回](https://picst.sunbangyan.cn/2023/11/29/6b7f958fbe983a0f05d3e9c2ad4252c3.jpeg)\n\n- 完成仿真，得出想要的结果，之后开始根据结果进行代码的设计\n\n## 3.代码设计\n\n- 代码设计采用最简单的Arduino控制，设计的过程也很简单，跟点灯一模一样，按照仿真的结果进行顺序点灯，即可达到效果\n\n```\nint DCF1=5;\nint DCF2=6;\nint DCF3=7;\n//引脚的定义根据实际连接电磁阀的需求来设计\nvoid setup() {\n  pinMode(DCF1,OUTPUT);\n  pinMode(DCF2,OUTPUT);\n  pinMode(DCF3,OUTPUT);\n}\nvoid UP(){//气缸伸长（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）\n  digitalWrite(DCF3,HIGH);\n  delay(100);//延时的目的防止电磁阀响应过快\n  digitalWrite(DCF1,HIGH);\n  delay(5000);//延时的目的为了能够控制进入气流量，达到控制位置效果\n  digitalWrite(DCF1,LOW);\n  delay(100);\n  digitalWrite(DCF3,LOW);\n  delay(100);\n}\nvoid Down(){//气缸缩短（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）\n  digitalWrite(DCF2,HIGH);\n  delay(100);\n  digitalWrite(DCF1,HIGH);\n  delay(5000);\n  digitalWrite(DCF1,LOW);\n  delay(100);\n  digitalWrite(DCF2,LOW);\n  delay(100);\n}\nvoid loop() {\n  UP();\n  Down();\n}\n```\n\n- 这里面的代码逻辑是跟上面仿真的结果一样，因此环环相扣，不能因为怕麻烦，缺失了其中一个环节\n\n## 4.[电磁阀](https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=36262310020&_u=t2g8gqc420ea)控制\n\n- 因为目前所用的电磁阀基本都是12V和24V的，所以要想能够利用单片机的3.3V输出的话是不可能的，因此就需要用我们的单片机的3.3V搭配上一个只能开关NMOS管来实现小电压控制大电压的效果，当然这里面还需要进行外部高电压的接入，以下是我们会用到的元器件以及他的功能\n  - **[ESP32](https://detail.tmall.com/item.htm?_u=t2g8gqc49fb1&id=670446268383&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**这个最简单理解，我们代码的承载体，以及整个机器人控制的设备，为啥选择ESP32，因为他简单而且比Arduino小，还集成WIFI功能\n  - **[24V/12V电源](https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=672833563616&_u=t2g8gqc4b0ae)：**一部分用于驱动电磁阀的通断，借助外部电源的电压来实现驱动，一部分用于ESP32的供电\n  - **[DC-DC降压模块](https://detail.tmall.com/item.htm?_u=t2g8gqc495fe&id=582430989377&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**利用输入的高电压，转为5V的稳压电源，供电给ESP32，来保证一个电源即可实现多种利用\n  - **[NMOS管（A3400）](https://detail.tmall.com/item.htm?_u=t2g8gqc44f16&id=14478416081&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来充当开关的作用，G极连接单片机引脚，用于接收信号来实现控制，D极连接24V/12V电源的正极，S极连接接地端，来实现电路的导通\n  - **[光耦模块(LTV-247)](https://item.taobao.com/item.htm?spm=a21n57.1.0.0.3d58523cFi5cOt&id=583531277832&ns=1&abbucket=19#detail)：**利用光电隔离，实现高低电压的连接处隔离，防止大电流倒灌，损坏ESP32，光耦模块最好只用三组，四组的功率太大，容易损坏光耦模块，光耦模块的输出接地端，需要加一个保护电阻560欧，输出端也需要加一个保护电阻100K欧\n  - **[LED灯（0603）](https://detail.tmall.com/item.htm?_u=t2g8gqc49a07&id=13860351935&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来提示电源是否接入，需要添加一个保护电阻100K\n  - **[船型开关](https://detail.tmall.com/item.htm?_u=t2g8gqc4e83f&id=18691413288&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来开关控制电源的输入，减少插拔电源的麻烦\n  - **[快速插拔二端子（XH-2.54-2P）](https://detail.tmall.com/item.htm?_u=t2g8gqc448e3&id=13300685584&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来快速插拔电磁阀，能够实现电池阀的快速的接入\n  - [**DC插头母头（DC-005）**](https://detail.tmall.com/item.htm?_u=t2g8gqc4ad83&id=16520506238&spm=a1z09.2.0.0.32c42e8dCPUvWl)：\n- **电路图请看目录下的QL-EDA.pdf文件**\n- 以上的是整体所需的元器件以及购买链接，正常来说都是以上的类型，然后需要注意一个问题，**就是整个电路，必须低电压一个接地，高电压一个接地，不允许出现共地情况，防止出现烧坏的情况，整体电路，导通24V/12V的PCB电路宽度不低于0.8mm，导通常规5V/3.3V的电路宽度不低于0.5mm**\n\n## 5.气路连接并控制\n\n- 做到这一步的时候，基本上已经完成差不多了，这个时候只需要对照第一步进行连线，这边需要强调的是电磁阀的1、2、3口是具体指那几个口，图片会给予详细解答，请查看\n\n  - 费斯托电磁阀（24V），具备高速开关能力\n\n  ![费斯托电磁阀](https://picdm.sunbangyan.cn/2023/11/29/2be07b3e5d478d569f147c98f91da10d.jpeg)\n\n  - 海德斯电磁阀（12V），小巧，但是不具备高速开关能力\n\n  ![海德斯电磁阀](https://picdm.sunbangyan.cn/2023/11/29/a611906e4e773fa55356787357dcf618.jpeg)\n\n  - 转接头，仅仅列举几个\n\n  ![TLTBHDFZOG4_{`U(H9GL6MR](https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![四通转接头](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)\n\n  - 气动调节阀\n\n  ![气动调节阀](https://picst.sunbangyan.cn/2023/11/29/8704c328c58619d6fb920f54f5bf54f2.jpeg)\n\n  - 稳压阀\n\n  ![稳压阀](https://picst.sunbangyan.cn/2023/11/29/9f9500dda6401faee73322dc803ee935.jpeg)\n\n- 以上就是电气路设计的全过程，这里面的经验成分居多，需要不断的实操，不断的学习，才能够更深的掌握气动方面的知识\n","source":"_posts/20231204ZYY-电气路设计.md","raw":"---\ntitle: 电气路控制设计\ntag: 控制设计\ndate: 2023-11-26\ncategories: 控制设计\nindex_img: https://s2.loli.net/2024/07/31/zVGW8v4spCNUdT9.jpg\n---\n\n# 电气路控制设计\n- **一个简单的气动控制一共分为四大步：**\n  - 第一步是进行**气路仿真**，然后确定气路控制的逻辑性；\n  - 第二步**编写控制程序**，将气路仿真得出的逻辑结果以控制代码的形式进行书写；\n  - 第三步**设计气路控制板**，因为很多电磁阀根本无法直接通过单片机进行驱动，因此我们需要借助外部电源的力量，就需要制作外围电路，来完成小马拉大车的效果；\n  - 第四步进行实际的**气路连接并控制**，连线的话就需要根据之前的仿真图来进行气路的连线，测试当然也是要基于第二步的控制代码来进行；\n- 所以要想做好一个完整的气路控制，这四步少一步不行，不要因为很麻烦而去省略其中一步，当你在排查气路问题的时候，会让你抓狂的\n\n## 1.设计需求假设\n\n- 示例：现在要设计一个机械臂的抬升，使用了一个双作用气缸，该气缸能够通过控制实现伸长和收缩\n\n## 2.气路仿真\n\n- 气路仿真最好用的还是FuildSim，这款软件是费斯托公司提供用户进行气路仿真，用法简单，操作容易，因此我这边仿真都是采用了这个软件进行仿真\n- 构建仿真原理图，这个软件的详细操作请看**FuildSim**专栏帖子，这边不进行详细介绍，下面是我构建的简易气路图，这个气路图里面包含了1个双作用气缸，3个电磁阀，1个气泵，1个节流阀，节流阀的作用是控制气流量来控制气缸伸缩的用时，这里面**我给电磁阀进行了编号，这个编号非常重要，而且后续接线以及编写代码，必须要按这个编号严格进行，减少错误，甚至后续测试的时候，必须在电磁阀上面贴上编号**\n\n![气路图](https://picss.sunbangyan.cn/2023/11/29/f271e8d8706ef9ac62eaab4025ec81f3.jpeg)\n\n- 开始进行仿真，这次的目的是要实现一个双作用气缸的伸长和收缩控制，开始仿真后，得出控制顺序为：\n  - 伸长：打开DCF3，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF3，归为所有电磁阀，达到伸长控制**（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）**；\n\n  ![气缸伸长](https://picdm.sunbangyan.cn/2023/11/29/f3526be0094237b34f961ecf2d2b9e04.jpeg)\n\n  \n\n  - 缩回：打开DCF2，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF2，归为所有电磁阀，达到伸长控制**（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）**；\n\n  ![气缸缩回](https://picst.sunbangyan.cn/2023/11/29/6b7f958fbe983a0f05d3e9c2ad4252c3.jpeg)\n\n- 完成仿真，得出想要的结果，之后开始根据结果进行代码的设计\n\n## 3.代码设计\n\n- 代码设计采用最简单的Arduino控制，设计的过程也很简单，跟点灯一模一样，按照仿真的结果进行顺序点灯，即可达到效果\n\n```\nint DCF1=5;\nint DCF2=6;\nint DCF3=7;\n//引脚的定义根据实际连接电磁阀的需求来设计\nvoid setup() {\n  pinMode(DCF1,OUTPUT);\n  pinMode(DCF2,OUTPUT);\n  pinMode(DCF3,OUTPUT);\n}\nvoid UP(){//气缸伸长（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）\n  digitalWrite(DCF3,HIGH);\n  delay(100);//延时的目的防止电磁阀响应过快\n  digitalWrite(DCF1,HIGH);\n  delay(5000);//延时的目的为了能够控制进入气流量，达到控制位置效果\n  digitalWrite(DCF1,LOW);\n  delay(100);\n  digitalWrite(DCF3,LOW);\n  delay(100);\n}\nvoid Down(){//气缸缩短（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）\n  digitalWrite(DCF2,HIGH);\n  delay(100);\n  digitalWrite(DCF1,HIGH);\n  delay(5000);\n  digitalWrite(DCF1,LOW);\n  delay(100);\n  digitalWrite(DCF2,LOW);\n  delay(100);\n}\nvoid loop() {\n  UP();\n  Down();\n}\n```\n\n- 这里面的代码逻辑是跟上面仿真的结果一样，因此环环相扣，不能因为怕麻烦，缺失了其中一个环节\n\n## 4.[电磁阀](https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=36262310020&_u=t2g8gqc420ea)控制\n\n- 因为目前所用的电磁阀基本都是12V和24V的，所以要想能够利用单片机的3.3V输出的话是不可能的，因此就需要用我们的单片机的3.3V搭配上一个只能开关NMOS管来实现小电压控制大电压的效果，当然这里面还需要进行外部高电压的接入，以下是我们会用到的元器件以及他的功能\n  - **[ESP32](https://detail.tmall.com/item.htm?_u=t2g8gqc49fb1&id=670446268383&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**这个最简单理解，我们代码的承载体，以及整个机器人控制的设备，为啥选择ESP32，因为他简单而且比Arduino小，还集成WIFI功能\n  - **[24V/12V电源](https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=672833563616&_u=t2g8gqc4b0ae)：**一部分用于驱动电磁阀的通断，借助外部电源的电压来实现驱动，一部分用于ESP32的供电\n  - **[DC-DC降压模块](https://detail.tmall.com/item.htm?_u=t2g8gqc495fe&id=582430989377&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**利用输入的高电压，转为5V的稳压电源，供电给ESP32，来保证一个电源即可实现多种利用\n  - **[NMOS管（A3400）](https://detail.tmall.com/item.htm?_u=t2g8gqc44f16&id=14478416081&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来充当开关的作用，G极连接单片机引脚，用于接收信号来实现控制，D极连接24V/12V电源的正极，S极连接接地端，来实现电路的导通\n  - **[光耦模块(LTV-247)](https://item.taobao.com/item.htm?spm=a21n57.1.0.0.3d58523cFi5cOt&id=583531277832&ns=1&abbucket=19#detail)：**利用光电隔离，实现高低电压的连接处隔离，防止大电流倒灌，损坏ESP32，光耦模块最好只用三组，四组的功率太大，容易损坏光耦模块，光耦模块的输出接地端，需要加一个保护电阻560欧，输出端也需要加一个保护电阻100K欧\n  - **[LED灯（0603）](https://detail.tmall.com/item.htm?_u=t2g8gqc49a07&id=13860351935&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来提示电源是否接入，需要添加一个保护电阻100K\n  - **[船型开关](https://detail.tmall.com/item.htm?_u=t2g8gqc4e83f&id=18691413288&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来开关控制电源的输入，减少插拔电源的麻烦\n  - **[快速插拔二端子（XH-2.54-2P）](https://detail.tmall.com/item.htm?_u=t2g8gqc448e3&id=13300685584&spm=a1z09.2.0.0.32c42e8dCPUvWl)：**用来快速插拔电磁阀，能够实现电池阀的快速的接入\n  - [**DC插头母头（DC-005）**](https://detail.tmall.com/item.htm?_u=t2g8gqc4ad83&id=16520506238&spm=a1z09.2.0.0.32c42e8dCPUvWl)：\n- **电路图请看目录下的QL-EDA.pdf文件**\n- 以上的是整体所需的元器件以及购买链接，正常来说都是以上的类型，然后需要注意一个问题，**就是整个电路，必须低电压一个接地，高电压一个接地，不允许出现共地情况，防止出现烧坏的情况，整体电路，导通24V/12V的PCB电路宽度不低于0.8mm，导通常规5V/3.3V的电路宽度不低于0.5mm**\n\n## 5.气路连接并控制\n\n- 做到这一步的时候，基本上已经完成差不多了，这个时候只需要对照第一步进行连线，这边需要强调的是电磁阀的1、2、3口是具体指那几个口，图片会给予详细解答，请查看\n\n  - 费斯托电磁阀（24V），具备高速开关能力\n\n  ![费斯托电磁阀](https://picdm.sunbangyan.cn/2023/11/29/2be07b3e5d478d569f147c98f91da10d.jpeg)\n\n  - 海德斯电磁阀（12V），小巧，但是不具备高速开关能力\n\n  ![海德斯电磁阀](https://picdm.sunbangyan.cn/2023/11/29/a611906e4e773fa55356787357dcf618.jpeg)\n\n  - 转接头，仅仅列举几个\n\n  ![TLTBHDFZOG4_{`U(H9GL6MR](https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![四通转接头](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)\n\n  - 气动调节阀\n\n  ![气动调节阀](https://picst.sunbangyan.cn/2023/11/29/8704c328c58619d6fb920f54f5bf54f2.jpeg)\n\n  - 稳压阀\n\n  ![稳压阀](https://picst.sunbangyan.cn/2023/11/29/9f9500dda6401faee73322dc803ee935.jpeg)\n\n- 以上就是电气路设计的全过程，这里面的经验成分居多，需要不断的实操，不断的学习，才能够更深的掌握气动方面的知识\n","slug":"20231204ZYY-电气路设计","published":1,"updated":"2024-07-31T03:32:37.888Z","_id":"clz9aaxqa000cygfb5imo9s6d","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"电气路控制设计\"><a href=\"#电气路控制设计\" class=\"headerlink\" title=\"电气路控制设计\"></a>电气路控制设计</h1><ul>\n<li><strong>一个简单的气动控制一共分为四大步：</strong><ul>\n<li>第一步是进行<strong>气路仿真</strong>，然后确定气路控制的逻辑性；</li>\n<li>第二步<strong>编写控制程序</strong>，将气路仿真得出的逻辑结果以控制代码的形式进行书写；</li>\n<li>第三步<strong>设计气路控制板</strong>，因为很多电磁阀根本无法直接通过单片机进行驱动，因此我们需要借助外部电源的力量，就需要制作外围电路，来完成小马拉大车的效果；</li>\n<li>第四步进行实际的<strong>气路连接并控制</strong>，连线的话就需要根据之前的仿真图来进行气路的连线，测试当然也是要基于第二步的控制代码来进行；</li>\n</ul>\n</li>\n<li>所以要想做好一个完整的气路控制，这四步少一步不行，不要因为很麻烦而去省略其中一步，当你在排查气路问题的时候，会让你抓狂的</li>\n</ul>\n<h2 id=\"1-设计需求假设\"><a href=\"#1-设计需求假设\" class=\"headerlink\" title=\"1.设计需求假设\"></a>1.设计需求假设</h2><ul>\n<li>示例：现在要设计一个机械臂的抬升，使用了一个双作用气缸，该气缸能够通过控制实现伸长和收缩</li>\n</ul>\n<h2 id=\"2-气路仿真\"><a href=\"#2-气路仿真\" class=\"headerlink\" title=\"2.气路仿真\"></a>2.气路仿真</h2><ul>\n<li>气路仿真最好用的还是FuildSim，这款软件是费斯托公司提供用户进行气路仿真，用法简单，操作容易，因此我这边仿真都是采用了这个软件进行仿真</li>\n<li>构建仿真原理图，这个软件的详细操作请看<strong>FuildSim</strong>专栏帖子，这边不进行详细介绍，下面是我构建的简易气路图，这个气路图里面包含了1个双作用气缸，3个电磁阀，1个气泵，1个节流阀，节流阀的作用是控制气流量来控制气缸伸缩的用时，这里面<strong>我给电磁阀进行了编号，这个编号非常重要，而且后续接线以及编写代码，必须要按这个编号严格进行，减少错误，甚至后续测试的时候，必须在电磁阀上面贴上编号</strong></li>\n</ul>\n<p><img src=\"https://picss.sunbangyan.cn/2023/11/29/f271e8d8706ef9ac62eaab4025ec81f3.jpeg\" alt=\"气路图\"></p>\n<ul>\n<li><p>开始进行仿真，这次的目的是要实现一个双作用气缸的伸长和收缩控制，开始仿真后，得出控制顺序为：</p>\n<ul>\n<li>伸长：打开DCF3，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF3，归为所有电磁阀，达到伸长控制<strong>（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）</strong>；</li>\n</ul>\n<p><img src=\"https://picdm.sunbangyan.cn/2023/11/29/f3526be0094237b34f961ecf2d2b9e04.jpeg\" alt=\"气缸伸长\"></p>\n<ul>\n<li>缩回：打开DCF2，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF2，归为所有电磁阀，达到伸长控制<strong>（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）</strong>；</li>\n</ul>\n<p><img src=\"https://picst.sunbangyan.cn/2023/11/29/6b7f958fbe983a0f05d3e9c2ad4252c3.jpeg\" alt=\"气缸缩回\"></p>\n</li>\n<li><p>完成仿真，得出想要的结果，之后开始根据结果进行代码的设计</p>\n</li>\n</ul>\n<h2 id=\"3-代码设计\"><a href=\"#3-代码设计\" class=\"headerlink\" title=\"3.代码设计\"></a>3.代码设计</h2><ul>\n<li>代码设计采用最简单的Arduino控制，设计的过程也很简单，跟点灯一模一样，按照仿真的结果进行顺序点灯，即可达到效果</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-type\">int</span> DCF1=<span class=\"hljs-number\">5</span>;<br><span class=\"hljs-type\">int</span> DCF2=<span class=\"hljs-number\">6</span>;<br><span class=\"hljs-type\">int</span> DCF3=<span class=\"hljs-number\">7</span>;<br><span class=\"hljs-comment\">//引脚的定义根据实际连接电磁阀的需求来设计</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setup</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-built_in\">pinMode</span>(DCF1,<span class=\"hljs-literal\">OUTPUT</span>);<br>  <span class=\"hljs-built_in\">pinMode</span>(DCF2,<span class=\"hljs-literal\">OUTPUT</span>);<br>  <span class=\"hljs-built_in\">pinMode</span>(DCF3,<span class=\"hljs-literal\">OUTPUT</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">UP</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//气缸伸长（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF3,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<span class=\"hljs-comment\">//延时的目的防止电磁阀响应过快</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">5000</span>);<span class=\"hljs-comment\">//延时的目的为了能够控制进入气流量，达到控制位置效果</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF3,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Down</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//气缸缩短（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF2,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">5000</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF2,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">loop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-built_in\">UP</span>();<br>  <span class=\"hljs-built_in\">Down</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>这里面的代码逻辑是跟上面仿真的结果一样，因此环环相扣，不能因为怕麻烦，缺失了其中一个环节</li>\n</ul>\n<h2 id=\"4-电磁阀控制\"><a href=\"#4-电磁阀控制\" class=\"headerlink\" title=\"4.电磁阀控制\"></a>4.<a href=\"https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=36262310020&_u=t2g8gqc420ea\">电磁阀</a>控制</h2><ul>\n<li>因为目前所用的电磁阀基本都是12V和24V的，所以要想能够利用单片机的3.3V输出的话是不可能的，因此就需要用我们的单片机的3.3V搭配上一个只能开关NMOS管来实现小电压控制大电压的效果，当然这里面还需要进行外部高电压的接入，以下是我们会用到的元器件以及他的功能<ul>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc49fb1&id=670446268383&spm=a1z09.2.0.0.32c42e8dCPUvWl\">ESP32</a>：</strong>这个最简单理解，我们代码的承载体，以及整个机器人控制的设备，为啥选择ESP32，因为他简单而且比Arduino小，还集成WIFI功能</li>\n<li><strong><a href=\"https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=672833563616&_u=t2g8gqc4b0ae\">24V&#x2F;12V电源</a>：</strong>一部分用于驱动电磁阀的通断，借助外部电源的电压来实现驱动，一部分用于ESP32的供电</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc495fe&id=582430989377&spm=a1z09.2.0.0.32c42e8dCPUvWl\">DC-DC降压模块</a>：</strong>利用输入的高电压，转为5V的稳压电源，供电给ESP32，来保证一个电源即可实现多种利用</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc44f16&id=14478416081&spm=a1z09.2.0.0.32c42e8dCPUvWl\">NMOS管（A3400）</a>：</strong>用来充当开关的作用，G极连接单片机引脚，用于接收信号来实现控制，D极连接24V&#x2F;12V电源的正极，S极连接接地端，来实现电路的导通</li>\n<li><strong><a href=\"https://item.taobao.com/item.htm?spm=a21n57.1.0.0.3d58523cFi5cOt&id=583531277832&ns=1&abbucket=19#detail\">光耦模块(LTV-247)</a>：</strong>利用光电隔离，实现高低电压的连接处隔离，防止大电流倒灌，损坏ESP32，光耦模块最好只用三组，四组的功率太大，容易损坏光耦模块，光耦模块的输出接地端，需要加一个保护电阻560欧，输出端也需要加一个保护电阻100K欧</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc49a07&id=13860351935&spm=a1z09.2.0.0.32c42e8dCPUvWl\">LED灯（0603）</a>：</strong>用来提示电源是否接入，需要添加一个保护电阻100K</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc4e83f&id=18691413288&spm=a1z09.2.0.0.32c42e8dCPUvWl\">船型开关</a>：</strong>用来开关控制电源的输入，减少插拔电源的麻烦</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc448e3&id=13300685584&spm=a1z09.2.0.0.32c42e8dCPUvWl\">快速插拔二端子（XH-2.54-2P）</a>：</strong>用来快速插拔电磁阀，能够实现电池阀的快速的接入</li>\n<li><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc4ad83&id=16520506238&spm=a1z09.2.0.0.32c42e8dCPUvWl\"><strong>DC插头母头（DC-005）</strong></a>：</li>\n</ul>\n</li>\n<li><strong>电路图请看目录下的QL-EDA.pdf文件</strong></li>\n<li>以上的是整体所需的元器件以及购买链接，正常来说都是以上的类型，然后需要注意一个问题，<strong>就是整个电路，必须低电压一个接地，高电压一个接地，不允许出现共地情况，防止出现烧坏的情况，整体电路，导通24V&#x2F;12V的PCB电路宽度不低于0.8mm，导通常规5V&#x2F;3.3V的电路宽度不低于0.5mm</strong></li>\n</ul>\n<h2 id=\"5-气路连接并控制\"><a href=\"#5-气路连接并控制\" class=\"headerlink\" title=\"5.气路连接并控制\"></a>5.气路连接并控制</h2><ul>\n<li><p>做到这一步的时候，基本上已经完成差不多了，这个时候只需要对照第一步进行连线，这边需要强调的是电磁阀的1、2、3口是具体指那几个口，图片会给予详细解答，请查看</p>\n<ul>\n<li>费斯托电磁阀（24V），具备高速开关能力</li>\n</ul>\n<p><img src=\"https://picdm.sunbangyan.cn/2023/11/29/2be07b3e5d478d569f147c98f91da10d.jpeg\" alt=\"费斯托电磁阀\"></p>\n<ul>\n<li>海德斯电磁阀（12V），小巧，但是不具备高速开关能力</li>\n</ul>\n<p><img src=\"https://picdm.sunbangyan.cn/2023/11/29/a611906e4e773fa55356787357dcf618.jpeg\" alt=\"海德斯电磁阀\"></p>\n<ul>\n<li>转接头，仅仅列举几个</li>\n</ul>\n<p>![TLTBHDFZOG4_{&#96;U(H9GL6MR](<a href=\"https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![%E5%9B%9B%E9%80%9A%E8%BD%AC%E6%8E%A5%E5%A4%B4](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)\">https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![四通转接头](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)</a></p>\n<ul>\n<li>气动调节阀</li>\n</ul>\n<p><img src=\"https://picst.sunbangyan.cn/2023/11/29/8704c328c58619d6fb920f54f5bf54f2.jpeg\" alt=\"气动调节阀\"></p>\n<ul>\n<li>稳压阀</li>\n</ul>\n<p><img src=\"https://picst.sunbangyan.cn/2023/11/29/9f9500dda6401faee73322dc803ee935.jpeg\" alt=\"稳压阀\"></p>\n</li>\n<li><p>以上就是电气路设计的全过程，这里面的经验成分居多，需要不断的实操，不断的学习，才能够更深的掌握气动方面的知识</p>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"电气路控制设计\"><a href=\"#电气路控制设计\" class=\"headerlink\" title=\"电气路控制设计\"></a>电气路控制设计</h1><ul>\n<li><strong>一个简单的气动控制一共分为四大步：</strong><ul>\n<li>第一步是进行<strong>气路仿真</strong>，然后确定气路控制的逻辑性；</li>\n<li>第二步<strong>编写控制程序</strong>，将气路仿真得出的逻辑结果以控制代码的形式进行书写；</li>\n<li>第三步<strong>设计气路控制板</strong>，因为很多电磁阀根本无法直接通过单片机进行驱动，因此我们需要借助外部电源的力量，就需要制作外围电路，来完成小马拉大车的效果；</li>\n<li>第四步进行实际的<strong>气路连接并控制</strong>，连线的话就需要根据之前的仿真图来进行气路的连线，测试当然也是要基于第二步的控制代码来进行；</li>\n</ul>\n</li>\n<li>所以要想做好一个完整的气路控制，这四步少一步不行，不要因为很麻烦而去省略其中一步，当你在排查气路问题的时候，会让你抓狂的</li>\n</ul>\n<h2 id=\"1-设计需求假设\"><a href=\"#1-设计需求假设\" class=\"headerlink\" title=\"1.设计需求假设\"></a>1.设计需求假设</h2><ul>\n<li>示例：现在要设计一个机械臂的抬升，使用了一个双作用气缸，该气缸能够通过控制实现伸长和收缩</li>\n</ul>\n<h2 id=\"2-气路仿真\"><a href=\"#2-气路仿真\" class=\"headerlink\" title=\"2.气路仿真\"></a>2.气路仿真</h2><ul>\n<li>气路仿真最好用的还是FuildSim，这款软件是费斯托公司提供用户进行气路仿真，用法简单，操作容易，因此我这边仿真都是采用了这个软件进行仿真</li>\n<li>构建仿真原理图，这个软件的详细操作请看<strong>FuildSim</strong>专栏帖子，这边不进行详细介绍，下面是我构建的简易气路图，这个气路图里面包含了1个双作用气缸，3个电磁阀，1个气泵，1个节流阀，节流阀的作用是控制气流量来控制气缸伸缩的用时，这里面<strong>我给电磁阀进行了编号，这个编号非常重要，而且后续接线以及编写代码，必须要按这个编号严格进行，减少错误，甚至后续测试的时候，必须在电磁阀上面贴上编号</strong></li>\n</ul>\n<p><img src=\"https://picss.sunbangyan.cn/2023/11/29/f271e8d8706ef9ac62eaab4025ec81f3.jpeg\" alt=\"气路图\"></p>\n<ul>\n<li><p>开始进行仿真，这次的目的是要实现一个双作用气缸的伸长和收缩控制，开始仿真后，得出控制顺序为：</p>\n<ul>\n<li>伸长：打开DCF3，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF3，归为所有电磁阀，达到伸长控制<strong>（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）</strong>；</li>\n</ul>\n<p><img src=\"https://picdm.sunbangyan.cn/2023/11/29/f3526be0094237b34f961ecf2d2b9e04.jpeg\" alt=\"气缸伸长\"></p>\n<ul>\n<li>缩回：打开DCF2，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF2，归为所有电磁阀，达到伸长控制<strong>（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）</strong>；</li>\n</ul>\n<p><img src=\"https://picst.sunbangyan.cn/2023/11/29/6b7f958fbe983a0f05d3e9c2ad4252c3.jpeg\" alt=\"气缸缩回\"></p>\n</li>\n<li><p>完成仿真，得出想要的结果，之后开始根据结果进行代码的设计</p>\n</li>\n</ul>\n<h2 id=\"3-代码设计\"><a href=\"#3-代码设计\" class=\"headerlink\" title=\"3.代码设计\"></a>3.代码设计</h2><ul>\n<li>代码设计采用最简单的Arduino控制，设计的过程也很简单，跟点灯一模一样，按照仿真的结果进行顺序点灯，即可达到效果</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-type\">int</span> DCF1=<span class=\"hljs-number\">5</span>;<br><span class=\"hljs-type\">int</span> DCF2=<span class=\"hljs-number\">6</span>;<br><span class=\"hljs-type\">int</span> DCF3=<span class=\"hljs-number\">7</span>;<br><span class=\"hljs-comment\">//引脚的定义根据实际连接电磁阀的需求来设计</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setup</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-built_in\">pinMode</span>(DCF1,<span class=\"hljs-literal\">OUTPUT</span>);<br>  <span class=\"hljs-built_in\">pinMode</span>(DCF2,<span class=\"hljs-literal\">OUTPUT</span>);<br>  <span class=\"hljs-built_in\">pinMode</span>(DCF3,<span class=\"hljs-literal\">OUTPUT</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">UP</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//气缸伸长（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF3,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<span class=\"hljs-comment\">//延时的目的防止电磁阀响应过快</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">5000</span>);<span class=\"hljs-comment\">//延时的目的为了能够控制进入气流量，达到控制位置效果</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF3,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Down</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//气缸缩短（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）</span><br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF2,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">HIGH</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">5000</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF1,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>  <span class=\"hljs-built_in\">digitalWrite</span>(DCF2,<span class=\"hljs-literal\">LOW</span>);<br>  <span class=\"hljs-built_in\">delay</span>(<span class=\"hljs-number\">100</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">loop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-built_in\">UP</span>();<br>  <span class=\"hljs-built_in\">Down</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>这里面的代码逻辑是跟上面仿真的结果一样，因此环环相扣，不能因为怕麻烦，缺失了其中一个环节</li>\n</ul>\n<h2 id=\"4-电磁阀控制\"><a href=\"#4-电磁阀控制\" class=\"headerlink\" title=\"4.电磁阀控制\"></a>4.<a href=\"https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=36262310020&_u=t2g8gqc420ea\">电磁阀</a>控制</h2><ul>\n<li>因为目前所用的电磁阀基本都是12V和24V的，所以要想能够利用单片机的3.3V输出的话是不可能的，因此就需要用我们的单片机的3.3V搭配上一个只能开关NMOS管来实现小电压控制大电压的效果，当然这里面还需要进行外部高电压的接入，以下是我们会用到的元器件以及他的功能<ul>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc49fb1&id=670446268383&spm=a1z09.2.0.0.32c42e8dCPUvWl\">ESP32</a>：</strong>这个最简单理解，我们代码的承载体，以及整个机器人控制的设备，为啥选择ESP32，因为他简单而且比Arduino小，还集成WIFI功能</li>\n<li><strong><a href=\"https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=672833563616&_u=t2g8gqc4b0ae\">24V&#x2F;12V电源</a>：</strong>一部分用于驱动电磁阀的通断，借助外部电源的电压来实现驱动，一部分用于ESP32的供电</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc495fe&id=582430989377&spm=a1z09.2.0.0.32c42e8dCPUvWl\">DC-DC降压模块</a>：</strong>利用输入的高电压，转为5V的稳压电源，供电给ESP32，来保证一个电源即可实现多种利用</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc44f16&id=14478416081&spm=a1z09.2.0.0.32c42e8dCPUvWl\">NMOS管（A3400）</a>：</strong>用来充当开关的作用，G极连接单片机引脚，用于接收信号来实现控制，D极连接24V&#x2F;12V电源的正极，S极连接接地端，来实现电路的导通</li>\n<li><strong><a href=\"https://item.taobao.com/item.htm?spm=a21n57.1.0.0.3d58523cFi5cOt&id=583531277832&ns=1&abbucket=19#detail\">光耦模块(LTV-247)</a>：</strong>利用光电隔离，实现高低电压的连接处隔离，防止大电流倒灌，损坏ESP32，光耦模块最好只用三组，四组的功率太大，容易损坏光耦模块，光耦模块的输出接地端，需要加一个保护电阻560欧，输出端也需要加一个保护电阻100K欧</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc49a07&id=13860351935&spm=a1z09.2.0.0.32c42e8dCPUvWl\">LED灯（0603）</a>：</strong>用来提示电源是否接入，需要添加一个保护电阻100K</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc4e83f&id=18691413288&spm=a1z09.2.0.0.32c42e8dCPUvWl\">船型开关</a>：</strong>用来开关控制电源的输入，减少插拔电源的麻烦</li>\n<li><strong><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc448e3&id=13300685584&spm=a1z09.2.0.0.32c42e8dCPUvWl\">快速插拔二端子（XH-2.54-2P）</a>：</strong>用来快速插拔电磁阀，能够实现电池阀的快速的接入</li>\n<li><a href=\"https://detail.tmall.com/item.htm?_u=t2g8gqc4ad83&id=16520506238&spm=a1z09.2.0.0.32c42e8dCPUvWl\"><strong>DC插头母头（DC-005）</strong></a>：</li>\n</ul>\n</li>\n<li><strong>电路图请看目录下的QL-EDA.pdf文件</strong></li>\n<li>以上的是整体所需的元器件以及购买链接，正常来说都是以上的类型，然后需要注意一个问题，<strong>就是整个电路，必须低电压一个接地，高电压一个接地，不允许出现共地情况，防止出现烧坏的情况，整体电路，导通24V&#x2F;12V的PCB电路宽度不低于0.8mm，导通常规5V&#x2F;3.3V的电路宽度不低于0.5mm</strong></li>\n</ul>\n<h2 id=\"5-气路连接并控制\"><a href=\"#5-气路连接并控制\" class=\"headerlink\" title=\"5.气路连接并控制\"></a>5.气路连接并控制</h2><ul>\n<li><p>做到这一步的时候，基本上已经完成差不多了，这个时候只需要对照第一步进行连线，这边需要强调的是电磁阀的1、2、3口是具体指那几个口，图片会给予详细解答，请查看</p>\n<ul>\n<li>费斯托电磁阀（24V），具备高速开关能力</li>\n</ul>\n<p><img src=\"https://picdm.sunbangyan.cn/2023/11/29/2be07b3e5d478d569f147c98f91da10d.jpeg\" alt=\"费斯托电磁阀\"></p>\n<ul>\n<li>海德斯电磁阀（12V），小巧，但是不具备高速开关能力</li>\n</ul>\n<p><img src=\"https://picdm.sunbangyan.cn/2023/11/29/a611906e4e773fa55356787357dcf618.jpeg\" alt=\"海德斯电磁阀\"></p>\n<ul>\n<li>转接头，仅仅列举几个</li>\n</ul>\n<p>![TLTBHDFZOG4_{&#96;U(H9GL6MR](<a href=\"https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![%E5%9B%9B%E9%80%9A%E8%BD%AC%E6%8E%A5%E5%A4%B4](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)\">https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![四通转接头](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)</a></p>\n<ul>\n<li>气动调节阀</li>\n</ul>\n<p><img src=\"https://picst.sunbangyan.cn/2023/11/29/8704c328c58619d6fb920f54f5bf54f2.jpeg\" alt=\"气动调节阀\"></p>\n<ul>\n<li>稳压阀</li>\n</ul>\n<p><img src=\"https://picst.sunbangyan.cn/2023/11/29/9f9500dda6401faee73322dc803ee935.jpeg\" alt=\"稳压阀\"></p>\n</li>\n<li><p>以上就是电气路设计的全过程，这里面的经验成分居多，需要不断的实操，不断的学习，才能够更深的掌握气动方面的知识</p>\n</li>\n</ul>\n"},{"title":"如何制作一份优秀的路演PPT","date":"2023-11-09T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/Oake2DnwAKftYhR.jpg","_content":"\n# 如何制作一份优秀的路演PPT\n\n### 1.PPT的基本思路\n\n- #### **这个比赛的定位**\n\n  - 商业比赛还是创新比赛，这两个是完全不一样的思路和逻辑，不能什么比赛都同一份PPT，需要根据评委的胃口来选择\n  - **评分细则，一定一定一定要详读评分细则，因为只有详细的阅读评分细则之后，你才能嗅到这个比赛的侧重点是啥，你的PPT必须要紧贴这个比赛的侧重点，评分细则的每一个字都要想清楚它在我们PPT里面如何体现**\n  - 如果是商业比赛，技术含量要降到4-5页，因为评委听不懂你讲的任何技术，要把技术转化成服务，**总结来说就是，你的产品能提供啥服务，能给用户提供啥功能，这些功能有啥用，效果咋样，咋卖钱，商业比赛要讲赚钱，怎么用最低的成本赚最多的钱**\n  - 如果是创新比赛，几乎都是技术讲解，因为评委是专家，他要看你这个项目的新意、创意，跟国内外比起来，你们项目新奇在哪里，技术点突破在哪里，突破的效果怎么样，**总结来说就是，你的项目创新点在哪，技术突破情况咋样，创新比赛要讲学术，你的理论基础、技术基础如何突破，偏学术**\n\n- #### **解决的社会痛点是啥**\n\n  - **项目背景：**你这个项目的起源是啥，为啥要做这个项目，做他的目的是啥，其中**重点是：讲清楚、跟随政策、量化数据、提供依据，明确方向**，但是切忌，项目的背景不要脱离实际，不要太离谱，比如郑州某大学想要自己研发光刻机，这只会给别人觉得你在骗人，但是也别出现太泛的情况，比如想要研发一种设备能够治疗所有疾病，没有针对点，没有细分领域。\n  - **社会痛点：**讲完你的项目起源，就要开始说清楚目前市面上的痛点是啥，这个痛点痛不痛，不要解决一个可有可无的社会痛点，那别人凭什么为你买单，**这个痛点要讲的很透彻，就是一下子让别人感觉，你这个项目想法很好，新意很好**\n- #### **你的解决方案**\n\n  - **项目概述：**第一时间告诉所有评委，针对这个痛点问题，你的完整解决方案是什么，**如果是商业比赛，第一时间要告诉评委，你能提供什么服务**，比如提供康复训练服务和康复评估服务，**如果是创新比赛，第一时间要告诉评委你这个项目的整体情况，以及你的创新点**，你的与众不同点在哪，比如采用柔顺康复、采用多模态康复评估等等，不同的比赛需要不同的方式\n  - 解决方案的整体介绍的方式有挺多种的，**偏向商业的就直接展示你这个产品**，然后告诉他们，这个产品有啥用，有哪些功能，**偏向创新的就需要展示这个项目整套技术流程**，技术流程里面的创新点如何体现，**这一部分是整个PPT的核心，需要非常精准有效的让别人第一时间知道你在做什么，你做的东西是啥，概括性很强，整体性很强，这里面不是简单把所有东西凑一起说，而是应该以一个整体思维，把每一个部分串联起来，介绍一个整体的东西**\n\n- #### **怎么证明你的方案比别人好**\n\n  - **项目技术突破：**这部分就是讲你的技术有多牛逼，这块偏向现有技术，但是你的技术比别人精度更高、效果更好等等，但是也一定要注意，**商业比赛不要讲很深的理论**，评委听不懂，你要用他听得懂的话语去讲最牛逼的事，**创新比赛也不能讲的太底层**，不然评委老师会困，要讲新的点，吸引住他们的点，这里面**必须要图文并茂，用实际成果证明你的数据可靠，用数据证明你牛逼**\n  - **项目新思路：**项目的新思路是另一个方面，就是别人走常规的道路，而你却实现弯道超车，用**更简单的思路解决问题**，类似这种的话一般会很感兴趣，而且**新思路的话不一定要做的很深，但是要说明你这个思路是实际可靠的，而不是天马行空**\n  - **竞品分析：**这个也是很好证明你比别人厉害的，同类型对比，你功能比他们多，价格比他们低等等，都会是你产品的优势，商业方面的话就讲功能、服务、价格优势，创新方面的话就讲技术突破、思路突破、效率等等，但是**切忌不要吹太过分了，到时候用很低的价格，然后功能却比别人强很多，大家都不是傻子，难道只有你想得到，所以一旦太过分了，就变得很假了**\n\n- #### **你的产品怎么卖**\n\n  - **产品市场：这个就告诉别人，你这个行业赚不赚钱，**如果行业很小，有可能投入都比你产出还大，那就没啥意义了，如果行业超级大，那会不会竞争对手也非常多，那你怎么脱颖而出，分析市场**主要就是告诉评委，我给你画的饼有多大，心不心动**\n  - **商业逻辑：很简单的道理，你怎么赚到别人的钱**，要考虑成本多少、客户是谁、供应商是谁、合作对象是谁、销售渠道有哪些、能提供哪些盈利服务、短期怎么推广、中期怎么推广、长期怎么推广、怎么打造产品的品牌效益等等，**要真实考虑到卖东西的各个方面，越详细越深入越好，而且要形成一个闭环，丢掉学生思维，转向商人思维，把自己当成一个老板，这个产品怎么进行打造**，可以学习国内外知名企业的商业逻辑，赚设备费用还是赚服务费用还是其他更新颖的赚钱思路\n  - **商业创新：**这块是一个能够脱颖而出的地方，商业也是有创新点的，**很多产品能够发家致富，产品的创新点反而是其次，更重要的是营销手段，商业创新**，比如共享单车、跑腿服务等等，这些都是纯靠商业模式活下来，技术根本不是核心，商业创新也有很多方面，比如我们有哪些独特优势、哪些特有资源，怎么利用这些去突围，我们常说的产学研合作就是这里面的一个创新，只不过太老了，还有产品生态，像小米或者苹果，他们其实不是卖手机，而是买一个能够买他们设备的设备而已，构建一套全生态，这样能够不断地、长期的盈利，所以，**我们可以想想，我们怎么卖得更好**\n\n### 2.PPT的基本框架\n\n- **常规的商业PPT主要包含这几大方面**\n  - 1.解决的社会痛点是啥：**项目背景、市场痛点**\n  - 2.你的解决方案：**项目简介、技术架构**\n  - 3.怎么证明你的方案比别人好：**项目创新点（一般都是3点，最多不超过4点），竞品分析**\n  - 4.你的产品怎么卖：**商业模式、成本分析、营销模式、客户对象、盈利预测、产品生态**\n  - 5.证明价值：**测试情况、落地情况、社会报道、商业合作、专家点评、知识产权、论文支撑、行业标准**等等\n  - 6.团队合作：**指导老师团队、开发团队**\n\n### 3.PPT制作过程中的细节\n\n- **配色正常**，不要太晃眼睛，**最好三配色，全文基本就三种颜色（推荐的是白色背景搭配藏蓝色、红色，重点部分用红色突出，暗系背景搭配白色和亮黄色，重点部分用亮黄色突出）**，不然会感觉花里胡哨的，字体一定不要全文太亮、或者全文太暗，遇到重点或者你想要强调的地方，一定用亮色突出，让别人第一目光就聚焦到你想要让他看的地方，**学会管理评委的目光**\n- **微软雅黑字体，最好都采用微软雅黑加粗，字体厚实，观看清晰，不会给人感觉看不清、或者太乱、太细**，楷体宋体都不好看，太细，给人感觉弱不禁风的样子\n- **背景配色**，**不要纯白背景、最好背景后面有点很淡的一些东西，感觉不是很空**，米白色会更好看，也不要纯黑背景，太黑暗，给人非常压抑，**如果想要偏暗系背景的话，采用藏蓝色然后搞一个黑色透明套上去**，我会提供几个背景模板\n- **方块**，PPT常用的就是各种方块，**方块一定一定一定要无边框，不然非常的难看**，想要在边框里面加上自己想要的字体，**不建议新建文本框，而是直接在方块里面编辑，不然后续想改的时候会非常麻烦，非常的累**\n- **设计器**，微软的PPT自带设计器，有时候能够解决你非常多的麻烦，又好看又快速\n- **图片版PPT，一定不要另存出来图片版，图片的质量非常的差，一定要一页一页播放，截图，然后粘贴在新的PPT里面**，遇到动图的时候，直接复制过去就行，如果遇到覆盖的时候，就做两页或者更多页\n- **切换方式，不要任何切换方式，所有PPT都不要任何切换方式**，评委会头晕，看的真的非常晕，而且而且，遇到垃圾电脑，你的动画会比老太太还慢，会出现各种bug，如果是线上的话，直接死亡，你觉得很快速，但是网速延迟非常高，别人那边就是一卡一卡的，印象分非常低","source":"_posts/20231204ZYY-如何制作一份优秀的路演PPT.md","raw":"---\ntitle: 如何制作一份优秀的路演PPT\ntag: PPT\ndate: 2023-11-10\ncategories: 路演文书\nindex_img: https://s2.loli.net/2024/07/31/Oake2DnwAKftYhR.jpg\n---\n\n# 如何制作一份优秀的路演PPT\n\n### 1.PPT的基本思路\n\n- #### **这个比赛的定位**\n\n  - 商业比赛还是创新比赛，这两个是完全不一样的思路和逻辑，不能什么比赛都同一份PPT，需要根据评委的胃口来选择\n  - **评分细则，一定一定一定要详读评分细则，因为只有详细的阅读评分细则之后，你才能嗅到这个比赛的侧重点是啥，你的PPT必须要紧贴这个比赛的侧重点，评分细则的每一个字都要想清楚它在我们PPT里面如何体现**\n  - 如果是商业比赛，技术含量要降到4-5页，因为评委听不懂你讲的任何技术，要把技术转化成服务，**总结来说就是，你的产品能提供啥服务，能给用户提供啥功能，这些功能有啥用，效果咋样，咋卖钱，商业比赛要讲赚钱，怎么用最低的成本赚最多的钱**\n  - 如果是创新比赛，几乎都是技术讲解，因为评委是专家，他要看你这个项目的新意、创意，跟国内外比起来，你们项目新奇在哪里，技术点突破在哪里，突破的效果怎么样，**总结来说就是，你的项目创新点在哪，技术突破情况咋样，创新比赛要讲学术，你的理论基础、技术基础如何突破，偏学术**\n\n- #### **解决的社会痛点是啥**\n\n  - **项目背景：**你这个项目的起源是啥，为啥要做这个项目，做他的目的是啥，其中**重点是：讲清楚、跟随政策、量化数据、提供依据，明确方向**，但是切忌，项目的背景不要脱离实际，不要太离谱，比如郑州某大学想要自己研发光刻机，这只会给别人觉得你在骗人，但是也别出现太泛的情况，比如想要研发一种设备能够治疗所有疾病，没有针对点，没有细分领域。\n  - **社会痛点：**讲完你的项目起源，就要开始说清楚目前市面上的痛点是啥，这个痛点痛不痛，不要解决一个可有可无的社会痛点，那别人凭什么为你买单，**这个痛点要讲的很透彻，就是一下子让别人感觉，你这个项目想法很好，新意很好**\n- #### **你的解决方案**\n\n  - **项目概述：**第一时间告诉所有评委，针对这个痛点问题，你的完整解决方案是什么，**如果是商业比赛，第一时间要告诉评委，你能提供什么服务**，比如提供康复训练服务和康复评估服务，**如果是创新比赛，第一时间要告诉评委你这个项目的整体情况，以及你的创新点**，你的与众不同点在哪，比如采用柔顺康复、采用多模态康复评估等等，不同的比赛需要不同的方式\n  - 解决方案的整体介绍的方式有挺多种的，**偏向商业的就直接展示你这个产品**，然后告诉他们，这个产品有啥用，有哪些功能，**偏向创新的就需要展示这个项目整套技术流程**，技术流程里面的创新点如何体现，**这一部分是整个PPT的核心，需要非常精准有效的让别人第一时间知道你在做什么，你做的东西是啥，概括性很强，整体性很强，这里面不是简单把所有东西凑一起说，而是应该以一个整体思维，把每一个部分串联起来，介绍一个整体的东西**\n\n- #### **怎么证明你的方案比别人好**\n\n  - **项目技术突破：**这部分就是讲你的技术有多牛逼，这块偏向现有技术，但是你的技术比别人精度更高、效果更好等等，但是也一定要注意，**商业比赛不要讲很深的理论**，评委听不懂，你要用他听得懂的话语去讲最牛逼的事，**创新比赛也不能讲的太底层**，不然评委老师会困，要讲新的点，吸引住他们的点，这里面**必须要图文并茂，用实际成果证明你的数据可靠，用数据证明你牛逼**\n  - **项目新思路：**项目的新思路是另一个方面，就是别人走常规的道路，而你却实现弯道超车，用**更简单的思路解决问题**，类似这种的话一般会很感兴趣，而且**新思路的话不一定要做的很深，但是要说明你这个思路是实际可靠的，而不是天马行空**\n  - **竞品分析：**这个也是很好证明你比别人厉害的，同类型对比，你功能比他们多，价格比他们低等等，都会是你产品的优势，商业方面的话就讲功能、服务、价格优势，创新方面的话就讲技术突破、思路突破、效率等等，但是**切忌不要吹太过分了，到时候用很低的价格，然后功能却比别人强很多，大家都不是傻子，难道只有你想得到，所以一旦太过分了，就变得很假了**\n\n- #### **你的产品怎么卖**\n\n  - **产品市场：这个就告诉别人，你这个行业赚不赚钱，**如果行业很小，有可能投入都比你产出还大，那就没啥意义了，如果行业超级大，那会不会竞争对手也非常多，那你怎么脱颖而出，分析市场**主要就是告诉评委，我给你画的饼有多大，心不心动**\n  - **商业逻辑：很简单的道理，你怎么赚到别人的钱**，要考虑成本多少、客户是谁、供应商是谁、合作对象是谁、销售渠道有哪些、能提供哪些盈利服务、短期怎么推广、中期怎么推广、长期怎么推广、怎么打造产品的品牌效益等等，**要真实考虑到卖东西的各个方面，越详细越深入越好，而且要形成一个闭环，丢掉学生思维，转向商人思维，把自己当成一个老板，这个产品怎么进行打造**，可以学习国内外知名企业的商业逻辑，赚设备费用还是赚服务费用还是其他更新颖的赚钱思路\n  - **商业创新：**这块是一个能够脱颖而出的地方，商业也是有创新点的，**很多产品能够发家致富，产品的创新点反而是其次，更重要的是营销手段，商业创新**，比如共享单车、跑腿服务等等，这些都是纯靠商业模式活下来，技术根本不是核心，商业创新也有很多方面，比如我们有哪些独特优势、哪些特有资源，怎么利用这些去突围，我们常说的产学研合作就是这里面的一个创新，只不过太老了，还有产品生态，像小米或者苹果，他们其实不是卖手机，而是买一个能够买他们设备的设备而已，构建一套全生态，这样能够不断地、长期的盈利，所以，**我们可以想想，我们怎么卖得更好**\n\n### 2.PPT的基本框架\n\n- **常规的商业PPT主要包含这几大方面**\n  - 1.解决的社会痛点是啥：**项目背景、市场痛点**\n  - 2.你的解决方案：**项目简介、技术架构**\n  - 3.怎么证明你的方案比别人好：**项目创新点（一般都是3点，最多不超过4点），竞品分析**\n  - 4.你的产品怎么卖：**商业模式、成本分析、营销模式、客户对象、盈利预测、产品生态**\n  - 5.证明价值：**测试情况、落地情况、社会报道、商业合作、专家点评、知识产权、论文支撑、行业标准**等等\n  - 6.团队合作：**指导老师团队、开发团队**\n\n### 3.PPT制作过程中的细节\n\n- **配色正常**，不要太晃眼睛，**最好三配色，全文基本就三种颜色（推荐的是白色背景搭配藏蓝色、红色，重点部分用红色突出，暗系背景搭配白色和亮黄色，重点部分用亮黄色突出）**，不然会感觉花里胡哨的，字体一定不要全文太亮、或者全文太暗，遇到重点或者你想要强调的地方，一定用亮色突出，让别人第一目光就聚焦到你想要让他看的地方，**学会管理评委的目光**\n- **微软雅黑字体，最好都采用微软雅黑加粗，字体厚实，观看清晰，不会给人感觉看不清、或者太乱、太细**，楷体宋体都不好看，太细，给人感觉弱不禁风的样子\n- **背景配色**，**不要纯白背景、最好背景后面有点很淡的一些东西，感觉不是很空**，米白色会更好看，也不要纯黑背景，太黑暗，给人非常压抑，**如果想要偏暗系背景的话，采用藏蓝色然后搞一个黑色透明套上去**，我会提供几个背景模板\n- **方块**，PPT常用的就是各种方块，**方块一定一定一定要无边框，不然非常的难看**，想要在边框里面加上自己想要的字体，**不建议新建文本框，而是直接在方块里面编辑，不然后续想改的时候会非常麻烦，非常的累**\n- **设计器**，微软的PPT自带设计器，有时候能够解决你非常多的麻烦，又好看又快速\n- **图片版PPT，一定不要另存出来图片版，图片的质量非常的差，一定要一页一页播放，截图，然后粘贴在新的PPT里面**，遇到动图的时候，直接复制过去就行，如果遇到覆盖的时候，就做两页或者更多页\n- **切换方式，不要任何切换方式，所有PPT都不要任何切换方式**，评委会头晕，看的真的非常晕，而且而且，遇到垃圾电脑，你的动画会比老太太还慢，会出现各种bug，如果是线上的话，直接死亡，你觉得很快速，但是网速延迟非常高，别人那边就是一卡一卡的，印象分非常低","slug":"20231204ZYY-如何制作一份优秀的路演PPT","published":1,"updated":"2024-07-31T03:32:32.669Z","_id":"clz9aaxqa000gygfb0bl52r8x","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"如何制作一份优秀的路演PPT\"><a href=\"#如何制作一份优秀的路演PPT\" class=\"headerlink\" title=\"如何制作一份优秀的路演PPT\"></a>如何制作一份优秀的路演PPT</h1><h3 id=\"1-PPT的基本思路\"><a href=\"#1-PPT的基本思路\" class=\"headerlink\" title=\"1.PPT的基本思路\"></a>1.PPT的基本思路</h3><ul>\n<li><h4 id=\"这个比赛的定位\"><a href=\"#这个比赛的定位\" class=\"headerlink\" title=\"这个比赛的定位\"></a><strong>这个比赛的定位</strong></h4><ul>\n<li>商业比赛还是创新比赛，这两个是完全不一样的思路和逻辑，不能什么比赛都同一份PPT，需要根据评委的胃口来选择</li>\n<li><strong>评分细则，一定一定一定要详读评分细则，因为只有详细的阅读评分细则之后，你才能嗅到这个比赛的侧重点是啥，你的PPT必须要紧贴这个比赛的侧重点，评分细则的每一个字都要想清楚它在我们PPT里面如何体现</strong></li>\n<li>如果是商业比赛，技术含量要降到4-5页，因为评委听不懂你讲的任何技术，要把技术转化成服务，<strong>总结来说就是，你的产品能提供啥服务，能给用户提供啥功能，这些功能有啥用，效果咋样，咋卖钱，商业比赛要讲赚钱，怎么用最低的成本赚最多的钱</strong></li>\n<li>如果是创新比赛，几乎都是技术讲解，因为评委是专家，他要看你这个项目的新意、创意，跟国内外比起来，你们项目新奇在哪里，技术点突破在哪里，突破的效果怎么样，<strong>总结来说就是，你的项目创新点在哪，技术突破情况咋样，创新比赛要讲学术，你的理论基础、技术基础如何突破，偏学术</strong></li>\n</ul>\n</li>\n<li><h4 id=\"解决的社会痛点是啥\"><a href=\"#解决的社会痛点是啥\" class=\"headerlink\" title=\"解决的社会痛点是啥\"></a><strong>解决的社会痛点是啥</strong></h4><ul>\n<li><strong>项目背景：</strong>你这个项目的起源是啥，为啥要做这个项目，做他的目的是啥，其中<strong>重点是：讲清楚、跟随政策、量化数据、提供依据，明确方向</strong>，但是切忌，项目的背景不要脱离实际，不要太离谱，比如郑州某大学想要自己研发光刻机，这只会给别人觉得你在骗人，但是也别出现太泛的情况，比如想要研发一种设备能够治疗所有疾病，没有针对点，没有细分领域。</li>\n<li><strong>社会痛点：</strong>讲完你的项目起源，就要开始说清楚目前市面上的痛点是啥，这个痛点痛不痛，不要解决一个可有可无的社会痛点，那别人凭什么为你买单，<strong>这个痛点要讲的很透彻，就是一下子让别人感觉，你这个项目想法很好，新意很好</strong></li>\n</ul>\n</li>\n<li><h4 id=\"你的解决方案\"><a href=\"#你的解决方案\" class=\"headerlink\" title=\"你的解决方案\"></a><strong>你的解决方案</strong></h4><ul>\n<li><strong>项目概述：</strong>第一时间告诉所有评委，针对这个痛点问题，你的完整解决方案是什么，<strong>如果是商业比赛，第一时间要告诉评委，你能提供什么服务</strong>，比如提供康复训练服务和康复评估服务，<strong>如果是创新比赛，第一时间要告诉评委你这个项目的整体情况，以及你的创新点</strong>，你的与众不同点在哪，比如采用柔顺康复、采用多模态康复评估等等，不同的比赛需要不同的方式</li>\n<li>解决方案的整体介绍的方式有挺多种的，<strong>偏向商业的就直接展示你这个产品</strong>，然后告诉他们，这个产品有啥用，有哪些功能，<strong>偏向创新的就需要展示这个项目整套技术流程</strong>，技术流程里面的创新点如何体现，<strong>这一部分是整个PPT的核心，需要非常精准有效的让别人第一时间知道你在做什么，你做的东西是啥，概括性很强，整体性很强，这里面不是简单把所有东西凑一起说，而是应该以一个整体思维，把每一个部分串联起来，介绍一个整体的东西</strong></li>\n</ul>\n</li>\n<li><h4 id=\"怎么证明你的方案比别人好\"><a href=\"#怎么证明你的方案比别人好\" class=\"headerlink\" title=\"怎么证明你的方案比别人好\"></a><strong>怎么证明你的方案比别人好</strong></h4><ul>\n<li><strong>项目技术突破：</strong>这部分就是讲你的技术有多牛逼，这块偏向现有技术，但是你的技术比别人精度更高、效果更好等等，但是也一定要注意，<strong>商业比赛不要讲很深的理论</strong>，评委听不懂，你要用他听得懂的话语去讲最牛逼的事，<strong>创新比赛也不能讲的太底层</strong>，不然评委老师会困，要讲新的点，吸引住他们的点，这里面<strong>必须要图文并茂，用实际成果证明你的数据可靠，用数据证明你牛逼</strong></li>\n<li><strong>项目新思路：</strong>项目的新思路是另一个方面，就是别人走常规的道路，而你却实现弯道超车，用<strong>更简单的思路解决问题</strong>，类似这种的话一般会很感兴趣，而且<strong>新思路的话不一定要做的很深，但是要说明你这个思路是实际可靠的，而不是天马行空</strong></li>\n<li><strong>竞品分析：</strong>这个也是很好证明你比别人厉害的，同类型对比，你功能比他们多，价格比他们低等等，都会是你产品的优势，商业方面的话就讲功能、服务、价格优势，创新方面的话就讲技术突破、思路突破、效率等等，但是<strong>切忌不要吹太过分了，到时候用很低的价格，然后功能却比别人强很多，大家都不是傻子，难道只有你想得到，所以一旦太过分了，就变得很假了</strong></li>\n</ul>\n</li>\n<li><h4 id=\"你的产品怎么卖\"><a href=\"#你的产品怎么卖\" class=\"headerlink\" title=\"你的产品怎么卖\"></a><strong>你的产品怎么卖</strong></h4><ul>\n<li><strong>产品市场：这个就告诉别人，你这个行业赚不赚钱，</strong>如果行业很小，有可能投入都比你产出还大，那就没啥意义了，如果行业超级大，那会不会竞争对手也非常多，那你怎么脱颖而出，分析市场<strong>主要就是告诉评委，我给你画的饼有多大，心不心动</strong></li>\n<li><strong>商业逻辑：很简单的道理，你怎么赚到别人的钱</strong>，要考虑成本多少、客户是谁、供应商是谁、合作对象是谁、销售渠道有哪些、能提供哪些盈利服务、短期怎么推广、中期怎么推广、长期怎么推广、怎么打造产品的品牌效益等等，<strong>要真实考虑到卖东西的各个方面，越详细越深入越好，而且要形成一个闭环，丢掉学生思维，转向商人思维，把自己当成一个老板，这个产品怎么进行打造</strong>，可以学习国内外知名企业的商业逻辑，赚设备费用还是赚服务费用还是其他更新颖的赚钱思路</li>\n<li><strong>商业创新：</strong>这块是一个能够脱颖而出的地方，商业也是有创新点的，<strong>很多产品能够发家致富，产品的创新点反而是其次，更重要的是营销手段，商业创新</strong>，比如共享单车、跑腿服务等等，这些都是纯靠商业模式活下来，技术根本不是核心，商业创新也有很多方面，比如我们有哪些独特优势、哪些特有资源，怎么利用这些去突围，我们常说的产学研合作就是这里面的一个创新，只不过太老了，还有产品生态，像小米或者苹果，他们其实不是卖手机，而是买一个能够买他们设备的设备而已，构建一套全生态，这样能够不断地、长期的盈利，所以，<strong>我们可以想想，我们怎么卖得更好</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-PPT的基本框架\"><a href=\"#2-PPT的基本框架\" class=\"headerlink\" title=\"2.PPT的基本框架\"></a>2.PPT的基本框架</h3><ul>\n<li><strong>常规的商业PPT主要包含这几大方面</strong><ul>\n<li>1.解决的社会痛点是啥：<strong>项目背景、市场痛点</strong></li>\n<li>2.你的解决方案：<strong>项目简介、技术架构</strong></li>\n<li>3.怎么证明你的方案比别人好：<strong>项目创新点（一般都是3点，最多不超过4点），竞品分析</strong></li>\n<li>4.你的产品怎么卖：<strong>商业模式、成本分析、营销模式、客户对象、盈利预测、产品生态</strong></li>\n<li>5.证明价值：<strong>测试情况、落地情况、社会报道、商业合作、专家点评、知识产权、论文支撑、行业标准</strong>等等</li>\n<li>6.团队合作：<strong>指导老师团队、开发团队</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-PPT制作过程中的细节\"><a href=\"#3-PPT制作过程中的细节\" class=\"headerlink\" title=\"3.PPT制作过程中的细节\"></a>3.PPT制作过程中的细节</h3><ul>\n<li><strong>配色正常</strong>，不要太晃眼睛，<strong>最好三配色，全文基本就三种颜色（推荐的是白色背景搭配藏蓝色、红色，重点部分用红色突出，暗系背景搭配白色和亮黄色，重点部分用亮黄色突出）</strong>，不然会感觉花里胡哨的，字体一定不要全文太亮、或者全文太暗，遇到重点或者你想要强调的地方，一定用亮色突出，让别人第一目光就聚焦到你想要让他看的地方，<strong>学会管理评委的目光</strong></li>\n<li><strong>微软雅黑字体，最好都采用微软雅黑加粗，字体厚实，观看清晰，不会给人感觉看不清、或者太乱、太细</strong>，楷体宋体都不好看，太细，给人感觉弱不禁风的样子</li>\n<li><strong>背景配色</strong>，<strong>不要纯白背景、最好背景后面有点很淡的一些东西，感觉不是很空</strong>，米白色会更好看，也不要纯黑背景，太黑暗，给人非常压抑，<strong>如果想要偏暗系背景的话，采用藏蓝色然后搞一个黑色透明套上去</strong>，我会提供几个背景模板</li>\n<li><strong>方块</strong>，PPT常用的就是各种方块，<strong>方块一定一定一定要无边框，不然非常的难看</strong>，想要在边框里面加上自己想要的字体，<strong>不建议新建文本框，而是直接在方块里面编辑，不然后续想改的时候会非常麻烦，非常的累</strong></li>\n<li><strong>设计器</strong>，微软的PPT自带设计器，有时候能够解决你非常多的麻烦，又好看又快速</li>\n<li><strong>图片版PPT，一定不要另存出来图片版，图片的质量非常的差，一定要一页一页播放，截图，然后粘贴在新的PPT里面</strong>，遇到动图的时候，直接复制过去就行，如果遇到覆盖的时候，就做两页或者更多页</li>\n<li><strong>切换方式，不要任何切换方式，所有PPT都不要任何切换方式</strong>，评委会头晕，看的真的非常晕，而且而且，遇到垃圾电脑，你的动画会比老太太还慢，会出现各种bug，如果是线上的话，直接死亡，你觉得很快速，但是网速延迟非常高，别人那边就是一卡一卡的，印象分非常低</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"如何制作一份优秀的路演PPT\"><a href=\"#如何制作一份优秀的路演PPT\" class=\"headerlink\" title=\"如何制作一份优秀的路演PPT\"></a>如何制作一份优秀的路演PPT</h1><h3 id=\"1-PPT的基本思路\"><a href=\"#1-PPT的基本思路\" class=\"headerlink\" title=\"1.PPT的基本思路\"></a>1.PPT的基本思路</h3><ul>\n<li><h4 id=\"这个比赛的定位\"><a href=\"#这个比赛的定位\" class=\"headerlink\" title=\"这个比赛的定位\"></a><strong>这个比赛的定位</strong></h4><ul>\n<li>商业比赛还是创新比赛，这两个是完全不一样的思路和逻辑，不能什么比赛都同一份PPT，需要根据评委的胃口来选择</li>\n<li><strong>评分细则，一定一定一定要详读评分细则，因为只有详细的阅读评分细则之后，你才能嗅到这个比赛的侧重点是啥，你的PPT必须要紧贴这个比赛的侧重点，评分细则的每一个字都要想清楚它在我们PPT里面如何体现</strong></li>\n<li>如果是商业比赛，技术含量要降到4-5页，因为评委听不懂你讲的任何技术，要把技术转化成服务，<strong>总结来说就是，你的产品能提供啥服务，能给用户提供啥功能，这些功能有啥用，效果咋样，咋卖钱，商业比赛要讲赚钱，怎么用最低的成本赚最多的钱</strong></li>\n<li>如果是创新比赛，几乎都是技术讲解，因为评委是专家，他要看你这个项目的新意、创意，跟国内外比起来，你们项目新奇在哪里，技术点突破在哪里，突破的效果怎么样，<strong>总结来说就是，你的项目创新点在哪，技术突破情况咋样，创新比赛要讲学术，你的理论基础、技术基础如何突破，偏学术</strong></li>\n</ul>\n</li>\n<li><h4 id=\"解决的社会痛点是啥\"><a href=\"#解决的社会痛点是啥\" class=\"headerlink\" title=\"解决的社会痛点是啥\"></a><strong>解决的社会痛点是啥</strong></h4><ul>\n<li><strong>项目背景：</strong>你这个项目的起源是啥，为啥要做这个项目，做他的目的是啥，其中<strong>重点是：讲清楚、跟随政策、量化数据、提供依据，明确方向</strong>，但是切忌，项目的背景不要脱离实际，不要太离谱，比如郑州某大学想要自己研发光刻机，这只会给别人觉得你在骗人，但是也别出现太泛的情况，比如想要研发一种设备能够治疗所有疾病，没有针对点，没有细分领域。</li>\n<li><strong>社会痛点：</strong>讲完你的项目起源，就要开始说清楚目前市面上的痛点是啥，这个痛点痛不痛，不要解决一个可有可无的社会痛点，那别人凭什么为你买单，<strong>这个痛点要讲的很透彻，就是一下子让别人感觉，你这个项目想法很好，新意很好</strong></li>\n</ul>\n</li>\n<li><h4 id=\"你的解决方案\"><a href=\"#你的解决方案\" class=\"headerlink\" title=\"你的解决方案\"></a><strong>你的解决方案</strong></h4><ul>\n<li><strong>项目概述：</strong>第一时间告诉所有评委，针对这个痛点问题，你的完整解决方案是什么，<strong>如果是商业比赛，第一时间要告诉评委，你能提供什么服务</strong>，比如提供康复训练服务和康复评估服务，<strong>如果是创新比赛，第一时间要告诉评委你这个项目的整体情况，以及你的创新点</strong>，你的与众不同点在哪，比如采用柔顺康复、采用多模态康复评估等等，不同的比赛需要不同的方式</li>\n<li>解决方案的整体介绍的方式有挺多种的，<strong>偏向商业的就直接展示你这个产品</strong>，然后告诉他们，这个产品有啥用，有哪些功能，<strong>偏向创新的就需要展示这个项目整套技术流程</strong>，技术流程里面的创新点如何体现，<strong>这一部分是整个PPT的核心，需要非常精准有效的让别人第一时间知道你在做什么，你做的东西是啥，概括性很强，整体性很强，这里面不是简单把所有东西凑一起说，而是应该以一个整体思维，把每一个部分串联起来，介绍一个整体的东西</strong></li>\n</ul>\n</li>\n<li><h4 id=\"怎么证明你的方案比别人好\"><a href=\"#怎么证明你的方案比别人好\" class=\"headerlink\" title=\"怎么证明你的方案比别人好\"></a><strong>怎么证明你的方案比别人好</strong></h4><ul>\n<li><strong>项目技术突破：</strong>这部分就是讲你的技术有多牛逼，这块偏向现有技术，但是你的技术比别人精度更高、效果更好等等，但是也一定要注意，<strong>商业比赛不要讲很深的理论</strong>，评委听不懂，你要用他听得懂的话语去讲最牛逼的事，<strong>创新比赛也不能讲的太底层</strong>，不然评委老师会困，要讲新的点，吸引住他们的点，这里面<strong>必须要图文并茂，用实际成果证明你的数据可靠，用数据证明你牛逼</strong></li>\n<li><strong>项目新思路：</strong>项目的新思路是另一个方面，就是别人走常规的道路，而你却实现弯道超车，用<strong>更简单的思路解决问题</strong>，类似这种的话一般会很感兴趣，而且<strong>新思路的话不一定要做的很深，但是要说明你这个思路是实际可靠的，而不是天马行空</strong></li>\n<li><strong>竞品分析：</strong>这个也是很好证明你比别人厉害的，同类型对比，你功能比他们多，价格比他们低等等，都会是你产品的优势，商业方面的话就讲功能、服务、价格优势，创新方面的话就讲技术突破、思路突破、效率等等，但是<strong>切忌不要吹太过分了，到时候用很低的价格，然后功能却比别人强很多，大家都不是傻子，难道只有你想得到，所以一旦太过分了，就变得很假了</strong></li>\n</ul>\n</li>\n<li><h4 id=\"你的产品怎么卖\"><a href=\"#你的产品怎么卖\" class=\"headerlink\" title=\"你的产品怎么卖\"></a><strong>你的产品怎么卖</strong></h4><ul>\n<li><strong>产品市场：这个就告诉别人，你这个行业赚不赚钱，</strong>如果行业很小，有可能投入都比你产出还大，那就没啥意义了，如果行业超级大，那会不会竞争对手也非常多，那你怎么脱颖而出，分析市场<strong>主要就是告诉评委，我给你画的饼有多大，心不心动</strong></li>\n<li><strong>商业逻辑：很简单的道理，你怎么赚到别人的钱</strong>，要考虑成本多少、客户是谁、供应商是谁、合作对象是谁、销售渠道有哪些、能提供哪些盈利服务、短期怎么推广、中期怎么推广、长期怎么推广、怎么打造产品的品牌效益等等，<strong>要真实考虑到卖东西的各个方面，越详细越深入越好，而且要形成一个闭环，丢掉学生思维，转向商人思维，把自己当成一个老板，这个产品怎么进行打造</strong>，可以学习国内外知名企业的商业逻辑，赚设备费用还是赚服务费用还是其他更新颖的赚钱思路</li>\n<li><strong>商业创新：</strong>这块是一个能够脱颖而出的地方，商业也是有创新点的，<strong>很多产品能够发家致富，产品的创新点反而是其次，更重要的是营销手段，商业创新</strong>，比如共享单车、跑腿服务等等，这些都是纯靠商业模式活下来，技术根本不是核心，商业创新也有很多方面，比如我们有哪些独特优势、哪些特有资源，怎么利用这些去突围，我们常说的产学研合作就是这里面的一个创新，只不过太老了，还有产品生态，像小米或者苹果，他们其实不是卖手机，而是买一个能够买他们设备的设备而已，构建一套全生态，这样能够不断地、长期的盈利，所以，<strong>我们可以想想，我们怎么卖得更好</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-PPT的基本框架\"><a href=\"#2-PPT的基本框架\" class=\"headerlink\" title=\"2.PPT的基本框架\"></a>2.PPT的基本框架</h3><ul>\n<li><strong>常规的商业PPT主要包含这几大方面</strong><ul>\n<li>1.解决的社会痛点是啥：<strong>项目背景、市场痛点</strong></li>\n<li>2.你的解决方案：<strong>项目简介、技术架构</strong></li>\n<li>3.怎么证明你的方案比别人好：<strong>项目创新点（一般都是3点，最多不超过4点），竞品分析</strong></li>\n<li>4.你的产品怎么卖：<strong>商业模式、成本分析、营销模式、客户对象、盈利预测、产品生态</strong></li>\n<li>5.证明价值：<strong>测试情况、落地情况、社会报道、商业合作、专家点评、知识产权、论文支撑、行业标准</strong>等等</li>\n<li>6.团队合作：<strong>指导老师团队、开发团队</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-PPT制作过程中的细节\"><a href=\"#3-PPT制作过程中的细节\" class=\"headerlink\" title=\"3.PPT制作过程中的细节\"></a>3.PPT制作过程中的细节</h3><ul>\n<li><strong>配色正常</strong>，不要太晃眼睛，<strong>最好三配色，全文基本就三种颜色（推荐的是白色背景搭配藏蓝色、红色，重点部分用红色突出，暗系背景搭配白色和亮黄色，重点部分用亮黄色突出）</strong>，不然会感觉花里胡哨的，字体一定不要全文太亮、或者全文太暗，遇到重点或者你想要强调的地方，一定用亮色突出，让别人第一目光就聚焦到你想要让他看的地方，<strong>学会管理评委的目光</strong></li>\n<li><strong>微软雅黑字体，最好都采用微软雅黑加粗，字体厚实，观看清晰，不会给人感觉看不清、或者太乱、太细</strong>，楷体宋体都不好看，太细，给人感觉弱不禁风的样子</li>\n<li><strong>背景配色</strong>，<strong>不要纯白背景、最好背景后面有点很淡的一些东西，感觉不是很空</strong>，米白色会更好看，也不要纯黑背景，太黑暗，给人非常压抑，<strong>如果想要偏暗系背景的话，采用藏蓝色然后搞一个黑色透明套上去</strong>，我会提供几个背景模板</li>\n<li><strong>方块</strong>，PPT常用的就是各种方块，<strong>方块一定一定一定要无边框，不然非常的难看</strong>，想要在边框里面加上自己想要的字体，<strong>不建议新建文本框，而是直接在方块里面编辑，不然后续想改的时候会非常麻烦，非常的累</strong></li>\n<li><strong>设计器</strong>，微软的PPT自带设计器，有时候能够解决你非常多的麻烦，又好看又快速</li>\n<li><strong>图片版PPT，一定不要另存出来图片版，图片的质量非常的差，一定要一页一页播放，截图，然后粘贴在新的PPT里面</strong>，遇到动图的时候，直接复制过去就行，如果遇到覆盖的时候，就做两页或者更多页</li>\n<li><strong>切换方式，不要任何切换方式，所有PPT都不要任何切换方式</strong>，评委会头晕，看的真的非常晕，而且而且，遇到垃圾电脑，你的动画会比老太太还慢，会出现各种bug，如果是线上的话，直接死亡，你觉得很快速，但是网速延迟非常高，别人那边就是一卡一卡的，印象分非常低</li>\n</ul>\n"},{"title":"STM32的中断使用","date":"2024-07-22T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/sdm7t4HwkQf5xlP.jpg","_content":"\n# STM32的中断使用\n\n### 内部中断NVIC\n\n配置过程中，首先初始化 NVIC_InitTypeDef 结构体，配置内部中断线、配置中断优先级分组，设置抢占优先级和子优先级，使能中断请求，最后写入初始化结构体。\n\n在启动文件 startup_stm32f10x_hd.s 中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在 stm32f10x_it.c 这个库文件中。\n\nNVIC_IROChannel：用来设置中断源，不同的中断中断源不一样\n\n系统就在中断向量表中找不到中断服务函数的入口，直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。\n\nNVIC_PriorityGroupConfig 是整个程序中只需要设置一次，多次设置无效，他只是一种配置方式，具体的分类有主优先级和子优先级有关，他只是提供不同的组合方式，需要根据项目需求进行设计\n\n从代码布局逻辑来说,NVIC_PriorityGroupConfig 适合放在 main() 函数中。\n\n```\n\t//定义结构体\n\tNVIC_InitTypeDef  NVIC_InitStruct;\n\t\n\t//NVIC初始化\n\tNVIC_PriorityGroupConfig(NVIC_PriorityGroup);//配置组优先级（0，1，2，3，4，5）\n\tNVIC_InitStruct.NVIC_IRQChannel = KEY_INT_EXTI_IRQ;//配置内部中断线\n\tNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = PreemptionPriority;//配置抢占优先级\n\tNVIC_InitStruct.NVIC_IRQChannelSubPriority = SubPriority;//配置子优先级\n\tNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//使能中断通道\n\tNVIC_Init(&NVIC_InitStruct);//将结构体进行定义\n```\n\n### 外部中断EXTI\n\nEXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的 20 个中断/事件线。每个中断/事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。 EXTI 可以实现对每个中断/事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。\n\n所以EXTI的配置，首先需要中断结构体初始化、打开AFIO中断线管理器的时钟、配置中断/事件线（20条）、选择中断屏蔽器输入位，并使能、选择中断/事件触发类型、选择上升沿或下降沿检测，最后写入初始化结构体\n\n```\n//定义结构体\n\tGPIO_InitTypeDef  GPIO_InitStruct;\n\tEXTI_InitTypeDef  EXTI_InitStruct;\n\t\n\t//配置中断优先级\n\tEXTI_NVIC_Config();\n\t\n\t//按键引脚初始化\n\tRCC_APB2PeriphClockCmd(KEY_INT_GPIO_CLK, ENABLE);//打开按键时钟\n\tGPIO_InitStruct.GPIO_Pin = KEY_INT_GPIO_PIN;//按键引脚定义\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;//选择输入输出模式（浮空输入）\n\tGPIO_Init(KEY_INT_GPIO_PORT,&GPIO_InitStruct);//将结构体进行定义\n\t\n\t//中断配置初始化\n\tRCC_APB2PeriphClockCmd(KEY_INT_EXTI_CLK, ENABLE);//打开AFIO时钟\n\tGPIO_EXTILineConfig(KEY_INT_EXTI_PORTSOURCE, KEY_INT_EXTI_PINSOURCE);//产生中断的事件线（Px0属于Line0，Px1属于Line1...）\n\t\n\tEXTI_InitStruct.EXTI_Line = KEY_INT_EXTI_LINE;//中断屏蔽器输入位的选择，以供EXTI_LineCmd精准使能\n\tEXTI_InitStruct.EXTI_LineCmd = ENABLE;//中断屏蔽器使能（控制中断接受IMR/EMR）\n\tEXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;//选择触发类型（中断触发和事件触发）\n\tEXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;//选择模式（上升沿和下降沿）\n\tEXTI_Init(&EXTI_InitStruct);//将结构体进行定义\n```\n\n前面 4 个线路有单独的中断函数，后面 5 至 9 和 10 至 15 线路使用 复用的思想思考，区分出什么是可以唯一标识的，什么是复用的，EXTI_Lines 在寄存器中都是一一对应状态标位, 中断函数复用，**因此在 EXTI9_5_IRQHandler 和 EXTI15_10_IRQHandler 的中断函数里面使用多次EXTI_GetITStatus 函数来判断出线路。**  \n\n```\n\tif(EXTI_GetITStatus(EXTI_Line10) != RESET)\n\t{\n\t\tLED_TOGGLE;\n\t}\n\tif(EXTI_GetITStatus(EXTI_Line14) != RESET)\n\t{\n\t\tLED_TOGGLE;\n\t}\n```\n","source":"_posts/STM32的中断使用.md","raw":"---\ntitle: STM32的中断使用\ntag: 中断函数\ndate: 2024-07-23\ncategories: STM32\nindex_img: https://s2.loli.net/2024/07/31/sdm7t4HwkQf5xlP.jpg\n---\n\n# STM32的中断使用\n\n### 内部中断NVIC\n\n配置过程中，首先初始化 NVIC_InitTypeDef 结构体，配置内部中断线、配置中断优先级分组，设置抢占优先级和子优先级，使能中断请求，最后写入初始化结构体。\n\n在启动文件 startup_stm32f10x_hd.s 中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在 stm32f10x_it.c 这个库文件中。\n\nNVIC_IROChannel：用来设置中断源，不同的中断中断源不一样\n\n系统就在中断向量表中找不到中断服务函数的入口，直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。\n\nNVIC_PriorityGroupConfig 是整个程序中只需要设置一次，多次设置无效，他只是一种配置方式，具体的分类有主优先级和子优先级有关，他只是提供不同的组合方式，需要根据项目需求进行设计\n\n从代码布局逻辑来说,NVIC_PriorityGroupConfig 适合放在 main() 函数中。\n\n```\n\t//定义结构体\n\tNVIC_InitTypeDef  NVIC_InitStruct;\n\t\n\t//NVIC初始化\n\tNVIC_PriorityGroupConfig(NVIC_PriorityGroup);//配置组优先级（0，1，2，3，4，5）\n\tNVIC_InitStruct.NVIC_IRQChannel = KEY_INT_EXTI_IRQ;//配置内部中断线\n\tNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = PreemptionPriority;//配置抢占优先级\n\tNVIC_InitStruct.NVIC_IRQChannelSubPriority = SubPriority;//配置子优先级\n\tNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//使能中断通道\n\tNVIC_Init(&NVIC_InitStruct);//将结构体进行定义\n```\n\n### 外部中断EXTI\n\nEXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的 20 个中断/事件线。每个中断/事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。 EXTI 可以实现对每个中断/事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。\n\n所以EXTI的配置，首先需要中断结构体初始化、打开AFIO中断线管理器的时钟、配置中断/事件线（20条）、选择中断屏蔽器输入位，并使能、选择中断/事件触发类型、选择上升沿或下降沿检测，最后写入初始化结构体\n\n```\n//定义结构体\n\tGPIO_InitTypeDef  GPIO_InitStruct;\n\tEXTI_InitTypeDef  EXTI_InitStruct;\n\t\n\t//配置中断优先级\n\tEXTI_NVIC_Config();\n\t\n\t//按键引脚初始化\n\tRCC_APB2PeriphClockCmd(KEY_INT_GPIO_CLK, ENABLE);//打开按键时钟\n\tGPIO_InitStruct.GPIO_Pin = KEY_INT_GPIO_PIN;//按键引脚定义\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;//选择输入输出模式（浮空输入）\n\tGPIO_Init(KEY_INT_GPIO_PORT,&GPIO_InitStruct);//将结构体进行定义\n\t\n\t//中断配置初始化\n\tRCC_APB2PeriphClockCmd(KEY_INT_EXTI_CLK, ENABLE);//打开AFIO时钟\n\tGPIO_EXTILineConfig(KEY_INT_EXTI_PORTSOURCE, KEY_INT_EXTI_PINSOURCE);//产生中断的事件线（Px0属于Line0，Px1属于Line1...）\n\t\n\tEXTI_InitStruct.EXTI_Line = KEY_INT_EXTI_LINE;//中断屏蔽器输入位的选择，以供EXTI_LineCmd精准使能\n\tEXTI_InitStruct.EXTI_LineCmd = ENABLE;//中断屏蔽器使能（控制中断接受IMR/EMR）\n\tEXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;//选择触发类型（中断触发和事件触发）\n\tEXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;//选择模式（上升沿和下降沿）\n\tEXTI_Init(&EXTI_InitStruct);//将结构体进行定义\n```\n\n前面 4 个线路有单独的中断函数，后面 5 至 9 和 10 至 15 线路使用 复用的思想思考，区分出什么是可以唯一标识的，什么是复用的，EXTI_Lines 在寄存器中都是一一对应状态标位, 中断函数复用，**因此在 EXTI9_5_IRQHandler 和 EXTI15_10_IRQHandler 的中断函数里面使用多次EXTI_GetITStatus 函数来判断出线路。**  \n\n```\n\tif(EXTI_GetITStatus(EXTI_Line10) != RESET)\n\t{\n\t\tLED_TOGGLE;\n\t}\n\tif(EXTI_GetITStatus(EXTI_Line14) != RESET)\n\t{\n\t\tLED_TOGGLE;\n\t}\n```\n","slug":"STM32的中断使用","published":1,"updated":"2024-07-31T03:33:45.871Z","_id":"clz9aaxqb000iygfbhawhdwgo","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"STM32的中断使用\"><a href=\"#STM32的中断使用\" class=\"headerlink\" title=\"STM32的中断使用\"></a>STM32的中断使用</h1><h3 id=\"内部中断NVIC\"><a href=\"#内部中断NVIC\" class=\"headerlink\" title=\"内部中断NVIC\"></a>内部中断NVIC</h3><p>配置过程中，首先初始化 NVIC_InitTypeDef 结构体，配置内部中断线、配置中断优先级分组，设置抢占优先级和子优先级，使能中断请求，最后写入初始化结构体。</p>\n<p>在启动文件 startup_stm32f10x_hd.s 中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在 stm32f10x_it.c 这个库文件中。</p>\n<p>NVIC_IROChannel：用来设置中断源，不同的中断中断源不一样</p>\n<p>系统就在中断向量表中找不到中断服务函数的入口，直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。</p>\n<p>NVIC_PriorityGroupConfig 是整个程序中只需要设置一次，多次设置无效，他只是一种配置方式，具体的分类有主优先级和子优先级有关，他只是提供不同的组合方式，需要根据项目需求进行设计</p>\n<p>从代码布局逻辑来说,NVIC_PriorityGroupConfig 适合放在 main() 函数中。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//定义结构体</span><br>NVIC_InitTypeDef  NVIC_InitStruct<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//NVIC初始化</span><br>NVIC_PriorityGroupConfig<span class=\"hljs-punctuation\">(</span>NVIC_PriorityGroup<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置组优先级（0，1，2，3，4，5）</span><br>NVIC_InitStruct.NVIC_IRQChannel <span class=\"hljs-punctuation\">=</span> KEY_INT_EXTI_IRQ<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置内部中断线</span><br>NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority <span class=\"hljs-punctuation\">=</span> PreemptionPriority<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置抢占优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelSubPriority <span class=\"hljs-punctuation\">=</span> SubPriority<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置子优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelCmd <span class=\"hljs-punctuation\">=</span> ENABLE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//使能中断通道</span><br>NVIC_Init<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;NVIC_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"外部中断EXTI\"><a href=\"#外部中断EXTI\" class=\"headerlink\" title=\"外部中断EXTI\"></a>外部中断EXTI</h3><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。 EXTI 可以实现对每个中断&#x2F;事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。</p>\n<p>所以EXTI的配置，首先需要中断结构体初始化、打开AFIO中断线管理器的时钟、配置中断&#x2F;事件线（20条）、选择中断屏蔽器输入位，并使能、选择中断&#x2F;事件触发类型、选择上升沿或下降沿检测，最后写入初始化结构体</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//定义结构体</span><br>\tGPIO_InitTypeDef  GPIO_InitStruct<span class=\"hljs-punctuation\">;</span><br>\tEXTI_InitTypeDef  EXTI_InitStruct<span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//配置中断优先级</span><br>\tEXTI_NVIC_Config<span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//按键引脚初始化</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>KEY_INT_GPIO_CLK<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//打开按键时钟</span><br>\tGPIO_InitStruct.GPIO_Pin <span class=\"hljs-punctuation\">=</span> KEY_INT_GPIO_PIN<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//按键引脚定义</span><br>\tGPIO_InitStruct.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_IN_FLOATING<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//选择输入输出模式（浮空输入）</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>KEY_INT_GPIO_PORT<span class=\"hljs-punctuation\">,</span><span class=\"hljs-meta\">&amp;GPIO_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br>\t<br>\t<span class=\"hljs-comment\">//中断配置初始化</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>KEY_INT_EXTI_CLK<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//打开AFIO时钟</span><br>\tGPIO_EXTILineConfig<span class=\"hljs-punctuation\">(</span>KEY_INT_EXTI_PORTSOURCE<span class=\"hljs-punctuation\">,</span> KEY_INT_EXTI_PINSOURCE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//产生中断的事件线（Px0属于Line0，Px1属于Line1...）</span><br>\t<br>\tEXTI_InitStruct.EXTI_Line <span class=\"hljs-punctuation\">=</span> KEY_INT_EXTI_LINE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//中断屏蔽器输入位的选择，以供EXTI_LineCmd精准使能</span><br>\tEXTI_InitStruct.EXTI_LineCmd <span class=\"hljs-punctuation\">=</span> ENABLE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//中断屏蔽器使能（控制中断接受IMR/EMR）</span><br>\tEXTI_InitStruct.EXTI_Mode <span class=\"hljs-punctuation\">=</span> EXTI_Mode_Interrupt<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//选择触发类型（中断触发和事件触发）</span><br>\tEXTI_InitStruct.EXTI_Trigger <span class=\"hljs-punctuation\">=</span> EXTI_Trigger_Rising<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//选择模式（上升沿和下降沿）</span><br>\tEXTI_Init<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;EXTI_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<p>前面 4 个线路有单独的中断函数，后面 5 至 9 和 10 至 15 线路使用 复用的思想思考，区分出什么是可以唯一标识的，什么是复用的，EXTI_Lines 在寄存器中都是一一对应状态标位, 中断函数复用，<strong>因此在 EXTI9_5_IRQHandler 和 EXTI15_10_IRQHandler 的中断函数里面使用多次EXTI_GetITStatus 函数来判断出线路。</strong>  </p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">if(EXTI_GetITStatus(EXTI_Line10) != RESET)<br>&#123;<br>\tLED_TOGGLE;<br>&#125;<br>if(EXTI_GetITStatus(EXTI_Line14) != RESET)<br>&#123;<br>\tLED_TOGGLE;<br>&#125;<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"STM32的中断使用\"><a href=\"#STM32的中断使用\" class=\"headerlink\" title=\"STM32的中断使用\"></a>STM32的中断使用</h1><h3 id=\"内部中断NVIC\"><a href=\"#内部中断NVIC\" class=\"headerlink\" title=\"内部中断NVIC\"></a>内部中断NVIC</h3><p>配置过程中，首先初始化 NVIC_InitTypeDef 结构体，配置内部中断线、配置中断优先级分组，设置抢占优先级和子优先级，使能中断请求，最后写入初始化结构体。</p>\n<p>在启动文件 startup_stm32f10x_hd.s 中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在 stm32f10x_it.c 这个库文件中。</p>\n<p>NVIC_IROChannel：用来设置中断源，不同的中断中断源不一样</p>\n<p>系统就在中断向量表中找不到中断服务函数的入口，直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。</p>\n<p>NVIC_PriorityGroupConfig 是整个程序中只需要设置一次，多次设置无效，他只是一种配置方式，具体的分类有主优先级和子优先级有关，他只是提供不同的组合方式，需要根据项目需求进行设计</p>\n<p>从代码布局逻辑来说,NVIC_PriorityGroupConfig 适合放在 main() 函数中。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//定义结构体</span><br>NVIC_InitTypeDef  NVIC_InitStruct<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//NVIC初始化</span><br>NVIC_PriorityGroupConfig<span class=\"hljs-punctuation\">(</span>NVIC_PriorityGroup<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置组优先级（0，1，2，3，4，5）</span><br>NVIC_InitStruct.NVIC_IRQChannel <span class=\"hljs-punctuation\">=</span> KEY_INT_EXTI_IRQ<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置内部中断线</span><br>NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority <span class=\"hljs-punctuation\">=</span> PreemptionPriority<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置抢占优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelSubPriority <span class=\"hljs-punctuation\">=</span> SubPriority<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置子优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelCmd <span class=\"hljs-punctuation\">=</span> ENABLE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//使能中断通道</span><br>NVIC_Init<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;NVIC_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"外部中断EXTI\"><a href=\"#外部中断EXTI\" class=\"headerlink\" title=\"外部中断EXTI\"></a>外部中断EXTI</h3><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。 EXTI 可以实现对每个中断&#x2F;事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。</p>\n<p>所以EXTI的配置，首先需要中断结构体初始化、打开AFIO中断线管理器的时钟、配置中断&#x2F;事件线（20条）、选择中断屏蔽器输入位，并使能、选择中断&#x2F;事件触发类型、选择上升沿或下降沿检测，最后写入初始化结构体</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//定义结构体</span><br>\tGPIO_InitTypeDef  GPIO_InitStruct<span class=\"hljs-punctuation\">;</span><br>\tEXTI_InitTypeDef  EXTI_InitStruct<span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//配置中断优先级</span><br>\tEXTI_NVIC_Config<span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//按键引脚初始化</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>KEY_INT_GPIO_CLK<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//打开按键时钟</span><br>\tGPIO_InitStruct.GPIO_Pin <span class=\"hljs-punctuation\">=</span> KEY_INT_GPIO_PIN<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//按键引脚定义</span><br>\tGPIO_InitStruct.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_IN_FLOATING<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//选择输入输出模式（浮空输入）</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>KEY_INT_GPIO_PORT<span class=\"hljs-punctuation\">,</span><span class=\"hljs-meta\">&amp;GPIO_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br>\t<br>\t<span class=\"hljs-comment\">//中断配置初始化</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>KEY_INT_EXTI_CLK<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//打开AFIO时钟</span><br>\tGPIO_EXTILineConfig<span class=\"hljs-punctuation\">(</span>KEY_INT_EXTI_PORTSOURCE<span class=\"hljs-punctuation\">,</span> KEY_INT_EXTI_PINSOURCE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//产生中断的事件线（Px0属于Line0，Px1属于Line1...）</span><br>\t<br>\tEXTI_InitStruct.EXTI_Line <span class=\"hljs-punctuation\">=</span> KEY_INT_EXTI_LINE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//中断屏蔽器输入位的选择，以供EXTI_LineCmd精准使能</span><br>\tEXTI_InitStruct.EXTI_LineCmd <span class=\"hljs-punctuation\">=</span> ENABLE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//中断屏蔽器使能（控制中断接受IMR/EMR）</span><br>\tEXTI_InitStruct.EXTI_Mode <span class=\"hljs-punctuation\">=</span> EXTI_Mode_Interrupt<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//选择触发类型（中断触发和事件触发）</span><br>\tEXTI_InitStruct.EXTI_Trigger <span class=\"hljs-punctuation\">=</span> EXTI_Trigger_Rising<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//选择模式（上升沿和下降沿）</span><br>\tEXTI_Init<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;EXTI_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<p>前面 4 个线路有单独的中断函数，后面 5 至 9 和 10 至 15 线路使用 复用的思想思考，区分出什么是可以唯一标识的，什么是复用的，EXTI_Lines 在寄存器中都是一一对应状态标位, 中断函数复用，<strong>因此在 EXTI9_5_IRQHandler 和 EXTI15_10_IRQHandler 的中断函数里面使用多次EXTI_GetITStatus 函数来判断出线路。</strong>  </p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">if(EXTI_GetITStatus(EXTI_Line10) != RESET)<br>&#123;<br>\tLED_TOGGLE;<br>&#125;<br>if(EXTI_GetITStatus(EXTI_Line14) != RESET)<br>&#123;<br>\tLED_TOGGLE;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"Hi3861开发","date":"2024-05-16T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/GWNSpkEigmD2VlO.jpg","_content":"\n# Hi3861开发\n\n## 一、学习资料\n\n- 【UART串口使用】[HI3861学习笔记（18）——UART串口使用_hi3861 uart-CSDN博客](https://blog.csdn.net/qq_36347513/article/details/121603716)\n\n- 【开发环境搭建】[2.1 Pegasus开发环境搭建.md · HiSpark/HiSpark_NICU2023 - Gitee.com](https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1 Pegasus开发环境搭建.md)\n\n- 【入门demo】[编写 Hello World”程序 (openharmony.cn)](https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-ide-3861-helloworld.md)\n\n- 【UART串口读取】[HarmonyOS小熊派 | HarmonyOS基础外设开发--UART数据读写-云社区-华为云 (huaweicloud.com)](https://bbs.huaweicloud.com/blogs/detail/281809)\n\n- 【QT转EXE格式】[QT打包成exe详细步骤 - 西北小蚂蚁 - 博客园 (cnblogs.com)](https://www.cnblogs.com/JinShanCheShen/p/16194526.html)\n\n- 【QT转EXE格式编译报错】[Qt软件打包后报错“无法定位程序输入点_ZN10QArrayData10deallocateEPs_jj于动态链接库..... .exe上。”解决办法-CSDN博客](https://blog.csdn.net/weijifen000/article/details/102537640)\n\n## 二、QT开发\n\n- geometry里的宽度、高度是分辨率，比如geometry设置为宽*高为1920*1080\n\n- 【窗口自适应】[【QT】QT Designer控件随窗口大小自适应-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2286080)\n\n- 【串口发送】[QT串口助手：识别串口号，发送，接收，十六进制_qt串口发送16进制数据-CSDN博客](https://blog.csdn.net/qq_26904271/article/details/132646641)\n\n- foreach是QT中的一个关键字，其作用是对第二个参数中的对象进行遍历，把遍历过程中的每个对象依次赋给第一个参数，并执行花括号中的内容。在这里，就是把可获取的串口列表availablePorts()中的串口，逐个将其串口号添加到combobox中。\n\n### 1.串口设定\n\n```\n  \t//mainwindow.h文件调用串口头文件\n  \t//串口头文件\n  \t#include <QSerialPort>\n\t#include <QSerialPortInfo>\n  \t\n  \t//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找\n  \t//使用foreach函数查找串口信息\n\tforeach (const QSerialPortInfo &portInfo,QSerialPortInfo::availablePorts()) \n  \t{\n      //将所有搜索的值写入serialport端口当中\n      ui->serialport->addItem(portInfo.portName());\n  \t}\n  \t//打开串口\n  \tserialPort->open();\n  \t//关闭串口\n  \tserialPort->close();\n  \t\n  \t//串口写入\n  \tserialPort->write(\"*****\");\n```\n\n### 2.读取下拉选项内容并赋予\n```\n\t//mainwindow.cpp文件中，自定义函数设定\n\t\n\t//定义参数格式为QString\n\tQString mBaudrate;//波特率\n\tQString mStopBits;//停止位字节\n    QString mDataBits;//数据字节\n    QString mParity;//奇偶校验\n    \n\t//读取baudrate槽中currentText()所选定的内容，后续类似\n\tmBaudrate = ui->baudrate->currentText();\n\tmStopBits = ui->stopbits->currentText();\n    mDataBits = ui->databits->currentText();\n    mParity = ui->parity->currentText();\n\t\n\t//判断起选定内容是否符合需求，并赋予相应操作\n\tif(mBaudrate == \"9600\") \n\t{\n\t\t//将串口波特率设定为9600\n        mSerialPort.setBaudRate(QSerialPort::Baud9600);//Baud9600、Baud115200\n        mSerialPort.setStopBits(QSerialPort::OneStop);//OneStop-1、OneAndHalfStop-1.5、TwoStop-2\n        mSerialPort.setDataBits(QSerialPort::Data5);//Data5、Data6、Data7、Data8\n        mSerialPort.setParity(QSerialPort::OddParity);//OddParity-奇校验、EvenParity-偶校验、NoParity无校验\n    } \n    else if(mBaudrate == \"115200\") \n    {\n    \t//将串口波特率设定为115200\n        mSerialPort.setBaudRate(QSerialPort::Baud19200);\n    }\n```\n\n### 3.摄像头设定\n\n```\n\t//***.pro格式文件加入multimediawidgets\n\tQT       += core gui multimediawidgets\n\t\n\t//mainwindow.h文件调用摄像头头文件\n\t#include <QCameraImageCapture>\n\t#include <QCamera>\n\t\n\t//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找\n\t//获取系统的所有可用的摄像头\n\tforeach(const QCameraInfo &cameraInfo , QCameraInfo::availableCameras())\n    {\n        //将所有搜索的值写入cameraBox端口当中\n        ui->cameraBox->addItem(cameraInfo.deviceName());\n    }\n    \n    //打开摄像头\n    cameraPort->start();\n    //关闭摄像头\n    cameraPort->stop();\n```\n\n### 4.QT中setCheckable()的作用\n\nsetCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。\n\n### 5.TCP通讯\n\n```\n\t//***.pro格式文件加入network\n\tQT       += network\n\t\n\t//mainwindow.h头文件中引用\n\t#include <QTcpServer>\n\t#include <QTcpSocket>\n\t//定义*socket和*server用来存放服务器的套接字和监听，用于与客户端进行通信\n\tQTcpSocket *socket;\n    QTcpServer *server;\n\t\n\t//mainwindow.cpp文件中MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找\n\t//setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。\n\tui->Monitor_OPEN->setCheckable(true);//简而言之就是按键的常开和常闭切换\n\t//创建服务器的套接字，用于与客户端进行通信\n\tsocket = new QTcpSocket();\n\t//声明一个QTcpserver的对象，用于监听\n    server = new QTcpServer();\n    //信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据\n    connect(server,SIGNAL(newConnection()),this,SLOT(newConnection_SLOT()));\n    \n    //定义新函数MainWindow::newConnection_SLOT()，用于新的客户端连接建立槽函数：获取客户端套接字，允许写入数据\n    void MainWindow::newConnection_SLOT()\n    {\n        socket = server->nextPendingConnection(); //获取已经连接的客户端套接字\n        connect(socket,SIGNAL(readyRead()),this,SLOT(readyRead_SLOT()));//如果socket中有缓存消息，触发槽函数\n    }\n    \n    //定义新函数MainWindow::readyRead_SLOT()，用于接收消息并显示到接收框\n    void MainWindow::readyRead_SLOT()\n    {\n        qDebug() << \"Server Received!\";\n        QString buffer;//定义容器\n        //读取缓冲区数据\n        buffer = socket->readAll();\n        if(!buffer.isEmpty())\n        {\n            //刷新显示，写入Receive_text组件，组件类型为Plain Text Line\n            ui->Receive_text->appendPlainText(buffer);\n        }\n    }\n    \n    //连接组件函数，按下开始监听组件Monitor_OPEN，类型为clicked(bool checked)，执行监听程序\n    void MainWindow::on_Monitor_OPEN_clicked(bool checked)\n    {\n        if(checked)//如果按下了\n        {\n            int port = ui->PORT_TEXT->text().toUInt();\n            //如果未监听到\n            if(!server->listen(QHostAddress::Any, port))\n            {\n                qDebug() << server->errorString();\n                //连接失败，再次点击则重新连接，将checked恢复为true\n                ui->Monitor_OPEN->toggle();\n                return;\n            }\n            qDebug() << \"Listen Successfully! Message from port:\" << port;\n            //修改按钮文字\n            ui->Monitor_OPEN->setText(\"停止监听\");\n            //发送键使能\n            ui->Send_Button->setEnabled(true);\n        }\n        else\n        {\n             qDebug() << \"Stop Listening!\";\n            //如果已经连接则断开连接\n            if(socket->state() == QAbstractSocket::ConnectedState)\n            {\n                //断开连接\n                socket->disconnectFromHost();\n            }\n            //关闭倾听服务\n            server->close();\n            //修改按钮文字&发送键静默\n            ui->Monitor_OPEN->setText(\"开始监听\");\n            ui->Send_Button->setEnabled(false);\n        }\n    }\n```\n\n### 6.滑动槽设定\n\n- 首先使用setRange()方法设置了滑动条的范围为0到100，然后使用setValue()方法设置了滑动条的当前值为50。通过value()方法可以获取当前滑动条的值。最后，使用connect()方法监听了滑动条的值变化，当值发生变化时，会调用onSliderValueChanged()槽函数。\n\n```text\n    // 假设有一个QSlider对象名为slider\n    // 设置滑动条的范围\n    slider->setRange(-180, 180);\n\n    // 设置滑动条的当前值\n    slider->setValue(0);\n\n    // 获取滑动条的当前值\n    int currentValue = slider->value();\n\n    // 监听滑动条的值变化\n    connect(slider, SIGNAL(valueChanged(int)), this, SLOT(onSliderValueChanged(int)));\n```\n\n- slider 提供了两个自然的步长；较大的步长用 pageStep 表示，相当于按下键盘上的 PageDown 和 PageUp，也相当于鼠标点击时移动的步进值:；较小的步长用 singleStep 表示，相当于按下键盘上的上、下键；\n\n```\n    // 设置移动每页的步长，滑块提供的两个自然步长中较大的那一个，相当于键盘上的 PageUp 和 PageDown；\n    horizontalSlider->setPageStep(10);\n\n    // 获取 每页的步长\n    int step = horizontalSlider->pageStep();\n\n    // 设置移动单步的步长，滑块提供的两个自然步长中较小的那一个，相当于键盘上的上、下箭头；\n    horizontalSlider->setSingleStep(2);\n\n    // 获取 单步的步长\n    int step =horizontalSlider->singleStep();\n```\n\n- 设置是否启用滑块追踪：\n\n```\n    // 设置是否启动滑块追踪：true 表示启动追踪；false 表示禁用追踪；\n    // 如果启用了滑块追踪，则滑块在拖动过程中会一直触发 valueChanged 信号；\n    // 如果禁用了滑块追踪，则滑块在拖动过程中不会触发 valueChanged 信号，\n    // 只有在用户释放滑块时，才触发 valueChanged 信号。\n    horizontalSlider->setTracking(true);\n    // 可以通过 hasTracking 属性获取是否启用了追踪：\n    bool isTrack = horizontalSlider->hasTracking();\n```\n\n- 槽函数设定\n\n```\n    valueChanged()//值被改变\n    sliderPressed()//滑块被点击\n    sliderMoved()//滑块移动\n    sliderReleased();//滑块被释放\n```\n\n## 三、TCP通讯\n\n【TCP通信】[HI3861学习笔记（20）——TCP客户端_hi3861 at tcp 指令 erre-CSDN博客](https://blog.csdn.net/qq_36347513/article/details/123099617)\n\n【TCP通信】[教你动手写TCP上位机与小熊派通信_小熊派设备的tcp通信-CSDN博客](https://blog.csdn.net/baidu_29900103/article/details/117970891)\n\n## 四、下位机代码\n\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\n#include \"iot_gpio_ex.h\"\n#include \"ohos_init.h\"\n#include \"cmsis_os2.h\"\n#include \"iot_gpio.h\"\n#include \"iot_uart.h\"\n#include \"hi_uart.h\"\n#include \"iot_watchdog.h\"\n#include \"iot_errno.h\"\n\n#include \"hal_bsp_pcf8574.h\"\n#include \"hal_bsp_wifi.h\"\n#include \"wifi_device.h\"\n#include \"lwip/netifapi.h\"\n#include \"lwip/sockets.h\"\n#include \"lwip/api_shell.h\"\n\n#define    ABS(x)    ((x) > 0 ? (x) : -(x))\n\n#define UART_BUFF_SIZE 100\n#define U_SLEEP_TIME   500000\n#define UART_TIMEOUT_MS 20   // 设置超时时间为100毫秒\n\nosThreadId_t Task1_ID; // 任务1设置为低优先级任务\n#define TASK_STACK_SIZE (1024 * 10)\n#define TCP_SERVER_IP \"192.168.245.23\"\n#define TCP_SERVER_PORT 8888\n\n#define DIR_pos 1 // 正方向\n#define DIR_neg 0 // 反方向\n#define Speed_acc 1000 // 加速度\n#define Speed_dec 1000 // 减速度\n#define Speed_max 2000.0f // 最大速度\n#define motor_raf_0 0 // 相位位置标志\n#define motor_raf_1 1 //绝对位置标志\n#define motor_snf_0 0 // 多机同步运动标志\n#define motor_snf_1 0 // 单机运动标志\n\n//读取数据的枚举值\ntypedef enum {\n  S_VER   = 0,      /* 读取固件版本和对应的硬件版本 */\n  S_RL    = 1,      /* 读取读取相电阻和相电感 */\n  S_PID   = 2,      /* 读取PID参数 */\n  S_ORG   = 3,      /* 读取回零参数 */\n  S_VBUS  = 4,      /* 读取总线电压 */\n  S_CBUS  = 5,      /* 读取总线电流 */\n  S_CPHA  = 6,      /* 读取相电流 */\n  S_ENC   = 7,      /* 读取编码器原始值 */\n  S_CPUL  = 8,      /* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */\n  S_ENCL  = 9,      /* 读取经过线性化校准后的编码器值 */\n  S_TPUL  = 10,     /* 读取输入脉冲数 */\n  S_TPOS  = 11,     /* 读取电机目标位置 */\n  S_OPOS  = 12,     /* 读取电机实时设定的目标位置（开环模式的实时位置） */\n  S_VEL   = 13,     /* 读取电机实时转速 */\n  S_CPOS  = 14,     /* 读取电机实时位置（基于角度编码器累加的电机实时位置） */\n  S_PERR  = 15,     /* 读取电机位置误差 */\n  S_TEMP  = 16,     /* 读取电机实时温度 */\n  S_SFLAG = 17,     /* 读取状态标志位 */\n  S_OFLAG = 18,     /* 读取回零状态标志位 */\n  S_Conf  = 19,     /* 读取驱动参数 */\n  S_State = 20,     /* 读取系统状态参数 */\n}SysParams_t;\n\nvoid Uart1GpioInit(void)//对UART和LED引脚进行初始化\n{\n    IoTGpioInit(IOT_IO_NAME_GPIO_6);\n    // 设置GPIO0的管脚复用关系为UART1_TX Set the pin reuse relationship of GPIO0 to UART1_ TX\n    IoSetFunc(IOT_IO_NAME_GPIO_6, IOT_IO_FUNC_GPIO_6_UART1_TXD);\n    \n    IoTGpioInit(IOT_IO_NAME_GPIO_5);\n    // 设置GPIO1的管脚复用关系为UART1_RX Set the pin reuse relationship of GPIO1 to UART1_ RX\n    IoSetFunc(IOT_IO_NAME_GPIO_5, IOT_IO_FUNC_GPIO_5_UART1_RXD);\n\n    // LED3的GPIO初始化 GPIO initialization of LED3\n    IoTGpioInit(IOT_IO_NAME_GPIO_2);\n    // 设置GPIO9的管脚复用关系为GPIO Set the pin reuse relationship of GPIO9 to GPIO\n    IoSetFunc(IOT_IO_NAME_GPIO_2, IOT_IO_FUNC_GPIO_2_GPIO);\n    // GPIO方向设置为输出 GPIO direction set to output\n    IoTGpioSetDir(IOT_IO_NAME_GPIO_2, IOT_GPIO_DIR_OUT);\n}\n\nvoid Uart1Config(void)//对UART配置初始化\n{\n    uint32_t ret;\n    /* 初始化UART配置，波特率 115200，数据bit为8,停止位1，奇偶校验为NONE */\n    /* Initialize UART configuration, baud rate is 9600, data bit is 8, stop bit is 1, parity is NONE */\n    IotUartAttribute uart_attr = {\n        .baudRate = 115200,\n        .dataBits = 8,\n        .stopBits = 1,\n        .parity = 0,\n    };\n\n    //uart初始化返回值\n    ret = IoTUartInit(HI_UART_IDX_1, &uart_attr);\n    //判断uart是否连接成功\n    if (ret != IOT_SUCCESS) {\n        printf(\"Init Uart1 Falied Error No : %d\\n\", ret);\n        return;\n    }\n}\n\nvoid ZDT_X42_V2_En_Control(uint8_t addr, int state, uint8_t snF)//电机使能控制函数\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n\n    //定义发送命令数组\n    uint8_t cmd[16] = {0};\n  \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n    cmd[1] =  0xF3;                       // 功能码\n    cmd[2] =  0xAB;                       // 辅助码\n    cmd[3] =  (uint8_t)state;             // 使能状态\n    cmd[4] =  snF;                        // 多机同步运动标志\n    cmd[5] =  0x6B;                       // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 6);\n}\n\n//电机驱动函数\nvoid ZDT_X42_V2_Traj_Position_Control(uint8_t addr, uint8_t dir, uint16_t acc, uint16_t dec, float velocity, float position, uint8_t raf, uint8_t snF)\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n    \n    //定义发送命令数组\n    uint8_t cmd[32] = {0};\n    uint16_t vel = 0; uint32_t pos = 0;\n\n    // 将速度和位置放大10倍发送过去\n    vel = (uint16_t)ABS(velocity * 10.0f); \n    pos = (uint32_t)ABS(position * 10.0f);\n\n    // 装载命令\n    cmd[0]  =  addr;                      // 地址\n    cmd[1]  =  0xFD;                      // 功能码\n    cmd[2]  =  dir;                       // 符号（方向）\n    cmd[3]  =  (uint8_t)(acc >> 8);       // 加速加速度(RPM/s)高8位字节\n    cmd[4]  =  (uint8_t)(acc >> 0);       // 加速加速度(RPM/s)低8位字节  \n    cmd[5]  =  (uint8_t)(dec >> 8);       // 减速加速度(RPM/s)高8位字节\n    cmd[6]  =  (uint8_t)(dec >> 0);       // 减速加速度(RPM/s)低8位字节  \n    cmd[7]  =  (uint8_t)(vel >> 8);       // 最大速度(RPM)高8位字节\n    cmd[8]  =  (uint8_t)(vel >> 0);       // 最大速度(RPM)低8位字节 \n    cmd[9]  =  (uint8_t)(pos >> 24);      // 位置(bit24 - bit31)\n    cmd[10] =  (uint8_t)(pos >> 16);      // 位置(bit16 - bit23)\n    cmd[11] =  (uint8_t)(pos >> 8);       // 位置(bit8  - bit15)\n    cmd[12] =  (uint8_t)(pos >> 0);       // 位置(bit0  - bit7 )\n    cmd[13] =  raf;                       // 相位位置/绝对位置标志\n    cmd[14] =  snF;                       // 多机同步运动标志\n    cmd[15] =  0x6B;                      // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 16);\n}\n\nvoid ZDT_X42_V2_Origin_Trigger_Return(uint8_t addr, uint8_t o_mode, bool snF)//电机归零函数，没啥用，需要外界碰撞或者限位，该文件未使用此函数\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n\n    uint8_t cmd[16] = {0};\n    \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n    cmd[1] =  0x9A;                       // 功能码\n    cmd[2] =  o_mode;                     // 回零模式，0为单圈就近回零，1为单圈方向回零，2为多圈无限位碰撞回零，3为多圈有限位开关回零\n    cmd[3] =  snF;                        // 多机同步运动标志，false为不启用，true为启用\n    cmd[4] =  0x6B;                       // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 5);\n}\n\nvoid ZDT_X42_V2_Stop_Now(uint8_t addr, uint8_t snF)//立即停机\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n\n    uint8_t cmd[16] = {0};\n    \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n    cmd[1] =  0xFE;                       // 功能码\n    cmd[2] =  0x98;                       // 辅助码\n    cmd[3] =  snF;                        // 多机同步运动标志\n    cmd[4] =  0x6B;                       // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 5);\n}\n\nunsigned int IoTUartFlush(unsigned int id) //串口清空函数，用于进行清空UART内部缓存，不然会出现读取错误\n{\n    //定义要存储数组\n    unsigned char buffer[128];\n\n    //定义读取值\n    int read;\n\n    do {\n        //将读取值全部存入数组当中，从而达到清空效果\n        read = IoTUartRead(id, buffer, sizeof(buffer));\n    } while (read > 0);\n\n    return IOT_SUCCESS;\n}\n\nvoid ZDT_X42_V2_Read_Sys_Params(uint8_t addr, SysParams_t s)//读取电机的实时位置\n{\n    //定义发送数组\n    uint8_t cmd[16] = {0};\n  \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n\n    //对功能码进行选择\n    switch(s)                             // 功能码\n    {\n        case S_VER   : cmd[1] = 0x1F; break;                  /* 读取固件版本和对应的硬件版本 */\n        case S_RL    : cmd[1] = 0x20; break;                  /* 读取读取相电阻和相电感 */\n        case S_PID   : cmd[1] = 0x21; break;                  /* 读取PID参数 */\n        case S_ORG   : cmd[1] = 0x22; break;                  /* 读取回零参数 */\n        case S_VBUS  : cmd[1] = 0x24; break;                  /* 读取总线电压 */\n        case S_CBUS  : cmd[1] = 0x26; break;                  /* 读取总线电流 */\n        case S_CPHA  : cmd[1] = 0x27; break;                  /* 读取相电流 */\n        case S_ENC   : cmd[1] = 0x29; break;                  /* 读取编码器原始值 */\n        case S_CPUL  : cmd[1] = 0x30; break;                  /* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */\n        case S_ENCL  : cmd[1] = 0x31; break;                  /* 读取经过线性化校准后的编码器值 */\n        case S_TPUL  : cmd[1] = 0x32; break;                  /* 读取输入脉冲数 */\n        case S_TPOS  : cmd[1] = 0x33; break;                  /* 读取电机目标位置 */\n        case S_OPOS  : cmd[1] = 0x34; break;                  /* 读取电机实时设定的目标位置（开环模式的实时位置） */\n        case S_VEL   : cmd[1] = 0x35; break;                  /* 读取电机实时转速 */\n        case S_CPOS  : cmd[1] = 0x36; break;                  /* 读取电机实时位置（基于角度编码器累加的电机实时位置） */\n        case S_PERR  : cmd[1] = 0x37; break;                  /* 读取电机位置误差 */\n        case S_TEMP  : cmd[1] = 0x39; break;                  /* 读取电机实时温度 */\n        case S_SFLAG : cmd[1] = 0x3A; break;                  /* 读取状态标志位 */\n        case S_OFLAG : cmd[1] = 0x3B; break;                  /* 读取回零状态标志位 */\n        case S_Conf  : cmd[1] = 0x42; cmd[2] = 0x6C; break;   /* 读取驱动参数 */\n        case S_State : cmd[1] = 0x43; cmd[2] = 0x7A; break;   /* 读取系统状态参数 */\n        default: break;\n    }\n\n    // 如果需要四字节，将校验字节放在 cmd[3]\n    cmd[2] = 0x6B; \n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 3);\n}\n\nvoid ZDT_X42_V2_Receive_Data(uint8_t addr, uint8_t *rxCmd, uint32_t *rxCount) \n{\n    uint32_t startTime = osKernelGetTickCount();  // 获取当前系统时间\n    uint8_t buffer[UART_BUFF_SIZE];\n    int len;\n\n    while (1) {\n        len = IoTUartRead(HI_UART_IDX_1, buffer, sizeof(buffer));  // 从UART读取数据\n        if (len > 0) {\n            // 将读取的数据复制到rxCmd数组中，确保不会溢出\n            uint32_t copySize = (*rxCount + len > UART_BUFF_SIZE) ? (UART_BUFF_SIZE - *rxCount) : len;\n            memcpy(rxCmd + *rxCount, buffer, copySize);\n            *rxCount += copySize;\n\n            startTime = osKernelGetTickCount();  // 更新最后一次接收数据的时间\n        }\n\n        // 检查是否超时\n        if ((osKernelGetTickCount() - startTime) > UART_TIMEOUT_MS) {\n            break;  // 如果超过设定的超时时间，则停止接收数据\n        }\n    }\n}\n\nfloat absolute(float value) //找不到绝对值的函数值定义，自己创建一个函数用于进行绝对值计算\n{\n    return (value < 0) ? -value : value;//判断如何取正\n}\n\nfloat ReadMotorAngle(uint8_t sliderId) //定义读取角度，并计算和输出角度值\n{\n    //清空缓存区\n    IoTUartFlush(HI_UART_IDX_1);\n\n    //定义角度取值为小数点后一位\n    float pos = 0.0f, Motor_Cur_Pos = 0.0f;\n\n    // 定义接收数据数组、接收数据长度\n    uint8_t rxCmd[UART_BUFF_SIZE] = {0};\n    uint32_t rxCount = 0;\n\n    // 读取电机实时位置\n    ZDT_X42_V2_Read_Sys_Params(sliderId, S_CPOS);\n\n    // 等待返回命令，命令数据缓存在数组rxCmd上，长度为rxCount\n    ZDT_X42_V2_Receive_Data(sliderId, rxCmd, &rxCount);\n\n    //将读取的rxCmd[]十六进制编码打印，用于测试调试\n    // printf(\"Received bytes: \");\n    // for (int i = 0; i < 8; i++) {\n    //     printf(\"%02X \", rxCmd[i]);\n    // }\n    // printf(\"\\n\");\n\n    // 获取电机实时角度返回值（电机实时角度返回值放大了10倍返回的，因为要保留1位小数）\n    pos = ((uint32_t)rxCmd[3] << 24) | ((uint32_t)rxCmd[4] << 16) | ((uint32_t)rxCmd[5] << 8) | (uint32_t)rxCmd[6];\n\n    // 缩小10倍，并判断符号，得到真正的实时角度，存放在浮点数变量Motor_Cur_Pos中\n    Motor_Cur_Pos = pos * 0.1f;\n    if (rxCmd[2]) {\n        Motor_Cur_Pos = -Motor_Cur_Pos;\n    }\n\n    // 打印解析后的角度值\n    printf(\"Current position (as angle): %.1f degrees\\n\", Motor_Cur_Pos);\n\n    return Motor_Cur_Pos;\n}\n\nvoid ResetMotorToOrigin(uint8_t sliderId) //电机归零函数\n{\n    //读取电机目前角度\n    float Motor_Cur_Pos = ReadMotorAngle(sliderId);\n\n    float targetPosition = 0; // 目标位置，这里假设为0度\n\n    // 根据当前角度和目标位置计算需要移动的距离\n    float delta = targetPosition - Motor_Cur_Pos;\n\n    // 将 delta 四舍五入到小数点后一位\n    //delta = ((int)(delta * 10 + 0.5)) / 10.0f;\n\n    printf(\"delta: %.1f degrees\\n\", delta);\n\n    // 调用轨迹位置控制函数将电机移动到目标位置\n    ZDT_X42_V2_Traj_Position_Control(sliderId, (delta < 0) ? 1 : 0, Speed_acc, Speed_dec, Speed_max, absolute(delta), motor_raf_0, motor_snf_0);\n}\n\nvoid ParseJson(const char* json)//电机uart运行主函数\n{\n    // 定义JSON键的字符串，根据上位机所需进行定义，格式类型相同\n    const char* labelStr = \"\\\"label\\\":\";\n    const char* motor_EnStr = \"\\\"motor_En\\\":\";\n    const char* sliderIdStr = \"\\\"sliderId\\\":\";\n    const char* valueStr = \"\\\"value\\\":\";\n    \n\n    // 找到JSON字符串中键的位置，用于进行键的连接，等于找到对应的标签\n    char* labelPos = strstr(json, labelStr);\n    char* motor_EnPos = strstr(json, motor_EnStr);\n    char* sliderIdPos = strstr(json, sliderIdStr);\n    char* valuePos = strstr(json, valueStr);\n\n    // 如果找到键，解析其对应的值\n    if (labelPos != NULL && motor_EnPos != NULL && sliderIdPos != NULL && valuePos != NULL) {\n        int label = atoi(labelPos + strlen(labelStr)); // 将label转换为整数\n        int sliderId = atoi(sliderIdPos + strlen(sliderIdStr)); // 将sliderId转换为整数\n\n        //放大30倍，对应谐波减速器\n        int value = atof(valuePos + strlen(valueStr));\n        int motor_En = atoi(motor_EnPos + strlen(motor_EnStr));\n\n        // 打印解析出的值\n        printf(\"label: %d, motor_En: %d, Slider ID: %d, Value: %d\\n\", label, motor_En, sliderId, value);\n\n        // 根据Slider ID和Value执行相应的操作\n        if (label == 1) \n        {\n            if (sliderId == 1){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            } \n            else if (sliderId == 2){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 3){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 4){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 5){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 6){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n        } \n        else if (label == 2) \n        {\n            if (sliderId == 1){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            } \n            else if (sliderId == 2){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 3){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 4){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 5){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 6){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            \n        }\n        else if (label == 3) //电机紧急停机\n        {\n            ZDT_X42_V2_Stop_Now(1, 0);  //调用停机函数\n            usleep(50);  //延时确保函数依次执行\n            ZDT_X42_V2_Stop_Now(2, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(3, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(4, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(5, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(6, 0);\n            usleep(50);\n        }\n        else if (label == 4) //电机复位函数\n        {\n            ResetMotorToOrigin(1);  //调用复位函数\n            usleep(50);  //延时确保函数依次执行\n            ResetMotorToOrigin(2);\n            usleep(50);\n            ResetMotorToOrigin(3);\n            usleep(50);\n            ResetMotorToOrigin(4);\n            usleep(50);\n            ResetMotorToOrigin(5);\n            usleep(50);\n            ResetMotorToOrigin(6);\n            usleep(50);\n        }\n    }\n}\n\nvoid Task1(void)//系统主函数\n{\n    int socket_fd = 0;\n    char buff[256];\n    int re = 0;\n\n    uint32_t count_0 = 0;\n    uint32_t len_0 = 0;\n    unsigned char uartReadBuff_0[UART_BUFF_SIZE] = {0};\n\n    // 对UART1的一些初始化 Some initialization of UART1\n    Uart1GpioInit();\n    // 对UART1参数的一些配置 Some configurations of UART1 parameters\n    Uart1Config();\n\n    // 连接Wifi\n    WiFi_connectHotspots(\"esp32\", \"12345678\");\n    socket_fd = socket(AF_INET, SOCK_STREAM, 0); // 创建套接字（TCP）\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(TCP_SERVER_PORT);\n    addr.sin_addr.s_addr = inet_addr(TCP_SERVER_IP); // 填写服务器的IP地址\n\n    re = connect(socket_fd, (struct sockaddr *)&addr, sizeof(addr)); // 连接服务器\n    if (re == -1) {\n        printf(\"Failed to connect to the server\\r\\n\");\n        return;\n    }\n    printf(\"Connection to server successful\\r\\n\");\n\n    // 发送第一条数据\n    send(socket_fd, \"Connection to server successful.\", strlen(\"Connection to server successful.\"), 0);\n\n    while (1) {\n        memset_s(buff, sizeof(buff), 0, sizeof(buff));\n        re = recv(socket_fd, buff, sizeof(buff), 0); //\t接收客户端发送过来的消息\n        if (re <= 0) \n        {\n            break;\n        } else {\n            ParseJson(buff);//执行控制主函数\n        }\n    }\n    close(socket_fd);\n}\n\nvoid UartExampleEntry(void)//配置上报函数\n{\n    //osThreadAttr_t attr;\n    IoTWatchDogDisable();\n\n    osThreadAttr_t options;\n    options.name = \"thread_1\";\n    options.attr_bits = 0;\n    options.cb_mem = NULL;\n    options.cb_size = 0;\n    options.stack_mem = NULL;\n    options.stack_size = TASK_STACK_SIZE;\n    options.priority = osPriorityNormal;\n\n    Task1_ID = osThreadNew((osThreadFunc_t)Task1, NULL, &options);\n    if (Task1_ID != NULL) {\n        printf(\"ID = %d, Create Task1_ID is OK!\\r\\n\", Task1_ID);\n    }\n}\n\nAPP_FEATURE_INIT(UartExampleEntry);\n```\n\n","source":"_posts/20240429ZYY-Hi3861开发.md","raw":"---\ntitle: Hi3861开发\ntag: Hi3861\ndate: 2024-05-17\ncategories: 单片机\nindex_img: https://s2.loli.net/2024/07/31/GWNSpkEigmD2VlO.jpg\n---\n\n# Hi3861开发\n\n## 一、学习资料\n\n- 【UART串口使用】[HI3861学习笔记（18）——UART串口使用_hi3861 uart-CSDN博客](https://blog.csdn.net/qq_36347513/article/details/121603716)\n\n- 【开发环境搭建】[2.1 Pegasus开发环境搭建.md · HiSpark/HiSpark_NICU2023 - Gitee.com](https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1 Pegasus开发环境搭建.md)\n\n- 【入门demo】[编写 Hello World”程序 (openharmony.cn)](https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-ide-3861-helloworld.md)\n\n- 【UART串口读取】[HarmonyOS小熊派 | HarmonyOS基础外设开发--UART数据读写-云社区-华为云 (huaweicloud.com)](https://bbs.huaweicloud.com/blogs/detail/281809)\n\n- 【QT转EXE格式】[QT打包成exe详细步骤 - 西北小蚂蚁 - 博客园 (cnblogs.com)](https://www.cnblogs.com/JinShanCheShen/p/16194526.html)\n\n- 【QT转EXE格式编译报错】[Qt软件打包后报错“无法定位程序输入点_ZN10QArrayData10deallocateEPs_jj于动态链接库..... .exe上。”解决办法-CSDN博客](https://blog.csdn.net/weijifen000/article/details/102537640)\n\n## 二、QT开发\n\n- geometry里的宽度、高度是分辨率，比如geometry设置为宽*高为1920*1080\n\n- 【窗口自适应】[【QT】QT Designer控件随窗口大小自适应-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2286080)\n\n- 【串口发送】[QT串口助手：识别串口号，发送，接收，十六进制_qt串口发送16进制数据-CSDN博客](https://blog.csdn.net/qq_26904271/article/details/132646641)\n\n- foreach是QT中的一个关键字，其作用是对第二个参数中的对象进行遍历，把遍历过程中的每个对象依次赋给第一个参数，并执行花括号中的内容。在这里，就是把可获取的串口列表availablePorts()中的串口，逐个将其串口号添加到combobox中。\n\n### 1.串口设定\n\n```\n  \t//mainwindow.h文件调用串口头文件\n  \t//串口头文件\n  \t#include <QSerialPort>\n\t#include <QSerialPortInfo>\n  \t\n  \t//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找\n  \t//使用foreach函数查找串口信息\n\tforeach (const QSerialPortInfo &portInfo,QSerialPortInfo::availablePorts()) \n  \t{\n      //将所有搜索的值写入serialport端口当中\n      ui->serialport->addItem(portInfo.portName());\n  \t}\n  \t//打开串口\n  \tserialPort->open();\n  \t//关闭串口\n  \tserialPort->close();\n  \t\n  \t//串口写入\n  \tserialPort->write(\"*****\");\n```\n\n### 2.读取下拉选项内容并赋予\n```\n\t//mainwindow.cpp文件中，自定义函数设定\n\t\n\t//定义参数格式为QString\n\tQString mBaudrate;//波特率\n\tQString mStopBits;//停止位字节\n    QString mDataBits;//数据字节\n    QString mParity;//奇偶校验\n    \n\t//读取baudrate槽中currentText()所选定的内容，后续类似\n\tmBaudrate = ui->baudrate->currentText();\n\tmStopBits = ui->stopbits->currentText();\n    mDataBits = ui->databits->currentText();\n    mParity = ui->parity->currentText();\n\t\n\t//判断起选定内容是否符合需求，并赋予相应操作\n\tif(mBaudrate == \"9600\") \n\t{\n\t\t//将串口波特率设定为9600\n        mSerialPort.setBaudRate(QSerialPort::Baud9600);//Baud9600、Baud115200\n        mSerialPort.setStopBits(QSerialPort::OneStop);//OneStop-1、OneAndHalfStop-1.5、TwoStop-2\n        mSerialPort.setDataBits(QSerialPort::Data5);//Data5、Data6、Data7、Data8\n        mSerialPort.setParity(QSerialPort::OddParity);//OddParity-奇校验、EvenParity-偶校验、NoParity无校验\n    } \n    else if(mBaudrate == \"115200\") \n    {\n    \t//将串口波特率设定为115200\n        mSerialPort.setBaudRate(QSerialPort::Baud19200);\n    }\n```\n\n### 3.摄像头设定\n\n```\n\t//***.pro格式文件加入multimediawidgets\n\tQT       += core gui multimediawidgets\n\t\n\t//mainwindow.h文件调用摄像头头文件\n\t#include <QCameraImageCapture>\n\t#include <QCamera>\n\t\n\t//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找\n\t//获取系统的所有可用的摄像头\n\tforeach(const QCameraInfo &cameraInfo , QCameraInfo::availableCameras())\n    {\n        //将所有搜索的值写入cameraBox端口当中\n        ui->cameraBox->addItem(cameraInfo.deviceName());\n    }\n    \n    //打开摄像头\n    cameraPort->start();\n    //关闭摄像头\n    cameraPort->stop();\n```\n\n### 4.QT中setCheckable()的作用\n\nsetCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。\n\n### 5.TCP通讯\n\n```\n\t//***.pro格式文件加入network\n\tQT       += network\n\t\n\t//mainwindow.h头文件中引用\n\t#include <QTcpServer>\n\t#include <QTcpSocket>\n\t//定义*socket和*server用来存放服务器的套接字和监听，用于与客户端进行通信\n\tQTcpSocket *socket;\n    QTcpServer *server;\n\t\n\t//mainwindow.cpp文件中MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找\n\t//setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。\n\tui->Monitor_OPEN->setCheckable(true);//简而言之就是按键的常开和常闭切换\n\t//创建服务器的套接字，用于与客户端进行通信\n\tsocket = new QTcpSocket();\n\t//声明一个QTcpserver的对象，用于监听\n    server = new QTcpServer();\n    //信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据\n    connect(server,SIGNAL(newConnection()),this,SLOT(newConnection_SLOT()));\n    \n    //定义新函数MainWindow::newConnection_SLOT()，用于新的客户端连接建立槽函数：获取客户端套接字，允许写入数据\n    void MainWindow::newConnection_SLOT()\n    {\n        socket = server->nextPendingConnection(); //获取已经连接的客户端套接字\n        connect(socket,SIGNAL(readyRead()),this,SLOT(readyRead_SLOT()));//如果socket中有缓存消息，触发槽函数\n    }\n    \n    //定义新函数MainWindow::readyRead_SLOT()，用于接收消息并显示到接收框\n    void MainWindow::readyRead_SLOT()\n    {\n        qDebug() << \"Server Received!\";\n        QString buffer;//定义容器\n        //读取缓冲区数据\n        buffer = socket->readAll();\n        if(!buffer.isEmpty())\n        {\n            //刷新显示，写入Receive_text组件，组件类型为Plain Text Line\n            ui->Receive_text->appendPlainText(buffer);\n        }\n    }\n    \n    //连接组件函数，按下开始监听组件Monitor_OPEN，类型为clicked(bool checked)，执行监听程序\n    void MainWindow::on_Monitor_OPEN_clicked(bool checked)\n    {\n        if(checked)//如果按下了\n        {\n            int port = ui->PORT_TEXT->text().toUInt();\n            //如果未监听到\n            if(!server->listen(QHostAddress::Any, port))\n            {\n                qDebug() << server->errorString();\n                //连接失败，再次点击则重新连接，将checked恢复为true\n                ui->Monitor_OPEN->toggle();\n                return;\n            }\n            qDebug() << \"Listen Successfully! Message from port:\" << port;\n            //修改按钮文字\n            ui->Monitor_OPEN->setText(\"停止监听\");\n            //发送键使能\n            ui->Send_Button->setEnabled(true);\n        }\n        else\n        {\n             qDebug() << \"Stop Listening!\";\n            //如果已经连接则断开连接\n            if(socket->state() == QAbstractSocket::ConnectedState)\n            {\n                //断开连接\n                socket->disconnectFromHost();\n            }\n            //关闭倾听服务\n            server->close();\n            //修改按钮文字&发送键静默\n            ui->Monitor_OPEN->setText(\"开始监听\");\n            ui->Send_Button->setEnabled(false);\n        }\n    }\n```\n\n### 6.滑动槽设定\n\n- 首先使用setRange()方法设置了滑动条的范围为0到100，然后使用setValue()方法设置了滑动条的当前值为50。通过value()方法可以获取当前滑动条的值。最后，使用connect()方法监听了滑动条的值变化，当值发生变化时，会调用onSliderValueChanged()槽函数。\n\n```text\n    // 假设有一个QSlider对象名为slider\n    // 设置滑动条的范围\n    slider->setRange(-180, 180);\n\n    // 设置滑动条的当前值\n    slider->setValue(0);\n\n    // 获取滑动条的当前值\n    int currentValue = slider->value();\n\n    // 监听滑动条的值变化\n    connect(slider, SIGNAL(valueChanged(int)), this, SLOT(onSliderValueChanged(int)));\n```\n\n- slider 提供了两个自然的步长；较大的步长用 pageStep 表示，相当于按下键盘上的 PageDown 和 PageUp，也相当于鼠标点击时移动的步进值:；较小的步长用 singleStep 表示，相当于按下键盘上的上、下键；\n\n```\n    // 设置移动每页的步长，滑块提供的两个自然步长中较大的那一个，相当于键盘上的 PageUp 和 PageDown；\n    horizontalSlider->setPageStep(10);\n\n    // 获取 每页的步长\n    int step = horizontalSlider->pageStep();\n\n    // 设置移动单步的步长，滑块提供的两个自然步长中较小的那一个，相当于键盘上的上、下箭头；\n    horizontalSlider->setSingleStep(2);\n\n    // 获取 单步的步长\n    int step =horizontalSlider->singleStep();\n```\n\n- 设置是否启用滑块追踪：\n\n```\n    // 设置是否启动滑块追踪：true 表示启动追踪；false 表示禁用追踪；\n    // 如果启用了滑块追踪，则滑块在拖动过程中会一直触发 valueChanged 信号；\n    // 如果禁用了滑块追踪，则滑块在拖动过程中不会触发 valueChanged 信号，\n    // 只有在用户释放滑块时，才触发 valueChanged 信号。\n    horizontalSlider->setTracking(true);\n    // 可以通过 hasTracking 属性获取是否启用了追踪：\n    bool isTrack = horizontalSlider->hasTracking();\n```\n\n- 槽函数设定\n\n```\n    valueChanged()//值被改变\n    sliderPressed()//滑块被点击\n    sliderMoved()//滑块移动\n    sliderReleased();//滑块被释放\n```\n\n## 三、TCP通讯\n\n【TCP通信】[HI3861学习笔记（20）——TCP客户端_hi3861 at tcp 指令 erre-CSDN博客](https://blog.csdn.net/qq_36347513/article/details/123099617)\n\n【TCP通信】[教你动手写TCP上位机与小熊派通信_小熊派设备的tcp通信-CSDN博客](https://blog.csdn.net/baidu_29900103/article/details/117970891)\n\n## 四、下位机代码\n\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\n#include \"iot_gpio_ex.h\"\n#include \"ohos_init.h\"\n#include \"cmsis_os2.h\"\n#include \"iot_gpio.h\"\n#include \"iot_uart.h\"\n#include \"hi_uart.h\"\n#include \"iot_watchdog.h\"\n#include \"iot_errno.h\"\n\n#include \"hal_bsp_pcf8574.h\"\n#include \"hal_bsp_wifi.h\"\n#include \"wifi_device.h\"\n#include \"lwip/netifapi.h\"\n#include \"lwip/sockets.h\"\n#include \"lwip/api_shell.h\"\n\n#define    ABS(x)    ((x) > 0 ? (x) : -(x))\n\n#define UART_BUFF_SIZE 100\n#define U_SLEEP_TIME   500000\n#define UART_TIMEOUT_MS 20   // 设置超时时间为100毫秒\n\nosThreadId_t Task1_ID; // 任务1设置为低优先级任务\n#define TASK_STACK_SIZE (1024 * 10)\n#define TCP_SERVER_IP \"192.168.245.23\"\n#define TCP_SERVER_PORT 8888\n\n#define DIR_pos 1 // 正方向\n#define DIR_neg 0 // 反方向\n#define Speed_acc 1000 // 加速度\n#define Speed_dec 1000 // 减速度\n#define Speed_max 2000.0f // 最大速度\n#define motor_raf_0 0 // 相位位置标志\n#define motor_raf_1 1 //绝对位置标志\n#define motor_snf_0 0 // 多机同步运动标志\n#define motor_snf_1 0 // 单机运动标志\n\n//读取数据的枚举值\ntypedef enum {\n  S_VER   = 0,      /* 读取固件版本和对应的硬件版本 */\n  S_RL    = 1,      /* 读取读取相电阻和相电感 */\n  S_PID   = 2,      /* 读取PID参数 */\n  S_ORG   = 3,      /* 读取回零参数 */\n  S_VBUS  = 4,      /* 读取总线电压 */\n  S_CBUS  = 5,      /* 读取总线电流 */\n  S_CPHA  = 6,      /* 读取相电流 */\n  S_ENC   = 7,      /* 读取编码器原始值 */\n  S_CPUL  = 8,      /* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */\n  S_ENCL  = 9,      /* 读取经过线性化校准后的编码器值 */\n  S_TPUL  = 10,     /* 读取输入脉冲数 */\n  S_TPOS  = 11,     /* 读取电机目标位置 */\n  S_OPOS  = 12,     /* 读取电机实时设定的目标位置（开环模式的实时位置） */\n  S_VEL   = 13,     /* 读取电机实时转速 */\n  S_CPOS  = 14,     /* 读取电机实时位置（基于角度编码器累加的电机实时位置） */\n  S_PERR  = 15,     /* 读取电机位置误差 */\n  S_TEMP  = 16,     /* 读取电机实时温度 */\n  S_SFLAG = 17,     /* 读取状态标志位 */\n  S_OFLAG = 18,     /* 读取回零状态标志位 */\n  S_Conf  = 19,     /* 读取驱动参数 */\n  S_State = 20,     /* 读取系统状态参数 */\n}SysParams_t;\n\nvoid Uart1GpioInit(void)//对UART和LED引脚进行初始化\n{\n    IoTGpioInit(IOT_IO_NAME_GPIO_6);\n    // 设置GPIO0的管脚复用关系为UART1_TX Set the pin reuse relationship of GPIO0 to UART1_ TX\n    IoSetFunc(IOT_IO_NAME_GPIO_6, IOT_IO_FUNC_GPIO_6_UART1_TXD);\n    \n    IoTGpioInit(IOT_IO_NAME_GPIO_5);\n    // 设置GPIO1的管脚复用关系为UART1_RX Set the pin reuse relationship of GPIO1 to UART1_ RX\n    IoSetFunc(IOT_IO_NAME_GPIO_5, IOT_IO_FUNC_GPIO_5_UART1_RXD);\n\n    // LED3的GPIO初始化 GPIO initialization of LED3\n    IoTGpioInit(IOT_IO_NAME_GPIO_2);\n    // 设置GPIO9的管脚复用关系为GPIO Set the pin reuse relationship of GPIO9 to GPIO\n    IoSetFunc(IOT_IO_NAME_GPIO_2, IOT_IO_FUNC_GPIO_2_GPIO);\n    // GPIO方向设置为输出 GPIO direction set to output\n    IoTGpioSetDir(IOT_IO_NAME_GPIO_2, IOT_GPIO_DIR_OUT);\n}\n\nvoid Uart1Config(void)//对UART配置初始化\n{\n    uint32_t ret;\n    /* 初始化UART配置，波特率 115200，数据bit为8,停止位1，奇偶校验为NONE */\n    /* Initialize UART configuration, baud rate is 9600, data bit is 8, stop bit is 1, parity is NONE */\n    IotUartAttribute uart_attr = {\n        .baudRate = 115200,\n        .dataBits = 8,\n        .stopBits = 1,\n        .parity = 0,\n    };\n\n    //uart初始化返回值\n    ret = IoTUartInit(HI_UART_IDX_1, &uart_attr);\n    //判断uart是否连接成功\n    if (ret != IOT_SUCCESS) {\n        printf(\"Init Uart1 Falied Error No : %d\\n\", ret);\n        return;\n    }\n}\n\nvoid ZDT_X42_V2_En_Control(uint8_t addr, int state, uint8_t snF)//电机使能控制函数\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n\n    //定义发送命令数组\n    uint8_t cmd[16] = {0};\n  \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n    cmd[1] =  0xF3;                       // 功能码\n    cmd[2] =  0xAB;                       // 辅助码\n    cmd[3] =  (uint8_t)state;             // 使能状态\n    cmd[4] =  snF;                        // 多机同步运动标志\n    cmd[5] =  0x6B;                       // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 6);\n}\n\n//电机驱动函数\nvoid ZDT_X42_V2_Traj_Position_Control(uint8_t addr, uint8_t dir, uint16_t acc, uint16_t dec, float velocity, float position, uint8_t raf, uint8_t snF)\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n    \n    //定义发送命令数组\n    uint8_t cmd[32] = {0};\n    uint16_t vel = 0; uint32_t pos = 0;\n\n    // 将速度和位置放大10倍发送过去\n    vel = (uint16_t)ABS(velocity * 10.0f); \n    pos = (uint32_t)ABS(position * 10.0f);\n\n    // 装载命令\n    cmd[0]  =  addr;                      // 地址\n    cmd[1]  =  0xFD;                      // 功能码\n    cmd[2]  =  dir;                       // 符号（方向）\n    cmd[3]  =  (uint8_t)(acc >> 8);       // 加速加速度(RPM/s)高8位字节\n    cmd[4]  =  (uint8_t)(acc >> 0);       // 加速加速度(RPM/s)低8位字节  \n    cmd[5]  =  (uint8_t)(dec >> 8);       // 减速加速度(RPM/s)高8位字节\n    cmd[6]  =  (uint8_t)(dec >> 0);       // 减速加速度(RPM/s)低8位字节  \n    cmd[7]  =  (uint8_t)(vel >> 8);       // 最大速度(RPM)高8位字节\n    cmd[8]  =  (uint8_t)(vel >> 0);       // 最大速度(RPM)低8位字节 \n    cmd[9]  =  (uint8_t)(pos >> 24);      // 位置(bit24 - bit31)\n    cmd[10] =  (uint8_t)(pos >> 16);      // 位置(bit16 - bit23)\n    cmd[11] =  (uint8_t)(pos >> 8);       // 位置(bit8  - bit15)\n    cmd[12] =  (uint8_t)(pos >> 0);       // 位置(bit0  - bit7 )\n    cmd[13] =  raf;                       // 相位位置/绝对位置标志\n    cmd[14] =  snF;                       // 多机同步运动标志\n    cmd[15] =  0x6B;                      // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 16);\n}\n\nvoid ZDT_X42_V2_Origin_Trigger_Return(uint8_t addr, uint8_t o_mode, bool snF)//电机归零函数，没啥用，需要外界碰撞或者限位，该文件未使用此函数\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n\n    uint8_t cmd[16] = {0};\n    \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n    cmd[1] =  0x9A;                       // 功能码\n    cmd[2] =  o_mode;                     // 回零模式，0为单圈就近回零，1为单圈方向回零，2为多圈无限位碰撞回零，3为多圈有限位开关回零\n    cmd[3] =  snF;                        // 多机同步运动标志，false为不启用，true为启用\n    cmd[4] =  0x6B;                       // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 5);\n}\n\nvoid ZDT_X42_V2_Stop_Now(uint8_t addr, uint8_t snF)//立即停机\n{\n    //定义接收值以及数据长度\n    uint32_t count = 0;\n    uint32_t len = 0;\n    unsigned char uartReadBuff[UART_BUFF_SIZE] = {0};\n\n    uint8_t cmd[16] = {0};\n    \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n    cmd[1] =  0xFE;                       // 功能码\n    cmd[2] =  0x98;                       // 辅助码\n    cmd[3] =  snF;                        // 多机同步运动标志\n    cmd[4] =  0x6B;                       // 校验字节\n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 5);\n}\n\nunsigned int IoTUartFlush(unsigned int id) //串口清空函数，用于进行清空UART内部缓存，不然会出现读取错误\n{\n    //定义要存储数组\n    unsigned char buffer[128];\n\n    //定义读取值\n    int read;\n\n    do {\n        //将读取值全部存入数组当中，从而达到清空效果\n        read = IoTUartRead(id, buffer, sizeof(buffer));\n    } while (read > 0);\n\n    return IOT_SUCCESS;\n}\n\nvoid ZDT_X42_V2_Read_Sys_Params(uint8_t addr, SysParams_t s)//读取电机的实时位置\n{\n    //定义发送数组\n    uint8_t cmd[16] = {0};\n  \n    // 装载命令\n    cmd[0] =  addr;                       // 地址\n\n    //对功能码进行选择\n    switch(s)                             // 功能码\n    {\n        case S_VER   : cmd[1] = 0x1F; break;                  /* 读取固件版本和对应的硬件版本 */\n        case S_RL    : cmd[1] = 0x20; break;                  /* 读取读取相电阻和相电感 */\n        case S_PID   : cmd[1] = 0x21; break;                  /* 读取PID参数 */\n        case S_ORG   : cmd[1] = 0x22; break;                  /* 读取回零参数 */\n        case S_VBUS  : cmd[1] = 0x24; break;                  /* 读取总线电压 */\n        case S_CBUS  : cmd[1] = 0x26; break;                  /* 读取总线电流 */\n        case S_CPHA  : cmd[1] = 0x27; break;                  /* 读取相电流 */\n        case S_ENC   : cmd[1] = 0x29; break;                  /* 读取编码器原始值 */\n        case S_CPUL  : cmd[1] = 0x30; break;                  /* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */\n        case S_ENCL  : cmd[1] = 0x31; break;                  /* 读取经过线性化校准后的编码器值 */\n        case S_TPUL  : cmd[1] = 0x32; break;                  /* 读取输入脉冲数 */\n        case S_TPOS  : cmd[1] = 0x33; break;                  /* 读取电机目标位置 */\n        case S_OPOS  : cmd[1] = 0x34; break;                  /* 读取电机实时设定的目标位置（开环模式的实时位置） */\n        case S_VEL   : cmd[1] = 0x35; break;                  /* 读取电机实时转速 */\n        case S_CPOS  : cmd[1] = 0x36; break;                  /* 读取电机实时位置（基于角度编码器累加的电机实时位置） */\n        case S_PERR  : cmd[1] = 0x37; break;                  /* 读取电机位置误差 */\n        case S_TEMP  : cmd[1] = 0x39; break;                  /* 读取电机实时温度 */\n        case S_SFLAG : cmd[1] = 0x3A; break;                  /* 读取状态标志位 */\n        case S_OFLAG : cmd[1] = 0x3B; break;                  /* 读取回零状态标志位 */\n        case S_Conf  : cmd[1] = 0x42; cmd[2] = 0x6C; break;   /* 读取驱动参数 */\n        case S_State : cmd[1] = 0x43; cmd[2] = 0x7A; break;   /* 读取系统状态参数 */\n        default: break;\n    }\n\n    // 如果需要四字节，将校验字节放在 cmd[3]\n    cmd[2] = 0x6B; \n\n    //通过UART的Write函数发送cmd的参数\n    IoTUartWrite(HI_UART_IDX_1, (unsigned char*)cmd, 3);\n}\n\nvoid ZDT_X42_V2_Receive_Data(uint8_t addr, uint8_t *rxCmd, uint32_t *rxCount) \n{\n    uint32_t startTime = osKernelGetTickCount();  // 获取当前系统时间\n    uint8_t buffer[UART_BUFF_SIZE];\n    int len;\n\n    while (1) {\n        len = IoTUartRead(HI_UART_IDX_1, buffer, sizeof(buffer));  // 从UART读取数据\n        if (len > 0) {\n            // 将读取的数据复制到rxCmd数组中，确保不会溢出\n            uint32_t copySize = (*rxCount + len > UART_BUFF_SIZE) ? (UART_BUFF_SIZE - *rxCount) : len;\n            memcpy(rxCmd + *rxCount, buffer, copySize);\n            *rxCount += copySize;\n\n            startTime = osKernelGetTickCount();  // 更新最后一次接收数据的时间\n        }\n\n        // 检查是否超时\n        if ((osKernelGetTickCount() - startTime) > UART_TIMEOUT_MS) {\n            break;  // 如果超过设定的超时时间，则停止接收数据\n        }\n    }\n}\n\nfloat absolute(float value) //找不到绝对值的函数值定义，自己创建一个函数用于进行绝对值计算\n{\n    return (value < 0) ? -value : value;//判断如何取正\n}\n\nfloat ReadMotorAngle(uint8_t sliderId) //定义读取角度，并计算和输出角度值\n{\n    //清空缓存区\n    IoTUartFlush(HI_UART_IDX_1);\n\n    //定义角度取值为小数点后一位\n    float pos = 0.0f, Motor_Cur_Pos = 0.0f;\n\n    // 定义接收数据数组、接收数据长度\n    uint8_t rxCmd[UART_BUFF_SIZE] = {0};\n    uint32_t rxCount = 0;\n\n    // 读取电机实时位置\n    ZDT_X42_V2_Read_Sys_Params(sliderId, S_CPOS);\n\n    // 等待返回命令，命令数据缓存在数组rxCmd上，长度为rxCount\n    ZDT_X42_V2_Receive_Data(sliderId, rxCmd, &rxCount);\n\n    //将读取的rxCmd[]十六进制编码打印，用于测试调试\n    // printf(\"Received bytes: \");\n    // for (int i = 0; i < 8; i++) {\n    //     printf(\"%02X \", rxCmd[i]);\n    // }\n    // printf(\"\\n\");\n\n    // 获取电机实时角度返回值（电机实时角度返回值放大了10倍返回的，因为要保留1位小数）\n    pos = ((uint32_t)rxCmd[3] << 24) | ((uint32_t)rxCmd[4] << 16) | ((uint32_t)rxCmd[5] << 8) | (uint32_t)rxCmd[6];\n\n    // 缩小10倍，并判断符号，得到真正的实时角度，存放在浮点数变量Motor_Cur_Pos中\n    Motor_Cur_Pos = pos * 0.1f;\n    if (rxCmd[2]) {\n        Motor_Cur_Pos = -Motor_Cur_Pos;\n    }\n\n    // 打印解析后的角度值\n    printf(\"Current position (as angle): %.1f degrees\\n\", Motor_Cur_Pos);\n\n    return Motor_Cur_Pos;\n}\n\nvoid ResetMotorToOrigin(uint8_t sliderId) //电机归零函数\n{\n    //读取电机目前角度\n    float Motor_Cur_Pos = ReadMotorAngle(sliderId);\n\n    float targetPosition = 0; // 目标位置，这里假设为0度\n\n    // 根据当前角度和目标位置计算需要移动的距离\n    float delta = targetPosition - Motor_Cur_Pos;\n\n    // 将 delta 四舍五入到小数点后一位\n    //delta = ((int)(delta * 10 + 0.5)) / 10.0f;\n\n    printf(\"delta: %.1f degrees\\n\", delta);\n\n    // 调用轨迹位置控制函数将电机移动到目标位置\n    ZDT_X42_V2_Traj_Position_Control(sliderId, (delta < 0) ? 1 : 0, Speed_acc, Speed_dec, Speed_max, absolute(delta), motor_raf_0, motor_snf_0);\n}\n\nvoid ParseJson(const char* json)//电机uart运行主函数\n{\n    // 定义JSON键的字符串，根据上位机所需进行定义，格式类型相同\n    const char* labelStr = \"\\\"label\\\":\";\n    const char* motor_EnStr = \"\\\"motor_En\\\":\";\n    const char* sliderIdStr = \"\\\"sliderId\\\":\";\n    const char* valueStr = \"\\\"value\\\":\";\n    \n\n    // 找到JSON字符串中键的位置，用于进行键的连接，等于找到对应的标签\n    char* labelPos = strstr(json, labelStr);\n    char* motor_EnPos = strstr(json, motor_EnStr);\n    char* sliderIdPos = strstr(json, sliderIdStr);\n    char* valuePos = strstr(json, valueStr);\n\n    // 如果找到键，解析其对应的值\n    if (labelPos != NULL && motor_EnPos != NULL && sliderIdPos != NULL && valuePos != NULL) {\n        int label = atoi(labelPos + strlen(labelStr)); // 将label转换为整数\n        int sliderId = atoi(sliderIdPos + strlen(sliderIdStr)); // 将sliderId转换为整数\n\n        //放大30倍，对应谐波减速器\n        int value = atof(valuePos + strlen(valueStr));\n        int motor_En = atoi(motor_EnPos + strlen(motor_EnStr));\n\n        // 打印解析出的值\n        printf(\"label: %d, motor_En: %d, Slider ID: %d, Value: %d\\n\", label, motor_En, sliderId, value);\n\n        // 根据Slider ID和Value执行相应的操作\n        if (label == 1) \n        {\n            if (sliderId == 1){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            } \n            else if (sliderId == 2){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 3){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 4){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 5){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n            else if (sliderId == 6){\n                if(motor_En == 1){\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 使能\n                }\n                else{\n                    ZDT_X42_V2_En_Control(sliderId, motor_En, motor_snf_0);  // 失能\n                }\n            }\n        } \n        else if (label == 2) \n        {\n            if (sliderId == 1){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            } \n            else if (sliderId == 2){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 3){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 4){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 5){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            else if (sliderId == 6){\n                float value_before = ReadMotorAngle(sliderId);  //读取电机现在角度值\n                float delta_value = value - value_before;  // 计算想要的变化值\n                if (delta_value <= 0) {  //利用值的正负，判断电机正反转\n                    //正转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码\n                }\n                else{\n                    //反转\n                    ZDT_X42_V2_Traj_Position_Control(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, absolute(delta_value), motor_raf_0, motor_snf_0);\n                    //IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码\n                }\n            }\n            \n        }\n        else if (label == 3) //电机紧急停机\n        {\n            ZDT_X42_V2_Stop_Now(1, 0);  //调用停机函数\n            usleep(50);  //延时确保函数依次执行\n            ZDT_X42_V2_Stop_Now(2, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(3, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(4, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(5, 0);\n            usleep(50);\n            ZDT_X42_V2_Stop_Now(6, 0);\n            usleep(50);\n        }\n        else if (label == 4) //电机复位函数\n        {\n            ResetMotorToOrigin(1);  //调用复位函数\n            usleep(50);  //延时确保函数依次执行\n            ResetMotorToOrigin(2);\n            usleep(50);\n            ResetMotorToOrigin(3);\n            usleep(50);\n            ResetMotorToOrigin(4);\n            usleep(50);\n            ResetMotorToOrigin(5);\n            usleep(50);\n            ResetMotorToOrigin(6);\n            usleep(50);\n        }\n    }\n}\n\nvoid Task1(void)//系统主函数\n{\n    int socket_fd = 0;\n    char buff[256];\n    int re = 0;\n\n    uint32_t count_0 = 0;\n    uint32_t len_0 = 0;\n    unsigned char uartReadBuff_0[UART_BUFF_SIZE] = {0};\n\n    // 对UART1的一些初始化 Some initialization of UART1\n    Uart1GpioInit();\n    // 对UART1参数的一些配置 Some configurations of UART1 parameters\n    Uart1Config();\n\n    // 连接Wifi\n    WiFi_connectHotspots(\"esp32\", \"12345678\");\n    socket_fd = socket(AF_INET, SOCK_STREAM, 0); // 创建套接字（TCP）\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(TCP_SERVER_PORT);\n    addr.sin_addr.s_addr = inet_addr(TCP_SERVER_IP); // 填写服务器的IP地址\n\n    re = connect(socket_fd, (struct sockaddr *)&addr, sizeof(addr)); // 连接服务器\n    if (re == -1) {\n        printf(\"Failed to connect to the server\\r\\n\");\n        return;\n    }\n    printf(\"Connection to server successful\\r\\n\");\n\n    // 发送第一条数据\n    send(socket_fd, \"Connection to server successful.\", strlen(\"Connection to server successful.\"), 0);\n\n    while (1) {\n        memset_s(buff, sizeof(buff), 0, sizeof(buff));\n        re = recv(socket_fd, buff, sizeof(buff), 0); //\t接收客户端发送过来的消息\n        if (re <= 0) \n        {\n            break;\n        } else {\n            ParseJson(buff);//执行控制主函数\n        }\n    }\n    close(socket_fd);\n}\n\nvoid UartExampleEntry(void)//配置上报函数\n{\n    //osThreadAttr_t attr;\n    IoTWatchDogDisable();\n\n    osThreadAttr_t options;\n    options.name = \"thread_1\";\n    options.attr_bits = 0;\n    options.cb_mem = NULL;\n    options.cb_size = 0;\n    options.stack_mem = NULL;\n    options.stack_size = TASK_STACK_SIZE;\n    options.priority = osPriorityNormal;\n\n    Task1_ID = osThreadNew((osThreadFunc_t)Task1, NULL, &options);\n    if (Task1_ID != NULL) {\n        printf(\"ID = %d, Create Task1_ID is OK!\\r\\n\", Task1_ID);\n    }\n}\n\nAPP_FEATURE_INIT(UartExampleEntry);\n```\n\n","slug":"20240429ZYY-Hi3861开发","published":1,"updated":"2024-07-31T03:32:00.809Z","_id":"clz9aaxqc000mygfb55nsep1j","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Hi3861开发\"><a href=\"#Hi3861开发\" class=\"headerlink\" title=\"Hi3861开发\"></a>Hi3861开发</h1><h2 id=\"一、学习资料\"><a href=\"#一、学习资料\" class=\"headerlink\" title=\"一、学习资料\"></a>一、学习资料</h2><ul>\n<li><p>【UART串口使用】<a href=\"https://blog.csdn.net/qq_36347513/article/details/121603716\">HI3861学习笔记（18）——UART串口使用_hi3861 uart-CSDN博客</a></p>\n</li>\n<li><p>【开发环境搭建】[2.1 Pegasus开发环境搭建.md · HiSpark&#x2F;HiSpark_NICU2023 - Gitee.com](<a href=\"https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1\">https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1</a> Pegasus开发环境搭建.md)</p>\n</li>\n<li><p>【入门demo】<a href=\"https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-ide-3861-helloworld.md\">编写 Hello World”程序 (openharmony.cn)</a></p>\n</li>\n<li><p>【UART串口读取】<a href=\"https://bbs.huaweicloud.com/blogs/detail/281809\">HarmonyOS小熊派 | HarmonyOS基础外设开发–UART数据读写-云社区-华为云 (huaweicloud.com)</a></p>\n</li>\n<li><p>【QT转EXE格式】<a href=\"https://www.cnblogs.com/JinShanCheShen/p/16194526.html\">QT打包成exe详细步骤 - 西北小蚂蚁 - 博客园 (cnblogs.com)</a></p>\n</li>\n<li><p>【QT转EXE格式编译报错】<a href=\"https://blog.csdn.net/weijifen000/article/details/102537640\">Qt软件打包后报错“无法定位程序输入点_ZN10QArrayData10deallocateEPs_jj于动态链接库….. .exe上。”解决办法-CSDN博客</a></p>\n</li>\n</ul>\n<h2 id=\"二、QT开发\"><a href=\"#二、QT开发\" class=\"headerlink\" title=\"二、QT开发\"></a>二、QT开发</h2><ul>\n<li><p>geometry里的宽度、高度是分辨率，比如geometry设置为宽<em>高为1920</em>1080</p>\n</li>\n<li><p>【窗口自适应】<a href=\"https://cloud.tencent.com/developer/article/2286080\">【QT】QT Designer控件随窗口大小自适应-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p>【串口发送】<a href=\"https://blog.csdn.net/qq_26904271/article/details/132646641\">QT串口助手：识别串口号，发送，接收，十六进制_qt串口发送16进制数据-CSDN博客</a></p>\n</li>\n<li><p>foreach是QT中的一个关键字，其作用是对第二个参数中的对象进行遍历，把遍历过程中的每个对象依次赋给第一个参数，并执行花括号中的内容。在这里，就是把可获取的串口列表availablePorts()中的串口，逐个将其串口号添加到combobox中。</p>\n</li>\n</ul>\n<h3 id=\"1-串口设定\"><a href=\"#1-串口设定\" class=\"headerlink\" title=\"1.串口设定\"></a>1.串口设定</h3><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"> \t<span class=\"hljs-comment\">//mainwindow.h文件调用串口头文件</span><br> \t<span class=\"hljs-comment\">//串口头文件</span><br> \t#include &lt;QSerialPort&gt;<br>#include &lt;QSerialPortInfo&gt;<br> \t<br> \t<span class=\"hljs-comment\">//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br> \t<span class=\"hljs-comment\">//使用foreach函数查找串口信息</span><br>foreach (const QSerialPortInfo &amp;portInfo,QSerialPortInfo::availablePorts()) <br> \t&#123;<br>     <span class=\"hljs-comment\">//将所有搜索的值写入serialport端口当中</span><br>     <span class=\"hljs-function\"><span class=\"hljs-title\">ui</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">serialport</span>-&gt;</span>addItem(portInfo.portName());<br> \t&#125;<br> \t<span class=\"hljs-comment\">//打开串口</span><br> \t<span class=\"hljs-function\"><span class=\"hljs-title\">serialPort</span>-&gt;</span>open();<br> \t<span class=\"hljs-comment\">//关闭串口</span><br> \t<span class=\"hljs-function\"><span class=\"hljs-title\">serialPort</span>-&gt;</span>close();<br> \t<br> \t<span class=\"hljs-comment\">//串口写入</span><br> \t<span class=\"hljs-function\"><span class=\"hljs-title\">serialPort</span>-&gt;</span>write(<span class=\"hljs-string\">&quot;*****&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-读取下拉选项内容并赋予\"><a href=\"#2-读取下拉选项内容并赋予\" class=\"headerlink\" title=\"2.读取下拉选项内容并赋予\"></a>2.读取下拉选项内容并赋予</h3><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//mainwindow.cpp文件中，自定义函数设定</span><br><br><span class=\"hljs-comment\">//定义参数格式为QString</span><br>QString mBaudrate;<span class=\"hljs-comment\">//波特率</span><br>QString mStopBits;<span class=\"hljs-comment\">//停止位字节</span><br>   QString mDataBits;<span class=\"hljs-comment\">//数据字节</span><br>   QString mParity;<span class=\"hljs-comment\">//奇偶校验</span><br>   <br><span class=\"hljs-comment\">//读取baudrate槽中currentText()所选定的内容，后续类似</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mBaudrate</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">baudrate</span>-&gt;</span>currentText();<br><span class=\"hljs-function\"><span class=\"hljs-title\">mStopBits</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">stopbits</span>-&gt;</span>currentText();<br>   <span class=\"hljs-function\"><span class=\"hljs-title\">mDataBits</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">databits</span>-&gt;</span>currentText();<br>   <span class=\"hljs-function\"><span class=\"hljs-title\">mParity</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">parity</span>-&gt;</span>currentText();<br><br><span class=\"hljs-comment\">//判断起选定内容是否符合需求，并赋予相应操作</span><br><span class=\"hljs-keyword\">if</span>(mBaudrate == <span class=\"hljs-string\">&quot;9600&quot;</span>) <br>&#123;<br>\t<span class=\"hljs-comment\">//将串口波特率设定为9600</span><br>       mSerialPort.setBaudRate(QSerialPort::Baud9600);<span class=\"hljs-comment\">//Baud9600、Baud115200</span><br>       mSerialPort.setStopBits(QSerialPort::OneStop);<span class=\"hljs-comment\">//OneStop-1、OneAndHalfStop-1.5、TwoStop-2</span><br>       mSerialPort.setDataBits(QSerialPort::Data5);<span class=\"hljs-comment\">//Data5、Data6、Data7、Data8</span><br>       mSerialPort.setParity(QSerialPort::OddParity);<span class=\"hljs-comment\">//OddParity-奇校验、EvenParity-偶校验、NoParity无校验</span><br>   &#125; <br>   <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(mBaudrate == <span class=\"hljs-string\">&quot;115200&quot;</span>) <br>   &#123;<br>   \t<span class=\"hljs-comment\">//将串口波特率设定为115200</span><br>       mSerialPort.setBaudRate(QSerialPort::Baud19200);<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-摄像头设定\"><a href=\"#3-摄像头设定\" class=\"headerlink\" title=\"3.摄像头设定\"></a>3.摄像头设定</h3><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-comment\">//***.pro格式文件加入multimediawidgets</span><br>QT       += core gui multimediawidgets<br><br><span class=\"hljs-comment\">//mainwindow.h文件调用摄像头头文件</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QCameraImageCapture&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QCamera&gt;</span></span><br><br><span class=\"hljs-comment\">//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br><span class=\"hljs-comment\">//获取系统的所有可用的摄像头</span><br>foreach(const QCameraInfo <span class=\"hljs-variable\">&amp;</span>cameraInfo , QCameraInfo::availableCameras())<br>   <span class=\"hljs-punctuation\">&#123;</span><br>       <span class=\"hljs-comment\">//将所有搜索的值写入cameraBox端口当中</span><br>       ui-&gt;cameraBox-&gt;addItem(cameraInfo.deviceName())<span class=\"hljs-punctuation\">;</span><br>   <span class=\"hljs-punctuation\">&#125;</span><br>   <br>   <span class=\"hljs-comment\">//打开摄像头</span><br>   cameraPort-&gt;start()<span class=\"hljs-punctuation\">;</span><br>   <span class=\"hljs-comment\">//关闭摄像头</span><br>   cameraPort-&gt;stop()<span class=\"hljs-punctuation\">;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-QT中setCheckable-的作用\"><a href=\"#4-QT中setCheckable-的作用\" class=\"headerlink\" title=\"4.QT中setCheckable()的作用\"></a>4.QT中setCheckable()的作用</h3><p>setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。</p>\n<h3 id=\"5-TCP通讯\"><a href=\"#5-TCP通讯\" class=\"headerlink\" title=\"5.TCP通讯\"></a>5.TCP通讯</h3><figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs zephir\"><span class=\"hljs-comment\">//***.pro格式文件加入network</span><br>QT       += network<br><br><span class=\"hljs-comment\">//mainwindow.h头文件中引用</span><br>#include &lt;QTcpServer&gt;<br>#include &lt;QTcpSocket&gt;<br><span class=\"hljs-comment\">//定义*socket和*server用来存放服务器的套接字和监听，用于与客户端进行通信</span><br>QTcpSocket *socket;<br>   QTcpServer *server;<br><br><span class=\"hljs-comment\">//mainwindow.cpp文件中MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br><span class=\"hljs-comment\">//setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。</span><br>ui-&gt;Monitor_OPEN-&gt;setCheckable(<span class=\"hljs-keyword\">true</span>);<span class=\"hljs-comment\">//简而言之就是按键的常开和常闭切换</span><br><span class=\"hljs-comment\">//创建服务器的套接字，用于与客户端进行通信</span><br>socket = <span class=\"hljs-keyword\">new</span> QTcpSocket();<br><span class=\"hljs-comment\">//声明一个QTcpserver的对象，用于监听</span><br>   server = <span class=\"hljs-keyword\">new</span> QTcpServer();<br>   <span class=\"hljs-comment\">//信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据</span><br>   connect(server,SIGNAL(newConnection()),this,SLOT(newConnection_SLOT()));<br>   <br>   <span class=\"hljs-comment\">//定义新函数MainWindow::newConnection_SLOT()，用于新的客户端连接建立槽函数：获取客户端套接字，允许写入数据</span><br>   void MainWindow::newConnection_SLOT()<br>   &#123;<br>       socket = server-&gt;nextPendingConnection(); <span class=\"hljs-comment\">//获取已经连接的客户端套接字</span><br>       connect(socket,SIGNAL(readyRead()),this,SLOT(readyRead_SLOT()));<span class=\"hljs-comment\">//如果socket中有缓存消息，触发槽函数</span><br>   &#125;<br>   <br>   <span class=\"hljs-comment\">//定义新函数MainWindow::readyRead_SLOT()，用于接收消息并显示到接收框</span><br>   void MainWindow::readyRead_SLOT()<br>   &#123;<br>       qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Server Received!&quot;</span>;<br>       QString buffer;<span class=\"hljs-comment\">//定义容器</span><br>       <span class=\"hljs-comment\">//读取缓冲区数据</span><br>       buffer = socket-&gt;readAll();<br>       <span class=\"hljs-keyword\">if</span>(!buffer.isEmpty())<br>       &#123;<br>           <span class=\"hljs-comment\">//刷新显示，写入Receive_text组件，组件类型为Plain Text Line</span><br>           ui-&gt;Receive_text-&gt;appendPlainText(buffer);<br>       &#125;<br>   &#125;<br>   <br>   <span class=\"hljs-comment\">//连接组件函数，按下开始监听组件Monitor_OPEN，类型为clicked(bool checked)，执行监听程序</span><br>   void MainWindow::on_Monitor_OPEN_clicked(<span class=\"hljs-keyword\">bool</span> checked)<br>   &#123;<br>       <span class=\"hljs-keyword\">if</span>(checked)<span class=\"hljs-comment\">//如果按下了</span><br>       &#123;<br>           <span class=\"hljs-keyword\">int</span> port = ui-&gt;PORT_TEXT-&gt;text().toUInt();<br>           <span class=\"hljs-comment\">//如果未监听到</span><br>           <span class=\"hljs-keyword\">if</span>(!server-&gt;listen(QHostAddress::Any, port))<br>           &#123;<br>               qDebug() &lt;&lt; server-&gt;errorString();<br>               <span class=\"hljs-comment\">//连接失败，再次点击则重新连接，将checked恢复为true</span><br>               ui-&gt;Monitor_OPEN-&gt;toggle();<br>               <span class=\"hljs-keyword\">return</span>;<br>           &#125;<br>           qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Listen Successfully! Message from port:&quot;</span> &lt;&lt; port;<br>           <span class=\"hljs-comment\">//修改按钮文字</span><br>           ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;停止监听&quot;</span>);<br>           <span class=\"hljs-comment\">//发送键使能</span><br>           ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">true</span>);<br>       &#125;<br>       <span class=\"hljs-keyword\">else</span><br>       &#123;<br>            qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Stop Listening!&quot;</span>;<br>           <span class=\"hljs-comment\">//如果已经连接则断开连接</span><br>           <span class=\"hljs-keyword\">if</span>(socket-&gt;state() == QAbstractSocket::ConnectedState)<br>           &#123;<br>               <span class=\"hljs-comment\">//断开连接</span><br>               socket-&gt;disconnectFromHost();<br>           &#125;<br>           <span class=\"hljs-comment\">//关闭倾听服务</span><br>           server-&gt;close();<br>           <span class=\"hljs-comment\">//修改按钮文字&amp;发送键静默</span><br>           ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;开始监听&quot;</span>);<br>           ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">false</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-滑动槽设定\"><a href=\"#6-滑动槽设定\" class=\"headerlink\" title=\"6.滑动槽设定\"></a>6.滑动槽设定</h3><ul>\n<li>首先使用setRange()方法设置了滑动条的范围为0到100，然后使用setValue()方法设置了滑动条的当前值为50。通过value()方法可以获取当前滑动条的值。最后，使用connect()方法监听了滑动条的值变化，当值发生变化时，会调用onSliderValueChanged()槽函数。</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">// 假设有一个QSlider对象名为slider<br>// 设置滑动条的范围<br>slider-&gt;setRange(-180, 180);<br><br>// 设置滑动条的当前值<br>slider-&gt;setValue(0);<br><br>// 获取滑动条的当前值<br>int currentValue = slider-&gt;value();<br><br>// 监听滑动条的值变化<br>connect(slider, SIGNAL(valueChanged(int)), this, SLOT(onSliderValueChanged(int)));<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>slider 提供了两个自然的步长；较大的步长用 pageStep 表示，相当于按下键盘上的 PageDown 和 PageUp，也相当于鼠标点击时移动的步进值:；较小的步长用 singleStep 表示，相当于按下键盘上的上、下键；</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">// 设置移动每页的步长，滑块提供的两个自然步长中较大的那一个，相当于键盘上的 PageUp 和 PageDown；</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">horizontalSlider</span>-&gt;</span>setPageStep(<span class=\"hljs-number\">10</span>);<br><br><span class=\"hljs-comment\">// 获取 每页的步长</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">int</span> step = horizontalSlider-&gt;</span>pageStep();<br><br><span class=\"hljs-comment\">// 设置移动单步的步长，滑块提供的两个自然步长中较小的那一个，相当于键盘上的上、下箭头；</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">horizontalSlider</span>-&gt;</span>setSingleStep(<span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-comment\">// 获取 单步的步长</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">int</span> step =horizontalSlider-&gt;</span>singleStep();<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>设置是否启用滑块追踪：</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">// 设置是否启动滑块追踪：true 表示启动追踪；false 表示禁用追踪；</span><br><span class=\"hljs-comment\">// 如果启用了滑块追踪，则滑块在拖动过程中会一直触发 valueChanged 信号；</span><br><span class=\"hljs-comment\">// 如果禁用了滑块追踪，则滑块在拖动过程中不会触发 valueChanged 信号，</span><br><span class=\"hljs-comment\">// 只有在用户释放滑块时，才触发 valueChanged 信号。</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">horizontalSlider</span>-&gt;</span>setTracking(<span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">// 可以通过 hasTracking 属性获取是否启用了追踪：</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">bool</span> isTrack = horizontalSlider-&gt;</span>hasTracking();<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>槽函数设定</li>\n</ul>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">valueChanged</span>()<span class=\"hljs-comment\">//值被改变</span><br><span class=\"hljs-built_in\">sliderPressed</span>()<span class=\"hljs-comment\">//滑块被点击</span><br><span class=\"hljs-built_in\">sliderMoved</span>()<span class=\"hljs-comment\">//滑块移动</span><br><span class=\"hljs-built_in\">sliderReleased</span>();<span class=\"hljs-comment\">//滑块被释放</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、TCP通讯\"><a href=\"#三、TCP通讯\" class=\"headerlink\" title=\"三、TCP通讯\"></a>三、TCP通讯</h2><p>【TCP通信】<a href=\"https://blog.csdn.net/qq_36347513/article/details/123099617\">HI3861学习笔记（20）——TCP客户端_hi3861 at tcp 指令 erre-CSDN博客</a></p>\n<p>【TCP通信】<a href=\"https://blog.csdn.net/baidu_29900103/article/details/117970891\">教你动手写TCP上位机与小熊派通信_小熊派设备的tcp通信-CSDN博客</a></p>\n<h2 id=\"四、下位机代码\"><a href=\"#四、下位机代码\" class=\"headerlink\" title=\"四、下位机代码\"></a>四、下位机代码</h2><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_gpio_ex.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ohos_init.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;cmsis_os2.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_gpio.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_uart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;hi_uart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_watchdog.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_errno.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;hal_bsp_pcf8574.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;hal_bsp_wifi.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;wifi_device.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lwip/netifapi.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lwip/sockets.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lwip/api_shell.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>    ABS(x)    ((x) &gt; 0 ? (x) : -(x))</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> UART_BUFF_SIZE 100</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> U_SLEEP_TIME   500000</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> UART_TIMEOUT_MS 20   <span class=\"hljs-comment\">// 设置超时时间为100毫秒</span></span><br><br>osThreadId_t Task1_ID; <span class=\"hljs-comment\">// 任务1设置为低优先级任务</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TASK_STACK_SIZE (1024 * 10)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TCP_SERVER_IP <span class=\"hljs-string\">&quot;192.168.245.23&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TCP_SERVER_PORT 8888</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DIR_pos 1 <span class=\"hljs-comment\">// 正方向</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DIR_neg 0 <span class=\"hljs-comment\">// 反方向</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> Speed_acc 1000 <span class=\"hljs-comment\">// 加速度</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> Speed_dec 1000 <span class=\"hljs-comment\">// 减速度</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> Speed_max 2000.0f <span class=\"hljs-comment\">// 最大速度</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_raf_0 0 <span class=\"hljs-comment\">// 相位位置标志</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_raf_1 1 <span class=\"hljs-comment\">//绝对位置标志</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_snf_0 0 <span class=\"hljs-comment\">// 多机同步运动标志</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_snf_1 0 <span class=\"hljs-comment\">// 单机运动标志</span></span><br><br><span class=\"hljs-comment\">//读取数据的枚举值</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span> &#123;<br>  S_VER   = <span class=\"hljs-number\">0</span>,      <span class=\"hljs-comment\">/* 读取固件版本和对应的硬件版本 */</span><br>  S_RL    = <span class=\"hljs-number\">1</span>,      <span class=\"hljs-comment\">/* 读取读取相电阻和相电感 */</span><br>  S_PID   = <span class=\"hljs-number\">2</span>,      <span class=\"hljs-comment\">/* 读取PID参数 */</span><br>  S_ORG   = <span class=\"hljs-number\">3</span>,      <span class=\"hljs-comment\">/* 读取回零参数 */</span><br>  S_VBUS  = <span class=\"hljs-number\">4</span>,      <span class=\"hljs-comment\">/* 读取总线电压 */</span><br>  S_CBUS  = <span class=\"hljs-number\">5</span>,      <span class=\"hljs-comment\">/* 读取总线电流 */</span><br>  S_CPHA  = <span class=\"hljs-number\">6</span>,      <span class=\"hljs-comment\">/* 读取相电流 */</span><br>  S_ENC   = <span class=\"hljs-number\">7</span>,      <span class=\"hljs-comment\">/* 读取编码器原始值 */</span><br>  S_CPUL  = <span class=\"hljs-number\">8</span>,      <span class=\"hljs-comment\">/* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */</span><br>  S_ENCL  = <span class=\"hljs-number\">9</span>,      <span class=\"hljs-comment\">/* 读取经过线性化校准后的编码器值 */</span><br>  S_TPUL  = <span class=\"hljs-number\">10</span>,     <span class=\"hljs-comment\">/* 读取输入脉冲数 */</span><br>  S_TPOS  = <span class=\"hljs-number\">11</span>,     <span class=\"hljs-comment\">/* 读取电机目标位置 */</span><br>  S_OPOS  = <span class=\"hljs-number\">12</span>,     <span class=\"hljs-comment\">/* 读取电机实时设定的目标位置（开环模式的实时位置） */</span><br>  S_VEL   = <span class=\"hljs-number\">13</span>,     <span class=\"hljs-comment\">/* 读取电机实时转速 */</span><br>  S_CPOS  = <span class=\"hljs-number\">14</span>,     <span class=\"hljs-comment\">/* 读取电机实时位置（基于角度编码器累加的电机实时位置） */</span><br>  S_PERR  = <span class=\"hljs-number\">15</span>,     <span class=\"hljs-comment\">/* 读取电机位置误差 */</span><br>  S_TEMP  = <span class=\"hljs-number\">16</span>,     <span class=\"hljs-comment\">/* 读取电机实时温度 */</span><br>  S_SFLAG = <span class=\"hljs-number\">17</span>,     <span class=\"hljs-comment\">/* 读取状态标志位 */</span><br>  S_OFLAG = <span class=\"hljs-number\">18</span>,     <span class=\"hljs-comment\">/* 读取回零状态标志位 */</span><br>  S_Conf  = <span class=\"hljs-number\">19</span>,     <span class=\"hljs-comment\">/* 读取驱动参数 */</span><br>  S_State = <span class=\"hljs-number\">20</span>,     <span class=\"hljs-comment\">/* 读取系统状态参数 */</span><br>&#125;SysParams_t;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Uart1GpioInit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//对UART和LED引脚进行初始化</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">IoTGpioInit</span>(IOT_IO_NAME_GPIO_6);<br>    <span class=\"hljs-comment\">// 设置GPIO0的管脚复用关系为UART1_TX Set the pin reuse relationship of GPIO0 to UART1_ TX</span><br>    <span class=\"hljs-built_in\">IoSetFunc</span>(IOT_IO_NAME_GPIO_6, IOT_IO_FUNC_GPIO_6_UART1_TXD);<br>    <br>    <span class=\"hljs-built_in\">IoTGpioInit</span>(IOT_IO_NAME_GPIO_5);<br>    <span class=\"hljs-comment\">// 设置GPIO1的管脚复用关系为UART1_RX Set the pin reuse relationship of GPIO1 to UART1_ RX</span><br>    <span class=\"hljs-built_in\">IoSetFunc</span>(IOT_IO_NAME_GPIO_5, IOT_IO_FUNC_GPIO_5_UART1_RXD);<br><br>    <span class=\"hljs-comment\">// LED3的GPIO初始化 GPIO initialization of LED3</span><br>    <span class=\"hljs-built_in\">IoTGpioInit</span>(IOT_IO_NAME_GPIO_2);<br>    <span class=\"hljs-comment\">// 设置GPIO9的管脚复用关系为GPIO Set the pin reuse relationship of GPIO9 to GPIO</span><br>    <span class=\"hljs-built_in\">IoSetFunc</span>(IOT_IO_NAME_GPIO_2, IOT_IO_FUNC_GPIO_2_GPIO);<br>    <span class=\"hljs-comment\">// GPIO方向设置为输出 GPIO direction set to output</span><br>    <span class=\"hljs-built_in\">IoTGpioSetDir</span>(IOT_IO_NAME_GPIO_2, IOT_GPIO_DIR_OUT);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Uart1Config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//对UART配置初始化</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">uint32_t</span> ret;<br>    <span class=\"hljs-comment\">/* 初始化UART配置，波特率 115200，数据bit为8,停止位1，奇偶校验为NONE */</span><br>    <span class=\"hljs-comment\">/* Initialize UART configuration, baud rate is 9600, data bit is 8, stop bit is 1, parity is NONE */</span><br>    IotUartAttribute uart_attr = &#123;<br>        .baudRate = <span class=\"hljs-number\">115200</span>,<br>        .dataBits = <span class=\"hljs-number\">8</span>,<br>        .stopBits = <span class=\"hljs-number\">1</span>,<br>        .parity = <span class=\"hljs-number\">0</span>,<br>    &#125;;<br><br>    <span class=\"hljs-comment\">//uart初始化返回值</span><br>    ret = <span class=\"hljs-built_in\">IoTUartInit</span>(HI_UART_IDX_1, &amp;uart_attr);<br>    <span class=\"hljs-comment\">//判断uart是否连接成功</span><br>    <span class=\"hljs-keyword\">if</span> (ret != IOT_SUCCESS) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Init Uart1 Falied Error No : %d\\n&quot;</span>, ret);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_En_Control</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">int</span> state, <span class=\"hljs-type\">uint8_t</span> snF)</span><span class=\"hljs-comment\">//电机使能控制函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-comment\">//定义发送命令数组</span><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>  <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>] =  <span class=\"hljs-number\">0xF3</span>;                       <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>] =  <span class=\"hljs-number\">0xAB</span>;                       <span class=\"hljs-comment\">// 辅助码</span><br>    cmd[<span class=\"hljs-number\">3</span>] =  (<span class=\"hljs-type\">uint8_t</span>)state;             <span class=\"hljs-comment\">// 使能状态</span><br>    cmd[<span class=\"hljs-number\">4</span>] =  snF;                        <span class=\"hljs-comment\">// 多机同步运动标志</span><br>    cmd[<span class=\"hljs-number\">5</span>] =  <span class=\"hljs-number\">0x6B</span>;                       <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">6</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//电机驱动函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Traj_Position_Control</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> dir, <span class=\"hljs-type\">uint16_t</span> acc, <span class=\"hljs-type\">uint16_t</span> dec, <span class=\"hljs-type\">float</span> velocity, <span class=\"hljs-type\">float</span> position, <span class=\"hljs-type\">uint8_t</span> raf, <span class=\"hljs-type\">uint8_t</span> snF)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-comment\">//定义发送命令数组</span><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">32</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <span class=\"hljs-type\">uint16_t</span> vel = <span class=\"hljs-number\">0</span>; <span class=\"hljs-type\">uint32_t</span> pos = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">// 将速度和位置放大10倍发送过去</span><br>    vel = (<span class=\"hljs-type\">uint16_t</span>)<span class=\"hljs-built_in\">ABS</span>(velocity * <span class=\"hljs-number\">10.0f</span>); <br>    pos = (<span class=\"hljs-type\">uint32_t</span>)<span class=\"hljs-built_in\">ABS</span>(position * <span class=\"hljs-number\">10.0f</span>);<br><br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>]  =  addr;                      <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>]  =  <span class=\"hljs-number\">0xFD</span>;                      <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>]  =  dir;                       <span class=\"hljs-comment\">// 符号（方向）</span><br>    cmd[<span class=\"hljs-number\">3</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(acc &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 加速加速度(RPM/s)高8位字节</span><br>    cmd[<span class=\"hljs-number\">4</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(acc &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 加速加速度(RPM/s)低8位字节  </span><br>    cmd[<span class=\"hljs-number\">5</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(dec &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 减速加速度(RPM/s)高8位字节</span><br>    cmd[<span class=\"hljs-number\">6</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(dec &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 减速加速度(RPM/s)低8位字节  </span><br>    cmd[<span class=\"hljs-number\">7</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(vel &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 最大速度(RPM)高8位字节</span><br>    cmd[<span class=\"hljs-number\">8</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(vel &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 最大速度(RPM)低8位字节 </span><br>    cmd[<span class=\"hljs-number\">9</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">24</span>);      <span class=\"hljs-comment\">// 位置(bit24 - bit31)</span><br>    cmd[<span class=\"hljs-number\">10</span>] =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">16</span>);      <span class=\"hljs-comment\">// 位置(bit16 - bit23)</span><br>    cmd[<span class=\"hljs-number\">11</span>] =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 位置(bit8  - bit15)</span><br>    cmd[<span class=\"hljs-number\">12</span>] =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 位置(bit0  - bit7 )</span><br>    cmd[<span class=\"hljs-number\">13</span>] =  raf;                       <span class=\"hljs-comment\">// 相位位置/绝对位置标志</span><br>    cmd[<span class=\"hljs-number\">14</span>] =  snF;                       <span class=\"hljs-comment\">// 多机同步运动标志</span><br>    cmd[<span class=\"hljs-number\">15</span>] =  <span class=\"hljs-number\">0x6B</span>;                      <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">16</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Origin_Trigger_Return</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> o_mode, <span class=\"hljs-type\">bool</span> snF)</span><span class=\"hljs-comment\">//电机归零函数，没啥用，需要外界碰撞或者限位，该文件未使用此函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>] =  <span class=\"hljs-number\">0x9A</span>;                       <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>] =  o_mode;                     <span class=\"hljs-comment\">// 回零模式，0为单圈就近回零，1为单圈方向回零，2为多圈无限位碰撞回零，3为多圈有限位开关回零</span><br>    cmd[<span class=\"hljs-number\">3</span>] =  snF;                        <span class=\"hljs-comment\">// 多机同步运动标志，false为不启用，true为启用</span><br>    cmd[<span class=\"hljs-number\">4</span>] =  <span class=\"hljs-number\">0x6B</span>;                       <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">5</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Stop_Now</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> snF)</span><span class=\"hljs-comment\">//立即停机</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>] =  <span class=\"hljs-number\">0xFE</span>;                       <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>] =  <span class=\"hljs-number\">0x98</span>;                       <span class=\"hljs-comment\">// 辅助码</span><br>    cmd[<span class=\"hljs-number\">3</span>] =  snF;                        <span class=\"hljs-comment\">// 多机同步运动标志</span><br>    cmd[<span class=\"hljs-number\">4</span>] =  <span class=\"hljs-number\">0x6B</span>;                       <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">5</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">IoTUartFlush</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span> <span class=\"hljs-comment\">//串口清空函数，用于进行清空UART内部缓存，不然会出现读取错误</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义要存储数组</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">128</span>];<br><br>    <span class=\"hljs-comment\">//定义读取值</span><br>    <span class=\"hljs-type\">int</span> read;<br><br>    <span class=\"hljs-keyword\">do</span> &#123;<br>        <span class=\"hljs-comment\">//将读取值全部存入数组当中，从而达到清空效果</span><br>        read = <span class=\"hljs-built_in\">IoTUartRead</span>(id, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));<br>    &#125; <span class=\"hljs-keyword\">while</span> (read &gt; <span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-keyword\">return</span> IOT_SUCCESS;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Read_Sys_Params</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, SysParams_t s)</span><span class=\"hljs-comment\">//读取电机的实时位置</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义发送数组</span><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>  <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br><br>    <span class=\"hljs-comment\">//对功能码进行选择</span><br>    <span class=\"hljs-keyword\">switch</span>(s)                             <span class=\"hljs-comment\">// 功能码</span><br>    &#123;<br>        <span class=\"hljs-keyword\">case</span> S_VER   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x1F</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取固件版本和对应的硬件版本 */</span><br>        <span class=\"hljs-keyword\">case</span> S_RL    : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x20</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取读取相电阻和相电感 */</span><br>        <span class=\"hljs-keyword\">case</span> S_PID   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x21</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取PID参数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_ORG   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x22</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取回零参数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_VBUS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x24</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取总线电压 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CBUS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x26</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取总线电流 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CPHA  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x27</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取相电流 */</span><br>        <span class=\"hljs-keyword\">case</span> S_ENC   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x29</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取编码器原始值 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CPUL  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x30</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */</span><br>        <span class=\"hljs-keyword\">case</span> S_ENCL  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x31</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取经过线性化校准后的编码器值 */</span><br>        <span class=\"hljs-keyword\">case</span> S_TPUL  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x32</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取输入脉冲数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_TPOS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x33</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机目标位置 */</span><br>        <span class=\"hljs-keyword\">case</span> S_OPOS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x34</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时设定的目标位置（开环模式的实时位置） */</span><br>        <span class=\"hljs-keyword\">case</span> S_VEL   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x35</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时转速 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CPOS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x36</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时位置（基于角度编码器累加的电机实时位置） */</span><br>        <span class=\"hljs-keyword\">case</span> S_PERR  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x37</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机位置误差 */</span><br>        <span class=\"hljs-keyword\">case</span> S_TEMP  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x39</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时温度 */</span><br>        <span class=\"hljs-keyword\">case</span> S_SFLAG : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x3A</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取状态标志位 */</span><br>        <span class=\"hljs-keyword\">case</span> S_OFLAG : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x3B</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取回零状态标志位 */</span><br>        <span class=\"hljs-keyword\">case</span> S_Conf  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x42</span>; cmd[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0x6C</span>; <span class=\"hljs-keyword\">break</span>;   <span class=\"hljs-comment\">/* 读取驱动参数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_State : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x43</span>; cmd[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0x7A</span>; <span class=\"hljs-keyword\">break</span>;   <span class=\"hljs-comment\">/* 读取系统状态参数 */</span><br>        <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 如果需要四字节，将校验字节放在 cmd[3]</span><br>    cmd[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0x6B</span>; <br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">3</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Receive_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> *rxCmd, <span class=\"hljs-type\">uint32_t</span> *rxCount)</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">uint32_t</span> startTime = <span class=\"hljs-built_in\">osKernelGetTickCount</span>();  <span class=\"hljs-comment\">// 获取当前系统时间</span><br>    <span class=\"hljs-type\">uint8_t</span> buffer[UART_BUFF_SIZE];<br>    <span class=\"hljs-type\">int</span> len;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        len = <span class=\"hljs-built_in\">IoTUartRead</span>(HI_UART_IDX_1, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));  <span class=\"hljs-comment\">// 从UART读取数据</span><br>        <span class=\"hljs-keyword\">if</span> (len &gt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">// 将读取的数据复制到rxCmd数组中，确保不会溢出</span><br>            <span class=\"hljs-type\">uint32_t</span> copySize = (*rxCount + len &gt; UART_BUFF_SIZE) ? (UART_BUFF_SIZE - *rxCount) : len;<br>            <span class=\"hljs-built_in\">memcpy</span>(rxCmd + *rxCount, buffer, copySize);<br>            *rxCount += copySize;<br><br>            startTime = <span class=\"hljs-built_in\">osKernelGetTickCount</span>();  <span class=\"hljs-comment\">// 更新最后一次接收数据的时间</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// 检查是否超时</span><br>        <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-built_in\">osKernelGetTickCount</span>() - startTime) &gt; UART_TIMEOUT_MS) &#123;<br>            <span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">// 如果超过设定的超时时间，则停止接收数据</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">absolute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> value)</span> <span class=\"hljs-comment\">//找不到绝对值的函数值定义，自己创建一个函数用于进行绝对值计算</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (value &lt; <span class=\"hljs-number\">0</span>) ? -value : value;<span class=\"hljs-comment\">//判断如何取正</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">ReadMotorAngle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> sliderId)</span> <span class=\"hljs-comment\">//定义读取角度，并计算和输出角度值</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//清空缓存区</span><br>    <span class=\"hljs-built_in\">IoTUartFlush</span>(HI_UART_IDX_1);<br><br>    <span class=\"hljs-comment\">//定义角度取值为小数点后一位</span><br>    <span class=\"hljs-type\">float</span> pos = <span class=\"hljs-number\">0.0f</span>, Motor_Cur_Pos = <span class=\"hljs-number\">0.0f</span>;<br><br>    <span class=\"hljs-comment\">// 定义接收数据数组、接收数据长度</span><br>    <span class=\"hljs-type\">uint8_t</span> rxCmd[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <span class=\"hljs-type\">uint32_t</span> rxCount = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">// 读取电机实时位置</span><br>    <span class=\"hljs-built_in\">ZDT_X42_V2_Read_Sys_Params</span>(sliderId, S_CPOS);<br><br>    <span class=\"hljs-comment\">// 等待返回命令，命令数据缓存在数组rxCmd上，长度为rxCount</span><br>    <span class=\"hljs-built_in\">ZDT_X42_V2_Receive_Data</span>(sliderId, rxCmd, &amp;rxCount);<br><br>    <span class=\"hljs-comment\">//将读取的rxCmd[]十六进制编码打印，用于测试调试</span><br>    <span class=\"hljs-comment\">// printf(&quot;Received bytes: &quot;);</span><br>    <span class=\"hljs-comment\">// for (int i = 0; i &lt; 8; i++) &#123;</span><br>    <span class=\"hljs-comment\">//     printf(&quot;%02X &quot;, rxCmd[i]);</span><br>    <span class=\"hljs-comment\">// &#125;</span><br>    <span class=\"hljs-comment\">// printf(&quot;\\n&quot;);</span><br><br>    <span class=\"hljs-comment\">// 获取电机实时角度返回值（电机实时角度返回值放大了10倍返回的，因为要保留1位小数）</span><br>    pos = ((<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">3</span>] &lt;&lt; <span class=\"hljs-number\">24</span>) | ((<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">4</span>] &lt;&lt; <span class=\"hljs-number\">16</span>) | ((<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">5</span>] &lt;&lt; <span class=\"hljs-number\">8</span>) | (<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">6</span>];<br><br>    <span class=\"hljs-comment\">// 缩小10倍，并判断符号，得到真正的实时角度，存放在浮点数变量Motor_Cur_Pos中</span><br>    Motor_Cur_Pos = pos * <span class=\"hljs-number\">0.1f</span>;<br>    <span class=\"hljs-keyword\">if</span> (rxCmd[<span class=\"hljs-number\">2</span>]) &#123;<br>        Motor_Cur_Pos = -Motor_Cur_Pos;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 打印解析后的角度值</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Current position (as angle): %.1f degrees\\n&quot;</span>, Motor_Cur_Pos);<br><br>    <span class=\"hljs-keyword\">return</span> Motor_Cur_Pos;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ResetMotorToOrigin</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> sliderId)</span> <span class=\"hljs-comment\">//电机归零函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//读取电机目前角度</span><br>    <span class=\"hljs-type\">float</span> Motor_Cur_Pos = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);<br><br>    <span class=\"hljs-type\">float</span> targetPosition = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 目标位置，这里假设为0度</span><br><br>    <span class=\"hljs-comment\">// 根据当前角度和目标位置计算需要移动的距离</span><br>    <span class=\"hljs-type\">float</span> delta = targetPosition - Motor_Cur_Pos;<br><br>    <span class=\"hljs-comment\">// 将 delta 四舍五入到小数点后一位</span><br>    <span class=\"hljs-comment\">//delta = ((int)(delta * 10 + 0.5)) / 10.0f;</span><br><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;delta: %.1f degrees\\n&quot;</span>, delta);<br><br>    <span class=\"hljs-comment\">// 调用轨迹位置控制函数将电机移动到目标位置</span><br>    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, (delta &lt; <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta), motor_raf_0, motor_snf_0);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ParseJson</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* json)</span><span class=\"hljs-comment\">//电机uart运行主函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 定义JSON键的字符串，根据上位机所需进行定义，格式类型相同</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* labelStr = <span class=\"hljs-string\">&quot;\\&quot;label\\&quot;:&quot;</span>;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* motor_EnStr = <span class=\"hljs-string\">&quot;\\&quot;motor_En\\&quot;:&quot;</span>;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* sliderIdStr = <span class=\"hljs-string\">&quot;\\&quot;sliderId\\&quot;:&quot;</span>;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* valueStr = <span class=\"hljs-string\">&quot;\\&quot;value\\&quot;:&quot;</span>;<br>    <br><br>    <span class=\"hljs-comment\">// 找到JSON字符串中键的位置，用于进行键的连接，等于找到对应的标签</span><br>    <span class=\"hljs-type\">char</span>* labelPos = <span class=\"hljs-built_in\">strstr</span>(json, labelStr);<br>    <span class=\"hljs-type\">char</span>* motor_EnPos = <span class=\"hljs-built_in\">strstr</span>(json, motor_EnStr);<br>    <span class=\"hljs-type\">char</span>* sliderIdPos = <span class=\"hljs-built_in\">strstr</span>(json, sliderIdStr);<br>    <span class=\"hljs-type\">char</span>* valuePos = <span class=\"hljs-built_in\">strstr</span>(json, valueStr);<br><br>    <span class=\"hljs-comment\">// 如果找到键，解析其对应的值</span><br>    <span class=\"hljs-keyword\">if</span> (labelPos != <span class=\"hljs-literal\">NULL</span> &amp;&amp; motor_EnPos != <span class=\"hljs-literal\">NULL</span> &amp;&amp; sliderIdPos != <span class=\"hljs-literal\">NULL</span> &amp;&amp; valuePos != <span class=\"hljs-literal\">NULL</span>) &#123;<br>        <span class=\"hljs-type\">int</span> label = <span class=\"hljs-built_in\">atoi</span>(labelPos + <span class=\"hljs-built_in\">strlen</span>(labelStr)); <span class=\"hljs-comment\">// 将label转换为整数</span><br>        <span class=\"hljs-type\">int</span> sliderId = <span class=\"hljs-built_in\">atoi</span>(sliderIdPos + <span class=\"hljs-built_in\">strlen</span>(sliderIdStr)); <span class=\"hljs-comment\">// 将sliderId转换为整数</span><br><br>        <span class=\"hljs-comment\">//放大30倍，对应谐波减速器</span><br>        <span class=\"hljs-type\">int</span> value = <span class=\"hljs-built_in\">atof</span>(valuePos + <span class=\"hljs-built_in\">strlen</span>(valueStr));<br>        <span class=\"hljs-type\">int</span> motor_En = <span class=\"hljs-built_in\">atoi</span>(motor_EnPos + <span class=\"hljs-built_in\">strlen</span>(motor_EnStr));<br><br>        <span class=\"hljs-comment\">// 打印解析出的值</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;label: %d, motor_En: %d, Slider ID: %d, Value: %d\\n&quot;</span>, label, motor_En, sliderId, value);<br><br>        <span class=\"hljs-comment\">// 根据Slider ID和Value执行相应的操作</span><br>        <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">1</span>) <br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">1</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125; <br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">2</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">3</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">4</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">5</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">6</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>        &#125; <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">2</span>) <br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">1</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125; <br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">2</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">3</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">4</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">5</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">6</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//电机紧急停机</span><br>        &#123;<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">//调用停机函数</span><br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);  <span class=\"hljs-comment\">//延时确保函数依次执行</span><br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">//电机复位函数</span><br>        &#123;<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">//调用复位函数</span><br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);  <span class=\"hljs-comment\">//延时确保函数依次执行</span><br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">2</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">3</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">4</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">5</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">6</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Task1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//系统主函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> socket_fd = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">256</span>];<br>    <span class=\"hljs-type\">int</span> re = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-type\">uint32_t</span> count_0 = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len_0 = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff_0[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-comment\">// 对UART1的一些初始化 Some initialization of UART1</span><br>    <span class=\"hljs-built_in\">Uart1GpioInit</span>();<br>    <span class=\"hljs-comment\">// 对UART1参数的一些配置 Some configurations of UART1 parameters</span><br>    <span class=\"hljs-built_in\">Uart1Config</span>();<br><br>    <span class=\"hljs-comment\">// 连接Wifi</span><br>    <span class=\"hljs-built_in\">WiFi_connectHotspots</span>(<span class=\"hljs-string\">&quot;esp32&quot;</span>, <span class=\"hljs-string\">&quot;12345678&quot;</span>);<br>    socket_fd = <span class=\"hljs-built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 创建套接字（TCP）</span><br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class=\"hljs-built_in\">htons</span>(TCP_SERVER_PORT);<br>    addr.sin_addr.s_addr = <span class=\"hljs-built_in\">inet_addr</span>(TCP_SERVER_IP); <span class=\"hljs-comment\">// 填写服务器的IP地址</span><br><br>    re = <span class=\"hljs-built_in\">connect</span>(socket_fd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;addr, <span class=\"hljs-built_in\">sizeof</span>(addr)); <span class=\"hljs-comment\">// 连接服务器</span><br>    <span class=\"hljs-keyword\">if</span> (re == <span class=\"hljs-number\">-1</span>) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Failed to connect to the server\\r\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection to server successful\\r\\n&quot;</span>);<br><br>    <span class=\"hljs-comment\">// 发送第一条数据</span><br>    <span class=\"hljs-built_in\">send</span>(socket_fd, <span class=\"hljs-string\">&quot;Connection to server successful.&quot;</span>, <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;Connection to server successful.&quot;</span>), <span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-built_in\">memset_s</span>(buff, <span class=\"hljs-built_in\">sizeof</span>(buff), <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(buff));<br>        re = <span class=\"hljs-built_in\">recv</span>(socket_fd, buff, <span class=\"hljs-built_in\">sizeof</span>(buff), <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//\t接收客户端发送过来的消息</span><br>        <span class=\"hljs-keyword\">if</span> (re &lt;= <span class=\"hljs-number\">0</span>) <br>        &#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-built_in\">ParseJson</span>(buff);<span class=\"hljs-comment\">//执行控制主函数</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-built_in\">close</span>(socket_fd);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">UartExampleEntry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//配置上报函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//osThreadAttr_t attr;</span><br>    <span class=\"hljs-built_in\">IoTWatchDogDisable</span>();<br><br>    osThreadAttr_t options;<br>    options.name = <span class=\"hljs-string\">&quot;thread_1&quot;</span>;<br>    options.attr_bits = <span class=\"hljs-number\">0</span>;<br>    options.cb_mem = <span class=\"hljs-literal\">NULL</span>;<br>    options.cb_size = <span class=\"hljs-number\">0</span>;<br>    options.stack_mem = <span class=\"hljs-literal\">NULL</span>;<br>    options.stack_size = TASK_STACK_SIZE;<br>    options.priority = osPriorityNormal;<br><br>    Task1_ID = <span class=\"hljs-built_in\">osThreadNew</span>((osThreadFunc_t)Task1, <span class=\"hljs-literal\">NULL</span>, &amp;options);<br>    <span class=\"hljs-keyword\">if</span> (Task1_ID != <span class=\"hljs-literal\">NULL</span>) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ID = %d, Create Task1_ID is OK!\\r\\n&quot;</span>, Task1_ID);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">APP_FEATURE_INIT</span>(UartExampleEntry);<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"Hi3861开发\"><a href=\"#Hi3861开发\" class=\"headerlink\" title=\"Hi3861开发\"></a>Hi3861开发</h1><h2 id=\"一、学习资料\"><a href=\"#一、学习资料\" class=\"headerlink\" title=\"一、学习资料\"></a>一、学习资料</h2><ul>\n<li><p>【UART串口使用】<a href=\"https://blog.csdn.net/qq_36347513/article/details/121603716\">HI3861学习笔记（18）——UART串口使用_hi3861 uart-CSDN博客</a></p>\n</li>\n<li><p>【开发环境搭建】[2.1 Pegasus开发环境搭建.md · HiSpark&#x2F;HiSpark_NICU2023 - Gitee.com](<a href=\"https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1\">https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1</a> Pegasus开发环境搭建.md)</p>\n</li>\n<li><p>【入门demo】<a href=\"https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-ide-3861-helloworld.md\">编写 Hello World”程序 (openharmony.cn)</a></p>\n</li>\n<li><p>【UART串口读取】<a href=\"https://bbs.huaweicloud.com/blogs/detail/281809\">HarmonyOS小熊派 | HarmonyOS基础外设开发–UART数据读写-云社区-华为云 (huaweicloud.com)</a></p>\n</li>\n<li><p>【QT转EXE格式】<a href=\"https://www.cnblogs.com/JinShanCheShen/p/16194526.html\">QT打包成exe详细步骤 - 西北小蚂蚁 - 博客园 (cnblogs.com)</a></p>\n</li>\n<li><p>【QT转EXE格式编译报错】<a href=\"https://blog.csdn.net/weijifen000/article/details/102537640\">Qt软件打包后报错“无法定位程序输入点_ZN10QArrayData10deallocateEPs_jj于动态链接库….. .exe上。”解决办法-CSDN博客</a></p>\n</li>\n</ul>\n<h2 id=\"二、QT开发\"><a href=\"#二、QT开发\" class=\"headerlink\" title=\"二、QT开发\"></a>二、QT开发</h2><ul>\n<li><p>geometry里的宽度、高度是分辨率，比如geometry设置为宽<em>高为1920</em>1080</p>\n</li>\n<li><p>【窗口自适应】<a href=\"https://cloud.tencent.com/developer/article/2286080\">【QT】QT Designer控件随窗口大小自适应-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p>【串口发送】<a href=\"https://blog.csdn.net/qq_26904271/article/details/132646641\">QT串口助手：识别串口号，发送，接收，十六进制_qt串口发送16进制数据-CSDN博客</a></p>\n</li>\n<li><p>foreach是QT中的一个关键字，其作用是对第二个参数中的对象进行遍历，把遍历过程中的每个对象依次赋给第一个参数，并执行花括号中的内容。在这里，就是把可获取的串口列表availablePorts()中的串口，逐个将其串口号添加到combobox中。</p>\n</li>\n</ul>\n<h3 id=\"1-串口设定\"><a href=\"#1-串口设定\" class=\"headerlink\" title=\"1.串口设定\"></a>1.串口设定</h3><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"> \t<span class=\"hljs-comment\">//mainwindow.h文件调用串口头文件</span><br> \t<span class=\"hljs-comment\">//串口头文件</span><br> \t#include &lt;QSerialPort&gt;<br>#include &lt;QSerialPortInfo&gt;<br> \t<br> \t<span class=\"hljs-comment\">//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br> \t<span class=\"hljs-comment\">//使用foreach函数查找串口信息</span><br>foreach (const QSerialPortInfo &amp;portInfo,QSerialPortInfo::availablePorts()) <br> \t&#123;<br>     <span class=\"hljs-comment\">//将所有搜索的值写入serialport端口当中</span><br>     <span class=\"hljs-function\"><span class=\"hljs-title\">ui</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">serialport</span>-&gt;</span>addItem(portInfo.portName());<br> \t&#125;<br> \t<span class=\"hljs-comment\">//打开串口</span><br> \t<span class=\"hljs-function\"><span class=\"hljs-title\">serialPort</span>-&gt;</span>open();<br> \t<span class=\"hljs-comment\">//关闭串口</span><br> \t<span class=\"hljs-function\"><span class=\"hljs-title\">serialPort</span>-&gt;</span>close();<br> \t<br> \t<span class=\"hljs-comment\">//串口写入</span><br> \t<span class=\"hljs-function\"><span class=\"hljs-title\">serialPort</span>-&gt;</span>write(<span class=\"hljs-string\">&quot;*****&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-读取下拉选项内容并赋予\"><a href=\"#2-读取下拉选项内容并赋予\" class=\"headerlink\" title=\"2.读取下拉选项内容并赋予\"></a>2.读取下拉选项内容并赋予</h3><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//mainwindow.cpp文件中，自定义函数设定</span><br><br><span class=\"hljs-comment\">//定义参数格式为QString</span><br>QString mBaudrate;<span class=\"hljs-comment\">//波特率</span><br>QString mStopBits;<span class=\"hljs-comment\">//停止位字节</span><br>   QString mDataBits;<span class=\"hljs-comment\">//数据字节</span><br>   QString mParity;<span class=\"hljs-comment\">//奇偶校验</span><br>   <br><span class=\"hljs-comment\">//读取baudrate槽中currentText()所选定的内容，后续类似</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mBaudrate</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">baudrate</span>-&gt;</span>currentText();<br><span class=\"hljs-function\"><span class=\"hljs-title\">mStopBits</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">stopbits</span>-&gt;</span>currentText();<br>   <span class=\"hljs-function\"><span class=\"hljs-title\">mDataBits</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">databits</span>-&gt;</span>currentText();<br>   <span class=\"hljs-function\"><span class=\"hljs-title\">mParity</span> = ui-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">parity</span>-&gt;</span>currentText();<br><br><span class=\"hljs-comment\">//判断起选定内容是否符合需求，并赋予相应操作</span><br><span class=\"hljs-keyword\">if</span>(mBaudrate == <span class=\"hljs-string\">&quot;9600&quot;</span>) <br>&#123;<br>\t<span class=\"hljs-comment\">//将串口波特率设定为9600</span><br>       mSerialPort.setBaudRate(QSerialPort::Baud9600);<span class=\"hljs-comment\">//Baud9600、Baud115200</span><br>       mSerialPort.setStopBits(QSerialPort::OneStop);<span class=\"hljs-comment\">//OneStop-1、OneAndHalfStop-1.5、TwoStop-2</span><br>       mSerialPort.setDataBits(QSerialPort::Data5);<span class=\"hljs-comment\">//Data5、Data6、Data7、Data8</span><br>       mSerialPort.setParity(QSerialPort::OddParity);<span class=\"hljs-comment\">//OddParity-奇校验、EvenParity-偶校验、NoParity无校验</span><br>   &#125; <br>   <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(mBaudrate == <span class=\"hljs-string\">&quot;115200&quot;</span>) <br>   &#123;<br>   \t<span class=\"hljs-comment\">//将串口波特率设定为115200</span><br>       mSerialPort.setBaudRate(QSerialPort::Baud19200);<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-摄像头设定\"><a href=\"#3-摄像头设定\" class=\"headerlink\" title=\"3.摄像头设定\"></a>3.摄像头设定</h3><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-comment\">//***.pro格式文件加入multimediawidgets</span><br>QT       += core gui multimediawidgets<br><br><span class=\"hljs-comment\">//mainwindow.h文件调用摄像头头文件</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QCameraImageCapture&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QCamera&gt;</span></span><br><br><span class=\"hljs-comment\">//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br><span class=\"hljs-comment\">//获取系统的所有可用的摄像头</span><br>foreach(const QCameraInfo <span class=\"hljs-variable\">&amp;</span>cameraInfo , QCameraInfo::availableCameras())<br>   <span class=\"hljs-punctuation\">&#123;</span><br>       <span class=\"hljs-comment\">//将所有搜索的值写入cameraBox端口当中</span><br>       ui-&gt;cameraBox-&gt;addItem(cameraInfo.deviceName())<span class=\"hljs-punctuation\">;</span><br>   <span class=\"hljs-punctuation\">&#125;</span><br>   <br>   <span class=\"hljs-comment\">//打开摄像头</span><br>   cameraPort-&gt;start()<span class=\"hljs-punctuation\">;</span><br>   <span class=\"hljs-comment\">//关闭摄像头</span><br>   cameraPort-&gt;stop()<span class=\"hljs-punctuation\">;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-QT中setCheckable-的作用\"><a href=\"#4-QT中setCheckable-的作用\" class=\"headerlink\" title=\"4.QT中setCheckable()的作用\"></a>4.QT中setCheckable()的作用</h3><p>setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。</p>\n<h3 id=\"5-TCP通讯\"><a href=\"#5-TCP通讯\" class=\"headerlink\" title=\"5.TCP通讯\"></a>5.TCP通讯</h3><figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs zephir\"><span class=\"hljs-comment\">//***.pro格式文件加入network</span><br>QT       += network<br><br><span class=\"hljs-comment\">//mainwindow.h头文件中引用</span><br>#include &lt;QTcpServer&gt;<br>#include &lt;QTcpSocket&gt;<br><span class=\"hljs-comment\">//定义*socket和*server用来存放服务器的套接字和监听，用于与客户端进行通信</span><br>QTcpSocket *socket;<br>   QTcpServer *server;<br><br><span class=\"hljs-comment\">//mainwindow.cpp文件中MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br><span class=\"hljs-comment\">//setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。</span><br>ui-&gt;Monitor_OPEN-&gt;setCheckable(<span class=\"hljs-keyword\">true</span>);<span class=\"hljs-comment\">//简而言之就是按键的常开和常闭切换</span><br><span class=\"hljs-comment\">//创建服务器的套接字，用于与客户端进行通信</span><br>socket = <span class=\"hljs-keyword\">new</span> QTcpSocket();<br><span class=\"hljs-comment\">//声明一个QTcpserver的对象，用于监听</span><br>   server = <span class=\"hljs-keyword\">new</span> QTcpServer();<br>   <span class=\"hljs-comment\">//信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据</span><br>   connect(server,SIGNAL(newConnection()),this,SLOT(newConnection_SLOT()));<br>   <br>   <span class=\"hljs-comment\">//定义新函数MainWindow::newConnection_SLOT()，用于新的客户端连接建立槽函数：获取客户端套接字，允许写入数据</span><br>   void MainWindow::newConnection_SLOT()<br>   &#123;<br>       socket = server-&gt;nextPendingConnection(); <span class=\"hljs-comment\">//获取已经连接的客户端套接字</span><br>       connect(socket,SIGNAL(readyRead()),this,SLOT(readyRead_SLOT()));<span class=\"hljs-comment\">//如果socket中有缓存消息，触发槽函数</span><br>   &#125;<br>   <br>   <span class=\"hljs-comment\">//定义新函数MainWindow::readyRead_SLOT()，用于接收消息并显示到接收框</span><br>   void MainWindow::readyRead_SLOT()<br>   &#123;<br>       qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Server Received!&quot;</span>;<br>       QString buffer;<span class=\"hljs-comment\">//定义容器</span><br>       <span class=\"hljs-comment\">//读取缓冲区数据</span><br>       buffer = socket-&gt;readAll();<br>       <span class=\"hljs-keyword\">if</span>(!buffer.isEmpty())<br>       &#123;<br>           <span class=\"hljs-comment\">//刷新显示，写入Receive_text组件，组件类型为Plain Text Line</span><br>           ui-&gt;Receive_text-&gt;appendPlainText(buffer);<br>       &#125;<br>   &#125;<br>   <br>   <span class=\"hljs-comment\">//连接组件函数，按下开始监听组件Monitor_OPEN，类型为clicked(bool checked)，执行监听程序</span><br>   void MainWindow::on_Monitor_OPEN_clicked(<span class=\"hljs-keyword\">bool</span> checked)<br>   &#123;<br>       <span class=\"hljs-keyword\">if</span>(checked)<span class=\"hljs-comment\">//如果按下了</span><br>       &#123;<br>           <span class=\"hljs-keyword\">int</span> port = ui-&gt;PORT_TEXT-&gt;text().toUInt();<br>           <span class=\"hljs-comment\">//如果未监听到</span><br>           <span class=\"hljs-keyword\">if</span>(!server-&gt;listen(QHostAddress::Any, port))<br>           &#123;<br>               qDebug() &lt;&lt; server-&gt;errorString();<br>               <span class=\"hljs-comment\">//连接失败，再次点击则重新连接，将checked恢复为true</span><br>               ui-&gt;Monitor_OPEN-&gt;toggle();<br>               <span class=\"hljs-keyword\">return</span>;<br>           &#125;<br>           qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Listen Successfully! Message from port:&quot;</span> &lt;&lt; port;<br>           <span class=\"hljs-comment\">//修改按钮文字</span><br>           ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;停止监听&quot;</span>);<br>           <span class=\"hljs-comment\">//发送键使能</span><br>           ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">true</span>);<br>       &#125;<br>       <span class=\"hljs-keyword\">else</span><br>       &#123;<br>            qDebug() &lt;&lt; <span class=\"hljs-string\">&quot;Stop Listening!&quot;</span>;<br>           <span class=\"hljs-comment\">//如果已经连接则断开连接</span><br>           <span class=\"hljs-keyword\">if</span>(socket-&gt;state() == QAbstractSocket::ConnectedState)<br>           &#123;<br>               <span class=\"hljs-comment\">//断开连接</span><br>               socket-&gt;disconnectFromHost();<br>           &#125;<br>           <span class=\"hljs-comment\">//关闭倾听服务</span><br>           server-&gt;close();<br>           <span class=\"hljs-comment\">//修改按钮文字&amp;发送键静默</span><br>           ui-&gt;Monitor_OPEN-&gt;setText(<span class=\"hljs-string\">&quot;开始监听&quot;</span>);<br>           ui-&gt;Send_Button-&gt;setEnabled(<span class=\"hljs-keyword\">false</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-滑动槽设定\"><a href=\"#6-滑动槽设定\" class=\"headerlink\" title=\"6.滑动槽设定\"></a>6.滑动槽设定</h3><ul>\n<li>首先使用setRange()方法设置了滑动条的范围为0到100，然后使用setValue()方法设置了滑动条的当前值为50。通过value()方法可以获取当前滑动条的值。最后，使用connect()方法监听了滑动条的值变化，当值发生变化时，会调用onSliderValueChanged()槽函数。</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">// 假设有一个QSlider对象名为slider<br>// 设置滑动条的范围<br>slider-&gt;setRange(-180, 180);<br><br>// 设置滑动条的当前值<br>slider-&gt;setValue(0);<br><br>// 获取滑动条的当前值<br>int currentValue = slider-&gt;value();<br><br>// 监听滑动条的值变化<br>connect(slider, SIGNAL(valueChanged(int)), this, SLOT(onSliderValueChanged(int)));<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>slider 提供了两个自然的步长；较大的步长用 pageStep 表示，相当于按下键盘上的 PageDown 和 PageUp，也相当于鼠标点击时移动的步进值:；较小的步长用 singleStep 表示，相当于按下键盘上的上、下键；</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">// 设置移动每页的步长，滑块提供的两个自然步长中较大的那一个，相当于键盘上的 PageUp 和 PageDown；</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">horizontalSlider</span>-&gt;</span>setPageStep(<span class=\"hljs-number\">10</span>);<br><br><span class=\"hljs-comment\">// 获取 每页的步长</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">int</span> step = horizontalSlider-&gt;</span>pageStep();<br><br><span class=\"hljs-comment\">// 设置移动单步的步长，滑块提供的两个自然步长中较小的那一个，相当于键盘上的上、下箭头；</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">horizontalSlider</span>-&gt;</span>setSingleStep(<span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-comment\">// 获取 单步的步长</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">int</span> step =horizontalSlider-&gt;</span>singleStep();<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>设置是否启用滑块追踪：</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">// 设置是否启动滑块追踪：true 表示启动追踪；false 表示禁用追踪；</span><br><span class=\"hljs-comment\">// 如果启用了滑块追踪，则滑块在拖动过程中会一直触发 valueChanged 信号；</span><br><span class=\"hljs-comment\">// 如果禁用了滑块追踪，则滑块在拖动过程中不会触发 valueChanged 信号，</span><br><span class=\"hljs-comment\">// 只有在用户释放滑块时，才触发 valueChanged 信号。</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">horizontalSlider</span>-&gt;</span>setTracking(<span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">// 可以通过 hasTracking 属性获取是否启用了追踪：</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">bool</span> isTrack = horizontalSlider-&gt;</span>hasTracking();<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>槽函数设定</li>\n</ul>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">valueChanged</span>()<span class=\"hljs-comment\">//值被改变</span><br><span class=\"hljs-built_in\">sliderPressed</span>()<span class=\"hljs-comment\">//滑块被点击</span><br><span class=\"hljs-built_in\">sliderMoved</span>()<span class=\"hljs-comment\">//滑块移动</span><br><span class=\"hljs-built_in\">sliderReleased</span>();<span class=\"hljs-comment\">//滑块被释放</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、TCP通讯\"><a href=\"#三、TCP通讯\" class=\"headerlink\" title=\"三、TCP通讯\"></a>三、TCP通讯</h2><p>【TCP通信】<a href=\"https://blog.csdn.net/qq_36347513/article/details/123099617\">HI3861学习笔记（20）——TCP客户端_hi3861 at tcp 指令 erre-CSDN博客</a></p>\n<p>【TCP通信】<a href=\"https://blog.csdn.net/baidu_29900103/article/details/117970891\">教你动手写TCP上位机与小熊派通信_小熊派设备的tcp通信-CSDN博客</a></p>\n<h2 id=\"四、下位机代码\"><a href=\"#四、下位机代码\" class=\"headerlink\" title=\"四、下位机代码\"></a>四、下位机代码</h2><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_gpio_ex.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ohos_init.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;cmsis_os2.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_gpio.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_uart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;hi_uart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_watchdog.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;iot_errno.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;hal_bsp_pcf8574.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;hal_bsp_wifi.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;wifi_device.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lwip/netifapi.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lwip/sockets.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lwip/api_shell.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>    ABS(x)    ((x) &gt; 0 ? (x) : -(x))</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> UART_BUFF_SIZE 100</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> U_SLEEP_TIME   500000</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> UART_TIMEOUT_MS 20   <span class=\"hljs-comment\">// 设置超时时间为100毫秒</span></span><br><br>osThreadId_t Task1_ID; <span class=\"hljs-comment\">// 任务1设置为低优先级任务</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TASK_STACK_SIZE (1024 * 10)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TCP_SERVER_IP <span class=\"hljs-string\">&quot;192.168.245.23&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TCP_SERVER_PORT 8888</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DIR_pos 1 <span class=\"hljs-comment\">// 正方向</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DIR_neg 0 <span class=\"hljs-comment\">// 反方向</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> Speed_acc 1000 <span class=\"hljs-comment\">// 加速度</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> Speed_dec 1000 <span class=\"hljs-comment\">// 减速度</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> Speed_max 2000.0f <span class=\"hljs-comment\">// 最大速度</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_raf_0 0 <span class=\"hljs-comment\">// 相位位置标志</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_raf_1 1 <span class=\"hljs-comment\">//绝对位置标志</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_snf_0 0 <span class=\"hljs-comment\">// 多机同步运动标志</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> motor_snf_1 0 <span class=\"hljs-comment\">// 单机运动标志</span></span><br><br><span class=\"hljs-comment\">//读取数据的枚举值</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span> &#123;<br>  S_VER   = <span class=\"hljs-number\">0</span>,      <span class=\"hljs-comment\">/* 读取固件版本和对应的硬件版本 */</span><br>  S_RL    = <span class=\"hljs-number\">1</span>,      <span class=\"hljs-comment\">/* 读取读取相电阻和相电感 */</span><br>  S_PID   = <span class=\"hljs-number\">2</span>,      <span class=\"hljs-comment\">/* 读取PID参数 */</span><br>  S_ORG   = <span class=\"hljs-number\">3</span>,      <span class=\"hljs-comment\">/* 读取回零参数 */</span><br>  S_VBUS  = <span class=\"hljs-number\">4</span>,      <span class=\"hljs-comment\">/* 读取总线电压 */</span><br>  S_CBUS  = <span class=\"hljs-number\">5</span>,      <span class=\"hljs-comment\">/* 读取总线电流 */</span><br>  S_CPHA  = <span class=\"hljs-number\">6</span>,      <span class=\"hljs-comment\">/* 读取相电流 */</span><br>  S_ENC   = <span class=\"hljs-number\">7</span>,      <span class=\"hljs-comment\">/* 读取编码器原始值 */</span><br>  S_CPUL  = <span class=\"hljs-number\">8</span>,      <span class=\"hljs-comment\">/* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */</span><br>  S_ENCL  = <span class=\"hljs-number\">9</span>,      <span class=\"hljs-comment\">/* 读取经过线性化校准后的编码器值 */</span><br>  S_TPUL  = <span class=\"hljs-number\">10</span>,     <span class=\"hljs-comment\">/* 读取输入脉冲数 */</span><br>  S_TPOS  = <span class=\"hljs-number\">11</span>,     <span class=\"hljs-comment\">/* 读取电机目标位置 */</span><br>  S_OPOS  = <span class=\"hljs-number\">12</span>,     <span class=\"hljs-comment\">/* 读取电机实时设定的目标位置（开环模式的实时位置） */</span><br>  S_VEL   = <span class=\"hljs-number\">13</span>,     <span class=\"hljs-comment\">/* 读取电机实时转速 */</span><br>  S_CPOS  = <span class=\"hljs-number\">14</span>,     <span class=\"hljs-comment\">/* 读取电机实时位置（基于角度编码器累加的电机实时位置） */</span><br>  S_PERR  = <span class=\"hljs-number\">15</span>,     <span class=\"hljs-comment\">/* 读取电机位置误差 */</span><br>  S_TEMP  = <span class=\"hljs-number\">16</span>,     <span class=\"hljs-comment\">/* 读取电机实时温度 */</span><br>  S_SFLAG = <span class=\"hljs-number\">17</span>,     <span class=\"hljs-comment\">/* 读取状态标志位 */</span><br>  S_OFLAG = <span class=\"hljs-number\">18</span>,     <span class=\"hljs-comment\">/* 读取回零状态标志位 */</span><br>  S_Conf  = <span class=\"hljs-number\">19</span>,     <span class=\"hljs-comment\">/* 读取驱动参数 */</span><br>  S_State = <span class=\"hljs-number\">20</span>,     <span class=\"hljs-comment\">/* 读取系统状态参数 */</span><br>&#125;SysParams_t;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Uart1GpioInit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//对UART和LED引脚进行初始化</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">IoTGpioInit</span>(IOT_IO_NAME_GPIO_6);<br>    <span class=\"hljs-comment\">// 设置GPIO0的管脚复用关系为UART1_TX Set the pin reuse relationship of GPIO0 to UART1_ TX</span><br>    <span class=\"hljs-built_in\">IoSetFunc</span>(IOT_IO_NAME_GPIO_6, IOT_IO_FUNC_GPIO_6_UART1_TXD);<br>    <br>    <span class=\"hljs-built_in\">IoTGpioInit</span>(IOT_IO_NAME_GPIO_5);<br>    <span class=\"hljs-comment\">// 设置GPIO1的管脚复用关系为UART1_RX Set the pin reuse relationship of GPIO1 to UART1_ RX</span><br>    <span class=\"hljs-built_in\">IoSetFunc</span>(IOT_IO_NAME_GPIO_5, IOT_IO_FUNC_GPIO_5_UART1_RXD);<br><br>    <span class=\"hljs-comment\">// LED3的GPIO初始化 GPIO initialization of LED3</span><br>    <span class=\"hljs-built_in\">IoTGpioInit</span>(IOT_IO_NAME_GPIO_2);<br>    <span class=\"hljs-comment\">// 设置GPIO9的管脚复用关系为GPIO Set the pin reuse relationship of GPIO9 to GPIO</span><br>    <span class=\"hljs-built_in\">IoSetFunc</span>(IOT_IO_NAME_GPIO_2, IOT_IO_FUNC_GPIO_2_GPIO);<br>    <span class=\"hljs-comment\">// GPIO方向设置为输出 GPIO direction set to output</span><br>    <span class=\"hljs-built_in\">IoTGpioSetDir</span>(IOT_IO_NAME_GPIO_2, IOT_GPIO_DIR_OUT);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Uart1Config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//对UART配置初始化</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">uint32_t</span> ret;<br>    <span class=\"hljs-comment\">/* 初始化UART配置，波特率 115200，数据bit为8,停止位1，奇偶校验为NONE */</span><br>    <span class=\"hljs-comment\">/* Initialize UART configuration, baud rate is 9600, data bit is 8, stop bit is 1, parity is NONE */</span><br>    IotUartAttribute uart_attr = &#123;<br>        .baudRate = <span class=\"hljs-number\">115200</span>,<br>        .dataBits = <span class=\"hljs-number\">8</span>,<br>        .stopBits = <span class=\"hljs-number\">1</span>,<br>        .parity = <span class=\"hljs-number\">0</span>,<br>    &#125;;<br><br>    <span class=\"hljs-comment\">//uart初始化返回值</span><br>    ret = <span class=\"hljs-built_in\">IoTUartInit</span>(HI_UART_IDX_1, &amp;uart_attr);<br>    <span class=\"hljs-comment\">//判断uart是否连接成功</span><br>    <span class=\"hljs-keyword\">if</span> (ret != IOT_SUCCESS) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Init Uart1 Falied Error No : %d\\n&quot;</span>, ret);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_En_Control</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">int</span> state, <span class=\"hljs-type\">uint8_t</span> snF)</span><span class=\"hljs-comment\">//电机使能控制函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-comment\">//定义发送命令数组</span><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>  <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>] =  <span class=\"hljs-number\">0xF3</span>;                       <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>] =  <span class=\"hljs-number\">0xAB</span>;                       <span class=\"hljs-comment\">// 辅助码</span><br>    cmd[<span class=\"hljs-number\">3</span>] =  (<span class=\"hljs-type\">uint8_t</span>)state;             <span class=\"hljs-comment\">// 使能状态</span><br>    cmd[<span class=\"hljs-number\">4</span>] =  snF;                        <span class=\"hljs-comment\">// 多机同步运动标志</span><br>    cmd[<span class=\"hljs-number\">5</span>] =  <span class=\"hljs-number\">0x6B</span>;                       <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">6</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//电机驱动函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Traj_Position_Control</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> dir, <span class=\"hljs-type\">uint16_t</span> acc, <span class=\"hljs-type\">uint16_t</span> dec, <span class=\"hljs-type\">float</span> velocity, <span class=\"hljs-type\">float</span> position, <span class=\"hljs-type\">uint8_t</span> raf, <span class=\"hljs-type\">uint8_t</span> snF)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-comment\">//定义发送命令数组</span><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">32</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <span class=\"hljs-type\">uint16_t</span> vel = <span class=\"hljs-number\">0</span>; <span class=\"hljs-type\">uint32_t</span> pos = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">// 将速度和位置放大10倍发送过去</span><br>    vel = (<span class=\"hljs-type\">uint16_t</span>)<span class=\"hljs-built_in\">ABS</span>(velocity * <span class=\"hljs-number\">10.0f</span>); <br>    pos = (<span class=\"hljs-type\">uint32_t</span>)<span class=\"hljs-built_in\">ABS</span>(position * <span class=\"hljs-number\">10.0f</span>);<br><br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>]  =  addr;                      <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>]  =  <span class=\"hljs-number\">0xFD</span>;                      <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>]  =  dir;                       <span class=\"hljs-comment\">// 符号（方向）</span><br>    cmd[<span class=\"hljs-number\">3</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(acc &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 加速加速度(RPM/s)高8位字节</span><br>    cmd[<span class=\"hljs-number\">4</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(acc &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 加速加速度(RPM/s)低8位字节  </span><br>    cmd[<span class=\"hljs-number\">5</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(dec &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 减速加速度(RPM/s)高8位字节</span><br>    cmd[<span class=\"hljs-number\">6</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(dec &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 减速加速度(RPM/s)低8位字节  </span><br>    cmd[<span class=\"hljs-number\">7</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(vel &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 最大速度(RPM)高8位字节</span><br>    cmd[<span class=\"hljs-number\">8</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(vel &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 最大速度(RPM)低8位字节 </span><br>    cmd[<span class=\"hljs-number\">9</span>]  =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">24</span>);      <span class=\"hljs-comment\">// 位置(bit24 - bit31)</span><br>    cmd[<span class=\"hljs-number\">10</span>] =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">16</span>);      <span class=\"hljs-comment\">// 位置(bit16 - bit23)</span><br>    cmd[<span class=\"hljs-number\">11</span>] =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">8</span>);       <span class=\"hljs-comment\">// 位置(bit8  - bit15)</span><br>    cmd[<span class=\"hljs-number\">12</span>] =  (<span class=\"hljs-type\">uint8_t</span>)(pos &gt;&gt; <span class=\"hljs-number\">0</span>);       <span class=\"hljs-comment\">// 位置(bit0  - bit7 )</span><br>    cmd[<span class=\"hljs-number\">13</span>] =  raf;                       <span class=\"hljs-comment\">// 相位位置/绝对位置标志</span><br>    cmd[<span class=\"hljs-number\">14</span>] =  snF;                       <span class=\"hljs-comment\">// 多机同步运动标志</span><br>    cmd[<span class=\"hljs-number\">15</span>] =  <span class=\"hljs-number\">0x6B</span>;                      <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">16</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Origin_Trigger_Return</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> o_mode, <span class=\"hljs-type\">bool</span> snF)</span><span class=\"hljs-comment\">//电机归零函数，没啥用，需要外界碰撞或者限位，该文件未使用此函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>] =  <span class=\"hljs-number\">0x9A</span>;                       <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>] =  o_mode;                     <span class=\"hljs-comment\">// 回零模式，0为单圈就近回零，1为单圈方向回零，2为多圈无限位碰撞回零，3为多圈有限位开关回零</span><br>    cmd[<span class=\"hljs-number\">3</span>] =  snF;                        <span class=\"hljs-comment\">// 多机同步运动标志，false为不启用，true为启用</span><br>    cmd[<span class=\"hljs-number\">4</span>] =  <span class=\"hljs-number\">0x6B</span>;                       <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">5</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Stop_Now</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> snF)</span><span class=\"hljs-comment\">//立即停机</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义接收值以及数据长度</span><br>    <span class=\"hljs-type\">uint32_t</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br>    cmd[<span class=\"hljs-number\">1</span>] =  <span class=\"hljs-number\">0xFE</span>;                       <span class=\"hljs-comment\">// 功能码</span><br>    cmd[<span class=\"hljs-number\">2</span>] =  <span class=\"hljs-number\">0x98</span>;                       <span class=\"hljs-comment\">// 辅助码</span><br>    cmd[<span class=\"hljs-number\">3</span>] =  snF;                        <span class=\"hljs-comment\">// 多机同步运动标志</span><br>    cmd[<span class=\"hljs-number\">4</span>] =  <span class=\"hljs-number\">0x6B</span>;                       <span class=\"hljs-comment\">// 校验字节</span><br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">5</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">IoTUartFlush</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span> <span class=\"hljs-comment\">//串口清空函数，用于进行清空UART内部缓存，不然会出现读取错误</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义要存储数组</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">128</span>];<br><br>    <span class=\"hljs-comment\">//定义读取值</span><br>    <span class=\"hljs-type\">int</span> read;<br><br>    <span class=\"hljs-keyword\">do</span> &#123;<br>        <span class=\"hljs-comment\">//将读取值全部存入数组当中，从而达到清空效果</span><br>        read = <span class=\"hljs-built_in\">IoTUartRead</span>(id, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));<br>    &#125; <span class=\"hljs-keyword\">while</span> (read &gt; <span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-keyword\">return</span> IOT_SUCCESS;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Read_Sys_Params</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, SysParams_t s)</span><span class=\"hljs-comment\">//读取电机的实时位置</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//定义发送数组</span><br>    <span class=\"hljs-type\">uint8_t</span> cmd[<span class=\"hljs-number\">16</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>  <br>    <span class=\"hljs-comment\">// 装载命令</span><br>    cmd[<span class=\"hljs-number\">0</span>] =  addr;                       <span class=\"hljs-comment\">// 地址</span><br><br>    <span class=\"hljs-comment\">//对功能码进行选择</span><br>    <span class=\"hljs-keyword\">switch</span>(s)                             <span class=\"hljs-comment\">// 功能码</span><br>    &#123;<br>        <span class=\"hljs-keyword\">case</span> S_VER   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x1F</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取固件版本和对应的硬件版本 */</span><br>        <span class=\"hljs-keyword\">case</span> S_RL    : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x20</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取读取相电阻和相电感 */</span><br>        <span class=\"hljs-keyword\">case</span> S_PID   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x21</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取PID参数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_ORG   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x22</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取回零参数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_VBUS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x24</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取总线电压 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CBUS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x26</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取总线电流 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CPHA  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x27</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取相电流 */</span><br>        <span class=\"hljs-keyword\">case</span> S_ENC   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x29</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取编码器原始值 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CPUL  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x30</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */</span><br>        <span class=\"hljs-keyword\">case</span> S_ENCL  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x31</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取经过线性化校准后的编码器值 */</span><br>        <span class=\"hljs-keyword\">case</span> S_TPUL  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x32</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取输入脉冲数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_TPOS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x33</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机目标位置 */</span><br>        <span class=\"hljs-keyword\">case</span> S_OPOS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x34</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时设定的目标位置（开环模式的实时位置） */</span><br>        <span class=\"hljs-keyword\">case</span> S_VEL   : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x35</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时转速 */</span><br>        <span class=\"hljs-keyword\">case</span> S_CPOS  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x36</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时位置（基于角度编码器累加的电机实时位置） */</span><br>        <span class=\"hljs-keyword\">case</span> S_PERR  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x37</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机位置误差 */</span><br>        <span class=\"hljs-keyword\">case</span> S_TEMP  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x39</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取电机实时温度 */</span><br>        <span class=\"hljs-keyword\">case</span> S_SFLAG : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x3A</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取状态标志位 */</span><br>        <span class=\"hljs-keyword\">case</span> S_OFLAG : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x3B</span>; <span class=\"hljs-keyword\">break</span>;                  <span class=\"hljs-comment\">/* 读取回零状态标志位 */</span><br>        <span class=\"hljs-keyword\">case</span> S_Conf  : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x42</span>; cmd[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0x6C</span>; <span class=\"hljs-keyword\">break</span>;   <span class=\"hljs-comment\">/* 读取驱动参数 */</span><br>        <span class=\"hljs-keyword\">case</span> S_State : cmd[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0x43</span>; cmd[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0x7A</span>; <span class=\"hljs-keyword\">break</span>;   <span class=\"hljs-comment\">/* 读取系统状态参数 */</span><br>        <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 如果需要四字节，将校验字节放在 cmd[3]</span><br>    cmd[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0x6B</span>; <br><br>    <span class=\"hljs-comment\">//通过UART的Write函数发送cmd的参数</span><br>    <span class=\"hljs-built_in\">IoTUartWrite</span>(HI_UART_IDX_1, (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>*)cmd, <span class=\"hljs-number\">3</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ZDT_X42_V2_Receive_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> *rxCmd, <span class=\"hljs-type\">uint32_t</span> *rxCount)</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">uint32_t</span> startTime = <span class=\"hljs-built_in\">osKernelGetTickCount</span>();  <span class=\"hljs-comment\">// 获取当前系统时间</span><br>    <span class=\"hljs-type\">uint8_t</span> buffer[UART_BUFF_SIZE];<br>    <span class=\"hljs-type\">int</span> len;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        len = <span class=\"hljs-built_in\">IoTUartRead</span>(HI_UART_IDX_1, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));  <span class=\"hljs-comment\">// 从UART读取数据</span><br>        <span class=\"hljs-keyword\">if</span> (len &gt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">// 将读取的数据复制到rxCmd数组中，确保不会溢出</span><br>            <span class=\"hljs-type\">uint32_t</span> copySize = (*rxCount + len &gt; UART_BUFF_SIZE) ? (UART_BUFF_SIZE - *rxCount) : len;<br>            <span class=\"hljs-built_in\">memcpy</span>(rxCmd + *rxCount, buffer, copySize);<br>            *rxCount += copySize;<br><br>            startTime = <span class=\"hljs-built_in\">osKernelGetTickCount</span>();  <span class=\"hljs-comment\">// 更新最后一次接收数据的时间</span><br>        &#125;<br><br>        <span class=\"hljs-comment\">// 检查是否超时</span><br>        <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-built_in\">osKernelGetTickCount</span>() - startTime) &gt; UART_TIMEOUT_MS) &#123;<br>            <span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">// 如果超过设定的超时时间，则停止接收数据</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">absolute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> value)</span> <span class=\"hljs-comment\">//找不到绝对值的函数值定义，自己创建一个函数用于进行绝对值计算</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (value &lt; <span class=\"hljs-number\">0</span>) ? -value : value;<span class=\"hljs-comment\">//判断如何取正</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">ReadMotorAngle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> sliderId)</span> <span class=\"hljs-comment\">//定义读取角度，并计算和输出角度值</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//清空缓存区</span><br>    <span class=\"hljs-built_in\">IoTUartFlush</span>(HI_UART_IDX_1);<br><br>    <span class=\"hljs-comment\">//定义角度取值为小数点后一位</span><br>    <span class=\"hljs-type\">float</span> pos = <span class=\"hljs-number\">0.0f</span>, Motor_Cur_Pos = <span class=\"hljs-number\">0.0f</span>;<br><br>    <span class=\"hljs-comment\">// 定义接收数据数组、接收数据长度</span><br>    <span class=\"hljs-type\">uint8_t</span> rxCmd[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <span class=\"hljs-type\">uint32_t</span> rxCount = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">// 读取电机实时位置</span><br>    <span class=\"hljs-built_in\">ZDT_X42_V2_Read_Sys_Params</span>(sliderId, S_CPOS);<br><br>    <span class=\"hljs-comment\">// 等待返回命令，命令数据缓存在数组rxCmd上，长度为rxCount</span><br>    <span class=\"hljs-built_in\">ZDT_X42_V2_Receive_Data</span>(sliderId, rxCmd, &amp;rxCount);<br><br>    <span class=\"hljs-comment\">//将读取的rxCmd[]十六进制编码打印，用于测试调试</span><br>    <span class=\"hljs-comment\">// printf(&quot;Received bytes: &quot;);</span><br>    <span class=\"hljs-comment\">// for (int i = 0; i &lt; 8; i++) &#123;</span><br>    <span class=\"hljs-comment\">//     printf(&quot;%02X &quot;, rxCmd[i]);</span><br>    <span class=\"hljs-comment\">// &#125;</span><br>    <span class=\"hljs-comment\">// printf(&quot;\\n&quot;);</span><br><br>    <span class=\"hljs-comment\">// 获取电机实时角度返回值（电机实时角度返回值放大了10倍返回的，因为要保留1位小数）</span><br>    pos = ((<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">3</span>] &lt;&lt; <span class=\"hljs-number\">24</span>) | ((<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">4</span>] &lt;&lt; <span class=\"hljs-number\">16</span>) | ((<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">5</span>] &lt;&lt; <span class=\"hljs-number\">8</span>) | (<span class=\"hljs-type\">uint32_t</span>)rxCmd[<span class=\"hljs-number\">6</span>];<br><br>    <span class=\"hljs-comment\">// 缩小10倍，并判断符号，得到真正的实时角度，存放在浮点数变量Motor_Cur_Pos中</span><br>    Motor_Cur_Pos = pos * <span class=\"hljs-number\">0.1f</span>;<br>    <span class=\"hljs-keyword\">if</span> (rxCmd[<span class=\"hljs-number\">2</span>]) &#123;<br>        Motor_Cur_Pos = -Motor_Cur_Pos;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 打印解析后的角度值</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Current position (as angle): %.1f degrees\\n&quot;</span>, Motor_Cur_Pos);<br><br>    <span class=\"hljs-keyword\">return</span> Motor_Cur_Pos;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ResetMotorToOrigin</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> sliderId)</span> <span class=\"hljs-comment\">//电机归零函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//读取电机目前角度</span><br>    <span class=\"hljs-type\">float</span> Motor_Cur_Pos = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);<br><br>    <span class=\"hljs-type\">float</span> targetPosition = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 目标位置，这里假设为0度</span><br><br>    <span class=\"hljs-comment\">// 根据当前角度和目标位置计算需要移动的距离</span><br>    <span class=\"hljs-type\">float</span> delta = targetPosition - Motor_Cur_Pos;<br><br>    <span class=\"hljs-comment\">// 将 delta 四舍五入到小数点后一位</span><br>    <span class=\"hljs-comment\">//delta = ((int)(delta * 10 + 0.5)) / 10.0f;</span><br><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;delta: %.1f degrees\\n&quot;</span>, delta);<br><br>    <span class=\"hljs-comment\">// 调用轨迹位置控制函数将电机移动到目标位置</span><br>    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, (delta &lt; <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta), motor_raf_0, motor_snf_0);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ParseJson</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* json)</span><span class=\"hljs-comment\">//电机uart运行主函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 定义JSON键的字符串，根据上位机所需进行定义，格式类型相同</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* labelStr = <span class=\"hljs-string\">&quot;\\&quot;label\\&quot;:&quot;</span>;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* motor_EnStr = <span class=\"hljs-string\">&quot;\\&quot;motor_En\\&quot;:&quot;</span>;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* sliderIdStr = <span class=\"hljs-string\">&quot;\\&quot;sliderId\\&quot;:&quot;</span>;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* valueStr = <span class=\"hljs-string\">&quot;\\&quot;value\\&quot;:&quot;</span>;<br>    <br><br>    <span class=\"hljs-comment\">// 找到JSON字符串中键的位置，用于进行键的连接，等于找到对应的标签</span><br>    <span class=\"hljs-type\">char</span>* labelPos = <span class=\"hljs-built_in\">strstr</span>(json, labelStr);<br>    <span class=\"hljs-type\">char</span>* motor_EnPos = <span class=\"hljs-built_in\">strstr</span>(json, motor_EnStr);<br>    <span class=\"hljs-type\">char</span>* sliderIdPos = <span class=\"hljs-built_in\">strstr</span>(json, sliderIdStr);<br>    <span class=\"hljs-type\">char</span>* valuePos = <span class=\"hljs-built_in\">strstr</span>(json, valueStr);<br><br>    <span class=\"hljs-comment\">// 如果找到键，解析其对应的值</span><br>    <span class=\"hljs-keyword\">if</span> (labelPos != <span class=\"hljs-literal\">NULL</span> &amp;&amp; motor_EnPos != <span class=\"hljs-literal\">NULL</span> &amp;&amp; sliderIdPos != <span class=\"hljs-literal\">NULL</span> &amp;&amp; valuePos != <span class=\"hljs-literal\">NULL</span>) &#123;<br>        <span class=\"hljs-type\">int</span> label = <span class=\"hljs-built_in\">atoi</span>(labelPos + <span class=\"hljs-built_in\">strlen</span>(labelStr)); <span class=\"hljs-comment\">// 将label转换为整数</span><br>        <span class=\"hljs-type\">int</span> sliderId = <span class=\"hljs-built_in\">atoi</span>(sliderIdPos + <span class=\"hljs-built_in\">strlen</span>(sliderIdStr)); <span class=\"hljs-comment\">// 将sliderId转换为整数</span><br><br>        <span class=\"hljs-comment\">//放大30倍，对应谐波减速器</span><br>        <span class=\"hljs-type\">int</span> value = <span class=\"hljs-built_in\">atof</span>(valuePos + <span class=\"hljs-built_in\">strlen</span>(valueStr));<br>        <span class=\"hljs-type\">int</span> motor_En = <span class=\"hljs-built_in\">atoi</span>(motor_EnPos + <span class=\"hljs-built_in\">strlen</span>(motor_EnStr));<br><br>        <span class=\"hljs-comment\">// 打印解析出的值</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;label: %d, motor_En: %d, Slider ID: %d, Value: %d\\n&quot;</span>, label, motor_En, sliderId, value);<br><br>        <span class=\"hljs-comment\">// 根据Slider ID和Value执行相应的操作</span><br>        <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">1</span>) <br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">1</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125; <br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">2</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">3</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">4</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">5</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">6</span>)&#123;<br>                <span class=\"hljs-keyword\">if</span>(motor_En == <span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 使能</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class=\"hljs-comment\">// 失能</span><br>                &#125;<br>            &#125;<br>        &#125; <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">2</span>) <br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">1</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125; <br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">2</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">3</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">4</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">5</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (sliderId == <span class=\"hljs-number\">6</span>)&#123;<br>                <span class=\"hljs-type\">float</span> value_before = <span class=\"hljs-built_in\">ReadMotorAngle</span>(sliderId);  <span class=\"hljs-comment\">//读取电机现在角度值</span><br>                <span class=\"hljs-type\">float</span> delta_value = value - value_before;  <span class=\"hljs-comment\">// 计算想要的变化值</span><br>                <span class=\"hljs-keyword\">if</span> (delta_value &lt;= <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">//利用值的正负，判断电机正反转</span><br>                    <span class=\"hljs-comment\">//正转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class=\"hljs-keyword\">else</span>&#123;<br>                    <span class=\"hljs-comment\">//反转</span><br>                    <span class=\"hljs-built_in\">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class=\"hljs-built_in\">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class=\"hljs-comment\">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//电机紧急停机</span><br>        &#123;<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">//调用停机函数</span><br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);  <span class=\"hljs-comment\">//延时确保函数依次执行</span><br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ZDT_X42_V2_Stop_Now</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (label == <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">//电机复位函数</span><br>        &#123;<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">//调用复位函数</span><br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);  <span class=\"hljs-comment\">//延时确保函数依次执行</span><br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">2</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">3</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">4</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">5</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>            <span class=\"hljs-built_in\">ResetMotorToOrigin</span>(<span class=\"hljs-number\">6</span>);<br>            <span class=\"hljs-built_in\">usleep</span>(<span class=\"hljs-number\">50</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Task1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//系统主函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> socket_fd = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">256</span>];<br>    <span class=\"hljs-type\">int</span> re = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-type\">uint32_t</span> count_0 = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">uint32_t</span> len_0 = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> uartReadBuff_0[UART_BUFF_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><br>    <span class=\"hljs-comment\">// 对UART1的一些初始化 Some initialization of UART1</span><br>    <span class=\"hljs-built_in\">Uart1GpioInit</span>();<br>    <span class=\"hljs-comment\">// 对UART1参数的一些配置 Some configurations of UART1 parameters</span><br>    <span class=\"hljs-built_in\">Uart1Config</span>();<br><br>    <span class=\"hljs-comment\">// 连接Wifi</span><br>    <span class=\"hljs-built_in\">WiFi_connectHotspots</span>(<span class=\"hljs-string\">&quot;esp32&quot;</span>, <span class=\"hljs-string\">&quot;12345678&quot;</span>);<br>    socket_fd = <span class=\"hljs-built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 创建套接字（TCP）</span><br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class=\"hljs-built_in\">htons</span>(TCP_SERVER_PORT);<br>    addr.sin_addr.s_addr = <span class=\"hljs-built_in\">inet_addr</span>(TCP_SERVER_IP); <span class=\"hljs-comment\">// 填写服务器的IP地址</span><br><br>    re = <span class=\"hljs-built_in\">connect</span>(socket_fd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;addr, <span class=\"hljs-built_in\">sizeof</span>(addr)); <span class=\"hljs-comment\">// 连接服务器</span><br>    <span class=\"hljs-keyword\">if</span> (re == <span class=\"hljs-number\">-1</span>) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Failed to connect to the server\\r\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection to server successful\\r\\n&quot;</span>);<br><br>    <span class=\"hljs-comment\">// 发送第一条数据</span><br>    <span class=\"hljs-built_in\">send</span>(socket_fd, <span class=\"hljs-string\">&quot;Connection to server successful.&quot;</span>, <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;Connection to server successful.&quot;</span>), <span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-built_in\">memset_s</span>(buff, <span class=\"hljs-built_in\">sizeof</span>(buff), <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(buff));<br>        re = <span class=\"hljs-built_in\">recv</span>(socket_fd, buff, <span class=\"hljs-built_in\">sizeof</span>(buff), <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//\t接收客户端发送过来的消息</span><br>        <span class=\"hljs-keyword\">if</span> (re &lt;= <span class=\"hljs-number\">0</span>) <br>        &#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-built_in\">ParseJson</span>(buff);<span class=\"hljs-comment\">//执行控制主函数</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-built_in\">close</span>(socket_fd);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">UartExampleEntry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><span class=\"hljs-comment\">//配置上报函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//osThreadAttr_t attr;</span><br>    <span class=\"hljs-built_in\">IoTWatchDogDisable</span>();<br><br>    osThreadAttr_t options;<br>    options.name = <span class=\"hljs-string\">&quot;thread_1&quot;</span>;<br>    options.attr_bits = <span class=\"hljs-number\">0</span>;<br>    options.cb_mem = <span class=\"hljs-literal\">NULL</span>;<br>    options.cb_size = <span class=\"hljs-number\">0</span>;<br>    options.stack_mem = <span class=\"hljs-literal\">NULL</span>;<br>    options.stack_size = TASK_STACK_SIZE;<br>    options.priority = osPriorityNormal;<br><br>    Task1_ID = <span class=\"hljs-built_in\">osThreadNew</span>((osThreadFunc_t)Task1, <span class=\"hljs-literal\">NULL</span>, &amp;options);<br>    <span class=\"hljs-keyword\">if</span> (Task1_ID != <span class=\"hljs-literal\">NULL</span>) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ID = %d, Create Task1_ID is OK!\\r\\n&quot;</span>, Task1_ID);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">APP_FEATURE_INIT</span>(UartExampleEntry);<br></code></pre></td></tr></table></figure>\n\n"},{"title":"STM32的时钟学习","date":"2024-07-24T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/kWFf3yjEqbCtX8M.jpg","_content":"\n# STM32的时钟学习\n\n## 时钟SysTick\n\n时钟一共有五个部分，重装载寄存器、递减计数器、时钟源、时钟中断控制器、校准数值寄存器（用不到）\n\n![SysTick.png](https://s2.loli.net/2024/07/27/mbKvAFMpZEVXnd4.png)\n\n#### 重装载寄存器 LOAD\n\n作用就是当递减计数器递减到零时，重新装载计数器，再次进行递减计数\n\n#### 递减计数器 VAL\n\n读取时会返回该递减值，如果在该位写入1，则会清理，同时也会清除时钟中断控制器里面的COUNTFLAG\n\n#### 时钟源\n\n提供递减计数器工作的动力源，有外部晶振提供\n\n#### 时钟中断控制器\n\n```\n16-COUNTFLAG：如果上次读取该寄存器后，再递减到1，则该位置为1\n\n2-CLKSOURCE：时钟源选择，0=AHB/8=72/8=9M，1=AHB=72M\n\n1-TICKINT：递减计数器到零时发出异常请求\n\n0-ENABLE：控制器的使能位\n```\n\n#### 代码Demo\n\n```\n#include \"bsp_systick.h\"\n\n#if 0\n\nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)\n{ \n\t//判断ticks传入的值是否大于 2^24，如果大于则返回错误值\n  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */\n  \n\t//初始化寄存器reload的值                                  \n  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */\n\t\n\t//配置时钟中断优先级，1左移四个位，再减1，配置的是15，最低等级\n  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */\n  \n\t//初始化count的值为0\n\tSysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */\n\t\n\t//时钟配置成72M，使能中断，使能systick\n  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | \n                   SysTick_CTRL_TICKINT_Msk   | \n                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */\n  return (0);                                                  /* Function successful */\n}\n\n#endif\n\nvoid SysTick_Delay_us(uint32_t us)\n{\n\tuint32_t i;\n\t\n\t//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒\n\tSysTick_Config(72);\n\t\n\tfor(i=0;i<us;i++)//进行输入值的循环，循环结束则退出\n\t{\n\t\twhile (!((SysTick -> CTRL) & (1<<16)));//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环\n\t}\n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//将使能位关闭，停止计时，退出循环\n}\n\nvoid SysTick_Delay_ms(uint32_t ms)\n{\n\tuint32_t j;\n\t\n\t//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒\n\tSysTick_Config(72000);\n\n\t\n\tfor(j=0;j<ms;j++)//进行输入值的循环，循环结束则退出\n\t{\n\t\twhile (!((SysTick -> CTRL) & (1<<16)));//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环\n\t}\n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//将使能位关闭，停止计时，退出循环\n}\n\n```\n","source":"_posts/STM32的时钟学习.md","raw":"---\ntitle: STM32的时钟学习\ntag: Systick\ndate: 2024-07-25\ncategories: STM32\nindex_img: https://s2.loli.net/2024/07/31/kWFf3yjEqbCtX8M.jpg\n---\n\n# STM32的时钟学习\n\n## 时钟SysTick\n\n时钟一共有五个部分，重装载寄存器、递减计数器、时钟源、时钟中断控制器、校准数值寄存器（用不到）\n\n![SysTick.png](https://s2.loli.net/2024/07/27/mbKvAFMpZEVXnd4.png)\n\n#### 重装载寄存器 LOAD\n\n作用就是当递减计数器递减到零时，重新装载计数器，再次进行递减计数\n\n#### 递减计数器 VAL\n\n读取时会返回该递减值，如果在该位写入1，则会清理，同时也会清除时钟中断控制器里面的COUNTFLAG\n\n#### 时钟源\n\n提供递减计数器工作的动力源，有外部晶振提供\n\n#### 时钟中断控制器\n\n```\n16-COUNTFLAG：如果上次读取该寄存器后，再递减到1，则该位置为1\n\n2-CLKSOURCE：时钟源选择，0=AHB/8=72/8=9M，1=AHB=72M\n\n1-TICKINT：递减计数器到零时发出异常请求\n\n0-ENABLE：控制器的使能位\n```\n\n#### 代码Demo\n\n```\n#include \"bsp_systick.h\"\n\n#if 0\n\nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)\n{ \n\t//判断ticks传入的值是否大于 2^24，如果大于则返回错误值\n  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */\n  \n\t//初始化寄存器reload的值                                  \n  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */\n\t\n\t//配置时钟中断优先级，1左移四个位，再减1，配置的是15，最低等级\n  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */\n  \n\t//初始化count的值为0\n\tSysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */\n\t\n\t//时钟配置成72M，使能中断，使能systick\n  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | \n                   SysTick_CTRL_TICKINT_Msk   | \n                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */\n  return (0);                                                  /* Function successful */\n}\n\n#endif\n\nvoid SysTick_Delay_us(uint32_t us)\n{\n\tuint32_t i;\n\t\n\t//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒\n\tSysTick_Config(72);\n\t\n\tfor(i=0;i<us;i++)//进行输入值的循环，循环结束则退出\n\t{\n\t\twhile (!((SysTick -> CTRL) & (1<<16)));//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环\n\t}\n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//将使能位关闭，停止计时，退出循环\n}\n\nvoid SysTick_Delay_ms(uint32_t ms)\n{\n\tuint32_t j;\n\t\n\t//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒\n\tSysTick_Config(72000);\n\n\t\n\tfor(j=0;j<ms;j++)//进行输入值的循环，循环结束则退出\n\t{\n\t\twhile (!((SysTick -> CTRL) & (1<<16)));//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环\n\t}\n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//将使能位关闭，停止计时，退出循环\n}\n\n```\n","slug":"STM32的时钟学习","published":1,"updated":"2024-07-31T03:33:49.967Z","_id":"clz9aaxqd000sygfb7jibdf8e","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"STM32的时钟学习\"><a href=\"#STM32的时钟学习\" class=\"headerlink\" title=\"STM32的时钟学习\"></a>STM32的时钟学习</h1><h2 id=\"时钟SysTick\"><a href=\"#时钟SysTick\" class=\"headerlink\" title=\"时钟SysTick\"></a>时钟SysTick</h2><p>时钟一共有五个部分，重装载寄存器、递减计数器、时钟源、时钟中断控制器、校准数值寄存器（用不到）</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/mbKvAFMpZEVXnd4.png\" alt=\"SysTick.png\"></p>\n<h4 id=\"重装载寄存器-LOAD\"><a href=\"#重装载寄存器-LOAD\" class=\"headerlink\" title=\"重装载寄存器 LOAD\"></a>重装载寄存器 LOAD</h4><p>作用就是当递减计数器递减到零时，重新装载计数器，再次进行递减计数</p>\n<h4 id=\"递减计数器-VAL\"><a href=\"#递减计数器-VAL\" class=\"headerlink\" title=\"递减计数器 VAL\"></a>递减计数器 VAL</h4><p>读取时会返回该递减值，如果在该位写入1，则会清理，同时也会清除时钟中断控制器里面的COUNTFLAG</p>\n<h4 id=\"时钟源\"><a href=\"#时钟源\" class=\"headerlink\" title=\"时钟源\"></a>时钟源</h4><p>提供递减计数器工作的动力源，有外部晶振提供</p>\n<h4 id=\"时钟中断控制器\"><a href=\"#时钟中断控制器\" class=\"headerlink\" title=\"时钟中断控制器\"></a>时钟中断控制器</h4><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">16</span>-COUNTFLAG：如果上次读取该寄存器后，再递减到<span class=\"hljs-number\">1</span>，则该位置为<span class=\"hljs-number\">1</span><br><br><span class=\"hljs-attribute\">2</span>-CLKSOURCE：时钟源选择，<span class=\"hljs-number\">0</span>=AHB/<span class=\"hljs-number\">8</span>=<span class=\"hljs-number\">72</span>/<span class=\"hljs-number\">8</span>=<span class=\"hljs-number\">9</span>M，<span class=\"hljs-number\">1</span>=AHB=<span class=\"hljs-number\">72</span>M<br><br><span class=\"hljs-attribute\">1</span>-TICKINT：递减计数器到零时发出异常请求<br><br><span class=\"hljs-attribute\">0</span>-ENABLE：控制器的使能位<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"代码Demo\"><a href=\"#代码Demo\" class=\"headerlink\" title=\"代码Demo\"></a>代码Demo</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_systick.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> 0</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> __INLINE <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SysTick_Config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> ticks)</span></span><br><span class=\"hljs-function\"></span>&#123; <br>\t<span class=\"hljs-comment\">//判断ticks传入的值是否大于 2^24，如果大于则返回错误值</span><br>  <span class=\"hljs-keyword\">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>);            <span class=\"hljs-comment\">/* Reload value impossible */</span><br>  <br>\t<span class=\"hljs-comment\">//初始化寄存器reload的值                                  </span><br>  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class=\"hljs-number\">1</span>;      <span class=\"hljs-comment\">/* set reload register */</span><br>\t<br>\t<span class=\"hljs-comment\">//配置时钟中断优先级，1左移四个位，再减1，配置的是15，最低等级</span><br>  <span class=\"hljs-built_in\">NVIC_SetPriority</span> (SysTick_IRQn, (<span class=\"hljs-number\">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">/* set Priority for Cortex-M0 System Interrupts */</span><br>  <br>\t<span class=\"hljs-comment\">//初始化count的值为0</span><br>\tSysTick-&gt;VAL   = <span class=\"hljs-number\">0</span>;                                          <span class=\"hljs-comment\">/* Load the SysTick Counter Value */</span><br>\t<br>\t<span class=\"hljs-comment\">//时钟配置成72M，使能中断，使能systick</span><br>  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | <br>                   SysTick_CTRL_TICKINT_Msk   | <br>                   SysTick_CTRL_ENABLE_Msk;                    <span class=\"hljs-comment\">/* Enable SysTick IRQ and SysTick Timer */</span><br>  <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);                                                  <span class=\"hljs-comment\">/* Function successful */</span><br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SysTick_Delay_us</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> us)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">uint32_t</span> i;<br>\t<br>\t<span class=\"hljs-comment\">//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒</span><br>\t<span class=\"hljs-built_in\">SysTick_Config</span>(<span class=\"hljs-number\">72</span>);<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;us;i++)<span class=\"hljs-comment\">//进行输入值的循环，循环结束则退出</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (!((SysTick -&gt; CTRL) &amp; (<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">16</span>)));<span class=\"hljs-comment\">//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环</span><br>\t&#125;<br>\tSysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;<span class=\"hljs-comment\">//将使能位关闭，停止计时，退出循环</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SysTick_Delay_ms</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> ms)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">uint32_t</span> j;<br>\t<br>\t<span class=\"hljs-comment\">//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒</span><br>\t<span class=\"hljs-built_in\">SysTick_Config</span>(<span class=\"hljs-number\">72000</span>);<br><br>\t<br>\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;ms;j++)<span class=\"hljs-comment\">//进行输入值的循环，循环结束则退出</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (!((SysTick -&gt; CTRL) &amp; (<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">16</span>)));<span class=\"hljs-comment\">//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环</span><br>\t&#125;<br>\tSysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;<span class=\"hljs-comment\">//将使能位关闭，停止计时，退出循环</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"STM32的时钟学习\"><a href=\"#STM32的时钟学习\" class=\"headerlink\" title=\"STM32的时钟学习\"></a>STM32的时钟学习</h1><h2 id=\"时钟SysTick\"><a href=\"#时钟SysTick\" class=\"headerlink\" title=\"时钟SysTick\"></a>时钟SysTick</h2><p>时钟一共有五个部分，重装载寄存器、递减计数器、时钟源、时钟中断控制器、校准数值寄存器（用不到）</p>\n<p><img src=\"https://s2.loli.net/2024/07/27/mbKvAFMpZEVXnd4.png\" alt=\"SysTick.png\"></p>\n<h4 id=\"重装载寄存器-LOAD\"><a href=\"#重装载寄存器-LOAD\" class=\"headerlink\" title=\"重装载寄存器 LOAD\"></a>重装载寄存器 LOAD</h4><p>作用就是当递减计数器递减到零时，重新装载计数器，再次进行递减计数</p>\n<h4 id=\"递减计数器-VAL\"><a href=\"#递减计数器-VAL\" class=\"headerlink\" title=\"递减计数器 VAL\"></a>递减计数器 VAL</h4><p>读取时会返回该递减值，如果在该位写入1，则会清理，同时也会清除时钟中断控制器里面的COUNTFLAG</p>\n<h4 id=\"时钟源\"><a href=\"#时钟源\" class=\"headerlink\" title=\"时钟源\"></a>时钟源</h4><p>提供递减计数器工作的动力源，有外部晶振提供</p>\n<h4 id=\"时钟中断控制器\"><a href=\"#时钟中断控制器\" class=\"headerlink\" title=\"时钟中断控制器\"></a>时钟中断控制器</h4><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">16</span>-COUNTFLAG：如果上次读取该寄存器后，再递减到<span class=\"hljs-number\">1</span>，则该位置为<span class=\"hljs-number\">1</span><br><br><span class=\"hljs-attribute\">2</span>-CLKSOURCE：时钟源选择，<span class=\"hljs-number\">0</span>=AHB/<span class=\"hljs-number\">8</span>=<span class=\"hljs-number\">72</span>/<span class=\"hljs-number\">8</span>=<span class=\"hljs-number\">9</span>M，<span class=\"hljs-number\">1</span>=AHB=<span class=\"hljs-number\">72</span>M<br><br><span class=\"hljs-attribute\">1</span>-TICKINT：递减计数器到零时发出异常请求<br><br><span class=\"hljs-attribute\">0</span>-ENABLE：控制器的使能位<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"代码Demo\"><a href=\"#代码Demo\" class=\"headerlink\" title=\"代码Demo\"></a>代码Demo</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_systick.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> 0</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> __INLINE <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SysTick_Config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> ticks)</span></span><br><span class=\"hljs-function\"></span>&#123; <br>\t<span class=\"hljs-comment\">//判断ticks传入的值是否大于 2^24，如果大于则返回错误值</span><br>  <span class=\"hljs-keyword\">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>);            <span class=\"hljs-comment\">/* Reload value impossible */</span><br>  <br>\t<span class=\"hljs-comment\">//初始化寄存器reload的值                                  </span><br>  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class=\"hljs-number\">1</span>;      <span class=\"hljs-comment\">/* set reload register */</span><br>\t<br>\t<span class=\"hljs-comment\">//配置时钟中断优先级，1左移四个位，再减1，配置的是15，最低等级</span><br>  <span class=\"hljs-built_in\">NVIC_SetPriority</span> (SysTick_IRQn, (<span class=\"hljs-number\">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">/* set Priority for Cortex-M0 System Interrupts */</span><br>  <br>\t<span class=\"hljs-comment\">//初始化count的值为0</span><br>\tSysTick-&gt;VAL   = <span class=\"hljs-number\">0</span>;                                          <span class=\"hljs-comment\">/* Load the SysTick Counter Value */</span><br>\t<br>\t<span class=\"hljs-comment\">//时钟配置成72M，使能中断，使能systick</span><br>  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | <br>                   SysTick_CTRL_TICKINT_Msk   | <br>                   SysTick_CTRL_ENABLE_Msk;                    <span class=\"hljs-comment\">/* Enable SysTick IRQ and SysTick Timer */</span><br>  <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);                                                  <span class=\"hljs-comment\">/* Function successful */</span><br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SysTick_Delay_us</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> us)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">uint32_t</span> i;<br>\t<br>\t<span class=\"hljs-comment\">//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒</span><br>\t<span class=\"hljs-built_in\">SysTick_Config</span>(<span class=\"hljs-number\">72</span>);<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;us;i++)<span class=\"hljs-comment\">//进行输入值的循环，循环结束则退出</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (!((SysTick -&gt; CTRL) &amp; (<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">16</span>)));<span class=\"hljs-comment\">//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环</span><br>\t&#125;<br>\tSysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;<span class=\"hljs-comment\">//将使能位关闭，停止计时，退出循环</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SysTick_Delay_ms</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> ms)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">uint32_t</span> j;<br>\t<br>\t<span class=\"hljs-comment\">//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒</span><br>\t<span class=\"hljs-built_in\">SysTick_Config</span>(<span class=\"hljs-number\">72000</span>);<br><br>\t<br>\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;ms;j++)<span class=\"hljs-comment\">//进行输入值的循环，循环结束则退出</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (!((SysTick -&gt; CTRL) &amp; (<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">16</span>)));<span class=\"hljs-comment\">//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环</span><br>\t&#125;<br>\tSysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;<span class=\"hljs-comment\">//将使能位关闭，停止计时，退出循环</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n"},{"title":"Linux环境安装和配置","date":"2024-07-08T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/buUim8aA5VDrt6d.png","_content":"\n# Linux环境安装和配置\n\n## 一、安装VMware（16/17）\n\n安装版本：VMware® Workstation 16 Pro\n\n安装保姆链接：[安装虚拟机（VMware）保姆级教程（附安装包）_vmware虚拟机-CSDN博客](https://blog.csdn.net/weixin_74195551/article/details/127288338)\n\n破解链接：[VMware Workstation虚拟机合集+激活密钥_Win+Linux_10∕11∕12∕14∕15∕16∕17 - 『逆向资源区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn](https://www.52pojie.cn/thread-1804571-1-1.html)\n\n破解码：ZF3R0-FHED2-M80TY-8QYGC-NPKYF\n\nMobaXtem链接：[VMware虚拟机配置、连接MobaXterm_mobaxtem怎么连接虚拟机-CSDN博客](https://blog.csdn.net/qq_42578036/article/details/107710339)\n\n终极链接：[保姆级教程|VMware安装Ubuntu20.04(系统安装+网络配置+open-vm-tools安装+国内软件源更新)-CSDN博客](https://blog.csdn.net/lhl_blog/article/details/123406322)\n\n报错：\n\nVMware Workstation 无法连接到虚拟机\n\n点开虚拟机“属性”，在“兼容性”里面设置为以管理员身份运行此程序。\n\nVMware创建新的虚拟机，弹出“您已输入用户名，客户机操作将保留此用户名”错误提示\n\n【root】被系统占用了，让用户新建一个低权限的账户，修改用户名，不要再使用【root】，如：改为【user】或【your_name】\n\nVMware Ubuntu ping 百度不通\n\n选择 虚拟机->设置->网络适配器->自定义特定虚拟网络->选择VMnet1(桥接网络)->确定\n\n目的是确定我们使用的是VMnet1(桥接网络)，之后就可以ping通\n\n安装磁盘管理工具gparted并运行\n\n```\nsudo apt install gparted\nsudo gparted\n```\n\n报错是权限不足,那么修改挂载点的权限即可(注:所谓\"挂载\"的概念体现的是Linux\"一切皆文件\"的思想,物理世界中的一块硬盘在Linux系统的逻辑中也被映射为一个文件)\n\n```\nsudo mount -o remount -rw / \nsudo mount -o remount -rw /var/snap/firefox/common/host-hunspell\n```\n\n## 二、安装Ubuntu（22.04）\n\n安装版本：Linux Ubuntu22.04.4\n\n安装保姆链接：[ubuntu 22.04下载安装_ubuntu22.04下载-CSDN博客](https://blog.csdn.net/weixin_42640280/article/details/128351105)\n\n清华源：[清华大学开源软件镜像站 | Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/)\n\n步骤指令\n\n```\nsudo su //进入管理者模式\n\napt-get update //更新apt\n\napt-get install net-tools //安装ifconfig相关配件\n\napt-get install openssh-server //下载和安装ssh\n\nservice ssh restart //启动ssh\n```\n\n## 三、安装应用依赖第三方库\n\n将工程导入虚拟机中，tar -xvf 解压工程包\n\ngit clone 的所有包的位置可以随机放置，但是需要对每个包进行编译，编译参照readme文件或者网上查找，如果下载不下来，可以直接去官网直接下载zip格式，使用unzip xxx.zip进行安装\n\n```\nsudo apt-get install -y build-essential libsdl2-dev\n\ngit clone http://172.23.88.26:3333/zhangyufeng/libcrlog.git  //按照readme文档可以编译\n\nsudo apt-get install  libjson-c-dev\n\ngit clone https://github.com/protocolbuffers/protobuf.git\n\t//没安装成功，bash: ./autogen.sh: No such file or directory\n\t//在晚上的时候安装成功了，原因是高版本的缺失了./autogen.sh脚本，进行降版本就可以了，花费4小时\n\t//终极感谢博主：https://blog.csdn.net/jax_fanyang/article/details/135937002\n\t\n    1.11 点击链接下载3.21.12版本源码。https://github.com/protocolbuffers/protobuf/releases/tag/v2\n    1.12 cd protobuf-21.12/\n    1.13 ./autogen.sh\n    1.14 ./configure --prefix=/usr/local/protobuf\n    1.15 make\n    1.16 sudo make install\n    1.17 sudo vim /etc/profile\n    1.18 #添加以下内容：\n\n    #(动态库搜索路径) 程序加载运⾏期间查找动态链接库时指定除了系统默认路径之外的其他路径\n    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/protobuf/lib/\n    #(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径\n    export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/protobuf/lib/\n    #执⾏程序搜索路径\n    export PATH=$PATH:/usr/local/protobuf/bin/\n    #c程序头⽂件搜索路径\n    export C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/local/protobuf/include/\n    #c++程序头⽂件搜索路径\n    export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/protobuf/include/\n    #pkg-config 路径\n    export PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/\n    1.18 source /etc/profile\n    1.19  protoc --version \n    执行之后应该看到==libprotoc 3.21.12==如果出现这个版本信息则安装成功\n    \ngit clone https://github.com/protobuf-c/protobuf-c  //按照readme文档可以编译\n\ngit clone https://github.com/eclipse/paho.mqtt.c.git\n\t\n\tbash\n    cd paho.mqtt.c\n    mkdir build && cd build\n    cmake ..\n    make\n    sudo make install\n\ngit clone https://github.com/eclipse/paho.mqtt.cpp.git（1.3.10）  //安装失败\n\ngit clone https://github.com/aliyun/aliyun-oss-cpp-sdk.git\n\n    cd <path/to/aliyun-oss-cpp-sdk>\n    mkdir build\n    cd build\n    cmake ..\n    \n    sudo apt-get install libcurl4-openssl-dev libssl-dev\n    make\n\ngit clone https://github.com/open-source-parsers/jsoncpp.git\n\n    mkdir -p build/debug\n    cd build/debug\n    cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G \"Unix Makefiles\" ../..\n    make\n\nsudo apt install libapr1-dev\n\nsudo apt install libaprutil1-dev\n\nsudo apt install libmxml-dev\n\nsudo apt-get install uuid-dev \n\ngit clone https://github.com/aliyun/aliyun-oss-c-sdk.git //好像安装有点问题\n\n    ./configure\n    make\n    make install\n\nhttps://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/102787/cn_zh/1558078831675/VodSDK-C_1.0.0.tar.gz?spm=a2c4g.11186623.0.0.65c71cd50vaal4&file=VodSDK-C_1.0.0.tar.gz //不知道怎么安装\n\n//找阿里云帮忙实现：[使用C/C++ SDK上传文件_视频点播(VOD)-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/vod/developer-reference/upload-sdk-for-c-or-cpp?spm=a2c4g.11186623.0.0.61dd2c16XPqrTn#multiTask7060)\n\n    cmake .\n    make\n    make install\n\ngit clone https://github.com/ithewei/libhv\n\n    mkdir build\n    cd build\n    cmake ..\n    cmake --build .\n\nsudo apt-get install libboost-all-dev\n\ngit clone https://github.com/inotify-tools/inotify-tools.git//安装不知道成没成功\n\nsudo apt-get install libfreeimage3 libfreeimage-dev\n\ngit clone https://github.com/dpilger26/NumCpp.git\n\nsudo apt-get install libavformat-dev\n\nsudo apt-get install libswscale-dev\n```\n\n## 四、在PC上编译运行应用\n\nmake 编译程序\n\nmake clean 清除编译\n\n头文件所在位置：\n\n```\n/usr/include/\n\n/usr/local/include/\n\ncp  -r /usr/local/include/vod_sdk/ /usr/include/vod_sdk/  //缺失upload.h头文件，将他进行复制到usr/include/文件夹当中\n\n- 安装依赖\n  sudo apt install libjson-c-dev\n\n- 编译\n  make\n\n- 安装\n  sudo make install\n\n- 更新系统动态库\n  sudo ldconfig\n```\n\n运行项目\n\n先获得虚拟设备参数，导入config中\"/home/user/creality/userdata/config/\"\n\n开始编译主程序  make clean && make -j4（j4、j8代表进程速度，越高越快）\n\n获得各个文件的单独运行包，在vscode中运行./master-server，即可跑通实体机\n\nlinux中/opt目录用来**安装附加软件包**，是用户级的程序目录，可以理解为D:/Software。 安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。\n\n## 五、交叉编译到目标板运行\n\n交叉编译讲解：[交叉编译入门及必要配置方法总结_gcc-manifest.txt-CSDN博客](https://blog.csdn.net/lc315yuhuofei/article/details/103782049)\n\n虚拟机交叉编译教程：[立创泰山派学习05-虚拟机ubuntu安装交叉编译工具 - zbl1118 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zblblog/p/18136017)\n\n## 六、知识点总结\n\n#### 1.交叉编译知识点\n\n交叉编译的目的是在一台架构A主机平台上编译另一种架构B目标平台的二进制文件或者库，交叉编译在目标系统平台（开发出来的应用程序序所运行的平台）难以或不容易编译时非常有用。 完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上\n\n主机平台：PC端 Windows 10 专业工作站版\n\n目标平台：Linux Ubuntu22.04.4/VMware® Workstation 16 Pro\n\n通常交叉编译工具链命名规则为：arch-core-kernel-system\n\narch：目标平台架构，如上文提到的arm，mips等；\n\ncore：有两种种情况，第一是CPU Core，如Cortex A8；第二是指定工具链的供应商。如果没有特殊指定，则留空不填。这一组命名比较灵活，有以厂家名称命名的，有以开发者命名的，也有以开发板命名的，或者直接是none或cross的；\n\nkernel： 目标平台的OS，见过的有linux，uclinux，bare-metal（无OS）；\n\nsystem：嵌入式应用二进制接口（Embedded Application Binary Interface），交叉编译工具链所选择的库函数和目标映像的规范，如gnu，gnueabi等。其中gnu等价于glibc+oabi；gnueabi等价于glibc+eabi。若不指定，则也可以留空不填；\n\n上述命名规则并不是统一的规范，使用的时候作为参考就行。我使用的交叉编译工具链名称为：gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu。\n\n获取交叉编译工具链两个途径：\n\n直接下载知名厂家已经编译好的工具链。\n\n```\nhttps://www.linaro.org/downloads/\nhttp://ftp.arm.linux.org.uk/pub/armlinux/toolchain/\nhttp://www.denx.de/en/Software/WebHome\nhttps://launchpad.net/gcc-arm-embedded\n```\n\n自己编译交叉编译工具链\n\n编译交叉编译工具链的工具：crosstool-NG、Buildroot、Embedded Linux Development Kit (ELDK)\n\n#### 2.Linux 系统编程知识点\n\n[Linux 系统编程从入门到进阶 学习指南-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1457993)\n\n什么是库函数？\n\n库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。\n\n[Linux C函数库大全 - 一觉醒来写程序 - 博客园 (cnblogs.com)](https://www.cnblogs.com/realjimmy/p/12844359.html)\n\n参考手册：[介紹 | Linux C API 参考手册 (gitbooks.io)](https://wizardforcel.gitbooks.io/linux-c-api-ref/content/index.html)\n\n**进程究竟是什么？**\n\n每当你启动一个程序，Linux 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。\n\n**1.管道 （Pipe）**\n\n管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：**匿名管道**和**有名管道**。\n\n**2.信号 (Signals)**\n\n在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。\n\n信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。\n\n**3.文件(Files)**\n\n文件在 Linux 系统中是一种基本的持久化存储机制，可用于**进程间通信**。多个进程可以通过对同一个文件的读取和写入来共享信息。\n\n**4.信号量(Semaphores)**\n信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。\n\n**5.共享内存(Shared Memory)**\n在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。\n\n**6.消息队列 (Message Queues)**\n\n消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。\n\n**7.套接字 (Sockets)**\n\n套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。\n\n## 七、常用指令\n\n```\n\nuname -m /*查看系统架构*/\nlscpu /*查看更多CPU情况*/\n\ntar -vxf [xxx.tar.gz压缩包]\nmv [现在的位置] [将要移动的位置]\n\npip list /*罗列所有的安装包*/\n\nmake clean  /*清理编译*/\nmake && make install  /*开始编译*/\n\ncp  -r /usr/local/include/vod_sdk/ /usr/include/vod_sdk/  /*复制文件夹到另一个文件夹上*/\n\nsudo apt-get autoremove xxx  /*卸载*/\n```\n\n常用指令汇总：[linux 常用命令【编程必备】-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1561151?spm=a2c6h.12873639.article-detail.33.657a1be0lxiKr4&scm=20140722.ID_community@@article@@1561151._.ID_community@@article@@1561151-OR_rec-V_1-RL_community@@article@@1457993)\n","source":"_posts/Work No.1.md","raw":"---\ntitle: Linux环境安装和配置\ntags: Linux\ndate: 2024-07-09\ncategories: Linux\nindex_img: https://s2.loli.net/2024/07/31/buUim8aA5VDrt6d.png\n---\n\n# Linux环境安装和配置\n\n## 一、安装VMware（16/17）\n\n安装版本：VMware® Workstation 16 Pro\n\n安装保姆链接：[安装虚拟机（VMware）保姆级教程（附安装包）_vmware虚拟机-CSDN博客](https://blog.csdn.net/weixin_74195551/article/details/127288338)\n\n破解链接：[VMware Workstation虚拟机合集+激活密钥_Win+Linux_10∕11∕12∕14∕15∕16∕17 - 『逆向资源区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn](https://www.52pojie.cn/thread-1804571-1-1.html)\n\n破解码：ZF3R0-FHED2-M80TY-8QYGC-NPKYF\n\nMobaXtem链接：[VMware虚拟机配置、连接MobaXterm_mobaxtem怎么连接虚拟机-CSDN博客](https://blog.csdn.net/qq_42578036/article/details/107710339)\n\n终极链接：[保姆级教程|VMware安装Ubuntu20.04(系统安装+网络配置+open-vm-tools安装+国内软件源更新)-CSDN博客](https://blog.csdn.net/lhl_blog/article/details/123406322)\n\n报错：\n\nVMware Workstation 无法连接到虚拟机\n\n点开虚拟机“属性”，在“兼容性”里面设置为以管理员身份运行此程序。\n\nVMware创建新的虚拟机，弹出“您已输入用户名，客户机操作将保留此用户名”错误提示\n\n【root】被系统占用了，让用户新建一个低权限的账户，修改用户名，不要再使用【root】，如：改为【user】或【your_name】\n\nVMware Ubuntu ping 百度不通\n\n选择 虚拟机->设置->网络适配器->自定义特定虚拟网络->选择VMnet1(桥接网络)->确定\n\n目的是确定我们使用的是VMnet1(桥接网络)，之后就可以ping通\n\n安装磁盘管理工具gparted并运行\n\n```\nsudo apt install gparted\nsudo gparted\n```\n\n报错是权限不足,那么修改挂载点的权限即可(注:所谓\"挂载\"的概念体现的是Linux\"一切皆文件\"的思想,物理世界中的一块硬盘在Linux系统的逻辑中也被映射为一个文件)\n\n```\nsudo mount -o remount -rw / \nsudo mount -o remount -rw /var/snap/firefox/common/host-hunspell\n```\n\n## 二、安装Ubuntu（22.04）\n\n安装版本：Linux Ubuntu22.04.4\n\n安装保姆链接：[ubuntu 22.04下载安装_ubuntu22.04下载-CSDN博客](https://blog.csdn.net/weixin_42640280/article/details/128351105)\n\n清华源：[清华大学开源软件镜像站 | Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/)\n\n步骤指令\n\n```\nsudo su //进入管理者模式\n\napt-get update //更新apt\n\napt-get install net-tools //安装ifconfig相关配件\n\napt-get install openssh-server //下载和安装ssh\n\nservice ssh restart //启动ssh\n```\n\n## 三、安装应用依赖第三方库\n\n将工程导入虚拟机中，tar -xvf 解压工程包\n\ngit clone 的所有包的位置可以随机放置，但是需要对每个包进行编译，编译参照readme文件或者网上查找，如果下载不下来，可以直接去官网直接下载zip格式，使用unzip xxx.zip进行安装\n\n```\nsudo apt-get install -y build-essential libsdl2-dev\n\ngit clone http://172.23.88.26:3333/zhangyufeng/libcrlog.git  //按照readme文档可以编译\n\nsudo apt-get install  libjson-c-dev\n\ngit clone https://github.com/protocolbuffers/protobuf.git\n\t//没安装成功，bash: ./autogen.sh: No such file or directory\n\t//在晚上的时候安装成功了，原因是高版本的缺失了./autogen.sh脚本，进行降版本就可以了，花费4小时\n\t//终极感谢博主：https://blog.csdn.net/jax_fanyang/article/details/135937002\n\t\n    1.11 点击链接下载3.21.12版本源码。https://github.com/protocolbuffers/protobuf/releases/tag/v2\n    1.12 cd protobuf-21.12/\n    1.13 ./autogen.sh\n    1.14 ./configure --prefix=/usr/local/protobuf\n    1.15 make\n    1.16 sudo make install\n    1.17 sudo vim /etc/profile\n    1.18 #添加以下内容：\n\n    #(动态库搜索路径) 程序加载运⾏期间查找动态链接库时指定除了系统默认路径之外的其他路径\n    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/protobuf/lib/\n    #(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径\n    export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/protobuf/lib/\n    #执⾏程序搜索路径\n    export PATH=$PATH:/usr/local/protobuf/bin/\n    #c程序头⽂件搜索路径\n    export C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/local/protobuf/include/\n    #c++程序头⽂件搜索路径\n    export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/protobuf/include/\n    #pkg-config 路径\n    export PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/\n    1.18 source /etc/profile\n    1.19  protoc --version \n    执行之后应该看到==libprotoc 3.21.12==如果出现这个版本信息则安装成功\n    \ngit clone https://github.com/protobuf-c/protobuf-c  //按照readme文档可以编译\n\ngit clone https://github.com/eclipse/paho.mqtt.c.git\n\t\n\tbash\n    cd paho.mqtt.c\n    mkdir build && cd build\n    cmake ..\n    make\n    sudo make install\n\ngit clone https://github.com/eclipse/paho.mqtt.cpp.git（1.3.10）  //安装失败\n\ngit clone https://github.com/aliyun/aliyun-oss-cpp-sdk.git\n\n    cd <path/to/aliyun-oss-cpp-sdk>\n    mkdir build\n    cd build\n    cmake ..\n    \n    sudo apt-get install libcurl4-openssl-dev libssl-dev\n    make\n\ngit clone https://github.com/open-source-parsers/jsoncpp.git\n\n    mkdir -p build/debug\n    cd build/debug\n    cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G \"Unix Makefiles\" ../..\n    make\n\nsudo apt install libapr1-dev\n\nsudo apt install libaprutil1-dev\n\nsudo apt install libmxml-dev\n\nsudo apt-get install uuid-dev \n\ngit clone https://github.com/aliyun/aliyun-oss-c-sdk.git //好像安装有点问题\n\n    ./configure\n    make\n    make install\n\nhttps://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/102787/cn_zh/1558078831675/VodSDK-C_1.0.0.tar.gz?spm=a2c4g.11186623.0.0.65c71cd50vaal4&file=VodSDK-C_1.0.0.tar.gz //不知道怎么安装\n\n//找阿里云帮忙实现：[使用C/C++ SDK上传文件_视频点播(VOD)-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/vod/developer-reference/upload-sdk-for-c-or-cpp?spm=a2c4g.11186623.0.0.61dd2c16XPqrTn#multiTask7060)\n\n    cmake .\n    make\n    make install\n\ngit clone https://github.com/ithewei/libhv\n\n    mkdir build\n    cd build\n    cmake ..\n    cmake --build .\n\nsudo apt-get install libboost-all-dev\n\ngit clone https://github.com/inotify-tools/inotify-tools.git//安装不知道成没成功\n\nsudo apt-get install libfreeimage3 libfreeimage-dev\n\ngit clone https://github.com/dpilger26/NumCpp.git\n\nsudo apt-get install libavformat-dev\n\nsudo apt-get install libswscale-dev\n```\n\n## 四、在PC上编译运行应用\n\nmake 编译程序\n\nmake clean 清除编译\n\n头文件所在位置：\n\n```\n/usr/include/\n\n/usr/local/include/\n\ncp  -r /usr/local/include/vod_sdk/ /usr/include/vod_sdk/  //缺失upload.h头文件，将他进行复制到usr/include/文件夹当中\n\n- 安装依赖\n  sudo apt install libjson-c-dev\n\n- 编译\n  make\n\n- 安装\n  sudo make install\n\n- 更新系统动态库\n  sudo ldconfig\n```\n\n运行项目\n\n先获得虚拟设备参数，导入config中\"/home/user/creality/userdata/config/\"\n\n开始编译主程序  make clean && make -j4（j4、j8代表进程速度，越高越快）\n\n获得各个文件的单独运行包，在vscode中运行./master-server，即可跑通实体机\n\nlinux中/opt目录用来**安装附加软件包**，是用户级的程序目录，可以理解为D:/Software。 安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。\n\n## 五、交叉编译到目标板运行\n\n交叉编译讲解：[交叉编译入门及必要配置方法总结_gcc-manifest.txt-CSDN博客](https://blog.csdn.net/lc315yuhuofei/article/details/103782049)\n\n虚拟机交叉编译教程：[立创泰山派学习05-虚拟机ubuntu安装交叉编译工具 - zbl1118 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zblblog/p/18136017)\n\n## 六、知识点总结\n\n#### 1.交叉编译知识点\n\n交叉编译的目的是在一台架构A主机平台上编译另一种架构B目标平台的二进制文件或者库，交叉编译在目标系统平台（开发出来的应用程序序所运行的平台）难以或不容易编译时非常有用。 完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上\n\n主机平台：PC端 Windows 10 专业工作站版\n\n目标平台：Linux Ubuntu22.04.4/VMware® Workstation 16 Pro\n\n通常交叉编译工具链命名规则为：arch-core-kernel-system\n\narch：目标平台架构，如上文提到的arm，mips等；\n\ncore：有两种种情况，第一是CPU Core，如Cortex A8；第二是指定工具链的供应商。如果没有特殊指定，则留空不填。这一组命名比较灵活，有以厂家名称命名的，有以开发者命名的，也有以开发板命名的，或者直接是none或cross的；\n\nkernel： 目标平台的OS，见过的有linux，uclinux，bare-metal（无OS）；\n\nsystem：嵌入式应用二进制接口（Embedded Application Binary Interface），交叉编译工具链所选择的库函数和目标映像的规范，如gnu，gnueabi等。其中gnu等价于glibc+oabi；gnueabi等价于glibc+eabi。若不指定，则也可以留空不填；\n\n上述命名规则并不是统一的规范，使用的时候作为参考就行。我使用的交叉编译工具链名称为：gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu。\n\n获取交叉编译工具链两个途径：\n\n直接下载知名厂家已经编译好的工具链。\n\n```\nhttps://www.linaro.org/downloads/\nhttp://ftp.arm.linux.org.uk/pub/armlinux/toolchain/\nhttp://www.denx.de/en/Software/WebHome\nhttps://launchpad.net/gcc-arm-embedded\n```\n\n自己编译交叉编译工具链\n\n编译交叉编译工具链的工具：crosstool-NG、Buildroot、Embedded Linux Development Kit (ELDK)\n\n#### 2.Linux 系统编程知识点\n\n[Linux 系统编程从入门到进阶 学习指南-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1457993)\n\n什么是库函数？\n\n库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。\n\n[Linux C函数库大全 - 一觉醒来写程序 - 博客园 (cnblogs.com)](https://www.cnblogs.com/realjimmy/p/12844359.html)\n\n参考手册：[介紹 | Linux C API 参考手册 (gitbooks.io)](https://wizardforcel.gitbooks.io/linux-c-api-ref/content/index.html)\n\n**进程究竟是什么？**\n\n每当你启动一个程序，Linux 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。\n\n**1.管道 （Pipe）**\n\n管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：**匿名管道**和**有名管道**。\n\n**2.信号 (Signals)**\n\n在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。\n\n信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。\n\n**3.文件(Files)**\n\n文件在 Linux 系统中是一种基本的持久化存储机制，可用于**进程间通信**。多个进程可以通过对同一个文件的读取和写入来共享信息。\n\n**4.信号量(Semaphores)**\n信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。\n\n**5.共享内存(Shared Memory)**\n在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。\n\n**6.消息队列 (Message Queues)**\n\n消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。\n\n**7.套接字 (Sockets)**\n\n套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。\n\n## 七、常用指令\n\n```\n\nuname -m /*查看系统架构*/\nlscpu /*查看更多CPU情况*/\n\ntar -vxf [xxx.tar.gz压缩包]\nmv [现在的位置] [将要移动的位置]\n\npip list /*罗列所有的安装包*/\n\nmake clean  /*清理编译*/\nmake && make install  /*开始编译*/\n\ncp  -r /usr/local/include/vod_sdk/ /usr/include/vod_sdk/  /*复制文件夹到另一个文件夹上*/\n\nsudo apt-get autoremove xxx  /*卸载*/\n```\n\n常用指令汇总：[linux 常用命令【编程必备】-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1561151?spm=a2c6h.12873639.article-detail.33.657a1be0lxiKr4&scm=20140722.ID_community@@article@@1561151._.ID_community@@article@@1561151-OR_rec-V_1-RL_community@@article@@1457993)\n","slug":"Work No.1","published":1,"updated":"2024-07-31T03:33:29.311Z","_id":"clz9aaxqf000vygfbdgmgalz0","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Linux环境安装和配置\"><a href=\"#Linux环境安装和配置\" class=\"headerlink\" title=\"Linux环境安装和配置\"></a>Linux环境安装和配置</h1><h2 id=\"一、安装VMware（16-17）\"><a href=\"#一、安装VMware（16-17）\" class=\"headerlink\" title=\"一、安装VMware（16&#x2F;17）\"></a>一、安装VMware（16&#x2F;17）</h2><p>安装版本：VMware® Workstation 16 Pro</p>\n<p>安装保姆链接：<a href=\"https://blog.csdn.net/weixin_74195551/article/details/127288338\">安装虚拟机（VMware）保姆级教程（附安装包）_vmware虚拟机-CSDN博客</a></p>\n<p>破解链接：<a href=\"https://www.52pojie.cn/thread-1804571-1-1.html\">VMware Workstation虚拟机合集+激活密钥_Win+Linux_10∕11∕12∕14∕15∕16∕17 - 『逆向资源区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>\n<p>破解码：ZF3R0-FHED2-M80TY-8QYGC-NPKYF</p>\n<p>MobaXtem链接：<a href=\"https://blog.csdn.net/qq_42578036/article/details/107710339\">VMware虚拟机配置、连接MobaXterm_mobaxtem怎么连接虚拟机-CSDN博客</a></p>\n<p>终极链接：<a href=\"https://blog.csdn.net/lhl_blog/article/details/123406322\">保姆级教程|VMware安装Ubuntu20.04(系统安装+网络配置+open-vm-tools安装+国内软件源更新)-CSDN博客</a></p>\n<p>报错：</p>\n<p>VMware Workstation 无法连接到虚拟机</p>\n<p>点开虚拟机“属性”，在“兼容性”里面设置为以管理员身份运行此程序。</p>\n<p>VMware创建新的虚拟机，弹出“您已输入用户名，客户机操作将保留此用户名”错误提示</p>\n<p>【root】被系统占用了，让用户新建一个低权限的账户，修改用户名，不要再使用【root】，如：改为【user】或【your_name】</p>\n<p>VMware Ubuntu ping 百度不通</p>\n<p>选择 虚拟机-&gt;设置-&gt;网络适配器-&gt;自定义特定虚拟网络-&gt;选择VMnet1(桥接网络)-&gt;确定</p>\n<p>目的是确定我们使用的是VMnet1(桥接网络)，之后就可以ping通</p>\n<p>安装磁盘管理工具gparted并运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> apt install gparted<br><span class=\"hljs-built_in\">sudo</span> gparted<br></code></pre></td></tr></table></figure>\n\n<p>报错是权限不足,那么修改挂载点的权限即可(注:所谓”挂载”的概念体现的是Linux”一切皆文件”的思想,物理世界中的一块硬盘在Linux系统的逻辑中也被映射为一个文件)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> mount -o remount -rw / <br><span class=\"hljs-built_in\">sudo</span> mount -o remount -rw /var/snap/firefox/common/host-hunspell<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、安装Ubuntu（22-04）\"><a href=\"#二、安装Ubuntu（22-04）\" class=\"headerlink\" title=\"二、安装Ubuntu（22.04）\"></a>二、安装Ubuntu（22.04）</h2><p>安装版本：Linux Ubuntu22.04.4</p>\n<p>安装保姆链接：<a href=\"https://blog.csdn.net/weixin_42640280/article/details/128351105\">ubuntu 22.04下载安装_ubuntu22.04下载-CSDN博客</a></p>\n<p>清华源：<a href=\"https://mirrors.tuna.tsinghua.edu.cn/\">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>\n<p>步骤指令</p>\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs q\">sudo su <span class=\"hljs-comment\">//进入管理者模式</span><br><br>apt-<span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-comment\">//更新apt</span><br><br>apt-<span class=\"hljs-built_in\">get</span> install net-tools <span class=\"hljs-comment\">//安装ifconfig相关配件</span><br><br>apt-<span class=\"hljs-built_in\">get</span> install openssh-server <span class=\"hljs-comment\">//下载和安装ssh</span><br><br>service ssh restart <span class=\"hljs-comment\">//启动ssh</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、安装应用依赖第三方库\"><a href=\"#三、安装应用依赖第三方库\" class=\"headerlink\" title=\"三、安装应用依赖第三方库\"></a>三、安装应用依赖第三方库</h2><p>将工程导入虚拟机中，tar -xvf 解压工程包</p>\n<p>git clone 的所有包的位置可以随机放置，但是需要对每个包进行编译，编译参照readme文件或者网上查找，如果下载不下来，可以直接去官网直接下载zip格式，使用unzip xxx.zip进行安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> apt-get install -y build-essential libsdl2-dev<br><br>git <span class=\"hljs-built_in\">clone</span> http://172.23.88.26:3333/zhangyufeng/libcrlog.git  //按照readme文档可以编译<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install  libjson-c-dev<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/protocolbuffers/protobuf.git<br>\t//没安装成功，bash: ./autogen.sh: No such file or directory<br>\t//在晚上的时候安装成功了，原因是高版本的缺失了./autogen.sh脚本，进行降版本就可以了，花费4小时<br>\t//终极感谢博主：https://blog.csdn.net/jax_fanyang/article/details/135937002<br>\t<br>    1.11 点击链接下载3.21.12版本源码。https://github.com/protocolbuffers/protobuf/releases/tag/v2<br>    1.12 <span class=\"hljs-built_in\">cd</span> protobuf-21.12/<br>    1.13 ./autogen.sh<br>    1.14 ./configure --prefix=/usr/local/protobuf<br>    1.15 make<br>    1.16 <span class=\"hljs-built_in\">sudo</span> make install<br>    1.17 <span class=\"hljs-built_in\">sudo</span> vim /etc/profile<br>    1.18 <span class=\"hljs-comment\">#添加以下内容：</span><br><br>    <span class=\"hljs-comment\">#(动态库搜索路径) 程序加载运⾏期间查找动态链接库时指定除了系统默认路径之外的其他路径</span><br>    <span class=\"hljs-built_in\">export</span> LD_LIBRARY_PATH=<span class=\"hljs-variable\">$LD_LIBRARY_PATH</span>:/usr/local/protobuf/lib/<br>    <span class=\"hljs-comment\">#(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径</span><br>    <span class=\"hljs-built_in\">export</span> LIBRARY_PATH=<span class=\"hljs-variable\">$LIBRARY_PATH</span>:/usr/local/protobuf/lib/<br>    <span class=\"hljs-comment\">#执⾏程序搜索路径</span><br>    <span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/local/protobuf/bin/<br>    <span class=\"hljs-comment\">#c程序头⽂件搜索路径</span><br>    <span class=\"hljs-built_in\">export</span> C_INCLUDE_PATH=<span class=\"hljs-variable\">$C_INCLUDE_PATH</span>:/usr/local/protobuf/include/<br>    <span class=\"hljs-comment\">#c++程序头⽂件搜索路径</span><br>    <span class=\"hljs-built_in\">export</span> CPLUS_INCLUDE_PATH=<span class=\"hljs-variable\">$CPLUS_INCLUDE_PATH</span>:/usr/local/protobuf/include/<br>    <span class=\"hljs-comment\">#pkg-config 路径</span><br>    <span class=\"hljs-built_in\">export</span> PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/<br>    1.18 <span class=\"hljs-built_in\">source</span> /etc/profile<br>    1.19  protoc --version <br>    执行之后应该看到==libprotoc 3.21.12==如果出现这个版本信息则安装成功<br>    <br>git <span class=\"hljs-built_in\">clone</span> https://github.com/protobuf-c/protobuf-c  //按照readme文档可以编译<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/eclipse/paho.mqtt.c.git<br>\t<br>\tbash<br>    <span class=\"hljs-built_in\">cd</span> paho.mqtt.c<br>    <span class=\"hljs-built_in\">mkdir</span> build &amp;&amp; <span class=\"hljs-built_in\">cd</span> build<br>    cmake ..<br>    make<br>    <span class=\"hljs-built_in\">sudo</span> make install<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/eclipse/paho.mqtt.cpp.git（1.3.10）  //安装失败<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/aliyun/aliyun-oss-cpp-sdk.git<br><br>    <span class=\"hljs-built_in\">cd</span> &lt;path/to/aliyun-oss-cpp-sdk&gt;<br>    <span class=\"hljs-built_in\">mkdir</span> build<br>    <span class=\"hljs-built_in\">cd</span> build<br>    cmake ..<br>    <br>    <span class=\"hljs-built_in\">sudo</span> apt-get install libcurl4-openssl-dev libssl-dev<br>    make<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/open-source-parsers/jsoncpp.git<br><br>    <span class=\"hljs-built_in\">mkdir</span> -p build/debug<br>    <span class=\"hljs-built_in\">cd</span> build/debug<br>    cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G <span class=\"hljs-string\">&quot;Unix Makefiles&quot;</span> ../..<br>    make<br><br><span class=\"hljs-built_in\">sudo</span> apt install libapr1-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt install libaprutil1-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt install libmxml-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install uuid-dev <br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/aliyun/aliyun-oss-c-sdk.git //好像安装有点问题<br><br>    ./configure<br>    make<br>    make install<br><br>https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/102787/cn_zh/1558078831675/VodSDK-C_1.0.0.tar.gz?spm=a2c4g.11186623.0.0.65c71cd50vaal4&amp;file=VodSDK-C_1.0.0.tar.gz //不知道怎么安装<br><br>//找阿里云帮忙实现：[使用C/C++ SDK上传文件_视频点播(VOD)-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/vod/developer-reference/upload-sdk-for-c-or-cpp?spm=a2c4g.11186623.0.0.61dd2c16XPqrTn#multiTask7060)<br><br>    cmake .<br>    make<br>    make install<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/ithewei/libhv<br><br>    <span class=\"hljs-built_in\">mkdir</span> build<br>    <span class=\"hljs-built_in\">cd</span> build<br>    cmake ..<br>    cmake --build .<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libboost-all-dev<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/inotify-tools/inotify-tools.git//安装不知道成没成功<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libfreeimage3 libfreeimage-dev<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/dpilger26/NumCpp.git<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libavformat-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libswscale-dev<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、在PC上编译运行应用\"><a href=\"#四、在PC上编译运行应用\" class=\"headerlink\" title=\"四、在PC上编译运行应用\"></a>四、在PC上编译运行应用</h2><p>make 编译程序</p>\n<p>make clean 清除编译</p>\n<p>头文件所在位置：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">/usr/i</span>nclude/<br><br><span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/include/</span><br><br>cp  -r <span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/include/</span>vod_sdk<span class=\"hljs-regexp\">/ /u</span>sr<span class=\"hljs-regexp\">/include/</span>vod_sdk<span class=\"hljs-regexp\">/  /</span><span class=\"hljs-regexp\">/缺失upload.h头文件，将他进行复制到usr/i</span>nclude/文件夹当中<br><br>- 安装依赖<br>  sudo apt install libjson-c-dev<br><br>- 编译<br>  make<br><br>- 安装<br>  sudo make install<br><br>- 更新系统动态库<br>  sudo ldconfig<br></code></pre></td></tr></table></figure>\n\n<p>运行项目</p>\n<p>先获得虚拟设备参数，导入config中”&#x2F;home&#x2F;user&#x2F;creality&#x2F;userdata&#x2F;config&#x2F;“</p>\n<p>开始编译主程序  make clean &amp;&amp; make -j4（j4、j8代表进程速度，越高越快）</p>\n<p>获得各个文件的单独运行包，在vscode中运行.&#x2F;master-server，即可跑通实体机</p>\n<p>linux中&#x2F;opt目录用来<strong>安装附加软件包</strong>，是用户级的程序目录，可以理解为D:&#x2F;Software。 安装到&#x2F;opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。</p>\n<h2 id=\"五、交叉编译到目标板运行\"><a href=\"#五、交叉编译到目标板运行\" class=\"headerlink\" title=\"五、交叉编译到目标板运行\"></a>五、交叉编译到目标板运行</h2><p>交叉编译讲解：<a href=\"https://blog.csdn.net/lc315yuhuofei/article/details/103782049\">交叉编译入门及必要配置方法总结_gcc-manifest.txt-CSDN博客</a></p>\n<p>虚拟机交叉编译教程：<a href=\"https://www.cnblogs.com/zblblog/p/18136017\">立创泰山派学习05-虚拟机ubuntu安装交叉编译工具 - zbl1118 - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"六、知识点总结\"><a href=\"#六、知识点总结\" class=\"headerlink\" title=\"六、知识点总结\"></a>六、知识点总结</h2><h4 id=\"1-交叉编译知识点\"><a href=\"#1-交叉编译知识点\" class=\"headerlink\" title=\"1.交叉编译知识点\"></a>1.交叉编译知识点</h4><p>交叉编译的目的是在一台架构A主机平台上编译另一种架构B目标平台的二进制文件或者库，交叉编译在目标系统平台（开发出来的应用程序序所运行的平台）难以或不容易编译时非常有用。 完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上</p>\n<p>主机平台：PC端 Windows 10 专业工作站版</p>\n<p>目标平台：Linux Ubuntu22.04.4&#x2F;VMware® Workstation 16 Pro</p>\n<p>通常交叉编译工具链命名规则为：arch-core-kernel-system</p>\n<p>arch：目标平台架构，如上文提到的arm，mips等；</p>\n<p>core：有两种种情况，第一是CPU Core，如Cortex A8；第二是指定工具链的供应商。如果没有特殊指定，则留空不填。这一组命名比较灵活，有以厂家名称命名的，有以开发者命名的，也有以开发板命名的，或者直接是none或cross的；</p>\n<p>kernel： 目标平台的OS，见过的有linux，uclinux，bare-metal（无OS）；</p>\n<p>system：嵌入式应用二进制接口（Embedded Application Binary Interface），交叉编译工具链所选择的库函数和目标映像的规范，如gnu，gnueabi等。其中gnu等价于glibc+oabi；gnueabi等价于glibc+eabi。若不指定，则也可以留空不填；</p>\n<p>上述命名规则并不是统一的规范，使用的时候作为参考就行。我使用的交叉编译工具链名称为：gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu。</p>\n<p>获取交叉编译工具链两个途径：</p>\n<p>直接下载知名厂家已经编译好的工具链。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">https:<span class=\"hljs-regexp\">//</span>www.linaro.org<span class=\"hljs-regexp\">/downloads/</span><br>http:<span class=\"hljs-regexp\">//</span>ftp.arm.linux.org.uk<span class=\"hljs-regexp\">/pub/</span>armlinux<span class=\"hljs-regexp\">/toolchain/</span><br>http:<span class=\"hljs-regexp\">//</span>www.denx.de<span class=\"hljs-regexp\">/en/</span>Software/WebHome<br>https:<span class=\"hljs-regexp\">//</span>launchpad.net/gcc-arm-embedded<br></code></pre></td></tr></table></figure>\n\n<p>自己编译交叉编译工具链</p>\n<p>编译交叉编译工具链的工具：crosstool-NG、Buildroot、Embedded Linux Development Kit (ELDK)</p>\n<h4 id=\"2-Linux-系统编程知识点\"><a href=\"#2-Linux-系统编程知识点\" class=\"headerlink\" title=\"2.Linux 系统编程知识点\"></a>2.Linux 系统编程知识点</h4><p><a href=\"https://developer.aliyun.com/article/1457993\">Linux 系统编程从入门到进阶 学习指南-阿里云开发者社区 (aliyun.com)</a></p>\n<p>什么是库函数？</p>\n<p>库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。</p>\n<p><a href=\"https://www.cnblogs.com/realjimmy/p/12844359.html\">Linux C函数库大全 - 一觉醒来写程序 - 博客园 (cnblogs.com)</a></p>\n<p>参考手册：<a href=\"https://wizardforcel.gitbooks.io/linux-c-api-ref/content/index.html\">介紹 | Linux C API 参考手册 (gitbooks.io)</a></p>\n<p><strong>进程究竟是什么？</strong></p>\n<p>每当你启动一个程序，Linux 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。</p>\n<p><strong>1.管道 （Pipe）</strong></p>\n<p>管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：<strong>匿名管道</strong>和<strong>有名管道</strong>。</p>\n<p><strong>2.信号 (Signals)</strong></p>\n<p>在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。</p>\n<p>信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。</p>\n<p><strong>3.文件(Files)</strong></p>\n<p>文件在 Linux 系统中是一种基本的持久化存储机制，可用于<strong>进程间通信</strong>。多个进程可以通过对同一个文件的读取和写入来共享信息。</p>\n<p><strong>4.信号量(Semaphores)</strong><br>信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。</p>\n<p><strong>5.共享内存(Shared Memory)</strong><br>在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。</p>\n<p><strong>6.消息队列 (Message Queues)</strong></p>\n<p>消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。</p>\n<p><strong>7.套接字 (Sockets)</strong></p>\n<p>套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。</p>\n<h2 id=\"七、常用指令\"><a href=\"#七、常用指令\" class=\"headerlink\" title=\"七、常用指令\"></a>七、常用指令</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><br>uname <span class=\"hljs-operator\">-</span>m <span class=\"hljs-comment\">/*查看系统架构*/</span><br>lscpu <span class=\"hljs-comment\">/*查看更多CPU情况*/</span><br><br>tar <span class=\"hljs-operator\">-</span>vxf [xxx.tar.gz压缩包]<br>mv [现在的位置] [将要移动的位置]<br><br>pip list <span class=\"hljs-comment\">/*罗列所有的安装包*/</span><br><br>make clean  <span class=\"hljs-comment\">/*清理编译*/</span><br>make <span class=\"hljs-operator\">&amp;&amp;</span> make install  <span class=\"hljs-comment\">/*开始编译*/</span><br><br>cp  <span class=\"hljs-operator\">-</span>r <span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/include/</span>vod_sdk<span class=\"hljs-operator\">/</span> <span class=\"hljs-regexp\">/usr/</span>include<span class=\"hljs-regexp\">/vod_sdk/</span>  <span class=\"hljs-comment\">/*复制文件夹到另一个文件夹上*/</span><br><br>sudo apt<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">get</span> autoremove xxx  <span class=\"hljs-comment\">/*卸载*/</span><br></code></pre></td></tr></table></figure>\n\n<p>常用指令汇总：<a href=\"https://developer.aliyun.com/article/1561151?spm=a2c6h.12873639.article-detail.33.657a1be0lxiKr4&scm=20140722.ID_community@@article@@1561151._.ID_community@@article@@1561151-OR_rec-V_1-RL_community@@article@@1457993\">linux 常用命令【编程必备】-阿里云开发者社区 (aliyun.com)</a></p>\n","excerpt":"","more":"<h1 id=\"Linux环境安装和配置\"><a href=\"#Linux环境安装和配置\" class=\"headerlink\" title=\"Linux环境安装和配置\"></a>Linux环境安装和配置</h1><h2 id=\"一、安装VMware（16-17）\"><a href=\"#一、安装VMware（16-17）\" class=\"headerlink\" title=\"一、安装VMware（16&#x2F;17）\"></a>一、安装VMware（16&#x2F;17）</h2><p>安装版本：VMware® Workstation 16 Pro</p>\n<p>安装保姆链接：<a href=\"https://blog.csdn.net/weixin_74195551/article/details/127288338\">安装虚拟机（VMware）保姆级教程（附安装包）_vmware虚拟机-CSDN博客</a></p>\n<p>破解链接：<a href=\"https://www.52pojie.cn/thread-1804571-1-1.html\">VMware Workstation虚拟机合集+激活密钥_Win+Linux_10∕11∕12∕14∕15∕16∕17 - 『逆向资源区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>\n<p>破解码：ZF3R0-FHED2-M80TY-8QYGC-NPKYF</p>\n<p>MobaXtem链接：<a href=\"https://blog.csdn.net/qq_42578036/article/details/107710339\">VMware虚拟机配置、连接MobaXterm_mobaxtem怎么连接虚拟机-CSDN博客</a></p>\n<p>终极链接：<a href=\"https://blog.csdn.net/lhl_blog/article/details/123406322\">保姆级教程|VMware安装Ubuntu20.04(系统安装+网络配置+open-vm-tools安装+国内软件源更新)-CSDN博客</a></p>\n<p>报错：</p>\n<p>VMware Workstation 无法连接到虚拟机</p>\n<p>点开虚拟机“属性”，在“兼容性”里面设置为以管理员身份运行此程序。</p>\n<p>VMware创建新的虚拟机，弹出“您已输入用户名，客户机操作将保留此用户名”错误提示</p>\n<p>【root】被系统占用了，让用户新建一个低权限的账户，修改用户名，不要再使用【root】，如：改为【user】或【your_name】</p>\n<p>VMware Ubuntu ping 百度不通</p>\n<p>选择 虚拟机-&gt;设置-&gt;网络适配器-&gt;自定义特定虚拟网络-&gt;选择VMnet1(桥接网络)-&gt;确定</p>\n<p>目的是确定我们使用的是VMnet1(桥接网络)，之后就可以ping通</p>\n<p>安装磁盘管理工具gparted并运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> apt install gparted<br><span class=\"hljs-built_in\">sudo</span> gparted<br></code></pre></td></tr></table></figure>\n\n<p>报错是权限不足,那么修改挂载点的权限即可(注:所谓”挂载”的概念体现的是Linux”一切皆文件”的思想,物理世界中的一块硬盘在Linux系统的逻辑中也被映射为一个文件)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> mount -o remount -rw / <br><span class=\"hljs-built_in\">sudo</span> mount -o remount -rw /var/snap/firefox/common/host-hunspell<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、安装Ubuntu（22-04）\"><a href=\"#二、安装Ubuntu（22-04）\" class=\"headerlink\" title=\"二、安装Ubuntu（22.04）\"></a>二、安装Ubuntu（22.04）</h2><p>安装版本：Linux Ubuntu22.04.4</p>\n<p>安装保姆链接：<a href=\"https://blog.csdn.net/weixin_42640280/article/details/128351105\">ubuntu 22.04下载安装_ubuntu22.04下载-CSDN博客</a></p>\n<p>清华源：<a href=\"https://mirrors.tuna.tsinghua.edu.cn/\">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>\n<p>步骤指令</p>\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs q\">sudo su <span class=\"hljs-comment\">//进入管理者模式</span><br><br>apt-<span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">update</span> <span class=\"hljs-comment\">//更新apt</span><br><br>apt-<span class=\"hljs-built_in\">get</span> install net-tools <span class=\"hljs-comment\">//安装ifconfig相关配件</span><br><br>apt-<span class=\"hljs-built_in\">get</span> install openssh-server <span class=\"hljs-comment\">//下载和安装ssh</span><br><br>service ssh restart <span class=\"hljs-comment\">//启动ssh</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、安装应用依赖第三方库\"><a href=\"#三、安装应用依赖第三方库\" class=\"headerlink\" title=\"三、安装应用依赖第三方库\"></a>三、安装应用依赖第三方库</h2><p>将工程导入虚拟机中，tar -xvf 解压工程包</p>\n<p>git clone 的所有包的位置可以随机放置，但是需要对每个包进行编译，编译参照readme文件或者网上查找，如果下载不下来，可以直接去官网直接下载zip格式，使用unzip xxx.zip进行安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> apt-get install -y build-essential libsdl2-dev<br><br>git <span class=\"hljs-built_in\">clone</span> http://172.23.88.26:3333/zhangyufeng/libcrlog.git  //按照readme文档可以编译<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install  libjson-c-dev<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/protocolbuffers/protobuf.git<br>\t//没安装成功，bash: ./autogen.sh: No such file or directory<br>\t//在晚上的时候安装成功了，原因是高版本的缺失了./autogen.sh脚本，进行降版本就可以了，花费4小时<br>\t//终极感谢博主：https://blog.csdn.net/jax_fanyang/article/details/135937002<br>\t<br>    1.11 点击链接下载3.21.12版本源码。https://github.com/protocolbuffers/protobuf/releases/tag/v2<br>    1.12 <span class=\"hljs-built_in\">cd</span> protobuf-21.12/<br>    1.13 ./autogen.sh<br>    1.14 ./configure --prefix=/usr/local/protobuf<br>    1.15 make<br>    1.16 <span class=\"hljs-built_in\">sudo</span> make install<br>    1.17 <span class=\"hljs-built_in\">sudo</span> vim /etc/profile<br>    1.18 <span class=\"hljs-comment\">#添加以下内容：</span><br><br>    <span class=\"hljs-comment\">#(动态库搜索路径) 程序加载运⾏期间查找动态链接库时指定除了系统默认路径之外的其他路径</span><br>    <span class=\"hljs-built_in\">export</span> LD_LIBRARY_PATH=<span class=\"hljs-variable\">$LD_LIBRARY_PATH</span>:/usr/local/protobuf/lib/<br>    <span class=\"hljs-comment\">#(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径</span><br>    <span class=\"hljs-built_in\">export</span> LIBRARY_PATH=<span class=\"hljs-variable\">$LIBRARY_PATH</span>:/usr/local/protobuf/lib/<br>    <span class=\"hljs-comment\">#执⾏程序搜索路径</span><br>    <span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/local/protobuf/bin/<br>    <span class=\"hljs-comment\">#c程序头⽂件搜索路径</span><br>    <span class=\"hljs-built_in\">export</span> C_INCLUDE_PATH=<span class=\"hljs-variable\">$C_INCLUDE_PATH</span>:/usr/local/protobuf/include/<br>    <span class=\"hljs-comment\">#c++程序头⽂件搜索路径</span><br>    <span class=\"hljs-built_in\">export</span> CPLUS_INCLUDE_PATH=<span class=\"hljs-variable\">$CPLUS_INCLUDE_PATH</span>:/usr/local/protobuf/include/<br>    <span class=\"hljs-comment\">#pkg-config 路径</span><br>    <span class=\"hljs-built_in\">export</span> PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/<br>    1.18 <span class=\"hljs-built_in\">source</span> /etc/profile<br>    1.19  protoc --version <br>    执行之后应该看到==libprotoc 3.21.12==如果出现这个版本信息则安装成功<br>    <br>git <span class=\"hljs-built_in\">clone</span> https://github.com/protobuf-c/protobuf-c  //按照readme文档可以编译<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/eclipse/paho.mqtt.c.git<br>\t<br>\tbash<br>    <span class=\"hljs-built_in\">cd</span> paho.mqtt.c<br>    <span class=\"hljs-built_in\">mkdir</span> build &amp;&amp; <span class=\"hljs-built_in\">cd</span> build<br>    cmake ..<br>    make<br>    <span class=\"hljs-built_in\">sudo</span> make install<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/eclipse/paho.mqtt.cpp.git（1.3.10）  //安装失败<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/aliyun/aliyun-oss-cpp-sdk.git<br><br>    <span class=\"hljs-built_in\">cd</span> &lt;path/to/aliyun-oss-cpp-sdk&gt;<br>    <span class=\"hljs-built_in\">mkdir</span> build<br>    <span class=\"hljs-built_in\">cd</span> build<br>    cmake ..<br>    <br>    <span class=\"hljs-built_in\">sudo</span> apt-get install libcurl4-openssl-dev libssl-dev<br>    make<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/open-source-parsers/jsoncpp.git<br><br>    <span class=\"hljs-built_in\">mkdir</span> -p build/debug<br>    <span class=\"hljs-built_in\">cd</span> build/debug<br>    cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G <span class=\"hljs-string\">&quot;Unix Makefiles&quot;</span> ../..<br>    make<br><br><span class=\"hljs-built_in\">sudo</span> apt install libapr1-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt install libaprutil1-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt install libmxml-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install uuid-dev <br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/aliyun/aliyun-oss-c-sdk.git //好像安装有点问题<br><br>    ./configure<br>    make<br>    make install<br><br>https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/102787/cn_zh/1558078831675/VodSDK-C_1.0.0.tar.gz?spm=a2c4g.11186623.0.0.65c71cd50vaal4&amp;file=VodSDK-C_1.0.0.tar.gz //不知道怎么安装<br><br>//找阿里云帮忙实现：[使用C/C++ SDK上传文件_视频点播(VOD)-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/vod/developer-reference/upload-sdk-for-c-or-cpp?spm=a2c4g.11186623.0.0.61dd2c16XPqrTn#multiTask7060)<br><br>    cmake .<br>    make<br>    make install<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/ithewei/libhv<br><br>    <span class=\"hljs-built_in\">mkdir</span> build<br>    <span class=\"hljs-built_in\">cd</span> build<br>    cmake ..<br>    cmake --build .<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libboost-all-dev<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/inotify-tools/inotify-tools.git//安装不知道成没成功<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libfreeimage3 libfreeimage-dev<br><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/dpilger26/NumCpp.git<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libavformat-dev<br><br><span class=\"hljs-built_in\">sudo</span> apt-get install libswscale-dev<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、在PC上编译运行应用\"><a href=\"#四、在PC上编译运行应用\" class=\"headerlink\" title=\"四、在PC上编译运行应用\"></a>四、在PC上编译运行应用</h2><p>make 编译程序</p>\n<p>make clean 清除编译</p>\n<p>头文件所在位置：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">/usr/i</span>nclude/<br><br><span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/include/</span><br><br>cp  -r <span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/include/</span>vod_sdk<span class=\"hljs-regexp\">/ /u</span>sr<span class=\"hljs-regexp\">/include/</span>vod_sdk<span class=\"hljs-regexp\">/  /</span><span class=\"hljs-regexp\">/缺失upload.h头文件，将他进行复制到usr/i</span>nclude/文件夹当中<br><br>- 安装依赖<br>  sudo apt install libjson-c-dev<br><br>- 编译<br>  make<br><br>- 安装<br>  sudo make install<br><br>- 更新系统动态库<br>  sudo ldconfig<br></code></pre></td></tr></table></figure>\n\n<p>运行项目</p>\n<p>先获得虚拟设备参数，导入config中”&#x2F;home&#x2F;user&#x2F;creality&#x2F;userdata&#x2F;config&#x2F;“</p>\n<p>开始编译主程序  make clean &amp;&amp; make -j4（j4、j8代表进程速度，越高越快）</p>\n<p>获得各个文件的单独运行包，在vscode中运行.&#x2F;master-server，即可跑通实体机</p>\n<p>linux中&#x2F;opt目录用来<strong>安装附加软件包</strong>，是用户级的程序目录，可以理解为D:&#x2F;Software。 安装到&#x2F;opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。</p>\n<h2 id=\"五、交叉编译到目标板运行\"><a href=\"#五、交叉编译到目标板运行\" class=\"headerlink\" title=\"五、交叉编译到目标板运行\"></a>五、交叉编译到目标板运行</h2><p>交叉编译讲解：<a href=\"https://blog.csdn.net/lc315yuhuofei/article/details/103782049\">交叉编译入门及必要配置方法总结_gcc-manifest.txt-CSDN博客</a></p>\n<p>虚拟机交叉编译教程：<a href=\"https://www.cnblogs.com/zblblog/p/18136017\">立创泰山派学习05-虚拟机ubuntu安装交叉编译工具 - zbl1118 - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"六、知识点总结\"><a href=\"#六、知识点总结\" class=\"headerlink\" title=\"六、知识点总结\"></a>六、知识点总结</h2><h4 id=\"1-交叉编译知识点\"><a href=\"#1-交叉编译知识点\" class=\"headerlink\" title=\"1.交叉编译知识点\"></a>1.交叉编译知识点</h4><p>交叉编译的目的是在一台架构A主机平台上编译另一种架构B目标平台的二进制文件或者库，交叉编译在目标系统平台（开发出来的应用程序序所运行的平台）难以或不容易编译时非常有用。 完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上</p>\n<p>主机平台：PC端 Windows 10 专业工作站版</p>\n<p>目标平台：Linux Ubuntu22.04.4&#x2F;VMware® Workstation 16 Pro</p>\n<p>通常交叉编译工具链命名规则为：arch-core-kernel-system</p>\n<p>arch：目标平台架构，如上文提到的arm，mips等；</p>\n<p>core：有两种种情况，第一是CPU Core，如Cortex A8；第二是指定工具链的供应商。如果没有特殊指定，则留空不填。这一组命名比较灵活，有以厂家名称命名的，有以开发者命名的，也有以开发板命名的，或者直接是none或cross的；</p>\n<p>kernel： 目标平台的OS，见过的有linux，uclinux，bare-metal（无OS）；</p>\n<p>system：嵌入式应用二进制接口（Embedded Application Binary Interface），交叉编译工具链所选择的库函数和目标映像的规范，如gnu，gnueabi等。其中gnu等价于glibc+oabi；gnueabi等价于glibc+eabi。若不指定，则也可以留空不填；</p>\n<p>上述命名规则并不是统一的规范，使用的时候作为参考就行。我使用的交叉编译工具链名称为：gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu。</p>\n<p>获取交叉编译工具链两个途径：</p>\n<p>直接下载知名厂家已经编译好的工具链。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">https:<span class=\"hljs-regexp\">//</span>www.linaro.org<span class=\"hljs-regexp\">/downloads/</span><br>http:<span class=\"hljs-regexp\">//</span>ftp.arm.linux.org.uk<span class=\"hljs-regexp\">/pub/</span>armlinux<span class=\"hljs-regexp\">/toolchain/</span><br>http:<span class=\"hljs-regexp\">//</span>www.denx.de<span class=\"hljs-regexp\">/en/</span>Software/WebHome<br>https:<span class=\"hljs-regexp\">//</span>launchpad.net/gcc-arm-embedded<br></code></pre></td></tr></table></figure>\n\n<p>自己编译交叉编译工具链</p>\n<p>编译交叉编译工具链的工具：crosstool-NG、Buildroot、Embedded Linux Development Kit (ELDK)</p>\n<h4 id=\"2-Linux-系统编程知识点\"><a href=\"#2-Linux-系统编程知识点\" class=\"headerlink\" title=\"2.Linux 系统编程知识点\"></a>2.Linux 系统编程知识点</h4><p><a href=\"https://developer.aliyun.com/article/1457993\">Linux 系统编程从入门到进阶 学习指南-阿里云开发者社区 (aliyun.com)</a></p>\n<p>什么是库函数？</p>\n<p>库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。</p>\n<p><a href=\"https://www.cnblogs.com/realjimmy/p/12844359.html\">Linux C函数库大全 - 一觉醒来写程序 - 博客园 (cnblogs.com)</a></p>\n<p>参考手册：<a href=\"https://wizardforcel.gitbooks.io/linux-c-api-ref/content/index.html\">介紹 | Linux C API 参考手册 (gitbooks.io)</a></p>\n<p><strong>进程究竟是什么？</strong></p>\n<p>每当你启动一个程序，Linux 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。</p>\n<p><strong>1.管道 （Pipe）</strong></p>\n<p>管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：<strong>匿名管道</strong>和<strong>有名管道</strong>。</p>\n<p><strong>2.信号 (Signals)</strong></p>\n<p>在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。</p>\n<p>信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。</p>\n<p><strong>3.文件(Files)</strong></p>\n<p>文件在 Linux 系统中是一种基本的持久化存储机制，可用于<strong>进程间通信</strong>。多个进程可以通过对同一个文件的读取和写入来共享信息。</p>\n<p><strong>4.信号量(Semaphores)</strong><br>信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。</p>\n<p><strong>5.共享内存(Shared Memory)</strong><br>在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。</p>\n<p><strong>6.消息队列 (Message Queues)</strong></p>\n<p>消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。</p>\n<p><strong>7.套接字 (Sockets)</strong></p>\n<p>套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。</p>\n<h2 id=\"七、常用指令\"><a href=\"#七、常用指令\" class=\"headerlink\" title=\"七、常用指令\"></a>七、常用指令</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><br>uname <span class=\"hljs-operator\">-</span>m <span class=\"hljs-comment\">/*查看系统架构*/</span><br>lscpu <span class=\"hljs-comment\">/*查看更多CPU情况*/</span><br><br>tar <span class=\"hljs-operator\">-</span>vxf [xxx.tar.gz压缩包]<br>mv [现在的位置] [将要移动的位置]<br><br>pip list <span class=\"hljs-comment\">/*罗列所有的安装包*/</span><br><br>make clean  <span class=\"hljs-comment\">/*清理编译*/</span><br>make <span class=\"hljs-operator\">&amp;&amp;</span> make install  <span class=\"hljs-comment\">/*开始编译*/</span><br><br>cp  <span class=\"hljs-operator\">-</span>r <span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/include/</span>vod_sdk<span class=\"hljs-operator\">/</span> <span class=\"hljs-regexp\">/usr/</span>include<span class=\"hljs-regexp\">/vod_sdk/</span>  <span class=\"hljs-comment\">/*复制文件夹到另一个文件夹上*/</span><br><br>sudo apt<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">get</span> autoremove xxx  <span class=\"hljs-comment\">/*卸载*/</span><br></code></pre></td></tr></table></figure>\n\n<p>常用指令汇总：<a href=\"https://developer.aliyun.com/article/1561151?spm=a2c6h.12873639.article-detail.33.657a1be0lxiKr4&scm=20140722.ID_community@@article@@1561151._.ID_community@@article@@1561151-OR_rec-V_1-RL_community@@article@@1457993\">linux 常用命令【编程必备】-阿里云开发者社区 (aliyun.com)</a></p>\n"},{"title":"Github+HEXO实现网站DIY","date":"2024-07-22T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/AkJxXrnV57TZ4YP.jpg","_content":"\n# Github+HEXO实现网站DIY\n\n### 创建github.page网页\n\n点击Repositories，选择新建Repositories仓库\n\n在仓库名字Repository name栏填写网页的网址，后缀需要添加 .github.io\n\n例如 webname.github.io\n\n![image-20240724153741084.png](https://s2.loli.net/2024/07/25/CagbJOAwjnGZl5h.png)\n\n之后点击 Create repository ，创建该仓库，其他无需调整\n\n之后需要创建一个 index.html 文件，用于后续能够选取分支\n\n![image-20240724154237430.png](https://s2.loli.net/2024/07/25/fCE81aVXuvQHwkK.png)\n\n文件名字输入 index.html，内容为 `<hl> hello </hl>` 这个文件会初始化成一个网页，网页的内容只有 hello，这个随便填就行，后续会用模板，不用考虑这个\n\n![image-20240724154427037.png](https://s2.loli.net/2024/07/25/xcCAzGZfilE8pXI.png)\n\n进入仓库，选择 Setting ，点击 pages ，在 branch 上选择 main 分支（刚刚创建文件也是为了创建这个分支），点击 save 保存，之后等待几分钟，就会出现创建的网址，点击 visit site 即可进入建立的网页\n\n![image-20240724155135615.png](https://s2.loli.net/2024/07/25/iJS68ZOUrkLHKBo.png)\n\n完成这一步之后，就可以得到一个”hello“的网页，该网页没有任何排版和格式\n\n### 配置HEXO并进行部署\n\n打开git bash，执行如下命令安装hexo\n\n```\n\t$ npm install -g hexo-cli # 此命令完成对 hexo 的安装\n```\n\n如果没有安装npm、git、node.js的话\n\nnode.js参考https://blog.csdn.net/yaorongke/article/details/119084295\n\ngit安装参考https://blog.csdn.net/mukes/article/details/115693833\n\n之后随便在想要的地方建一个文件夹，这个文件夹的作用是用于博客文章存放和仓库交互，例如<blog>\n\n进入该文件，将该文件初始化\n\n```\n\t$ cd blog # 进入该文件夹\n\t$ hexo init # 该命令完成 hexo 在本地博客目录的初始化\n```\n\n之后生成网页的静态文件，如果需要更新网页的配置，需要先清理，在重新生成\n\n```\n\t$ hexo g # 生成静态文件，生成的文件在public文件夹里面\n\t\n\t$ hexo clean # 清除生成的静态文件\n```\n\n可以进行本地预览，本地预览的ctrl+c会退出运行，所以用右键复制网址到网页上预览\n\n```\n\t$ hexo s # 开启本地预览\n```\n\n安装部署插件\n\n```\n\t$ npm install hexo-deployer-git --save # 安装部署插件\n```\n\n`hexo` 有 2 种 `_config.yml` 文件，一个是根目录下的全局的 `_config.yml`，一个是各个主体 `theme` 下的 `_config.yml`。将前者称为站点配置文件， 后者称为主题配置文件。打开根目录下站点配置文件 `_config.yml`，配置有关 `deploy`和`url `的部分：\n\n```\n\t# URL\n\t## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\n\turl: GitHub pages的网址，例如https://GitHub用户名/仓库名               //修改这个地方，需要把网址改对，否则网页没有格式\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\tpretty_urls:\n\t  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n\t  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/one-command-deployment\n\tdeploy:\n\t  type: git\n\t  repo: git@github.com:GitHub账户名/仓库名.github.io.git\n\t  branch: master #如果分支是main记得修改，需要推送到哪个分支，就选择哪个分支\n```\n\n![image-20240724161404111.png](https://s2.loli.net/2024/07/25/Us5zgjtJm8fKQ6X.png)\n\n部署到 GitHub\n\n```\n\t$ hexo d # 将public里面的文件发送到云端GitHub上面\n```\n\n之后就可以刷新网页看到上传上去的网页，就拥有了自己的网页\n\n### 主题更换和选择\n\n我们上面用的是系统默认的主题，比较丑，所以我们可以使用hexo去挑选我们想要的主题类型\n\n[开始使用 | Hexo Fluid 用户手册 (fluid-dev.github.io)](https://fluid-dev.github.io/hexo-fluid-docs/start/#更新主题)\n\n[Themes | Hexo](https://hexo.io/themes/)可以在这个网址里面挑选自己喜欢的\n\n本文挑选了fluid进行下载，选择直接下载zip包或者`git clone https://github.com/fluid-dev/hexo-theme-fluid.git`\n\n将下载的包解压放到 themes 文件夹里面，文件夹的名字改成fluid，最好不要文件夹套娃，如果出现，则将里面的文件全部移出来\n\n继续修改博客根目录下的 _config.yml 文件，注意，不是fluid里面的_config.yml文件\n\n```\n\tlanguage: zh-CN  # 指定语言，会影响主题显示的语言，按需修改\n\t\n\ttheme: fluid  # 指定主题\n```\n\n首次使用主题的「关于页」需要手动创建，打开git，输入代码\n\n```\n\t$ hexo new page about\n```\n\n创建成功后修改 `/source/about/index.md`，添加 `layout` 属性，`layout: about` 必须存在，并且不能修改成其他值，否则不会显示头像等样式\n\n```\n\t---\n\ttitle: 标题\n\tlayout: about\n\t---\n```\n\n之后重复上面的步骤先进行静态页面清除，再生成，之后上传到GitHub仓库中进行页面更新，等待几分钟后，如下图所示\n\n![image-20240724162639684.png](https://s2.loli.net/2024/07/25/2wTjGbtilvdkBpW.png)\n\n### 文档上传\n\n使用Typora进行.md文档的编写，非常好用的一个编辑器，绿色版可以网上搜索\n\n之后将md文件放到博客文件夹下面` source/_posts/ `文件夹下面\n\n之后使用vim编辑器对文档进行title和tag的编辑\n\n[Linux vi/vim | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-vim.html)\n\n进入md文件，首先点击 i 进入编辑模式，在开头位置输入，其中title为文章的名字，tag为文章的标签，方便进行检索\n\n```\n\t---\n\ttitle： hello word\n\ttag： write\n\t---\n```\n\n编辑完成点击 Esc 退出报错，直接输入 :wq 保存编辑并且退出，完成文件的标记修改\n\n之后回到git bash中输入\n\n```\n\t$ hexo g # 生成静态文件，生成的文件在public文件夹里面\n\n\t$ hexo d # 将生成的文件导入GitHub站点\n```\n\n到此，等待几分钟后，你的文章就在你的网页上面出现了\n","source":"_posts/Work No.6.md","raw":"---\ntitle: Github+HEXO实现网站DIY\ntag: Github_Pages\ndate: 2024-07-23\ncategories: Github\nindex_img: https://s2.loli.net/2024/07/31/AkJxXrnV57TZ4YP.jpg\n---\n\n# Github+HEXO实现网站DIY\n\n### 创建github.page网页\n\n点击Repositories，选择新建Repositories仓库\n\n在仓库名字Repository name栏填写网页的网址，后缀需要添加 .github.io\n\n例如 webname.github.io\n\n![image-20240724153741084.png](https://s2.loli.net/2024/07/25/CagbJOAwjnGZl5h.png)\n\n之后点击 Create repository ，创建该仓库，其他无需调整\n\n之后需要创建一个 index.html 文件，用于后续能够选取分支\n\n![image-20240724154237430.png](https://s2.loli.net/2024/07/25/fCE81aVXuvQHwkK.png)\n\n文件名字输入 index.html，内容为 `<hl> hello </hl>` 这个文件会初始化成一个网页，网页的内容只有 hello，这个随便填就行，后续会用模板，不用考虑这个\n\n![image-20240724154427037.png](https://s2.loli.net/2024/07/25/xcCAzGZfilE8pXI.png)\n\n进入仓库，选择 Setting ，点击 pages ，在 branch 上选择 main 分支（刚刚创建文件也是为了创建这个分支），点击 save 保存，之后等待几分钟，就会出现创建的网址，点击 visit site 即可进入建立的网页\n\n![image-20240724155135615.png](https://s2.loli.net/2024/07/25/iJS68ZOUrkLHKBo.png)\n\n完成这一步之后，就可以得到一个”hello“的网页，该网页没有任何排版和格式\n\n### 配置HEXO并进行部署\n\n打开git bash，执行如下命令安装hexo\n\n```\n\t$ npm install -g hexo-cli # 此命令完成对 hexo 的安装\n```\n\n如果没有安装npm、git、node.js的话\n\nnode.js参考https://blog.csdn.net/yaorongke/article/details/119084295\n\ngit安装参考https://blog.csdn.net/mukes/article/details/115693833\n\n之后随便在想要的地方建一个文件夹，这个文件夹的作用是用于博客文章存放和仓库交互，例如<blog>\n\n进入该文件，将该文件初始化\n\n```\n\t$ cd blog # 进入该文件夹\n\t$ hexo init # 该命令完成 hexo 在本地博客目录的初始化\n```\n\n之后生成网页的静态文件，如果需要更新网页的配置，需要先清理，在重新生成\n\n```\n\t$ hexo g # 生成静态文件，生成的文件在public文件夹里面\n\t\n\t$ hexo clean # 清除生成的静态文件\n```\n\n可以进行本地预览，本地预览的ctrl+c会退出运行，所以用右键复制网址到网页上预览\n\n```\n\t$ hexo s # 开启本地预览\n```\n\n安装部署插件\n\n```\n\t$ npm install hexo-deployer-git --save # 安装部署插件\n```\n\n`hexo` 有 2 种 `_config.yml` 文件，一个是根目录下的全局的 `_config.yml`，一个是各个主体 `theme` 下的 `_config.yml`。将前者称为站点配置文件， 后者称为主题配置文件。打开根目录下站点配置文件 `_config.yml`，配置有关 `deploy`和`url `的部分：\n\n```\n\t# URL\n\t## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\n\turl: GitHub pages的网址，例如https://GitHub用户名/仓库名               //修改这个地方，需要把网址改对，否则网页没有格式\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\tpretty_urls:\n\t  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n\t  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/one-command-deployment\n\tdeploy:\n\t  type: git\n\t  repo: git@github.com:GitHub账户名/仓库名.github.io.git\n\t  branch: master #如果分支是main记得修改，需要推送到哪个分支，就选择哪个分支\n```\n\n![image-20240724161404111.png](https://s2.loli.net/2024/07/25/Us5zgjtJm8fKQ6X.png)\n\n部署到 GitHub\n\n```\n\t$ hexo d # 将public里面的文件发送到云端GitHub上面\n```\n\n之后就可以刷新网页看到上传上去的网页，就拥有了自己的网页\n\n### 主题更换和选择\n\n我们上面用的是系统默认的主题，比较丑，所以我们可以使用hexo去挑选我们想要的主题类型\n\n[开始使用 | Hexo Fluid 用户手册 (fluid-dev.github.io)](https://fluid-dev.github.io/hexo-fluid-docs/start/#更新主题)\n\n[Themes | Hexo](https://hexo.io/themes/)可以在这个网址里面挑选自己喜欢的\n\n本文挑选了fluid进行下载，选择直接下载zip包或者`git clone https://github.com/fluid-dev/hexo-theme-fluid.git`\n\n将下载的包解压放到 themes 文件夹里面，文件夹的名字改成fluid，最好不要文件夹套娃，如果出现，则将里面的文件全部移出来\n\n继续修改博客根目录下的 _config.yml 文件，注意，不是fluid里面的_config.yml文件\n\n```\n\tlanguage: zh-CN  # 指定语言，会影响主题显示的语言，按需修改\n\t\n\ttheme: fluid  # 指定主题\n```\n\n首次使用主题的「关于页」需要手动创建，打开git，输入代码\n\n```\n\t$ hexo new page about\n```\n\n创建成功后修改 `/source/about/index.md`，添加 `layout` 属性，`layout: about` 必须存在，并且不能修改成其他值，否则不会显示头像等样式\n\n```\n\t---\n\ttitle: 标题\n\tlayout: about\n\t---\n```\n\n之后重复上面的步骤先进行静态页面清除，再生成，之后上传到GitHub仓库中进行页面更新，等待几分钟后，如下图所示\n\n![image-20240724162639684.png](https://s2.loli.net/2024/07/25/2wTjGbtilvdkBpW.png)\n\n### 文档上传\n\n使用Typora进行.md文档的编写，非常好用的一个编辑器，绿色版可以网上搜索\n\n之后将md文件放到博客文件夹下面` source/_posts/ `文件夹下面\n\n之后使用vim编辑器对文档进行title和tag的编辑\n\n[Linux vi/vim | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-vim.html)\n\n进入md文件，首先点击 i 进入编辑模式，在开头位置输入，其中title为文章的名字，tag为文章的标签，方便进行检索\n\n```\n\t---\n\ttitle： hello word\n\ttag： write\n\t---\n```\n\n编辑完成点击 Esc 退出报错，直接输入 :wq 保存编辑并且退出，完成文件的标记修改\n\n之后回到git bash中输入\n\n```\n\t$ hexo g # 生成静态文件，生成的文件在public文件夹里面\n\n\t$ hexo d # 将生成的文件导入GitHub站点\n```\n\n到此，等待几分钟后，你的文章就在你的网页上面出现了\n","slug":"Work No.6","published":1,"updated":"2024-07-31T03:32:56.525Z","_id":"clz9aaxqf000yygfb23s47znj","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Github-HEXO实现网站DIY\"><a href=\"#Github-HEXO实现网站DIY\" class=\"headerlink\" title=\"Github+HEXO实现网站DIY\"></a>Github+HEXO实现网站DIY</h1><h3 id=\"创建github-page网页\"><a href=\"#创建github-page网页\" class=\"headerlink\" title=\"创建github.page网页\"></a>创建github.page网页</h3><p>点击Repositories，选择新建Repositories仓库</p>\n<p>在仓库名字Repository name栏填写网页的网址，后缀需要添加 .github.io</p>\n<p>例如 webname.github.io</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/CagbJOAwjnGZl5h.png\" alt=\"image-20240724153741084.png\"></p>\n<p>之后点击 Create repository ，创建该仓库，其他无需调整</p>\n<p>之后需要创建一个 index.html 文件，用于后续能够选取分支</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/fCE81aVXuvQHwkK.png\" alt=\"image-20240724154237430.png\"></p>\n<p>文件名字输入 index.html，内容为 <code>&lt;hl&gt; hello &lt;/hl&gt;</code> 这个文件会初始化成一个网页，网页的内容只有 hello，这个随便填就行，后续会用模板，不用考虑这个</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/xcCAzGZfilE8pXI.png\" alt=\"image-20240724154427037.png\"></p>\n<p>进入仓库，选择 Setting ，点击 pages ，在 branch 上选择 main 分支（刚刚创建文件也是为了创建这个分支），点击 save 保存，之后等待几分钟，就会出现创建的网址，点击 visit site 即可进入建立的网页</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/iJS68ZOUrkLHKBo.png\" alt=\"image-20240724155135615.png\"></p>\n<p>完成这一步之后，就可以得到一个”hello“的网页，该网页没有任何排版和格式</p>\n<h3 id=\"配置HEXO并进行部署\"><a href=\"#配置HEXO并进行部署\" class=\"headerlink\" title=\"配置HEXO并进行部署\"></a>配置HEXO并进行部署</h3><p>打开git bash，执行如下命令安装hexo</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">$ npm install -g hexo-<span class=\"hljs-keyword\">cli</span> <span class=\"hljs-meta\"># 此命令完成对 hexo 的安装</span><br></code></pre></td></tr></table></figure>\n\n<p>如果没有安装npm、git、node.js的话</p>\n<p>node.js参考<a href=\"https://blog.csdn.net/yaorongke/article/details/119084295\">https://blog.csdn.net/yaorongke/article/details/119084295</a></p>\n<p>git安装参考<a href=\"https://blog.csdn.net/mukes/article/details/115693833\">https://blog.csdn.net/mukes/article/details/115693833</a></p>\n<p>之后随便在想要的地方建一个文件夹，这个文件夹的作用是用于博客文章存放和仓库交互，例如<blog></p>\n<p>进入该文件，将该文件初始化</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-variable\">$</span> <span class=\"hljs-built_in\">cd</span> blog <span class=\"hljs-comment\"># 进入该文件夹</span><br><span class=\"hljs-variable\">$</span> hexo init <span class=\"hljs-comment\"># 该命令完成 hexo 在本地博客目录的初始化</span><br></code></pre></td></tr></table></figure>\n\n<p>之后生成网页的静态文件，如果需要更新网页的配置，需要先清理，在重新生成</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo g <span class=\"hljs-comment\"># 生成静态文件，生成的文件在public文件夹里面</span><br><br><span class=\"hljs-variable\">$ </span>hexo clean <span class=\"hljs-comment\"># 清除生成的静态文件</span><br></code></pre></td></tr></table></figure>\n\n<p>可以进行本地预览，本地预览的ctrl+c会退出运行，所以用右键复制网址到网页上预览</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo s <span class=\"hljs-comment\"># 开启本地预览</span><br></code></pre></td></tr></table></figure>\n\n<p>安装部署插件</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">$ npm <span class=\"hljs-keyword\">install</span> hexo-deployer-git --save <span class=\"hljs-comment\"># 安装部署插件</span><br></code></pre></td></tr></table></figure>\n\n<p><code>hexo</code> 有 2 种 <code>_config.yml</code> 文件，一个是根目录下的全局的 <code>_config.yml</code>，一个是各个主体 <code>theme</code> 下的 <code>_config.yml</code>。将前者称为站点配置文件， 后者称为主题配置文件。打开根目录下站点配置文件 <code>_config.yml</code>，配置有关 <code>deploy</code>和<code>url </code>的部分：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"># URL<br>## <span class=\"hljs-keyword\">Set</span> your site url here. <span class=\"hljs-keyword\">For</span> example, <span class=\"hljs-keyword\">if</span> you use GitHub Page, <span class=\"hljs-keyword\">set</span> url <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">&#x27;https://username.github.io/project&#x27;</span><br>url: GitHub pages的网址，例如https:<span class=\"hljs-comment\">//GitHub用户名/仓库名               //修改这个地方，需要把网址改对，否则网页没有格式</span><br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br>pretty_urls:<br>  trailing_index: <span class=\"hljs-keyword\">true</span> # <span class=\"hljs-keyword\">Set</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">false</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">remove</span> trailing <span class=\"hljs-string\">&#x27;index.html&#x27;</span> <span class=\"hljs-keyword\">from</span> permalinks<br>  trailing_html: <span class=\"hljs-keyword\">true</span> # <span class=\"hljs-keyword\">Set</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">false</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">remove</span> trailing <span class=\"hljs-string\">&#x27;.html&#x27;</span> <span class=\"hljs-keyword\">from</span> permalinks<br><br># Deployment<br>## Docs: https:<span class=\"hljs-comment\">//hexo.io/docs/one-command-deployment</span><br>deploy:<br>  <span class=\"hljs-keyword\">type</span>: git<br>  repo: git@github.com:GitHub账户名/仓库名.github.io.git<br>  branch: master #如果分支是main记得修改，需要推送到哪个分支，就选择哪个分支<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2024/07/25/Us5zgjtJm8fKQ6X.png\" alt=\"image-20240724161404111.png\"></p>\n<p>部署到 GitHub</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo d <span class=\"hljs-comment\"># 将public里面的文件发送到云端GitHub上面</span><br></code></pre></td></tr></table></figure>\n\n<p>之后就可以刷新网页看到上传上去的网页，就拥有了自己的网页</p>\n<h3 id=\"主题更换和选择\"><a href=\"#主题更换和选择\" class=\"headerlink\" title=\"主题更换和选择\"></a>主题更换和选择</h3><p>我们上面用的是系统默认的主题，比较丑，所以我们可以使用hexo去挑选我们想要的主题类型</p>\n<p><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/start/#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98\">开始使用 | Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p>\n<p><a href=\"https://hexo.io/themes/\">Themes | Hexo</a>可以在这个网址里面挑选自己喜欢的</p>\n<p>本文挑选了fluid进行下载，选择直接下载zip包或者<code>git clone https://github.com/fluid-dev/hexo-theme-fluid.git</code></p>\n<p>将下载的包解压放到 themes 文件夹里面，文件夹的名字改成fluid，最好不要文件夹套娃，如果出现，则将里面的文件全部移出来</p>\n<p>继续修改博客根目录下的 _config.yml 文件，注意，不是fluid里面的_config.yml文件</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">language:</span> <span class=\"hljs-built_in\">zh</span>-CN  <span class=\"hljs-meta\"># 指定语言，会影响主题显示的语言，按需修改</span><br><br><span class=\"hljs-symbol\">theme:</span> fluid  <span class=\"hljs-meta\"># 指定主题</span><br></code></pre></td></tr></table></figure>\n\n<p>首次使用主题的「关于页」需要手动创建，打开git，输入代码</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\">$ hexo <span class=\"hljs-keyword\">new</span> page about<br></code></pre></td></tr></table></figure>\n\n<p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性，<code>layout: about</code> 必须存在，并且不能修改成其他值，否则不会显示头像等样式</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-meta\">---</span><br><span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">标题</span><br><span class=\"hljs-attr\">layout:</span> <span class=\"hljs-string\">about</span><br><span class=\"hljs-meta\">---</span><br></code></pre></td></tr></table></figure>\n\n<p>之后重复上面的步骤先进行静态页面清除，再生成，之后上传到GitHub仓库中进行页面更新，等待几分钟后，如下图所示</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/2wTjGbtilvdkBpW.png\" alt=\"image-20240724162639684.png\"></p>\n<h3 id=\"文档上传\"><a href=\"#文档上传\" class=\"headerlink\" title=\"文档上传\"></a>文档上传</h3><p>使用Typora进行.md文档的编写，非常好用的一个编辑器，绿色版可以网上搜索</p>\n<p>之后将md文件放到博客文件夹下面<code>source/_posts/</code>文件夹下面</p>\n<p>之后使用vim编辑器对文档进行title和tag的编辑</p>\n<p><a href=\"https://www.runoob.com/linux/linux-vim.html\">Linux vi&#x2F;vim | 菜鸟教程 (runoob.com)</a></p>\n<p>进入md文件，首先点击 i 进入编辑模式，在开头位置输入，其中title为文章的名字，tag为文章的标签，方便进行检索</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-meta\">---</span><br><span class=\"hljs-string\">title：</span> <span class=\"hljs-string\">hello</span> <span class=\"hljs-string\">word</span><br><span class=\"hljs-string\">tag：</span> <span class=\"hljs-string\">write</span><br><span class=\"hljs-meta\">---</span><br></code></pre></td></tr></table></figure>\n\n<p>编辑完成点击 Esc 退出报错，直接输入 :wq 保存编辑并且退出，完成文件的标记修改</p>\n<p>之后回到git bash中输入</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo g <span class=\"hljs-comment\"># 生成静态文件，生成的文件在public文件夹里面</span><br><br><span class=\"hljs-variable\">$ </span>hexo d <span class=\"hljs-comment\"># 将生成的文件导入GitHub站点</span><br></code></pre></td></tr></table></figure>\n\n<p>到此，等待几分钟后，你的文章就在你的网页上面出现了</p>\n","excerpt":"","more":"<h1 id=\"Github-HEXO实现网站DIY\"><a href=\"#Github-HEXO实现网站DIY\" class=\"headerlink\" title=\"Github+HEXO实现网站DIY\"></a>Github+HEXO实现网站DIY</h1><h3 id=\"创建github-page网页\"><a href=\"#创建github-page网页\" class=\"headerlink\" title=\"创建github.page网页\"></a>创建github.page网页</h3><p>点击Repositories，选择新建Repositories仓库</p>\n<p>在仓库名字Repository name栏填写网页的网址，后缀需要添加 .github.io</p>\n<p>例如 webname.github.io</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/CagbJOAwjnGZl5h.png\" alt=\"image-20240724153741084.png\"></p>\n<p>之后点击 Create repository ，创建该仓库，其他无需调整</p>\n<p>之后需要创建一个 index.html 文件，用于后续能够选取分支</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/fCE81aVXuvQHwkK.png\" alt=\"image-20240724154237430.png\"></p>\n<p>文件名字输入 index.html，内容为 <code>&lt;hl&gt; hello &lt;/hl&gt;</code> 这个文件会初始化成一个网页，网页的内容只有 hello，这个随便填就行，后续会用模板，不用考虑这个</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/xcCAzGZfilE8pXI.png\" alt=\"image-20240724154427037.png\"></p>\n<p>进入仓库，选择 Setting ，点击 pages ，在 branch 上选择 main 分支（刚刚创建文件也是为了创建这个分支），点击 save 保存，之后等待几分钟，就会出现创建的网址，点击 visit site 即可进入建立的网页</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/iJS68ZOUrkLHKBo.png\" alt=\"image-20240724155135615.png\"></p>\n<p>完成这一步之后，就可以得到一个”hello“的网页，该网页没有任何排版和格式</p>\n<h3 id=\"配置HEXO并进行部署\"><a href=\"#配置HEXO并进行部署\" class=\"headerlink\" title=\"配置HEXO并进行部署\"></a>配置HEXO并进行部署</h3><p>打开git bash，执行如下命令安装hexo</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">$ npm install -g hexo-<span class=\"hljs-keyword\">cli</span> <span class=\"hljs-meta\"># 此命令完成对 hexo 的安装</span><br></code></pre></td></tr></table></figure>\n\n<p>如果没有安装npm、git、node.js的话</p>\n<p>node.js参考<a href=\"https://blog.csdn.net/yaorongke/article/details/119084295\">https://blog.csdn.net/yaorongke/article/details/119084295</a></p>\n<p>git安装参考<a href=\"https://blog.csdn.net/mukes/article/details/115693833\">https://blog.csdn.net/mukes/article/details/115693833</a></p>\n<p>之后随便在想要的地方建一个文件夹，这个文件夹的作用是用于博客文章存放和仓库交互，例如<blog></p>\n<p>进入该文件，将该文件初始化</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-variable\">$</span> <span class=\"hljs-built_in\">cd</span> blog <span class=\"hljs-comment\"># 进入该文件夹</span><br><span class=\"hljs-variable\">$</span> hexo init <span class=\"hljs-comment\"># 该命令完成 hexo 在本地博客目录的初始化</span><br></code></pre></td></tr></table></figure>\n\n<p>之后生成网页的静态文件，如果需要更新网页的配置，需要先清理，在重新生成</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo g <span class=\"hljs-comment\"># 生成静态文件，生成的文件在public文件夹里面</span><br><br><span class=\"hljs-variable\">$ </span>hexo clean <span class=\"hljs-comment\"># 清除生成的静态文件</span><br></code></pre></td></tr></table></figure>\n\n<p>可以进行本地预览，本地预览的ctrl+c会退出运行，所以用右键复制网址到网页上预览</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo s <span class=\"hljs-comment\"># 开启本地预览</span><br></code></pre></td></tr></table></figure>\n\n<p>安装部署插件</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">$ npm <span class=\"hljs-keyword\">install</span> hexo-deployer-git --save <span class=\"hljs-comment\"># 安装部署插件</span><br></code></pre></td></tr></table></figure>\n\n<p><code>hexo</code> 有 2 种 <code>_config.yml</code> 文件，一个是根目录下的全局的 <code>_config.yml</code>，一个是各个主体 <code>theme</code> 下的 <code>_config.yml</code>。将前者称为站点配置文件， 后者称为主题配置文件。打开根目录下站点配置文件 <code>_config.yml</code>，配置有关 <code>deploy</code>和<code>url </code>的部分：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"># URL<br>## <span class=\"hljs-keyword\">Set</span> your site url here. <span class=\"hljs-keyword\">For</span> example, <span class=\"hljs-keyword\">if</span> you use GitHub Page, <span class=\"hljs-keyword\">set</span> url <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">&#x27;https://username.github.io/project&#x27;</span><br>url: GitHub pages的网址，例如https:<span class=\"hljs-comment\">//GitHub用户名/仓库名               //修改这个地方，需要把网址改对，否则网页没有格式</span><br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br>pretty_urls:<br>  trailing_index: <span class=\"hljs-keyword\">true</span> # <span class=\"hljs-keyword\">Set</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">false</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">remove</span> trailing <span class=\"hljs-string\">&#x27;index.html&#x27;</span> <span class=\"hljs-keyword\">from</span> permalinks<br>  trailing_html: <span class=\"hljs-keyword\">true</span> # <span class=\"hljs-keyword\">Set</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">false</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">remove</span> trailing <span class=\"hljs-string\">&#x27;.html&#x27;</span> <span class=\"hljs-keyword\">from</span> permalinks<br><br># Deployment<br>## Docs: https:<span class=\"hljs-comment\">//hexo.io/docs/one-command-deployment</span><br>deploy:<br>  <span class=\"hljs-keyword\">type</span>: git<br>  repo: git@github.com:GitHub账户名/仓库名.github.io.git<br>  branch: master #如果分支是main记得修改，需要推送到哪个分支，就选择哪个分支<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2024/07/25/Us5zgjtJm8fKQ6X.png\" alt=\"image-20240724161404111.png\"></p>\n<p>部署到 GitHub</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo d <span class=\"hljs-comment\"># 将public里面的文件发送到云端GitHub上面</span><br></code></pre></td></tr></table></figure>\n\n<p>之后就可以刷新网页看到上传上去的网页，就拥有了自己的网页</p>\n<h3 id=\"主题更换和选择\"><a href=\"#主题更换和选择\" class=\"headerlink\" title=\"主题更换和选择\"></a>主题更换和选择</h3><p>我们上面用的是系统默认的主题，比较丑，所以我们可以使用hexo去挑选我们想要的主题类型</p>\n<p><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/start/#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98\">开始使用 | Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p>\n<p><a href=\"https://hexo.io/themes/\">Themes | Hexo</a>可以在这个网址里面挑选自己喜欢的</p>\n<p>本文挑选了fluid进行下载，选择直接下载zip包或者<code>git clone https://github.com/fluid-dev/hexo-theme-fluid.git</code></p>\n<p>将下载的包解压放到 themes 文件夹里面，文件夹的名字改成fluid，最好不要文件夹套娃，如果出现，则将里面的文件全部移出来</p>\n<p>继续修改博客根目录下的 _config.yml 文件，注意，不是fluid里面的_config.yml文件</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">language:</span> <span class=\"hljs-built_in\">zh</span>-CN  <span class=\"hljs-meta\"># 指定语言，会影响主题显示的语言，按需修改</span><br><br><span class=\"hljs-symbol\">theme:</span> fluid  <span class=\"hljs-meta\"># 指定主题</span><br></code></pre></td></tr></table></figure>\n\n<p>首次使用主题的「关于页」需要手动创建，打开git，输入代码</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\">$ hexo <span class=\"hljs-keyword\">new</span> page about<br></code></pre></td></tr></table></figure>\n\n<p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性，<code>layout: about</code> 必须存在，并且不能修改成其他值，否则不会显示头像等样式</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-meta\">---</span><br><span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">标题</span><br><span class=\"hljs-attr\">layout:</span> <span class=\"hljs-string\">about</span><br><span class=\"hljs-meta\">---</span><br></code></pre></td></tr></table></figure>\n\n<p>之后重复上面的步骤先进行静态页面清除，再生成，之后上传到GitHub仓库中进行页面更新，等待几分钟后，如下图所示</p>\n<p><img src=\"https://s2.loli.net/2024/07/25/2wTjGbtilvdkBpW.png\" alt=\"image-20240724162639684.png\"></p>\n<h3 id=\"文档上传\"><a href=\"#文档上传\" class=\"headerlink\" title=\"文档上传\"></a>文档上传</h3><p>使用Typora进行.md文档的编写，非常好用的一个编辑器，绿色版可以网上搜索</p>\n<p>之后将md文件放到博客文件夹下面<code>source/_posts/</code>文件夹下面</p>\n<p>之后使用vim编辑器对文档进行title和tag的编辑</p>\n<p><a href=\"https://www.runoob.com/linux/linux-vim.html\">Linux vi&#x2F;vim | 菜鸟教程 (runoob.com)</a></p>\n<p>进入md文件，首先点击 i 进入编辑模式，在开头位置输入，其中title为文章的名字，tag为文章的标签，方便进行检索</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-meta\">---</span><br><span class=\"hljs-string\">title：</span> <span class=\"hljs-string\">hello</span> <span class=\"hljs-string\">word</span><br><span class=\"hljs-string\">tag：</span> <span class=\"hljs-string\">write</span><br><span class=\"hljs-meta\">---</span><br></code></pre></td></tr></table></figure>\n\n<p>编辑完成点击 Esc 退出报错，直接输入 :wq 保存编辑并且退出，完成文件的标记修改</p>\n<p>之后回到git bash中输入</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>hexo g <span class=\"hljs-comment\"># 生成静态文件，生成的文件在public文件夹里面</span><br><br><span class=\"hljs-variable\">$ </span>hexo d <span class=\"hljs-comment\"># 将生成的文件导入GitHub站点</span><br></code></pre></td></tr></table></figure>\n\n<p>到此，等待几分钟后，你的文章就在你的网页上面出现了</p>\n"},{"title":"Gcode学习","date":"2024-07-23T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/aOHQ9Mg2j6PIBEl.png","_content":"\n# Gcode学习\n\n### 一、3D打印机编程\n\n### 学习资料\n\n[[G-Codes - Klipper 文档 (klipper3d.org)](https://www.klipper3d.org/zh/G-Codes.html)](https://www.klipper3d.org/zh/Overview.html)\n\n[G-code - RepRap](https://reprap.org/wiki/G-code)\n\n[3D 打印机 G 代码命令：完整列表和教程_3d打印机g代码-CSDN博客](https://blog.csdn.net/acktomas/article/details/125552309)\n\n[3D打印机DIY之六------G代码命令_g代码m300-CSDN博客](https://blog.csdn.net/qlexcel/article/details/103466638)\n\n### G指令\n\n#### G0/G1: 直线移动\n\nG0和G1命令完全等价，作用就是让喷头线性移动到一个特定的位置，使用时，不需要所有的参数全部存在，但至少要有一个参数。\n\nG0 Xnnn Ynnn Znnn Ennn Fnnn Snnn / G1 Xnnn Ynnn Znnn Ennn Fnnn Snnn\n\nXnnn表示X轴的移动位置；\n\nYnnn表示Y轴的移动位置；\n\nZnnn表示Z轴的移动位置；\n\nEnnn表示E轴（挤出头步进电机）的移动位置；\n\nFnnn表示移动速度，单位是毫米/每分钟；\n\nSnnn表示是否检查限位开关，S0不检查，S1检查，缺省值是S0；\n\n#### G28：复位\n\n打印机复位命令。执行时会让3个轴依次往限位开关的方向运行，碰到限位开关后还会减速做一次1mm左右的往返运动，来保证复位的准确性。如果在命令后面加上坐标值，则只会复位坐标值对应的坐标轴。（坐标值的数字会被忽略）\n\nG28 X0 Y72.3\n\n只会复位x轴和y轴。\n\n#### G29：Z轴高度三点测试\n\n这条命令会测试打印平面上三个点的Z轴高度，并在串口上输出结果。参数为Snnn，表示对测试结果的处理方式。S1表示更新内存中的Z轴高度值（重置系统会丢失），S2表示更新内存以及EEPROM中的Z轴高度值（重置系统不会丢失）。\n\n一般来说，只有使用高位限位开关（也就是说，Z轴的限位开关位于Z轴坐标最大处），且在挤出头上附带有Z轴高度测试微动开关的机型，适合使用G29命令测试Z轴高度。其他机械配置的机型，不适合使用G29命令。G29命令由固件配置\n\n#### G30：Z轴高度单点测试（单步）\n\n这条命令作为一个完整Z轴高度测试过程的一步，测试打印平面上一个点的Z轴高度，并在串口上输出结果。这个完整的Z轴高度测试过程，通常是由3D打印机控制软件连续发出的，通过参数控制G30的执行状态。因此在手动工作方式下，G30命令只适合不带参数运行\n\n#### G31：输出Z轴高度测试微动开关状态\n\n执行后会输出当前Z轴高度测试微动开关的当前状态，其中L表示微动开关没有触发。如果是处于触发状态，这里会输出H。\n\nG29命令、G30命令、G31命令只进行Z轴的高度测试，并不进行自动调平。\n\n#### G32：热床自动调平\n\n这条命令在G29命令的基础上，不仅测试打印平面上三个点的Z轴高度，而且还会根据测试的结果，对3D打印机的机械参数进行调整，实现热床自动调平。G32命令使用的参数与G29命令是一致的：Snnn，表示测试结果的处理方式。S1表示更新内存中的相关参数值（重置系统会丢失），S2表示更新内存以及EEPROM中的相关参数值（重置系统不会丢失）。\n\nG32命令执行完成时，不仅Z轴高度参数发生了改变，而且还会根据3D打印机的硬件配置，对热床进行相应的调平处理。\n\nG32命令会在3D打印机内存中构建一个转换矩阵（Transformation matrix），让未来3D打印机所处理的所有三维空间位置，都先经过这个矩阵的变换，保证在Z=0的情况下，正好与热床平面完全吻合\n\n#### G4: 暂停移动\n\n让喷头在当前位置停留一段时间。参数可以为：G4 Pnnn或G4 Snnn。Pnnn表示以毫秒为单位，Snnn表示以秒为单位。\n\nG4 P2000与G4 S2完全等价，都表示停顿2秒。\n\n在停顿过程中机器仍可以被控制，如挤出头温度。\n\n#### G20:使用英寸作为单位\n\n执行这条命令后，后面的命令都以英寸作为单位。\n\n#### G21: 使用毫米作为单位\n\n执行这条命令后，后面的命令都以毫米作为单位。\n\n#### G90/G91：设置坐标模式\n\n这两条命令用于设置当前坐标模式为绝对坐标模式(G90)或者相对坐标模式(G91)。没有参数。未设置时缺省值是绝对坐标模式\n\n#### G92:设置当前位置为某个坐标值\n\n把当前位置设定为某个坐标值，可以用来设置零点，如果参数为空表示把当前位置设置为所有轴的的零点。\n\n如：G92 X10 E90    ;表示把当前位置设置为x=10，喷头坐标=90\n\n再如：G92 E0       ；表示把当前喷头坐标设置为0\n\n#### G94/G95:进给速率单位\n\n使用了G94指令之后，所有的进给都是以mm/min为单位，即F100指刀具每分钟移动100毫米（默认的）\n\n使用了G95指令之后，所有的进给都是以mm/r为单位，即F100指主轴每转一转，刀具移动100毫米\n\n#### G17/G18/G19：选择加工平面\n\nG17–XY平面；\n\nG18–XZ平面；\n\nG19–YZ平面；\n\n### M指令\n\n#### M0:打印机停止\n\n打印机会终止任何动作，然后关机。所有的电机和加热器都会被关掉，这个时候只能通过reset按钮来重启控制器。\n\n#### M1: 打印机休眠\n\n打印机会终止任何动作，然后休眠。所有的马达和加热器都会被关掉，但是接收到G或M命令时，打印机可以被唤醒并进入工作状态。\n\n#### M17:启动所有步进电机\n\n#### M18:关闭所有步进电机\n\n#### M20:读取SD卡根目录中的文件\n\n读取SD卡根目录的文件，并通过串口输出文件名。\n\n#### M21:初始化SD卡\n\n初始化SD卡。如果在机器通电时插入SD卡，会默认初始化SD卡。开始其他SD卡功能时，SD卡一定要先初始化。本命令相当于文件系统中执行Mount动作。\n\n#### M22:卸载SD卡\n\n卸载SD卡，也就是执行Unmount动作。没有相关的参数。\n\n#### M23:选择SD卡中的文件\n\n选择一个SD卡上的文件。文件选择之后，可以执行打印、删除等动作。\n\n如：M23 filename.gcode   ;选中filename.gcode文件\n\n#### M24:开始打印SD卡中选中的文件\n\n开始打印通过M23命令选中的文件。\n\n#### M25:暂停SD卡打印\n\n暂停打印通过M23命令选定的文件。\n\n#### M27:报告SD卡打印进度\n\n获取SD卡打印进度。没有相关参数。\n\nM27命令的输出，格式为：SD printing byte 11518/1127578\n\n这条命令供上位机获取当前的3D打印进度信息，用于显示在电脑界面上。\n\n#### M28:开始往SD卡文件中写入数据\n\n接收到此命令后，后续接收到的命令（除了M29）都会被当成数据写入该文件。\n\n命令后面会跟着文件名，如果文件不存在则会被创建，如果存在则会被覆盖。接收到这条命令后，后续接收到的命令都会被写入该文件中，直到接收到M29命令。如：M28 filename.gcode  \n\n#### M29:停止往SD卡文件中写入数据\n\n接收到此命令后，后续接收到的命令要开始正常执行。\n\n#### M30:删除SD卡中的文件\n\n如：M30 filename.gcode     ;删除filename.gcode文件\n\n#### M32：创建子目录\n\n在SD卡上创建一个子目录。参数为：filename，表示待创建的子目录（包含目录名，以/分隔）；\n\n#### M82/M83：设置挤出头步进电机坐标模式\n\n与G90/G91命令类似，这两条命令用于设置挤出头当前坐标模式为绝对坐标模式(M82)或者相对坐标模式(M83)。没有参数。未设置时缺省值是绝对坐标模式。需要注意的是，G90/G91设置的坐标模式，同时对XYZE四个轴起作用，但M82/M83设置的坐标模式，只对E轴（挤出头步进电机）起作用。\n\n#### M84：设置步进电机自动关闭时间\n\n当3D打印机一段时间没有接收到步进电机运动指令之后，3D打印机（为了节能）会自动关闭步进电机。使用M84指令，可以设置这个自动关闭步进电机的时间。\n\nSnnn，表示步进电机关闭的时间，以秒为单位。\n\n如果使用M85时没有指定S参数，或者使用了S0参数，则代表取消3D打印机自动关闭功能，挤出头、热床等在工作完成之后，一直会处于当前状态，而不会被自动关闭。\n\n#### M73：获取当前打印进度\n\n告诉固件当前的构建进度百分比。预计这台机器会在显示屏上显示出来。如果百分比恰好为0，则向主机发送“构建开始”通知。如果百分比恰好为100，则向主机发送“构建结束”通知。\n\n#### M105: 获取当前温度（单位：℃）\n\n获取当前温度值，包括挤出头和热床的温度。\n\nX，表示输出ADC测量的原始值；\n\nM105命令的输出，格式为：T:18.97 /0 B:18.75 /0 B@:0 @:0\n\nT:之后的部分，代表挤出头的当前温度/目标温度；\n\nB:之后的部分代表热床的当前温度/目标温度。\n\n在PID温度控制模式下，B@:后面的数字代表热床当前的输出强度，是一个0~255的值，@:后面的数字，代表挤出头当前的输出强度，也是一个0~255的值。例子中，挤出头、热床都处于关闭状态，所以这个位置的值都是0。\n\n#### M104:设置挤出机（喷头）温度\n\n设置挤出头的目标温度。执行这条命令后，不需要等待达到这个温度，控制板继续执行下一条G-code语句。\n\nSnnn，表示目标温度；\n\nTnnn，表示对应的挤出头；\n\nP，表示要等待前面的指令完成之后，再开始设置挤出头温度；\n\nFnnn，表示到达目标温度之后，是否触发蜂鸣器。F1表示要触发；\n\n如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。\n\n如：M104 S190         ;将挤出机的温度设置为190度 \n\n#### M106: 打开风扇\n\n如：M106 S127    ;打开风扇（半速）。\n\n'S'表示 PWM值 (0-255). 可简单理解为：风扇有0-255级强度可选，其中 M106 S0 意味着风扇将被关掉。\n\nP表示风扇的数目，P0是第一个风扇，P1是第二个风扇\n\n#### M109: 等待挤出头加热达到目标温度\n\n设置挤出头的目标温度，并等待达到这个温度。\n\nSnnn，表示目标温度；\n\nTnnn，表示对应的挤出头；\n\nFnnn，表示到达目标温度之后，是否触发蜂鸣器。\n\nF1表示要触发；\n\n如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。如： M109 S185      ;等待挤出头加热到185度\n\n#### M114: 获取挤出头当前位置\n\n输出挤出头当前位置。没有相关的参数。\n\nM114命令的输出，格式为：\n\nM114 X:20.00 Y:30.00 Z:10.000 E:0.0000\n\n#### M115: 获取3D打印机信息\n\n输出3D打印机信息。没有相关的参数。\n\nM115命令的输出，格式为：FIRMWARE_NAME:Repetier_0.92.3FIRMWARE_URL:…Printedfilament:0.00mPrintingtime:0days0hours0minSpeedMultiply:100FlowMultiply:100\n\n第一行是固件的版本信息，很长，没有列完整。第二行是已经打印了多少米耗材，打印时间是几天几小时几分钟。第三行是速度系数，参考M220命令。第四行是流率系数，参考M221命令。\n\n#### M140 设置热床目标温度\n\n设置热床的目标温度。执行这条命令后，不需要等待达到这个温度，立即开始执行下一条G-code语句。\n\nSnnn表示目标温度；\n\nFnnn表示到达目标温度之后，是否触发蜂鸣器。\n\nF1表示要触发；\n\n#### M141:设置构建平台的温度\n\n可能用于特定的温控策略或多热床系统\n\nM141 S60将加热床设置为60摄氏度\n\n#### M190: 等待热床加热达到目标温度\n\n设置热床的目标温度，并等待达到这个温度。\n\nSnnn，表示目标温度；\n\nFnnn，表示到达目标温度之后，是否触发蜂鸣器。\n\nF1表示要触发；\n\n#### M204：设置PID参数\n\n设置挤出头温度控制的PID参数，\n\nSnnn表示对应的挤出头，无S参数表示使用当前挤出头；\n\nXnnn表示P参数；\n\nYnnn表示I参数；\n\nZnnn表示D参数；\n\n#### M220：设置速度\n\n设置3D打印机运行速度系数。\n\n命令参数为Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；\n\n3D打印机运行速度系数，是一个在25%到500%范围内变化的值。这个系数值在3D打印机运行过程中，与切片器给出的3D打印机运动速度基础值相乘，得到最终的3D打印机实际运动速度值。\n\nM220命令的输出，格式为：SpeedMultiply:100\n\n#### M221：设置流率\n\n设置3D打印机的流率系数（Flow rate）。\n\n命令参数为：Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；\n\n3D打印机流率系数，是在上位机切片软件通过耗材直径、喷头直径、层高以及3D打印速度等因素综合计算得到的E轴运动速度的基础上，叠加的一个E轴运动速度系数。简单地说，就是控制挤出头耗材挤出量的多少。这个系数可以在25%到500%范围内变化。\n\nM221命令的输出，格式为：FlowMultiply:100\n\n### T指令\n\n#### T0/T1/T2/T3 命令，选择不同的工具或挤出机\n\nT0 选择第一个挤出机；T1 选择第二个挤出机；T2 选择第三个挤出机；T3 选择第四个挤出机\n\n#### 节选注释\n\n```\nM106 P2 S204    //打开第三个风扇，PWM值为204\n;LAYER_CHANGE\n;Z:16.8\n;HEIGHT:0.199999\n;BEFORE_LAYER_CHANGE\n;16.8\nG92 E0    //设置喷头当前位置为零点\nM106 P2 S0    //关闭第二个风扇\n\nG1 E-.35 F2400  //挤出机回抽挤出0.35mm，速度设置为2400mm/min\n;WIPE_START\nG1 F9473.877    //速度设置为9473.877mm/min\nG1 X320.911 Y304.914 E-.11658    //直线插补，移动到（320.911，304.914）位置，并回抽0.11658\nG1 X321.066 Y304.753 E-.03342    //直线插补，移动到（321.066，304.753）位置，并回抽0.03342\n;WIPE_END\nEXCLUDE_OBJECT_END NAME=ksr_fdmtest_w4.stl_id_0_copy_0\n;_SET_FAN_SPEED_CHANGING_LAYER\nEXCLUDE_OBJECT_START NAME=ksr_fdmtest_w4.stl_id_0_copy_0\nG17    //选择XY平面\nG3 Z17 I.035 J-1.216 P1  F30000    //圆弧插补，Z轴位置为17mm，圆心坐标为（321.066+0.035，304.753-1.216）,P1表示为顺时针，速度为30000mm/min\nG1 X43.587 Y296.746 Z17    //直线插补，移动到（321.066，304.753，17）位置\nG1 Z16.8    //直线插补，移动到（321.066，304.753，16.8）位置\nG1 E.5 F2400    //挤出机挤出0.5mm，速度设置为2400mm/min\n```\n\n### 二、CNC数控编程\n\n#### 学习资料\n\n[数控机床编程入门【G-code】 | 学习软件编程 (hubwiz.com)](http://blog.hubwiz.com/2021/06/26/g-code-tutorial/)\n\n#### G00–快速定位\n\nG00命令以最大速度将机器从当前位置移动到指定的坐标。机器将同时移动所有轴，以便同时完成行程。 结果是直线移动到新的位置点。\n\n#### G01–线性插值\n\nG01 命令指示机器以设定速度直线移动。我们用X、Y和Z值指定最终位置，用F值指定速度。 CNC控制器计算（插值）要经过的中间点的坐标，以获得直线。\n\n#### G02–顺时针环形插值\n\nG02命令要求机器以圆形模式顺时针移动。它与 G01 命令的概念相同，在执行适当的加工过程时使用。除了 终点参数，在这里我们还需要定义旋转中心，或弧线起点与弧线中心点的距离。起点实际上是上一个命令的 终点或当前点。\n\n#### G03–逆时针环形插值\n\n与 G02 一样，G03 命令指示机器以圆形模式移动，区别在于G03是逆时针运动。所有其他功能和规则与 G02 命令相同。\n\n#### G20/G21 – 单位选择\n\nG20 和 G21 命令定义 G-code单位，英寸或毫米。G20 = 英寸；G21 = 毫米\n\n#### G17/G18/G18 – 工作面选择\n\nG17–XY平面；G18–XZ平面；G19–YZ平面\n\n#### G28–返回home\n\nG28命令要求机器将移动到其参考点或home位置。为了避免碰撞，我们可以包括一个带有 X、Y 和 Z 参数的 中间点。该工具将在转到参考点之前通过该点。\n\n#### G90/G91 – 定位模式\n\n使用 G90 和 G91 命令，我们告诉机器如何解析坐标值。G90为绝对模式，G91为相对模式。\n\n#### 其他代码\n\n```\n- M00–程序停止\n- M02–程序结束\n- M03–主轴打开–顺时针\n- M04–主轴打开–逆时针\n- M05–主轴停止\n- M06–工具更改\n- M08–启用Flood Colant\n- M09–禁用Flood Colant\n- M30 – 程序结束\n- M104–启动挤出加热\n- M109–等到挤出器到达T0\n- M140–开始底板加热\n- M190–等到底板到达T0\n- M106–设置风扇速度\n```\n\n#### 代码解释\n\n```\n%\nG21 G17 G90 F100                     //G21单位选择毫米，G17选择XY平面，G90选择绝对模式，F100代表转速\nM03 S1000                            //主轴打开-顺时针，速度为1000转\nG00 X5 Y5                 ; point B  //快速移动到（5，5）\nG01 X5 Y5 Z-1             ; point B  //直线插补移动到（5，5，-1）\nG01 X5 Y15 Z-1            ; point C  //直线插补移动到（5，15，-1）\nG02 X9 Y19 Z-1 I4 J0      ; point D  //顺时针环形插补移动到（9，19，-1），圆心为（9，15）\nG01 X23 Y19 Z-1           ; point E  //直线插补移动到（23，19，-1）\nG01 X32 Y5 Z-1            ; point F  //直线插补移动到（32，5，-1）\nG01 X21 Y5 Z-1            ; point G  //直线插补移动到（21，5，-1）\nG01 X21 Y8 Z-1            ; point H  //直线插补移动到（21，8，-1）\nG03 X19 Y10 Z-1 I-2 J0    ; point I  //逆时针环形插补移动到（19，10，-1），圆心为（19，8）\nG01 X13 Y10 Z-1           ; point J  //直线插补移动到（13，10，-1）\nG03 X11 Y8 Z-1 I0 J-2     ; point K  //逆时针环形插补移动到（11，8，-1），圆心为（13，8）\nG01 X11 Y5 Z-1            ; point L  //直线插补移动到（11，5，-1）\nG01 X5 Y5 Z-1             ; point B  //直线插补移动到（5，5，-1）\nG01 X5 Y5 Z0                         //直线插补移动到（5，5，0）\nG28  X0 Y0                           //返回零点（0，0，0）\nM05                                  //关闭主轴\nM30                                  //程序结束\n%\n```\n","source":"_posts/Work No.4.md","raw":"---\ntitle: Gcode学习\ntag: Gcode\ndate: 2024-07-24\ncategories: 3D打印机\nindex_img: https://s2.loli.net/2024/07/31/aOHQ9Mg2j6PIBEl.png\n---\n\n# Gcode学习\n\n### 一、3D打印机编程\n\n### 学习资料\n\n[[G-Codes - Klipper 文档 (klipper3d.org)](https://www.klipper3d.org/zh/G-Codes.html)](https://www.klipper3d.org/zh/Overview.html)\n\n[G-code - RepRap](https://reprap.org/wiki/G-code)\n\n[3D 打印机 G 代码命令：完整列表和教程_3d打印机g代码-CSDN博客](https://blog.csdn.net/acktomas/article/details/125552309)\n\n[3D打印机DIY之六------G代码命令_g代码m300-CSDN博客](https://blog.csdn.net/qlexcel/article/details/103466638)\n\n### G指令\n\n#### G0/G1: 直线移动\n\nG0和G1命令完全等价，作用就是让喷头线性移动到一个特定的位置，使用时，不需要所有的参数全部存在，但至少要有一个参数。\n\nG0 Xnnn Ynnn Znnn Ennn Fnnn Snnn / G1 Xnnn Ynnn Znnn Ennn Fnnn Snnn\n\nXnnn表示X轴的移动位置；\n\nYnnn表示Y轴的移动位置；\n\nZnnn表示Z轴的移动位置；\n\nEnnn表示E轴（挤出头步进电机）的移动位置；\n\nFnnn表示移动速度，单位是毫米/每分钟；\n\nSnnn表示是否检查限位开关，S0不检查，S1检查，缺省值是S0；\n\n#### G28：复位\n\n打印机复位命令。执行时会让3个轴依次往限位开关的方向运行，碰到限位开关后还会减速做一次1mm左右的往返运动，来保证复位的准确性。如果在命令后面加上坐标值，则只会复位坐标值对应的坐标轴。（坐标值的数字会被忽略）\n\nG28 X0 Y72.3\n\n只会复位x轴和y轴。\n\n#### G29：Z轴高度三点测试\n\n这条命令会测试打印平面上三个点的Z轴高度，并在串口上输出结果。参数为Snnn，表示对测试结果的处理方式。S1表示更新内存中的Z轴高度值（重置系统会丢失），S2表示更新内存以及EEPROM中的Z轴高度值（重置系统不会丢失）。\n\n一般来说，只有使用高位限位开关（也就是说，Z轴的限位开关位于Z轴坐标最大处），且在挤出头上附带有Z轴高度测试微动开关的机型，适合使用G29命令测试Z轴高度。其他机械配置的机型，不适合使用G29命令。G29命令由固件配置\n\n#### G30：Z轴高度单点测试（单步）\n\n这条命令作为一个完整Z轴高度测试过程的一步，测试打印平面上一个点的Z轴高度，并在串口上输出结果。这个完整的Z轴高度测试过程，通常是由3D打印机控制软件连续发出的，通过参数控制G30的执行状态。因此在手动工作方式下，G30命令只适合不带参数运行\n\n#### G31：输出Z轴高度测试微动开关状态\n\n执行后会输出当前Z轴高度测试微动开关的当前状态，其中L表示微动开关没有触发。如果是处于触发状态，这里会输出H。\n\nG29命令、G30命令、G31命令只进行Z轴的高度测试，并不进行自动调平。\n\n#### G32：热床自动调平\n\n这条命令在G29命令的基础上，不仅测试打印平面上三个点的Z轴高度，而且还会根据测试的结果，对3D打印机的机械参数进行调整，实现热床自动调平。G32命令使用的参数与G29命令是一致的：Snnn，表示测试结果的处理方式。S1表示更新内存中的相关参数值（重置系统会丢失），S2表示更新内存以及EEPROM中的相关参数值（重置系统不会丢失）。\n\nG32命令执行完成时，不仅Z轴高度参数发生了改变，而且还会根据3D打印机的硬件配置，对热床进行相应的调平处理。\n\nG32命令会在3D打印机内存中构建一个转换矩阵（Transformation matrix），让未来3D打印机所处理的所有三维空间位置，都先经过这个矩阵的变换，保证在Z=0的情况下，正好与热床平面完全吻合\n\n#### G4: 暂停移动\n\n让喷头在当前位置停留一段时间。参数可以为：G4 Pnnn或G4 Snnn。Pnnn表示以毫秒为单位，Snnn表示以秒为单位。\n\nG4 P2000与G4 S2完全等价，都表示停顿2秒。\n\n在停顿过程中机器仍可以被控制，如挤出头温度。\n\n#### G20:使用英寸作为单位\n\n执行这条命令后，后面的命令都以英寸作为单位。\n\n#### G21: 使用毫米作为单位\n\n执行这条命令后，后面的命令都以毫米作为单位。\n\n#### G90/G91：设置坐标模式\n\n这两条命令用于设置当前坐标模式为绝对坐标模式(G90)或者相对坐标模式(G91)。没有参数。未设置时缺省值是绝对坐标模式\n\n#### G92:设置当前位置为某个坐标值\n\n把当前位置设定为某个坐标值，可以用来设置零点，如果参数为空表示把当前位置设置为所有轴的的零点。\n\n如：G92 X10 E90    ;表示把当前位置设置为x=10，喷头坐标=90\n\n再如：G92 E0       ；表示把当前喷头坐标设置为0\n\n#### G94/G95:进给速率单位\n\n使用了G94指令之后，所有的进给都是以mm/min为单位，即F100指刀具每分钟移动100毫米（默认的）\n\n使用了G95指令之后，所有的进给都是以mm/r为单位，即F100指主轴每转一转，刀具移动100毫米\n\n#### G17/G18/G19：选择加工平面\n\nG17–XY平面；\n\nG18–XZ平面；\n\nG19–YZ平面；\n\n### M指令\n\n#### M0:打印机停止\n\n打印机会终止任何动作，然后关机。所有的电机和加热器都会被关掉，这个时候只能通过reset按钮来重启控制器。\n\n#### M1: 打印机休眠\n\n打印机会终止任何动作，然后休眠。所有的马达和加热器都会被关掉，但是接收到G或M命令时，打印机可以被唤醒并进入工作状态。\n\n#### M17:启动所有步进电机\n\n#### M18:关闭所有步进电机\n\n#### M20:读取SD卡根目录中的文件\n\n读取SD卡根目录的文件，并通过串口输出文件名。\n\n#### M21:初始化SD卡\n\n初始化SD卡。如果在机器通电时插入SD卡，会默认初始化SD卡。开始其他SD卡功能时，SD卡一定要先初始化。本命令相当于文件系统中执行Mount动作。\n\n#### M22:卸载SD卡\n\n卸载SD卡，也就是执行Unmount动作。没有相关的参数。\n\n#### M23:选择SD卡中的文件\n\n选择一个SD卡上的文件。文件选择之后，可以执行打印、删除等动作。\n\n如：M23 filename.gcode   ;选中filename.gcode文件\n\n#### M24:开始打印SD卡中选中的文件\n\n开始打印通过M23命令选中的文件。\n\n#### M25:暂停SD卡打印\n\n暂停打印通过M23命令选定的文件。\n\n#### M27:报告SD卡打印进度\n\n获取SD卡打印进度。没有相关参数。\n\nM27命令的输出，格式为：SD printing byte 11518/1127578\n\n这条命令供上位机获取当前的3D打印进度信息，用于显示在电脑界面上。\n\n#### M28:开始往SD卡文件中写入数据\n\n接收到此命令后，后续接收到的命令（除了M29）都会被当成数据写入该文件。\n\n命令后面会跟着文件名，如果文件不存在则会被创建，如果存在则会被覆盖。接收到这条命令后，后续接收到的命令都会被写入该文件中，直到接收到M29命令。如：M28 filename.gcode  \n\n#### M29:停止往SD卡文件中写入数据\n\n接收到此命令后，后续接收到的命令要开始正常执行。\n\n#### M30:删除SD卡中的文件\n\n如：M30 filename.gcode     ;删除filename.gcode文件\n\n#### M32：创建子目录\n\n在SD卡上创建一个子目录。参数为：filename，表示待创建的子目录（包含目录名，以/分隔）；\n\n#### M82/M83：设置挤出头步进电机坐标模式\n\n与G90/G91命令类似，这两条命令用于设置挤出头当前坐标模式为绝对坐标模式(M82)或者相对坐标模式(M83)。没有参数。未设置时缺省值是绝对坐标模式。需要注意的是，G90/G91设置的坐标模式，同时对XYZE四个轴起作用，但M82/M83设置的坐标模式，只对E轴（挤出头步进电机）起作用。\n\n#### M84：设置步进电机自动关闭时间\n\n当3D打印机一段时间没有接收到步进电机运动指令之后，3D打印机（为了节能）会自动关闭步进电机。使用M84指令，可以设置这个自动关闭步进电机的时间。\n\nSnnn，表示步进电机关闭的时间，以秒为单位。\n\n如果使用M85时没有指定S参数，或者使用了S0参数，则代表取消3D打印机自动关闭功能，挤出头、热床等在工作完成之后，一直会处于当前状态，而不会被自动关闭。\n\n#### M73：获取当前打印进度\n\n告诉固件当前的构建进度百分比。预计这台机器会在显示屏上显示出来。如果百分比恰好为0，则向主机发送“构建开始”通知。如果百分比恰好为100，则向主机发送“构建结束”通知。\n\n#### M105: 获取当前温度（单位：℃）\n\n获取当前温度值，包括挤出头和热床的温度。\n\nX，表示输出ADC测量的原始值；\n\nM105命令的输出，格式为：T:18.97 /0 B:18.75 /0 B@:0 @:0\n\nT:之后的部分，代表挤出头的当前温度/目标温度；\n\nB:之后的部分代表热床的当前温度/目标温度。\n\n在PID温度控制模式下，B@:后面的数字代表热床当前的输出强度，是一个0~255的值，@:后面的数字，代表挤出头当前的输出强度，也是一个0~255的值。例子中，挤出头、热床都处于关闭状态，所以这个位置的值都是0。\n\n#### M104:设置挤出机（喷头）温度\n\n设置挤出头的目标温度。执行这条命令后，不需要等待达到这个温度，控制板继续执行下一条G-code语句。\n\nSnnn，表示目标温度；\n\nTnnn，表示对应的挤出头；\n\nP，表示要等待前面的指令完成之后，再开始设置挤出头温度；\n\nFnnn，表示到达目标温度之后，是否触发蜂鸣器。F1表示要触发；\n\n如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。\n\n如：M104 S190         ;将挤出机的温度设置为190度 \n\n#### M106: 打开风扇\n\n如：M106 S127    ;打开风扇（半速）。\n\n'S'表示 PWM值 (0-255). 可简单理解为：风扇有0-255级强度可选，其中 M106 S0 意味着风扇将被关掉。\n\nP表示风扇的数目，P0是第一个风扇，P1是第二个风扇\n\n#### M109: 等待挤出头加热达到目标温度\n\n设置挤出头的目标温度，并等待达到这个温度。\n\nSnnn，表示目标温度；\n\nTnnn，表示对应的挤出头；\n\nFnnn，表示到达目标温度之后，是否触发蜂鸣器。\n\nF1表示要触发；\n\n如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。如： M109 S185      ;等待挤出头加热到185度\n\n#### M114: 获取挤出头当前位置\n\n输出挤出头当前位置。没有相关的参数。\n\nM114命令的输出，格式为：\n\nM114 X:20.00 Y:30.00 Z:10.000 E:0.0000\n\n#### M115: 获取3D打印机信息\n\n输出3D打印机信息。没有相关的参数。\n\nM115命令的输出，格式为：FIRMWARE_NAME:Repetier_0.92.3FIRMWARE_URL:…Printedfilament:0.00mPrintingtime:0days0hours0minSpeedMultiply:100FlowMultiply:100\n\n第一行是固件的版本信息，很长，没有列完整。第二行是已经打印了多少米耗材，打印时间是几天几小时几分钟。第三行是速度系数，参考M220命令。第四行是流率系数，参考M221命令。\n\n#### M140 设置热床目标温度\n\n设置热床的目标温度。执行这条命令后，不需要等待达到这个温度，立即开始执行下一条G-code语句。\n\nSnnn表示目标温度；\n\nFnnn表示到达目标温度之后，是否触发蜂鸣器。\n\nF1表示要触发；\n\n#### M141:设置构建平台的温度\n\n可能用于特定的温控策略或多热床系统\n\nM141 S60将加热床设置为60摄氏度\n\n#### M190: 等待热床加热达到目标温度\n\n设置热床的目标温度，并等待达到这个温度。\n\nSnnn，表示目标温度；\n\nFnnn，表示到达目标温度之后，是否触发蜂鸣器。\n\nF1表示要触发；\n\n#### M204：设置PID参数\n\n设置挤出头温度控制的PID参数，\n\nSnnn表示对应的挤出头，无S参数表示使用当前挤出头；\n\nXnnn表示P参数；\n\nYnnn表示I参数；\n\nZnnn表示D参数；\n\n#### M220：设置速度\n\n设置3D打印机运行速度系数。\n\n命令参数为Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；\n\n3D打印机运行速度系数，是一个在25%到500%范围内变化的值。这个系数值在3D打印机运行过程中，与切片器给出的3D打印机运动速度基础值相乘，得到最终的3D打印机实际运动速度值。\n\nM220命令的输出，格式为：SpeedMultiply:100\n\n#### M221：设置流率\n\n设置3D打印机的流率系数（Flow rate）。\n\n命令参数为：Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；\n\n3D打印机流率系数，是在上位机切片软件通过耗材直径、喷头直径、层高以及3D打印速度等因素综合计算得到的E轴运动速度的基础上，叠加的一个E轴运动速度系数。简单地说，就是控制挤出头耗材挤出量的多少。这个系数可以在25%到500%范围内变化。\n\nM221命令的输出，格式为：FlowMultiply:100\n\n### T指令\n\n#### T0/T1/T2/T3 命令，选择不同的工具或挤出机\n\nT0 选择第一个挤出机；T1 选择第二个挤出机；T2 选择第三个挤出机；T3 选择第四个挤出机\n\n#### 节选注释\n\n```\nM106 P2 S204    //打开第三个风扇，PWM值为204\n;LAYER_CHANGE\n;Z:16.8\n;HEIGHT:0.199999\n;BEFORE_LAYER_CHANGE\n;16.8\nG92 E0    //设置喷头当前位置为零点\nM106 P2 S0    //关闭第二个风扇\n\nG1 E-.35 F2400  //挤出机回抽挤出0.35mm，速度设置为2400mm/min\n;WIPE_START\nG1 F9473.877    //速度设置为9473.877mm/min\nG1 X320.911 Y304.914 E-.11658    //直线插补，移动到（320.911，304.914）位置，并回抽0.11658\nG1 X321.066 Y304.753 E-.03342    //直线插补，移动到（321.066，304.753）位置，并回抽0.03342\n;WIPE_END\nEXCLUDE_OBJECT_END NAME=ksr_fdmtest_w4.stl_id_0_copy_0\n;_SET_FAN_SPEED_CHANGING_LAYER\nEXCLUDE_OBJECT_START NAME=ksr_fdmtest_w4.stl_id_0_copy_0\nG17    //选择XY平面\nG3 Z17 I.035 J-1.216 P1  F30000    //圆弧插补，Z轴位置为17mm，圆心坐标为（321.066+0.035，304.753-1.216）,P1表示为顺时针，速度为30000mm/min\nG1 X43.587 Y296.746 Z17    //直线插补，移动到（321.066，304.753，17）位置\nG1 Z16.8    //直线插补，移动到（321.066，304.753，16.8）位置\nG1 E.5 F2400    //挤出机挤出0.5mm，速度设置为2400mm/min\n```\n\n### 二、CNC数控编程\n\n#### 学习资料\n\n[数控机床编程入门【G-code】 | 学习软件编程 (hubwiz.com)](http://blog.hubwiz.com/2021/06/26/g-code-tutorial/)\n\n#### G00–快速定位\n\nG00命令以最大速度将机器从当前位置移动到指定的坐标。机器将同时移动所有轴，以便同时完成行程。 结果是直线移动到新的位置点。\n\n#### G01–线性插值\n\nG01 命令指示机器以设定速度直线移动。我们用X、Y和Z值指定最终位置，用F值指定速度。 CNC控制器计算（插值）要经过的中间点的坐标，以获得直线。\n\n#### G02–顺时针环形插值\n\nG02命令要求机器以圆形模式顺时针移动。它与 G01 命令的概念相同，在执行适当的加工过程时使用。除了 终点参数，在这里我们还需要定义旋转中心，或弧线起点与弧线中心点的距离。起点实际上是上一个命令的 终点或当前点。\n\n#### G03–逆时针环形插值\n\n与 G02 一样，G03 命令指示机器以圆形模式移动，区别在于G03是逆时针运动。所有其他功能和规则与 G02 命令相同。\n\n#### G20/G21 – 单位选择\n\nG20 和 G21 命令定义 G-code单位，英寸或毫米。G20 = 英寸；G21 = 毫米\n\n#### G17/G18/G18 – 工作面选择\n\nG17–XY平面；G18–XZ平面；G19–YZ平面\n\n#### G28–返回home\n\nG28命令要求机器将移动到其参考点或home位置。为了避免碰撞，我们可以包括一个带有 X、Y 和 Z 参数的 中间点。该工具将在转到参考点之前通过该点。\n\n#### G90/G91 – 定位模式\n\n使用 G90 和 G91 命令，我们告诉机器如何解析坐标值。G90为绝对模式，G91为相对模式。\n\n#### 其他代码\n\n```\n- M00–程序停止\n- M02–程序结束\n- M03–主轴打开–顺时针\n- M04–主轴打开–逆时针\n- M05–主轴停止\n- M06–工具更改\n- M08–启用Flood Colant\n- M09–禁用Flood Colant\n- M30 – 程序结束\n- M104–启动挤出加热\n- M109–等到挤出器到达T0\n- M140–开始底板加热\n- M190–等到底板到达T0\n- M106–设置风扇速度\n```\n\n#### 代码解释\n\n```\n%\nG21 G17 G90 F100                     //G21单位选择毫米，G17选择XY平面，G90选择绝对模式，F100代表转速\nM03 S1000                            //主轴打开-顺时针，速度为1000转\nG00 X5 Y5                 ; point B  //快速移动到（5，5）\nG01 X5 Y5 Z-1             ; point B  //直线插补移动到（5，5，-1）\nG01 X5 Y15 Z-1            ; point C  //直线插补移动到（5，15，-1）\nG02 X9 Y19 Z-1 I4 J0      ; point D  //顺时针环形插补移动到（9，19，-1），圆心为（9，15）\nG01 X23 Y19 Z-1           ; point E  //直线插补移动到（23，19，-1）\nG01 X32 Y5 Z-1            ; point F  //直线插补移动到（32，5，-1）\nG01 X21 Y5 Z-1            ; point G  //直线插补移动到（21，5，-1）\nG01 X21 Y8 Z-1            ; point H  //直线插补移动到（21，8，-1）\nG03 X19 Y10 Z-1 I-2 J0    ; point I  //逆时针环形插补移动到（19，10，-1），圆心为（19，8）\nG01 X13 Y10 Z-1           ; point J  //直线插补移动到（13，10，-1）\nG03 X11 Y8 Z-1 I0 J-2     ; point K  //逆时针环形插补移动到（11，8，-1），圆心为（13，8）\nG01 X11 Y5 Z-1            ; point L  //直线插补移动到（11，5，-1）\nG01 X5 Y5 Z-1             ; point B  //直线插补移动到（5，5，-1）\nG01 X5 Y5 Z0                         //直线插补移动到（5，5，0）\nG28  X0 Y0                           //返回零点（0，0，0）\nM05                                  //关闭主轴\nM30                                  //程序结束\n%\n```\n","slug":"Work No.4","published":1,"updated":"2024-07-31T03:33:20.887Z","_id":"clz9aaxqg0011ygfbcoxve78n","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Gcode学习\"><a href=\"#Gcode学习\" class=\"headerlink\" title=\"Gcode学习\"></a>Gcode学习</h1><h3 id=\"一、3D打印机编程\"><a href=\"#一、3D打印机编程\" class=\"headerlink\" title=\"一、3D打印机编程\"></a>一、3D打印机编程</h3><h3 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h3><p><a href=\"https://www.klipper3d.org/zh/Overview.html\"><a href=\"https://www.klipper3d.org/zh/G-Codes.html\">G-Codes - Klipper 文档 (klipper3d.org)</a></a></p>\n<p><a href=\"https://reprap.org/wiki/G-code\">G-code - RepRap</a></p>\n<p><a href=\"https://blog.csdn.net/acktomas/article/details/125552309\">3D 打印机 G 代码命令：完整列表和教程_3d打印机g代码-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qlexcel/article/details/103466638\">3D打印机DIY之六——G代码命令_g代码m300-CSDN博客</a></p>\n<h3 id=\"G指令\"><a href=\"#G指令\" class=\"headerlink\" title=\"G指令\"></a>G指令</h3><h4 id=\"G0-G1-直线移动\"><a href=\"#G0-G1-直线移动\" class=\"headerlink\" title=\"G0&#x2F;G1: 直线移动\"></a>G0&#x2F;G1: 直线移动</h4><p>G0和G1命令完全等价，作用就是让喷头线性移动到一个特定的位置，使用时，不需要所有的参数全部存在，但至少要有一个参数。</p>\n<p>G0 Xnnn Ynnn Znnn Ennn Fnnn Snnn &#x2F; G1 Xnnn Ynnn Znnn Ennn Fnnn Snnn</p>\n<p>Xnnn表示X轴的移动位置；</p>\n<p>Ynnn表示Y轴的移动位置；</p>\n<p>Znnn表示Z轴的移动位置；</p>\n<p>Ennn表示E轴（挤出头步进电机）的移动位置；</p>\n<p>Fnnn表示移动速度，单位是毫米&#x2F;每分钟；</p>\n<p>Snnn表示是否检查限位开关，S0不检查，S1检查，缺省值是S0；</p>\n<h4 id=\"G28：复位\"><a href=\"#G28：复位\" class=\"headerlink\" title=\"G28：复位\"></a>G28：复位</h4><p>打印机复位命令。执行时会让3个轴依次往限位开关的方向运行，碰到限位开关后还会减速做一次1mm左右的往返运动，来保证复位的准确性。如果在命令后面加上坐标值，则只会复位坐标值对应的坐标轴。（坐标值的数字会被忽略）</p>\n<p>G28 X0 Y72.3</p>\n<p>只会复位x轴和y轴。</p>\n<h4 id=\"G29：Z轴高度三点测试\"><a href=\"#G29：Z轴高度三点测试\" class=\"headerlink\" title=\"G29：Z轴高度三点测试\"></a>G29：Z轴高度三点测试</h4><p>这条命令会测试打印平面上三个点的Z轴高度，并在串口上输出结果。参数为Snnn，表示对测试结果的处理方式。S1表示更新内存中的Z轴高度值（重置系统会丢失），S2表示更新内存以及EEPROM中的Z轴高度值（重置系统不会丢失）。</p>\n<p>一般来说，只有使用高位限位开关（也就是说，Z轴的限位开关位于Z轴坐标最大处），且在挤出头上附带有Z轴高度测试微动开关的机型，适合使用G29命令测试Z轴高度。其他机械配置的机型，不适合使用G29命令。G29命令由固件配置</p>\n<h4 id=\"G30：Z轴高度单点测试（单步）\"><a href=\"#G30：Z轴高度单点测试（单步）\" class=\"headerlink\" title=\"G30：Z轴高度单点测试（单步）\"></a>G30：Z轴高度单点测试（单步）</h4><p>这条命令作为一个完整Z轴高度测试过程的一步，测试打印平面上一个点的Z轴高度，并在串口上输出结果。这个完整的Z轴高度测试过程，通常是由3D打印机控制软件连续发出的，通过参数控制G30的执行状态。因此在手动工作方式下，G30命令只适合不带参数运行</p>\n<h4 id=\"G31：输出Z轴高度测试微动开关状态\"><a href=\"#G31：输出Z轴高度测试微动开关状态\" class=\"headerlink\" title=\"G31：输出Z轴高度测试微动开关状态\"></a>G31：输出Z轴高度测试微动开关状态</h4><p>执行后会输出当前Z轴高度测试微动开关的当前状态，其中L表示微动开关没有触发。如果是处于触发状态，这里会输出H。</p>\n<p>G29命令、G30命令、G31命令只进行Z轴的高度测试，并不进行自动调平。</p>\n<h4 id=\"G32：热床自动调平\"><a href=\"#G32：热床自动调平\" class=\"headerlink\" title=\"G32：热床自动调平\"></a>G32：热床自动调平</h4><p>这条命令在G29命令的基础上，不仅测试打印平面上三个点的Z轴高度，而且还会根据测试的结果，对3D打印机的机械参数进行调整，实现热床自动调平。G32命令使用的参数与G29命令是一致的：Snnn，表示测试结果的处理方式。S1表示更新内存中的相关参数值（重置系统会丢失），S2表示更新内存以及EEPROM中的相关参数值（重置系统不会丢失）。</p>\n<p>G32命令执行完成时，不仅Z轴高度参数发生了改变，而且还会根据3D打印机的硬件配置，对热床进行相应的调平处理。</p>\n<p>G32命令会在3D打印机内存中构建一个转换矩阵（Transformation matrix），让未来3D打印机所处理的所有三维空间位置，都先经过这个矩阵的变换，保证在Z&#x3D;0的情况下，正好与热床平面完全吻合</p>\n<h4 id=\"G4-暂停移动\"><a href=\"#G4-暂停移动\" class=\"headerlink\" title=\"G4: 暂停移动\"></a>G4: 暂停移动</h4><p>让喷头在当前位置停留一段时间。参数可以为：G4 Pnnn或G4 Snnn。Pnnn表示以毫秒为单位，Snnn表示以秒为单位。</p>\n<p>G4 P2000与G4 S2完全等价，都表示停顿2秒。</p>\n<p>在停顿过程中机器仍可以被控制，如挤出头温度。</p>\n<h4 id=\"G20-使用英寸作为单位\"><a href=\"#G20-使用英寸作为单位\" class=\"headerlink\" title=\"G20:使用英寸作为单位\"></a>G20:使用英寸作为单位</h4><p>执行这条命令后，后面的命令都以英寸作为单位。</p>\n<h4 id=\"G21-使用毫米作为单位\"><a href=\"#G21-使用毫米作为单位\" class=\"headerlink\" title=\"G21: 使用毫米作为单位\"></a>G21: 使用毫米作为单位</h4><p>执行这条命令后，后面的命令都以毫米作为单位。</p>\n<h4 id=\"G90-G91：设置坐标模式\"><a href=\"#G90-G91：设置坐标模式\" class=\"headerlink\" title=\"G90&#x2F;G91：设置坐标模式\"></a>G90&#x2F;G91：设置坐标模式</h4><p>这两条命令用于设置当前坐标模式为绝对坐标模式(G90)或者相对坐标模式(G91)。没有参数。未设置时缺省值是绝对坐标模式</p>\n<h4 id=\"G92-设置当前位置为某个坐标值\"><a href=\"#G92-设置当前位置为某个坐标值\" class=\"headerlink\" title=\"G92:设置当前位置为某个坐标值\"></a>G92:设置当前位置为某个坐标值</h4><p>把当前位置设定为某个坐标值，可以用来设置零点，如果参数为空表示把当前位置设置为所有轴的的零点。</p>\n<p>如：G92 X10 E90    ;表示把当前位置设置为x&#x3D;10，喷头坐标&#x3D;90</p>\n<p>再如：G92 E0       ；表示把当前喷头坐标设置为0</p>\n<h4 id=\"G94-G95-进给速率单位\"><a href=\"#G94-G95-进给速率单位\" class=\"headerlink\" title=\"G94&#x2F;G95:进给速率单位\"></a>G94&#x2F;G95:进给速率单位</h4><p>使用了G94指令之后，所有的进给都是以mm&#x2F;min为单位，即F100指刀具每分钟移动100毫米（默认的）</p>\n<p>使用了G95指令之后，所有的进给都是以mm&#x2F;r为单位，即F100指主轴每转一转，刀具移动100毫米</p>\n<h4 id=\"G17-G18-G19：选择加工平面\"><a href=\"#G17-G18-G19：选择加工平面\" class=\"headerlink\" title=\"G17&#x2F;G18&#x2F;G19：选择加工平面\"></a>G17&#x2F;G18&#x2F;G19：选择加工平面</h4><p>G17–XY平面；</p>\n<p>G18–XZ平面；</p>\n<p>G19–YZ平面；</p>\n<h3 id=\"M指令\"><a href=\"#M指令\" class=\"headerlink\" title=\"M指令\"></a>M指令</h3><h4 id=\"M0-打印机停止\"><a href=\"#M0-打印机停止\" class=\"headerlink\" title=\"M0:打印机停止\"></a>M0:打印机停止</h4><p>打印机会终止任何动作，然后关机。所有的电机和加热器都会被关掉，这个时候只能通过reset按钮来重启控制器。</p>\n<h4 id=\"M1-打印机休眠\"><a href=\"#M1-打印机休眠\" class=\"headerlink\" title=\"M1: 打印机休眠\"></a>M1: 打印机休眠</h4><p>打印机会终止任何动作，然后休眠。所有的马达和加热器都会被关掉，但是接收到G或M命令时，打印机可以被唤醒并进入工作状态。</p>\n<h4 id=\"M17-启动所有步进电机\"><a href=\"#M17-启动所有步进电机\" class=\"headerlink\" title=\"M17:启动所有步进电机\"></a>M17:启动所有步进电机</h4><h4 id=\"M18-关闭所有步进电机\"><a href=\"#M18-关闭所有步进电机\" class=\"headerlink\" title=\"M18:关闭所有步进电机\"></a>M18:关闭所有步进电机</h4><h4 id=\"M20-读取SD卡根目录中的文件\"><a href=\"#M20-读取SD卡根目录中的文件\" class=\"headerlink\" title=\"M20:读取SD卡根目录中的文件\"></a>M20:读取SD卡根目录中的文件</h4><p>读取SD卡根目录的文件，并通过串口输出文件名。</p>\n<h4 id=\"M21-初始化SD卡\"><a href=\"#M21-初始化SD卡\" class=\"headerlink\" title=\"M21:初始化SD卡\"></a>M21:初始化SD卡</h4><p>初始化SD卡。如果在机器通电时插入SD卡，会默认初始化SD卡。开始其他SD卡功能时，SD卡一定要先初始化。本命令相当于文件系统中执行Mount动作。</p>\n<h4 id=\"M22-卸载SD卡\"><a href=\"#M22-卸载SD卡\" class=\"headerlink\" title=\"M22:卸载SD卡\"></a>M22:卸载SD卡</h4><p>卸载SD卡，也就是执行Unmount动作。没有相关的参数。</p>\n<h4 id=\"M23-选择SD卡中的文件\"><a href=\"#M23-选择SD卡中的文件\" class=\"headerlink\" title=\"M23:选择SD卡中的文件\"></a>M23:选择SD卡中的文件</h4><p>选择一个SD卡上的文件。文件选择之后，可以执行打印、删除等动作。</p>\n<p>如：M23 filename.gcode   ;选中filename.gcode文件</p>\n<h4 id=\"M24-开始打印SD卡中选中的文件\"><a href=\"#M24-开始打印SD卡中选中的文件\" class=\"headerlink\" title=\"M24:开始打印SD卡中选中的文件\"></a>M24:开始打印SD卡中选中的文件</h4><p>开始打印通过M23命令选中的文件。</p>\n<h4 id=\"M25-暂停SD卡打印\"><a href=\"#M25-暂停SD卡打印\" class=\"headerlink\" title=\"M25:暂停SD卡打印\"></a>M25:暂停SD卡打印</h4><p>暂停打印通过M23命令选定的文件。</p>\n<h4 id=\"M27-报告SD卡打印进度\"><a href=\"#M27-报告SD卡打印进度\" class=\"headerlink\" title=\"M27:报告SD卡打印进度\"></a>M27:报告SD卡打印进度</h4><p>获取SD卡打印进度。没有相关参数。</p>\n<p>M27命令的输出，格式为：SD printing byte 11518&#x2F;1127578</p>\n<p>这条命令供上位机获取当前的3D打印进度信息，用于显示在电脑界面上。</p>\n<h4 id=\"M28-开始往SD卡文件中写入数据\"><a href=\"#M28-开始往SD卡文件中写入数据\" class=\"headerlink\" title=\"M28:开始往SD卡文件中写入数据\"></a>M28:开始往SD卡文件中写入数据</h4><p>接收到此命令后，后续接收到的命令（除了M29）都会被当成数据写入该文件。</p>\n<p>命令后面会跟着文件名，如果文件不存在则会被创建，如果存在则会被覆盖。接收到这条命令后，后续接收到的命令都会被写入该文件中，直到接收到M29命令。如：M28 filename.gcode  </p>\n<h4 id=\"M29-停止往SD卡文件中写入数据\"><a href=\"#M29-停止往SD卡文件中写入数据\" class=\"headerlink\" title=\"M29:停止往SD卡文件中写入数据\"></a>M29:停止往SD卡文件中写入数据</h4><p>接收到此命令后，后续接收到的命令要开始正常执行。</p>\n<h4 id=\"M30-删除SD卡中的文件\"><a href=\"#M30-删除SD卡中的文件\" class=\"headerlink\" title=\"M30:删除SD卡中的文件\"></a>M30:删除SD卡中的文件</h4><p>如：M30 filename.gcode     ;删除filename.gcode文件</p>\n<h4 id=\"M32：创建子目录\"><a href=\"#M32：创建子目录\" class=\"headerlink\" title=\"M32：创建子目录\"></a>M32：创建子目录</h4><p>在SD卡上创建一个子目录。参数为：filename，表示待创建的子目录（包含目录名，以&#x2F;分隔）；</p>\n<h4 id=\"M82-M83：设置挤出头步进电机坐标模式\"><a href=\"#M82-M83：设置挤出头步进电机坐标模式\" class=\"headerlink\" title=\"M82&#x2F;M83：设置挤出头步进电机坐标模式\"></a>M82&#x2F;M83：设置挤出头步进电机坐标模式</h4><p>与G90&#x2F;G91命令类似，这两条命令用于设置挤出头当前坐标模式为绝对坐标模式(M82)或者相对坐标模式(M83)。没有参数。未设置时缺省值是绝对坐标模式。需要注意的是，G90&#x2F;G91设置的坐标模式，同时对XYZE四个轴起作用，但M82&#x2F;M83设置的坐标模式，只对E轴（挤出头步进电机）起作用。</p>\n<h4 id=\"M84：设置步进电机自动关闭时间\"><a href=\"#M84：设置步进电机自动关闭时间\" class=\"headerlink\" title=\"M84：设置步进电机自动关闭时间\"></a>M84：设置步进电机自动关闭时间</h4><p>当3D打印机一段时间没有接收到步进电机运动指令之后，3D打印机（为了节能）会自动关闭步进电机。使用M84指令，可以设置这个自动关闭步进电机的时间。</p>\n<p>Snnn，表示步进电机关闭的时间，以秒为单位。</p>\n<p>如果使用M85时没有指定S参数，或者使用了S0参数，则代表取消3D打印机自动关闭功能，挤出头、热床等在工作完成之后，一直会处于当前状态，而不会被自动关闭。</p>\n<h4 id=\"M73：获取当前打印进度\"><a href=\"#M73：获取当前打印进度\" class=\"headerlink\" title=\"M73：获取当前打印进度\"></a>M73：获取当前打印进度</h4><p>告诉固件当前的构建进度百分比。预计这台机器会在显示屏上显示出来。如果百分比恰好为0，则向主机发送“构建开始”通知。如果百分比恰好为100，则向主机发送“构建结束”通知。</p>\n<h4 id=\"M105-获取当前温度（单位：℃）\"><a href=\"#M105-获取当前温度（单位：℃）\" class=\"headerlink\" title=\"M105: 获取当前温度（单位：℃）\"></a>M105: 获取当前温度（单位：℃）</h4><p>获取当前温度值，包括挤出头和热床的温度。</p>\n<p>X，表示输出ADC测量的原始值；</p>\n<p>M105命令的输出，格式为：T:18.97 &#x2F;0 B:18.75 &#x2F;0 B@:0 @:0</p>\n<p>T:之后的部分，代表挤出头的当前温度&#x2F;目标温度；</p>\n<p>B:之后的部分代表热床的当前温度&#x2F;目标温度。</p>\n<p>在PID温度控制模式下，B@:后面的数字代表热床当前的输出强度，是一个0<del>255的值，@:后面的数字，代表挤出头当前的输出强度，也是一个0</del>255的值。例子中，挤出头、热床都处于关闭状态，所以这个位置的值都是0。</p>\n<h4 id=\"M104-设置挤出机（喷头）温度\"><a href=\"#M104-设置挤出机（喷头）温度\" class=\"headerlink\" title=\"M104:设置挤出机（喷头）温度\"></a>M104:设置挤出机（喷头）温度</h4><p>设置挤出头的目标温度。执行这条命令后，不需要等待达到这个温度，控制板继续执行下一条G-code语句。</p>\n<p>Snnn，表示目标温度；</p>\n<p>Tnnn，表示对应的挤出头；</p>\n<p>P，表示要等待前面的指令完成之后，再开始设置挤出头温度；</p>\n<p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。F1表示要触发；</p>\n<p>如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。</p>\n<p>如：M104 S190         ;将挤出机的温度设置为190度 </p>\n<h4 id=\"M106-打开风扇\"><a href=\"#M106-打开风扇\" class=\"headerlink\" title=\"M106: 打开风扇\"></a>M106: 打开风扇</h4><p>如：M106 S127    ;打开风扇（半速）。</p>\n<p>‘S’表示 PWM值 (0-255). 可简单理解为：风扇有0-255级强度可选，其中 M106 S0 意味着风扇将被关掉。</p>\n<p>P表示风扇的数目，P0是第一个风扇，P1是第二个风扇</p>\n<h4 id=\"M109-等待挤出头加热达到目标温度\"><a href=\"#M109-等待挤出头加热达到目标温度\" class=\"headerlink\" title=\"M109: 等待挤出头加热达到目标温度\"></a>M109: 等待挤出头加热达到目标温度</h4><p>设置挤出头的目标温度，并等待达到这个温度。</p>\n<p>Snnn，表示目标温度；</p>\n<p>Tnnn，表示对应的挤出头；</p>\n<p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。</p>\n<p>F1表示要触发；</p>\n<p>如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。如： M109 S185      ;等待挤出头加热到185度</p>\n<h4 id=\"M114-获取挤出头当前位置\"><a href=\"#M114-获取挤出头当前位置\" class=\"headerlink\" title=\"M114: 获取挤出头当前位置\"></a>M114: 获取挤出头当前位置</h4><p>输出挤出头当前位置。没有相关的参数。</p>\n<p>M114命令的输出，格式为：</p>\n<p>M114 X:20.00 Y:30.00 Z:10.000 E:0.0000</p>\n<h4 id=\"M115-获取3D打印机信息\"><a href=\"#M115-获取3D打印机信息\" class=\"headerlink\" title=\"M115: 获取3D打印机信息\"></a>M115: 获取3D打印机信息</h4><p>输出3D打印机信息。没有相关的参数。</p>\n<p>M115命令的输出，格式为：FIRMWARE_NAME:Repetier_0.92.3FIRMWARE_URL:…Printedfilament:0.00mPrintingtime:0days0hours0minSpeedMultiply:100FlowMultiply:100</p>\n<p>第一行是固件的版本信息，很长，没有列完整。第二行是已经打印了多少米耗材，打印时间是几天几小时几分钟。第三行是速度系数，参考M220命令。第四行是流率系数，参考M221命令。</p>\n<h4 id=\"M140-设置热床目标温度\"><a href=\"#M140-设置热床目标温度\" class=\"headerlink\" title=\"M140 设置热床目标温度\"></a>M140 设置热床目标温度</h4><p>设置热床的目标温度。执行这条命令后，不需要等待达到这个温度，立即开始执行下一条G-code语句。</p>\n<p>Snnn表示目标温度；</p>\n<p>Fnnn表示到达目标温度之后，是否触发蜂鸣器。</p>\n<p>F1表示要触发；</p>\n<h4 id=\"M141-设置构建平台的温度\"><a href=\"#M141-设置构建平台的温度\" class=\"headerlink\" title=\"M141:设置构建平台的温度\"></a>M141:设置构建平台的温度</h4><p>可能用于特定的温控策略或多热床系统</p>\n<p>M141 S60将加热床设置为60摄氏度</p>\n<h4 id=\"M190-等待热床加热达到目标温度\"><a href=\"#M190-等待热床加热达到目标温度\" class=\"headerlink\" title=\"M190: 等待热床加热达到目标温度\"></a>M190: 等待热床加热达到目标温度</h4><p>设置热床的目标温度，并等待达到这个温度。</p>\n<p>Snnn，表示目标温度；</p>\n<p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。</p>\n<p>F1表示要触发；</p>\n<h4 id=\"M204：设置PID参数\"><a href=\"#M204：设置PID参数\" class=\"headerlink\" title=\"M204：设置PID参数\"></a>M204：设置PID参数</h4><p>设置挤出头温度控制的PID参数，</p>\n<p>Snnn表示对应的挤出头，无S参数表示使用当前挤出头；</p>\n<p>Xnnn表示P参数；</p>\n<p>Ynnn表示I参数；</p>\n<p>Znnn表示D参数；</p>\n<h4 id=\"M220：设置速度\"><a href=\"#M220：设置速度\" class=\"headerlink\" title=\"M220：设置速度\"></a>M220：设置速度</h4><p>设置3D打印机运行速度系数。</p>\n<p>命令参数为Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；</p>\n<p>3D打印机运行速度系数，是一个在25%到500%范围内变化的值。这个系数值在3D打印机运行过程中，与切片器给出的3D打印机运动速度基础值相乘，得到最终的3D打印机实际运动速度值。</p>\n<p>M220命令的输出，格式为：SpeedMultiply:100</p>\n<h4 id=\"M221：设置流率\"><a href=\"#M221：设置流率\" class=\"headerlink\" title=\"M221：设置流率\"></a>M221：设置流率</h4><p>设置3D打印机的流率系数（Flow rate）。</p>\n<p>命令参数为：Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；</p>\n<p>3D打印机流率系数，是在上位机切片软件通过耗材直径、喷头直径、层高以及3D打印速度等因素综合计算得到的E轴运动速度的基础上，叠加的一个E轴运动速度系数。简单地说，就是控制挤出头耗材挤出量的多少。这个系数可以在25%到500%范围内变化。</p>\n<p>M221命令的输出，格式为：FlowMultiply:100</p>\n<h3 id=\"T指令\"><a href=\"#T指令\" class=\"headerlink\" title=\"T指令\"></a>T指令</h3><h4 id=\"T0-T1-T2-T3-命令，选择不同的工具或挤出机\"><a href=\"#T0-T1-T2-T3-命令，选择不同的工具或挤出机\" class=\"headerlink\" title=\"T0&#x2F;T1&#x2F;T2&#x2F;T3 命令，选择不同的工具或挤出机\"></a>T0&#x2F;T1&#x2F;T2&#x2F;T3 命令，选择不同的工具或挤出机</h4><p>T0 选择第一个挤出机；T1 选择第二个挤出机；T2 选择第三个挤出机；T3 选择第四个挤出机</p>\n<h4 id=\"节选注释\"><a href=\"#节选注释\" class=\"headerlink\" title=\"节选注释\"></a>节选注释</h4><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">M106 P2 S204    //打开第三个风扇，PWM值为<span class=\"hljs-number\">204</span><br><span class=\"hljs-comment\">;LAYER_CHANGE</span><br><span class=\"hljs-comment\">;Z:16.8</span><br><span class=\"hljs-comment\">;HEIGHT:0.199999</span><br><span class=\"hljs-comment\">;BEFORE_LAYER_CHANGE</span><br><span class=\"hljs-comment\">;16.8</span><br>G92 E0    //设置喷头当前位置为零点<br>M106 P2 S0    //关闭第二个风扇<br><br>G1 E-.<span class=\"hljs-number\">35</span> F2400  //挤出机回抽挤出<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">35m</span>m，速度设置为<span class=\"hljs-number\">2400m</span>m/min<br><span class=\"hljs-comment\">;WIPE_START</span><br>G1 F<span class=\"hljs-number\">9473.877</span>    //速度设置为<span class=\"hljs-number\">9473</span>.<span class=\"hljs-number\">877m</span>m/min<br>G1 X<span class=\"hljs-number\">320.911</span> Y<span class=\"hljs-number\">304.914</span> E-.<span class=\"hljs-number\">11658</span>    //直线插补，移动到（<span class=\"hljs-number\">320.911</span>，<span class=\"hljs-number\">304.914</span>）位置，并回抽<span class=\"hljs-number\">0.11658</span><br>G1 X<span class=\"hljs-number\">321.066</span> Y<span class=\"hljs-number\">304.753</span> E-.<span class=\"hljs-number\">03342</span>    //直线插补，移动到（<span class=\"hljs-number\">321.066</span>，<span class=\"hljs-number\">304.753</span>）位置，并回抽<span class=\"hljs-number\">0.03342</span><br><span class=\"hljs-comment\">;WIPE_END</span><br>EXCLUDE_OBJECT_END NAME=ksr_fdmtest_w4.stl_id_0_copy_0<br><span class=\"hljs-comment\">;_SET_FAN_SPEED_CHANGING_LAYER</span><br>EXCLUDE_OBJECT_START NAME=ksr_fdmtest_w4.stl_id_0_copy_0<br>G17    //选择XY平面<br>G3 Z17 I.<span class=\"hljs-number\">035</span> J-<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">216</span> P1  F30000    //圆弧插补，Z轴位置为<span class=\"hljs-number\">17m</span>m，圆心坐标为（<span class=\"hljs-number\">321.066</span>+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">035，304</span>.<span class=\"hljs-number\">753-1.216</span>）,P1表示为顺时针，速度为<span class=\"hljs-number\">30000m</span>m/min<br>G1 X43.<span class=\"hljs-number\">587</span> Y<span class=\"hljs-number\">296.746</span> Z17    //直线插补，移动到（<span class=\"hljs-number\">321.066</span>，<span class=\"hljs-number\">304.753</span>，<span class=\"hljs-number\">17</span>）位置<br>G1 Z16.<span class=\"hljs-number\">8</span>    //直线插补，移动到（<span class=\"hljs-number\">321.066</span>，<span class=\"hljs-number\">304.753</span>，<span class=\"hljs-number\">16</span>.<span class=\"hljs-number\">8</span>）位置<br>G1 E.<span class=\"hljs-number\">5</span> F2400    //挤出机挤出<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5m</span>m，速度设置为<span class=\"hljs-number\">2400m</span>m/min<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二、CNC数控编程\"><a href=\"#二、CNC数控编程\" class=\"headerlink\" title=\"二、CNC数控编程\"></a>二、CNC数控编程</h3><h4 id=\"学习资料-1\"><a href=\"#学习资料-1\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h4><p><a href=\"http://blog.hubwiz.com/2021/06/26/g-code-tutorial/\">数控机床编程入门【G-code】 | 学习软件编程 (hubwiz.com)</a></p>\n<h4 id=\"G00–快速定位\"><a href=\"#G00–快速定位\" class=\"headerlink\" title=\"G00–快速定位\"></a>G00–快速定位</h4><p>G00命令以最大速度将机器从当前位置移动到指定的坐标。机器将同时移动所有轴，以便同时完成行程。 结果是直线移动到新的位置点。</p>\n<h4 id=\"G01–线性插值\"><a href=\"#G01–线性插值\" class=\"headerlink\" title=\"G01–线性插值\"></a>G01–线性插值</h4><p>G01 命令指示机器以设定速度直线移动。我们用X、Y和Z值指定最终位置，用F值指定速度。 CNC控制器计算（插值）要经过的中间点的坐标，以获得直线。</p>\n<h4 id=\"G02–顺时针环形插值\"><a href=\"#G02–顺时针环形插值\" class=\"headerlink\" title=\"G02–顺时针环形插值\"></a>G02–顺时针环形插值</h4><p>G02命令要求机器以圆形模式顺时针移动。它与 G01 命令的概念相同，在执行适当的加工过程时使用。除了 终点参数，在这里我们还需要定义旋转中心，或弧线起点与弧线中心点的距离。起点实际上是上一个命令的 终点或当前点。</p>\n<h4 id=\"G03–逆时针环形插值\"><a href=\"#G03–逆时针环形插值\" class=\"headerlink\" title=\"G03–逆时针环形插值\"></a>G03–逆时针环形插值</h4><p>与 G02 一样，G03 命令指示机器以圆形模式移动，区别在于G03是逆时针运动。所有其他功能和规则与 G02 命令相同。</p>\n<h4 id=\"G20-G21-–-单位选择\"><a href=\"#G20-G21-–-单位选择\" class=\"headerlink\" title=\"G20&#x2F;G21 – 单位选择\"></a>G20&#x2F;G21 – 单位选择</h4><p>G20 和 G21 命令定义 G-code单位，英寸或毫米。G20 &#x3D; 英寸；G21 &#x3D; 毫米</p>\n<h4 id=\"G17-G18-G18-–-工作面选择\"><a href=\"#G17-G18-G18-–-工作面选择\" class=\"headerlink\" title=\"G17&#x2F;G18&#x2F;G18 – 工作面选择\"></a>G17&#x2F;G18&#x2F;G18 – 工作面选择</h4><p>G17–XY平面；G18–XZ平面；G19–YZ平面</p>\n<h4 id=\"G28–返回home\"><a href=\"#G28–返回home\" class=\"headerlink\" title=\"G28–返回home\"></a>G28–返回home</h4><p>G28命令要求机器将移动到其参考点或home位置。为了避免碰撞，我们可以包括一个带有 X、Y 和 Z 参数的 中间点。该工具将在转到参考点之前通过该点。</p>\n<h4 id=\"G90-G91-–-定位模式\"><a href=\"#G90-G91-–-定位模式\" class=\"headerlink\" title=\"G90&#x2F;G91 – 定位模式\"></a>G90&#x2F;G91 – 定位模式</h4><p>使用 G90 和 G91 命令，我们告诉机器如何解析坐标值。G90为绝对模式，G91为相对模式。</p>\n<h4 id=\"其他代码\"><a href=\"#其他代码\" class=\"headerlink\" title=\"其他代码\"></a>其他代码</h4><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-bullet\">- </span>M00–程序停止<br><span class=\"hljs-bullet\">- </span>M02–程序结束<br><span class=\"hljs-bullet\">- </span>M03–主轴打开–顺时针<br><span class=\"hljs-bullet\">- </span>M04–主轴打开–逆时针<br><span class=\"hljs-bullet\">- </span>M05–主轴停止<br><span class=\"hljs-bullet\">- </span>M06–工具更改<br><span class=\"hljs-bullet\">- </span>M08–启用Flood Colant<br><span class=\"hljs-bullet\">- </span>M09–禁用Flood Colant<br><span class=\"hljs-bullet\">- </span>M30 – 程序结束<br><span class=\"hljs-bullet\">- </span>M104–启动挤出加热<br><span class=\"hljs-bullet\">- </span>M109–等到挤出器到达T0<br><span class=\"hljs-bullet\">- </span>M140–开始底板加热<br><span class=\"hljs-bullet\">- </span>M190–等到底板到达T0<br><span class=\"hljs-bullet\">- </span>M106–设置风扇速度<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h4><figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">%<br>G21 G17 G90 F100                     <span class=\"hljs-comment\">//G21单位选择毫米，G17选择XY平面，G90选择绝对模式，F100代表转速</span><br>M03 S1000                            <span class=\"hljs-comment\">//主轴打开-顺时针，速度为1000转</span><br>G00 X5 Y5                 ; <span class=\"hljs-built_in\">point</span> B  <span class=\"hljs-comment\">//快速移动到（5，5）</span><br>G01 X5 Y5 Z<span class=\"hljs-number\">-1</span>             ; <span class=\"hljs-built_in\">point</span> B  <span class=\"hljs-comment\">//直线插补移动到（5，5，-1）</span><br>G01 X5 Y15 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> C  <span class=\"hljs-comment\">//直线插补移动到（5，15，-1）</span><br>G02 X9 Y19 Z<span class=\"hljs-number\">-1</span> I4 J0      ; <span class=\"hljs-built_in\">point</span> D  <span class=\"hljs-comment\">//顺时针环形插补移动到（9，19，-1），圆心为（9，15）</span><br>G01 X23 Y19 Z<span class=\"hljs-number\">-1</span>           ; <span class=\"hljs-built_in\">point</span> E  <span class=\"hljs-comment\">//直线插补移动到（23，19，-1）</span><br>G01 X32 Y5 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> F  <span class=\"hljs-comment\">//直线插补移动到（32，5，-1）</span><br>G01 X21 Y5 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> G  <span class=\"hljs-comment\">//直线插补移动到（21，5，-1）</span><br>G01 X21 Y8 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> H  <span class=\"hljs-comment\">//直线插补移动到（21，8，-1）</span><br>G03 X19 Y10 Z<span class=\"hljs-number\">-1</span> I<span class=\"hljs-number\">-2</span> J0    ; <span class=\"hljs-built_in\">point</span> I  <span class=\"hljs-comment\">//逆时针环形插补移动到（19，10，-1），圆心为（19，8）</span><br>G01 X13 Y10 Z<span class=\"hljs-number\">-1</span>           ; <span class=\"hljs-built_in\">point</span> J  <span class=\"hljs-comment\">//直线插补移动到（13，10，-1）</span><br>G03 X11 Y8 Z<span class=\"hljs-number\">-1</span> I0 J<span class=\"hljs-number\">-2</span>     ; <span class=\"hljs-built_in\">point</span> K  <span class=\"hljs-comment\">//逆时针环形插补移动到（11，8，-1），圆心为（13，8）</span><br>G01 X11 Y5 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> L  <span class=\"hljs-comment\">//直线插补移动到（11，5，-1）</span><br>G01 X5 Y5 Z<span class=\"hljs-number\">-1</span>             ; <span class=\"hljs-built_in\">point</span> B  <span class=\"hljs-comment\">//直线插补移动到（5，5，-1）</span><br>G01 X5 Y5 Z0                         <span class=\"hljs-comment\">//直线插补移动到（5，5，0）</span><br>G28  X0 Y0                           <span class=\"hljs-comment\">//返回零点（0，0，0）</span><br>M05                                  <span class=\"hljs-comment\">//关闭主轴</span><br>M30                                  <span class=\"hljs-comment\">//程序结束</span><br>%<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Gcode学习\"><a href=\"#Gcode学习\" class=\"headerlink\" title=\"Gcode学习\"></a>Gcode学习</h1><h3 id=\"一、3D打印机编程\"><a href=\"#一、3D打印机编程\" class=\"headerlink\" title=\"一、3D打印机编程\"></a>一、3D打印机编程</h3><h3 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h3><p><a href=\"https://www.klipper3d.org/zh/Overview.html\"><a href=\"https://www.klipper3d.org/zh/G-Codes.html\">G-Codes - Klipper 文档 (klipper3d.org)</a></a></p>\n<p><a href=\"https://reprap.org/wiki/G-code\">G-code - RepRap</a></p>\n<p><a href=\"https://blog.csdn.net/acktomas/article/details/125552309\">3D 打印机 G 代码命令：完整列表和教程_3d打印机g代码-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qlexcel/article/details/103466638\">3D打印机DIY之六——G代码命令_g代码m300-CSDN博客</a></p>\n<h3 id=\"G指令\"><a href=\"#G指令\" class=\"headerlink\" title=\"G指令\"></a>G指令</h3><h4 id=\"G0-G1-直线移动\"><a href=\"#G0-G1-直线移动\" class=\"headerlink\" title=\"G0&#x2F;G1: 直线移动\"></a>G0&#x2F;G1: 直线移动</h4><p>G0和G1命令完全等价，作用就是让喷头线性移动到一个特定的位置，使用时，不需要所有的参数全部存在，但至少要有一个参数。</p>\n<p>G0 Xnnn Ynnn Znnn Ennn Fnnn Snnn &#x2F; G1 Xnnn Ynnn Znnn Ennn Fnnn Snnn</p>\n<p>Xnnn表示X轴的移动位置；</p>\n<p>Ynnn表示Y轴的移动位置；</p>\n<p>Znnn表示Z轴的移动位置；</p>\n<p>Ennn表示E轴（挤出头步进电机）的移动位置；</p>\n<p>Fnnn表示移动速度，单位是毫米&#x2F;每分钟；</p>\n<p>Snnn表示是否检查限位开关，S0不检查，S1检查，缺省值是S0；</p>\n<h4 id=\"G28：复位\"><a href=\"#G28：复位\" class=\"headerlink\" title=\"G28：复位\"></a>G28：复位</h4><p>打印机复位命令。执行时会让3个轴依次往限位开关的方向运行，碰到限位开关后还会减速做一次1mm左右的往返运动，来保证复位的准确性。如果在命令后面加上坐标值，则只会复位坐标值对应的坐标轴。（坐标值的数字会被忽略）</p>\n<p>G28 X0 Y72.3</p>\n<p>只会复位x轴和y轴。</p>\n<h4 id=\"G29：Z轴高度三点测试\"><a href=\"#G29：Z轴高度三点测试\" class=\"headerlink\" title=\"G29：Z轴高度三点测试\"></a>G29：Z轴高度三点测试</h4><p>这条命令会测试打印平面上三个点的Z轴高度，并在串口上输出结果。参数为Snnn，表示对测试结果的处理方式。S1表示更新内存中的Z轴高度值（重置系统会丢失），S2表示更新内存以及EEPROM中的Z轴高度值（重置系统不会丢失）。</p>\n<p>一般来说，只有使用高位限位开关（也就是说，Z轴的限位开关位于Z轴坐标最大处），且在挤出头上附带有Z轴高度测试微动开关的机型，适合使用G29命令测试Z轴高度。其他机械配置的机型，不适合使用G29命令。G29命令由固件配置</p>\n<h4 id=\"G30：Z轴高度单点测试（单步）\"><a href=\"#G30：Z轴高度单点测试（单步）\" class=\"headerlink\" title=\"G30：Z轴高度单点测试（单步）\"></a>G30：Z轴高度单点测试（单步）</h4><p>这条命令作为一个完整Z轴高度测试过程的一步，测试打印平面上一个点的Z轴高度，并在串口上输出结果。这个完整的Z轴高度测试过程，通常是由3D打印机控制软件连续发出的，通过参数控制G30的执行状态。因此在手动工作方式下，G30命令只适合不带参数运行</p>\n<h4 id=\"G31：输出Z轴高度测试微动开关状态\"><a href=\"#G31：输出Z轴高度测试微动开关状态\" class=\"headerlink\" title=\"G31：输出Z轴高度测试微动开关状态\"></a>G31：输出Z轴高度测试微动开关状态</h4><p>执行后会输出当前Z轴高度测试微动开关的当前状态，其中L表示微动开关没有触发。如果是处于触发状态，这里会输出H。</p>\n<p>G29命令、G30命令、G31命令只进行Z轴的高度测试，并不进行自动调平。</p>\n<h4 id=\"G32：热床自动调平\"><a href=\"#G32：热床自动调平\" class=\"headerlink\" title=\"G32：热床自动调平\"></a>G32：热床自动调平</h4><p>这条命令在G29命令的基础上，不仅测试打印平面上三个点的Z轴高度，而且还会根据测试的结果，对3D打印机的机械参数进行调整，实现热床自动调平。G32命令使用的参数与G29命令是一致的：Snnn，表示测试结果的处理方式。S1表示更新内存中的相关参数值（重置系统会丢失），S2表示更新内存以及EEPROM中的相关参数值（重置系统不会丢失）。</p>\n<p>G32命令执行完成时，不仅Z轴高度参数发生了改变，而且还会根据3D打印机的硬件配置，对热床进行相应的调平处理。</p>\n<p>G32命令会在3D打印机内存中构建一个转换矩阵（Transformation matrix），让未来3D打印机所处理的所有三维空间位置，都先经过这个矩阵的变换，保证在Z&#x3D;0的情况下，正好与热床平面完全吻合</p>\n<h4 id=\"G4-暂停移动\"><a href=\"#G4-暂停移动\" class=\"headerlink\" title=\"G4: 暂停移动\"></a>G4: 暂停移动</h4><p>让喷头在当前位置停留一段时间。参数可以为：G4 Pnnn或G4 Snnn。Pnnn表示以毫秒为单位，Snnn表示以秒为单位。</p>\n<p>G4 P2000与G4 S2完全等价，都表示停顿2秒。</p>\n<p>在停顿过程中机器仍可以被控制，如挤出头温度。</p>\n<h4 id=\"G20-使用英寸作为单位\"><a href=\"#G20-使用英寸作为单位\" class=\"headerlink\" title=\"G20:使用英寸作为单位\"></a>G20:使用英寸作为单位</h4><p>执行这条命令后，后面的命令都以英寸作为单位。</p>\n<h4 id=\"G21-使用毫米作为单位\"><a href=\"#G21-使用毫米作为单位\" class=\"headerlink\" title=\"G21: 使用毫米作为单位\"></a>G21: 使用毫米作为单位</h4><p>执行这条命令后，后面的命令都以毫米作为单位。</p>\n<h4 id=\"G90-G91：设置坐标模式\"><a href=\"#G90-G91：设置坐标模式\" class=\"headerlink\" title=\"G90&#x2F;G91：设置坐标模式\"></a>G90&#x2F;G91：设置坐标模式</h4><p>这两条命令用于设置当前坐标模式为绝对坐标模式(G90)或者相对坐标模式(G91)。没有参数。未设置时缺省值是绝对坐标模式</p>\n<h4 id=\"G92-设置当前位置为某个坐标值\"><a href=\"#G92-设置当前位置为某个坐标值\" class=\"headerlink\" title=\"G92:设置当前位置为某个坐标值\"></a>G92:设置当前位置为某个坐标值</h4><p>把当前位置设定为某个坐标值，可以用来设置零点，如果参数为空表示把当前位置设置为所有轴的的零点。</p>\n<p>如：G92 X10 E90    ;表示把当前位置设置为x&#x3D;10，喷头坐标&#x3D;90</p>\n<p>再如：G92 E0       ；表示把当前喷头坐标设置为0</p>\n<h4 id=\"G94-G95-进给速率单位\"><a href=\"#G94-G95-进给速率单位\" class=\"headerlink\" title=\"G94&#x2F;G95:进给速率单位\"></a>G94&#x2F;G95:进给速率单位</h4><p>使用了G94指令之后，所有的进给都是以mm&#x2F;min为单位，即F100指刀具每分钟移动100毫米（默认的）</p>\n<p>使用了G95指令之后，所有的进给都是以mm&#x2F;r为单位，即F100指主轴每转一转，刀具移动100毫米</p>\n<h4 id=\"G17-G18-G19：选择加工平面\"><a href=\"#G17-G18-G19：选择加工平面\" class=\"headerlink\" title=\"G17&#x2F;G18&#x2F;G19：选择加工平面\"></a>G17&#x2F;G18&#x2F;G19：选择加工平面</h4><p>G17–XY平面；</p>\n<p>G18–XZ平面；</p>\n<p>G19–YZ平面；</p>\n<h3 id=\"M指令\"><a href=\"#M指令\" class=\"headerlink\" title=\"M指令\"></a>M指令</h3><h4 id=\"M0-打印机停止\"><a href=\"#M0-打印机停止\" class=\"headerlink\" title=\"M0:打印机停止\"></a>M0:打印机停止</h4><p>打印机会终止任何动作，然后关机。所有的电机和加热器都会被关掉，这个时候只能通过reset按钮来重启控制器。</p>\n<h4 id=\"M1-打印机休眠\"><a href=\"#M1-打印机休眠\" class=\"headerlink\" title=\"M1: 打印机休眠\"></a>M1: 打印机休眠</h4><p>打印机会终止任何动作，然后休眠。所有的马达和加热器都会被关掉，但是接收到G或M命令时，打印机可以被唤醒并进入工作状态。</p>\n<h4 id=\"M17-启动所有步进电机\"><a href=\"#M17-启动所有步进电机\" class=\"headerlink\" title=\"M17:启动所有步进电机\"></a>M17:启动所有步进电机</h4><h4 id=\"M18-关闭所有步进电机\"><a href=\"#M18-关闭所有步进电机\" class=\"headerlink\" title=\"M18:关闭所有步进电机\"></a>M18:关闭所有步进电机</h4><h4 id=\"M20-读取SD卡根目录中的文件\"><a href=\"#M20-读取SD卡根目录中的文件\" class=\"headerlink\" title=\"M20:读取SD卡根目录中的文件\"></a>M20:读取SD卡根目录中的文件</h4><p>读取SD卡根目录的文件，并通过串口输出文件名。</p>\n<h4 id=\"M21-初始化SD卡\"><a href=\"#M21-初始化SD卡\" class=\"headerlink\" title=\"M21:初始化SD卡\"></a>M21:初始化SD卡</h4><p>初始化SD卡。如果在机器通电时插入SD卡，会默认初始化SD卡。开始其他SD卡功能时，SD卡一定要先初始化。本命令相当于文件系统中执行Mount动作。</p>\n<h4 id=\"M22-卸载SD卡\"><a href=\"#M22-卸载SD卡\" class=\"headerlink\" title=\"M22:卸载SD卡\"></a>M22:卸载SD卡</h4><p>卸载SD卡，也就是执行Unmount动作。没有相关的参数。</p>\n<h4 id=\"M23-选择SD卡中的文件\"><a href=\"#M23-选择SD卡中的文件\" class=\"headerlink\" title=\"M23:选择SD卡中的文件\"></a>M23:选择SD卡中的文件</h4><p>选择一个SD卡上的文件。文件选择之后，可以执行打印、删除等动作。</p>\n<p>如：M23 filename.gcode   ;选中filename.gcode文件</p>\n<h4 id=\"M24-开始打印SD卡中选中的文件\"><a href=\"#M24-开始打印SD卡中选中的文件\" class=\"headerlink\" title=\"M24:开始打印SD卡中选中的文件\"></a>M24:开始打印SD卡中选中的文件</h4><p>开始打印通过M23命令选中的文件。</p>\n<h4 id=\"M25-暂停SD卡打印\"><a href=\"#M25-暂停SD卡打印\" class=\"headerlink\" title=\"M25:暂停SD卡打印\"></a>M25:暂停SD卡打印</h4><p>暂停打印通过M23命令选定的文件。</p>\n<h4 id=\"M27-报告SD卡打印进度\"><a href=\"#M27-报告SD卡打印进度\" class=\"headerlink\" title=\"M27:报告SD卡打印进度\"></a>M27:报告SD卡打印进度</h4><p>获取SD卡打印进度。没有相关参数。</p>\n<p>M27命令的输出，格式为：SD printing byte 11518&#x2F;1127578</p>\n<p>这条命令供上位机获取当前的3D打印进度信息，用于显示在电脑界面上。</p>\n<h4 id=\"M28-开始往SD卡文件中写入数据\"><a href=\"#M28-开始往SD卡文件中写入数据\" class=\"headerlink\" title=\"M28:开始往SD卡文件中写入数据\"></a>M28:开始往SD卡文件中写入数据</h4><p>接收到此命令后，后续接收到的命令（除了M29）都会被当成数据写入该文件。</p>\n<p>命令后面会跟着文件名，如果文件不存在则会被创建，如果存在则会被覆盖。接收到这条命令后，后续接收到的命令都会被写入该文件中，直到接收到M29命令。如：M28 filename.gcode  </p>\n<h4 id=\"M29-停止往SD卡文件中写入数据\"><a href=\"#M29-停止往SD卡文件中写入数据\" class=\"headerlink\" title=\"M29:停止往SD卡文件中写入数据\"></a>M29:停止往SD卡文件中写入数据</h4><p>接收到此命令后，后续接收到的命令要开始正常执行。</p>\n<h4 id=\"M30-删除SD卡中的文件\"><a href=\"#M30-删除SD卡中的文件\" class=\"headerlink\" title=\"M30:删除SD卡中的文件\"></a>M30:删除SD卡中的文件</h4><p>如：M30 filename.gcode     ;删除filename.gcode文件</p>\n<h4 id=\"M32：创建子目录\"><a href=\"#M32：创建子目录\" class=\"headerlink\" title=\"M32：创建子目录\"></a>M32：创建子目录</h4><p>在SD卡上创建一个子目录。参数为：filename，表示待创建的子目录（包含目录名，以&#x2F;分隔）；</p>\n<h4 id=\"M82-M83：设置挤出头步进电机坐标模式\"><a href=\"#M82-M83：设置挤出头步进电机坐标模式\" class=\"headerlink\" title=\"M82&#x2F;M83：设置挤出头步进电机坐标模式\"></a>M82&#x2F;M83：设置挤出头步进电机坐标模式</h4><p>与G90&#x2F;G91命令类似，这两条命令用于设置挤出头当前坐标模式为绝对坐标模式(M82)或者相对坐标模式(M83)。没有参数。未设置时缺省值是绝对坐标模式。需要注意的是，G90&#x2F;G91设置的坐标模式，同时对XYZE四个轴起作用，但M82&#x2F;M83设置的坐标模式，只对E轴（挤出头步进电机）起作用。</p>\n<h4 id=\"M84：设置步进电机自动关闭时间\"><a href=\"#M84：设置步进电机自动关闭时间\" class=\"headerlink\" title=\"M84：设置步进电机自动关闭时间\"></a>M84：设置步进电机自动关闭时间</h4><p>当3D打印机一段时间没有接收到步进电机运动指令之后，3D打印机（为了节能）会自动关闭步进电机。使用M84指令，可以设置这个自动关闭步进电机的时间。</p>\n<p>Snnn，表示步进电机关闭的时间，以秒为单位。</p>\n<p>如果使用M85时没有指定S参数，或者使用了S0参数，则代表取消3D打印机自动关闭功能，挤出头、热床等在工作完成之后，一直会处于当前状态，而不会被自动关闭。</p>\n<h4 id=\"M73：获取当前打印进度\"><a href=\"#M73：获取当前打印进度\" class=\"headerlink\" title=\"M73：获取当前打印进度\"></a>M73：获取当前打印进度</h4><p>告诉固件当前的构建进度百分比。预计这台机器会在显示屏上显示出来。如果百分比恰好为0，则向主机发送“构建开始”通知。如果百分比恰好为100，则向主机发送“构建结束”通知。</p>\n<h4 id=\"M105-获取当前温度（单位：℃）\"><a href=\"#M105-获取当前温度（单位：℃）\" class=\"headerlink\" title=\"M105: 获取当前温度（单位：℃）\"></a>M105: 获取当前温度（单位：℃）</h4><p>获取当前温度值，包括挤出头和热床的温度。</p>\n<p>X，表示输出ADC测量的原始值；</p>\n<p>M105命令的输出，格式为：T:18.97 &#x2F;0 B:18.75 &#x2F;0 B@:0 @:0</p>\n<p>T:之后的部分，代表挤出头的当前温度&#x2F;目标温度；</p>\n<p>B:之后的部分代表热床的当前温度&#x2F;目标温度。</p>\n<p>在PID温度控制模式下，B@:后面的数字代表热床当前的输出强度，是一个0<del>255的值，@:后面的数字，代表挤出头当前的输出强度，也是一个0</del>255的值。例子中，挤出头、热床都处于关闭状态，所以这个位置的值都是0。</p>\n<h4 id=\"M104-设置挤出机（喷头）温度\"><a href=\"#M104-设置挤出机（喷头）温度\" class=\"headerlink\" title=\"M104:设置挤出机（喷头）温度\"></a>M104:设置挤出机（喷头）温度</h4><p>设置挤出头的目标温度。执行这条命令后，不需要等待达到这个温度，控制板继续执行下一条G-code语句。</p>\n<p>Snnn，表示目标温度；</p>\n<p>Tnnn，表示对应的挤出头；</p>\n<p>P，表示要等待前面的指令完成之后，再开始设置挤出头温度；</p>\n<p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。F1表示要触发；</p>\n<p>如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。</p>\n<p>如：M104 S190         ;将挤出机的温度设置为190度 </p>\n<h4 id=\"M106-打开风扇\"><a href=\"#M106-打开风扇\" class=\"headerlink\" title=\"M106: 打开风扇\"></a>M106: 打开风扇</h4><p>如：M106 S127    ;打开风扇（半速）。</p>\n<p>‘S’表示 PWM值 (0-255). 可简单理解为：风扇有0-255级强度可选，其中 M106 S0 意味着风扇将被关掉。</p>\n<p>P表示风扇的数目，P0是第一个风扇，P1是第二个风扇</p>\n<h4 id=\"M109-等待挤出头加热达到目标温度\"><a href=\"#M109-等待挤出头加热达到目标温度\" class=\"headerlink\" title=\"M109: 等待挤出头加热达到目标温度\"></a>M109: 等待挤出头加热达到目标温度</h4><p>设置挤出头的目标温度，并等待达到这个温度。</p>\n<p>Snnn，表示目标温度；</p>\n<p>Tnnn，表示对应的挤出头；</p>\n<p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。</p>\n<p>F1表示要触发；</p>\n<p>如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。如： M109 S185      ;等待挤出头加热到185度</p>\n<h4 id=\"M114-获取挤出头当前位置\"><a href=\"#M114-获取挤出头当前位置\" class=\"headerlink\" title=\"M114: 获取挤出头当前位置\"></a>M114: 获取挤出头当前位置</h4><p>输出挤出头当前位置。没有相关的参数。</p>\n<p>M114命令的输出，格式为：</p>\n<p>M114 X:20.00 Y:30.00 Z:10.000 E:0.0000</p>\n<h4 id=\"M115-获取3D打印机信息\"><a href=\"#M115-获取3D打印机信息\" class=\"headerlink\" title=\"M115: 获取3D打印机信息\"></a>M115: 获取3D打印机信息</h4><p>输出3D打印机信息。没有相关的参数。</p>\n<p>M115命令的输出，格式为：FIRMWARE_NAME:Repetier_0.92.3FIRMWARE_URL:…Printedfilament:0.00mPrintingtime:0days0hours0minSpeedMultiply:100FlowMultiply:100</p>\n<p>第一行是固件的版本信息，很长，没有列完整。第二行是已经打印了多少米耗材，打印时间是几天几小时几分钟。第三行是速度系数，参考M220命令。第四行是流率系数，参考M221命令。</p>\n<h4 id=\"M140-设置热床目标温度\"><a href=\"#M140-设置热床目标温度\" class=\"headerlink\" title=\"M140 设置热床目标温度\"></a>M140 设置热床目标温度</h4><p>设置热床的目标温度。执行这条命令后，不需要等待达到这个温度，立即开始执行下一条G-code语句。</p>\n<p>Snnn表示目标温度；</p>\n<p>Fnnn表示到达目标温度之后，是否触发蜂鸣器。</p>\n<p>F1表示要触发；</p>\n<h4 id=\"M141-设置构建平台的温度\"><a href=\"#M141-设置构建平台的温度\" class=\"headerlink\" title=\"M141:设置构建平台的温度\"></a>M141:设置构建平台的温度</h4><p>可能用于特定的温控策略或多热床系统</p>\n<p>M141 S60将加热床设置为60摄氏度</p>\n<h4 id=\"M190-等待热床加热达到目标温度\"><a href=\"#M190-等待热床加热达到目标温度\" class=\"headerlink\" title=\"M190: 等待热床加热达到目标温度\"></a>M190: 等待热床加热达到目标温度</h4><p>设置热床的目标温度，并等待达到这个温度。</p>\n<p>Snnn，表示目标温度；</p>\n<p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。</p>\n<p>F1表示要触发；</p>\n<h4 id=\"M204：设置PID参数\"><a href=\"#M204：设置PID参数\" class=\"headerlink\" title=\"M204：设置PID参数\"></a>M204：设置PID参数</h4><p>设置挤出头温度控制的PID参数，</p>\n<p>Snnn表示对应的挤出头，无S参数表示使用当前挤出头；</p>\n<p>Xnnn表示P参数；</p>\n<p>Ynnn表示I参数；</p>\n<p>Znnn表示D参数；</p>\n<h4 id=\"M220：设置速度\"><a href=\"#M220：设置速度\" class=\"headerlink\" title=\"M220：设置速度\"></a>M220：设置速度</h4><p>设置3D打印机运行速度系数。</p>\n<p>命令参数为Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；</p>\n<p>3D打印机运行速度系数，是一个在25%到500%范围内变化的值。这个系数值在3D打印机运行过程中，与切片器给出的3D打印机运动速度基础值相乘，得到最终的3D打印机实际运动速度值。</p>\n<p>M220命令的输出，格式为：SpeedMultiply:100</p>\n<h4 id=\"M221：设置流率\"><a href=\"#M221：设置流率\" class=\"headerlink\" title=\"M221：设置流率\"></a>M221：设置流率</h4><p>设置3D打印机的流率系数（Flow rate）。</p>\n<p>命令参数为：Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；</p>\n<p>3D打印机流率系数，是在上位机切片软件通过耗材直径、喷头直径、层高以及3D打印速度等因素综合计算得到的E轴运动速度的基础上，叠加的一个E轴运动速度系数。简单地说，就是控制挤出头耗材挤出量的多少。这个系数可以在25%到500%范围内变化。</p>\n<p>M221命令的输出，格式为：FlowMultiply:100</p>\n<h3 id=\"T指令\"><a href=\"#T指令\" class=\"headerlink\" title=\"T指令\"></a>T指令</h3><h4 id=\"T0-T1-T2-T3-命令，选择不同的工具或挤出机\"><a href=\"#T0-T1-T2-T3-命令，选择不同的工具或挤出机\" class=\"headerlink\" title=\"T0&#x2F;T1&#x2F;T2&#x2F;T3 命令，选择不同的工具或挤出机\"></a>T0&#x2F;T1&#x2F;T2&#x2F;T3 命令，选择不同的工具或挤出机</h4><p>T0 选择第一个挤出机；T1 选择第二个挤出机；T2 选择第三个挤出机；T3 选择第四个挤出机</p>\n<h4 id=\"节选注释\"><a href=\"#节选注释\" class=\"headerlink\" title=\"节选注释\"></a>节选注释</h4><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">M106 P2 S204    //打开第三个风扇，PWM值为<span class=\"hljs-number\">204</span><br><span class=\"hljs-comment\">;LAYER_CHANGE</span><br><span class=\"hljs-comment\">;Z:16.8</span><br><span class=\"hljs-comment\">;HEIGHT:0.199999</span><br><span class=\"hljs-comment\">;BEFORE_LAYER_CHANGE</span><br><span class=\"hljs-comment\">;16.8</span><br>G92 E0    //设置喷头当前位置为零点<br>M106 P2 S0    //关闭第二个风扇<br><br>G1 E-.<span class=\"hljs-number\">35</span> F2400  //挤出机回抽挤出<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">35m</span>m，速度设置为<span class=\"hljs-number\">2400m</span>m/min<br><span class=\"hljs-comment\">;WIPE_START</span><br>G1 F<span class=\"hljs-number\">9473.877</span>    //速度设置为<span class=\"hljs-number\">9473</span>.<span class=\"hljs-number\">877m</span>m/min<br>G1 X<span class=\"hljs-number\">320.911</span> Y<span class=\"hljs-number\">304.914</span> E-.<span class=\"hljs-number\">11658</span>    //直线插补，移动到（<span class=\"hljs-number\">320.911</span>，<span class=\"hljs-number\">304.914</span>）位置，并回抽<span class=\"hljs-number\">0.11658</span><br>G1 X<span class=\"hljs-number\">321.066</span> Y<span class=\"hljs-number\">304.753</span> E-.<span class=\"hljs-number\">03342</span>    //直线插补，移动到（<span class=\"hljs-number\">321.066</span>，<span class=\"hljs-number\">304.753</span>）位置，并回抽<span class=\"hljs-number\">0.03342</span><br><span class=\"hljs-comment\">;WIPE_END</span><br>EXCLUDE_OBJECT_END NAME=ksr_fdmtest_w4.stl_id_0_copy_0<br><span class=\"hljs-comment\">;_SET_FAN_SPEED_CHANGING_LAYER</span><br>EXCLUDE_OBJECT_START NAME=ksr_fdmtest_w4.stl_id_0_copy_0<br>G17    //选择XY平面<br>G3 Z17 I.<span class=\"hljs-number\">035</span> J-<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">216</span> P1  F30000    //圆弧插补，Z轴位置为<span class=\"hljs-number\">17m</span>m，圆心坐标为（<span class=\"hljs-number\">321.066</span>+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">035，304</span>.<span class=\"hljs-number\">753-1.216</span>）,P1表示为顺时针，速度为<span class=\"hljs-number\">30000m</span>m/min<br>G1 X43.<span class=\"hljs-number\">587</span> Y<span class=\"hljs-number\">296.746</span> Z17    //直线插补，移动到（<span class=\"hljs-number\">321.066</span>，<span class=\"hljs-number\">304.753</span>，<span class=\"hljs-number\">17</span>）位置<br>G1 Z16.<span class=\"hljs-number\">8</span>    //直线插补，移动到（<span class=\"hljs-number\">321.066</span>，<span class=\"hljs-number\">304.753</span>，<span class=\"hljs-number\">16</span>.<span class=\"hljs-number\">8</span>）位置<br>G1 E.<span class=\"hljs-number\">5</span> F2400    //挤出机挤出<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5m</span>m，速度设置为<span class=\"hljs-number\">2400m</span>m/min<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二、CNC数控编程\"><a href=\"#二、CNC数控编程\" class=\"headerlink\" title=\"二、CNC数控编程\"></a>二、CNC数控编程</h3><h4 id=\"学习资料-1\"><a href=\"#学习资料-1\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h4><p><a href=\"http://blog.hubwiz.com/2021/06/26/g-code-tutorial/\">数控机床编程入门【G-code】 | 学习软件编程 (hubwiz.com)</a></p>\n<h4 id=\"G00–快速定位\"><a href=\"#G00–快速定位\" class=\"headerlink\" title=\"G00–快速定位\"></a>G00–快速定位</h4><p>G00命令以最大速度将机器从当前位置移动到指定的坐标。机器将同时移动所有轴，以便同时完成行程。 结果是直线移动到新的位置点。</p>\n<h4 id=\"G01–线性插值\"><a href=\"#G01–线性插值\" class=\"headerlink\" title=\"G01–线性插值\"></a>G01–线性插值</h4><p>G01 命令指示机器以设定速度直线移动。我们用X、Y和Z值指定最终位置，用F值指定速度。 CNC控制器计算（插值）要经过的中间点的坐标，以获得直线。</p>\n<h4 id=\"G02–顺时针环形插值\"><a href=\"#G02–顺时针环形插值\" class=\"headerlink\" title=\"G02–顺时针环形插值\"></a>G02–顺时针环形插值</h4><p>G02命令要求机器以圆形模式顺时针移动。它与 G01 命令的概念相同，在执行适当的加工过程时使用。除了 终点参数，在这里我们还需要定义旋转中心，或弧线起点与弧线中心点的距离。起点实际上是上一个命令的 终点或当前点。</p>\n<h4 id=\"G03–逆时针环形插值\"><a href=\"#G03–逆时针环形插值\" class=\"headerlink\" title=\"G03–逆时针环形插值\"></a>G03–逆时针环形插值</h4><p>与 G02 一样，G03 命令指示机器以圆形模式移动，区别在于G03是逆时针运动。所有其他功能和规则与 G02 命令相同。</p>\n<h4 id=\"G20-G21-–-单位选择\"><a href=\"#G20-G21-–-单位选择\" class=\"headerlink\" title=\"G20&#x2F;G21 – 单位选择\"></a>G20&#x2F;G21 – 单位选择</h4><p>G20 和 G21 命令定义 G-code单位，英寸或毫米。G20 &#x3D; 英寸；G21 &#x3D; 毫米</p>\n<h4 id=\"G17-G18-G18-–-工作面选择\"><a href=\"#G17-G18-G18-–-工作面选择\" class=\"headerlink\" title=\"G17&#x2F;G18&#x2F;G18 – 工作面选择\"></a>G17&#x2F;G18&#x2F;G18 – 工作面选择</h4><p>G17–XY平面；G18–XZ平面；G19–YZ平面</p>\n<h4 id=\"G28–返回home\"><a href=\"#G28–返回home\" class=\"headerlink\" title=\"G28–返回home\"></a>G28–返回home</h4><p>G28命令要求机器将移动到其参考点或home位置。为了避免碰撞，我们可以包括一个带有 X、Y 和 Z 参数的 中间点。该工具将在转到参考点之前通过该点。</p>\n<h4 id=\"G90-G91-–-定位模式\"><a href=\"#G90-G91-–-定位模式\" class=\"headerlink\" title=\"G90&#x2F;G91 – 定位模式\"></a>G90&#x2F;G91 – 定位模式</h4><p>使用 G90 和 G91 命令，我们告诉机器如何解析坐标值。G90为绝对模式，G91为相对模式。</p>\n<h4 id=\"其他代码\"><a href=\"#其他代码\" class=\"headerlink\" title=\"其他代码\"></a>其他代码</h4><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-bullet\">- </span>M00–程序停止<br><span class=\"hljs-bullet\">- </span>M02–程序结束<br><span class=\"hljs-bullet\">- </span>M03–主轴打开–顺时针<br><span class=\"hljs-bullet\">- </span>M04–主轴打开–逆时针<br><span class=\"hljs-bullet\">- </span>M05–主轴停止<br><span class=\"hljs-bullet\">- </span>M06–工具更改<br><span class=\"hljs-bullet\">- </span>M08–启用Flood Colant<br><span class=\"hljs-bullet\">- </span>M09–禁用Flood Colant<br><span class=\"hljs-bullet\">- </span>M30 – 程序结束<br><span class=\"hljs-bullet\">- </span>M104–启动挤出加热<br><span class=\"hljs-bullet\">- </span>M109–等到挤出器到达T0<br><span class=\"hljs-bullet\">- </span>M140–开始底板加热<br><span class=\"hljs-bullet\">- </span>M190–等到底板到达T0<br><span class=\"hljs-bullet\">- </span>M106–设置风扇速度<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h4><figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">%<br>G21 G17 G90 F100                     <span class=\"hljs-comment\">//G21单位选择毫米，G17选择XY平面，G90选择绝对模式，F100代表转速</span><br>M03 S1000                            <span class=\"hljs-comment\">//主轴打开-顺时针，速度为1000转</span><br>G00 X5 Y5                 ; <span class=\"hljs-built_in\">point</span> B  <span class=\"hljs-comment\">//快速移动到（5，5）</span><br>G01 X5 Y5 Z<span class=\"hljs-number\">-1</span>             ; <span class=\"hljs-built_in\">point</span> B  <span class=\"hljs-comment\">//直线插补移动到（5，5，-1）</span><br>G01 X5 Y15 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> C  <span class=\"hljs-comment\">//直线插补移动到（5，15，-1）</span><br>G02 X9 Y19 Z<span class=\"hljs-number\">-1</span> I4 J0      ; <span class=\"hljs-built_in\">point</span> D  <span class=\"hljs-comment\">//顺时针环形插补移动到（9，19，-1），圆心为（9，15）</span><br>G01 X23 Y19 Z<span class=\"hljs-number\">-1</span>           ; <span class=\"hljs-built_in\">point</span> E  <span class=\"hljs-comment\">//直线插补移动到（23，19，-1）</span><br>G01 X32 Y5 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> F  <span class=\"hljs-comment\">//直线插补移动到（32，5，-1）</span><br>G01 X21 Y5 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> G  <span class=\"hljs-comment\">//直线插补移动到（21，5，-1）</span><br>G01 X21 Y8 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> H  <span class=\"hljs-comment\">//直线插补移动到（21，8，-1）</span><br>G03 X19 Y10 Z<span class=\"hljs-number\">-1</span> I<span class=\"hljs-number\">-2</span> J0    ; <span class=\"hljs-built_in\">point</span> I  <span class=\"hljs-comment\">//逆时针环形插补移动到（19，10，-1），圆心为（19，8）</span><br>G01 X13 Y10 Z<span class=\"hljs-number\">-1</span>           ; <span class=\"hljs-built_in\">point</span> J  <span class=\"hljs-comment\">//直线插补移动到（13，10，-1）</span><br>G03 X11 Y8 Z<span class=\"hljs-number\">-1</span> I0 J<span class=\"hljs-number\">-2</span>     ; <span class=\"hljs-built_in\">point</span> K  <span class=\"hljs-comment\">//逆时针环形插补移动到（11，8，-1），圆心为（13，8）</span><br>G01 X11 Y5 Z<span class=\"hljs-number\">-1</span>            ; <span class=\"hljs-built_in\">point</span> L  <span class=\"hljs-comment\">//直线插补移动到（11，5，-1）</span><br>G01 X5 Y5 Z<span class=\"hljs-number\">-1</span>             ; <span class=\"hljs-built_in\">point</span> B  <span class=\"hljs-comment\">//直线插补移动到（5，5，-1）</span><br>G01 X5 Y5 Z0                         <span class=\"hljs-comment\">//直线插补移动到（5，5，0）</span><br>G28  X0 Y0                           <span class=\"hljs-comment\">//返回零点（0，0，0）</span><br>M05                                  <span class=\"hljs-comment\">//关闭主轴</span><br>M30                                  <span class=\"hljs-comment\">//程序结束</span><br>%<br></code></pre></td></tr></table></figure>\n"},{"title":"STM32程序逻辑及GPIO使用","date":"2024-07-09T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/aexKkm4IUZCT2DP.png","_content":"\n# STM32程序逻辑及GPIO使用\n\n## 程序逻辑\n\n#### 1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件\n\n#### bsp_led.c\n\n主要用来构建所需程序的函数体（比如配置、驱动等等）\n\n#include \"bsp_led.h\"用来调用各种东西\n\n#### bsp_led.h\n\n主要用来给bsp_led.c文件提供库函数支持\n\n以及bsp_led.c所需的宏定义，都可以放在该文件夹中\n\n将bsp_led.c中的函数放入\n\n采用#ifndef和#endif的方式，实现头文件的判断编译，防止多次编译报错\n\n```\n#ifndef __BSP_LED_H\n#define __BSP_LED_H\n\n#include \"stm32f10x.h\"\n\n#define GPIO_G_PIN         GPIO_Pin_0\n#define GPIO_G_PORT        GPIOB\n#define GPIO_G_CLK         RCC_APB2Periph_GPIOB\n\nvoid delay(uint32_t count);\nvoid LED_GPIO_Config(void);\n\n#endif /* __BSP_LED_H */\n```\n\n#### 2.在主函数中调用#include \"bsp_led.h\"即可使用bsp_led.c中编写的各类函数\n\n## GPIO设置\n\n```\n//定义关键字\nGPIO_InitTypeDef  GPIO_InitStruct;\n\n//选择引脚，将硬件部分定义成宏，方便移植\n#define GPIO_G_PIN         GPIO_Pin_0\nGPIO_InitStruct.GPIO_Pin = GPIO_G_PIN;\n\n//选择输出方式\nGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\n\n//选择速度\nGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\n\n//配置引脚\nGPIO_Init(GPIO_G_PORT,&GPIO_InitStruct);\n\n//启动时钟\nRCC_APB2PeriphClockCmd(GPIO_G_CLK, ENABLE);\n```\n","source":"_posts/STM32程序逻辑及GPIO使用.md","raw":"---\ntitle: STM32程序逻辑及GPIO使用\ntag: GPIO\ndate: 2024-07-10\ncategories: STM32\nindex_img: https://s2.loli.net/2024/07/31/aexKkm4IUZCT2DP.png\n---\n\n# STM32程序逻辑及GPIO使用\n\n## 程序逻辑\n\n#### 1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件\n\n#### bsp_led.c\n\n主要用来构建所需程序的函数体（比如配置、驱动等等）\n\n#include \"bsp_led.h\"用来调用各种东西\n\n#### bsp_led.h\n\n主要用来给bsp_led.c文件提供库函数支持\n\n以及bsp_led.c所需的宏定义，都可以放在该文件夹中\n\n将bsp_led.c中的函数放入\n\n采用#ifndef和#endif的方式，实现头文件的判断编译，防止多次编译报错\n\n```\n#ifndef __BSP_LED_H\n#define __BSP_LED_H\n\n#include \"stm32f10x.h\"\n\n#define GPIO_G_PIN         GPIO_Pin_0\n#define GPIO_G_PORT        GPIOB\n#define GPIO_G_CLK         RCC_APB2Periph_GPIOB\n\nvoid delay(uint32_t count);\nvoid LED_GPIO_Config(void);\n\n#endif /* __BSP_LED_H */\n```\n\n#### 2.在主函数中调用#include \"bsp_led.h\"即可使用bsp_led.c中编写的各类函数\n\n## GPIO设置\n\n```\n//定义关键字\nGPIO_InitTypeDef  GPIO_InitStruct;\n\n//选择引脚，将硬件部分定义成宏，方便移植\n#define GPIO_G_PIN         GPIO_Pin_0\nGPIO_InitStruct.GPIO_Pin = GPIO_G_PIN;\n\n//选择输出方式\nGPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\n\n//选择速度\nGPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\n\n//配置引脚\nGPIO_Init(GPIO_G_PORT,&GPIO_InitStruct);\n\n//启动时钟\nRCC_APB2PeriphClockCmd(GPIO_G_CLK, ENABLE);\n```\n","slug":"STM32程序逻辑及GPIO使用","published":1,"updated":"2024-07-31T03:45:29.577Z","_id":"clz9aaxqh0013ygfb4xoogc9a","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"STM32程序逻辑及GPIO使用\"><a href=\"#STM32程序逻辑及GPIO使用\" class=\"headerlink\" title=\"STM32程序逻辑及GPIO使用\"></a>STM32程序逻辑及GPIO使用</h1><h2 id=\"程序逻辑\"><a href=\"#程序逻辑\" class=\"headerlink\" title=\"程序逻辑\"></a>程序逻辑</h2><h4 id=\"1-创建在USER文件夹中创建想要的文件夹，例如bsp-led，主要用来存放C文件和h文件\"><a href=\"#1-创建在USER文件夹中创建想要的文件夹，例如bsp-led，主要用来存放C文件和h文件\" class=\"headerlink\" title=\"1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件\"></a>1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件</h4><h4 id=\"bsp-led-c\"><a href=\"#bsp-led-c\" class=\"headerlink\" title=\"bsp_led.c\"></a>bsp_led.c</h4><p>主要用来构建所需程序的函数体（比如配置、驱动等等）</p>\n<p>#include “bsp_led.h”用来调用各种东西</p>\n<h4 id=\"bsp-led-h\"><a href=\"#bsp-led-h\" class=\"headerlink\" title=\"bsp_led.h\"></a>bsp_led.h</h4><p>主要用来给bsp_led.c文件提供库函数支持</p>\n<p>以及bsp_led.c所需的宏定义，都可以放在该文件夹中</p>\n<p>将bsp_led.c中的函数放入</p>\n<p>采用#ifndef和#endif的方式，实现头文件的判断编译，防止多次编译报错</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> __BSP_LED_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __BSP_LED_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stm32f10x.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_PIN         GPIO_Pin_0</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_PORT        GPIOB</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_CLK         RCC_APB2Periph_GPIOB</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delay</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> count)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">LED_GPIO_Config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* __BSP_LED_H */</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-在主函数中调用-include-“bsp-led-h”即可使用bsp-led-c中编写的各类函数\"><a href=\"#2-在主函数中调用-include-“bsp-led-h”即可使用bsp-led-c中编写的各类函数\" class=\"headerlink\" title=\"2.在主函数中调用#include “bsp_led.h”即可使用bsp_led.c中编写的各类函数\"></a>2.在主函数中调用#include “bsp_led.h”即可使用bsp_led.c中编写的各类函数</h4><h2 id=\"GPIO设置\"><a href=\"#GPIO设置\" class=\"headerlink\" title=\"GPIO设置\"></a>GPIO设置</h2><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-comment\">//定义关键字</span><br>GPIO_InitTypeDef  GPIO_InitS<span class=\"hljs-attr\">truct</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//选择引脚，将硬件部分定义成宏，方便移植</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_PIN         GPIO_Pin_0</span><br>GPIO_InitStruct.GPIO_P<span class=\"hljs-attr\">in</span> <span class=\"hljs-operator\">=</span> GPIO_G_PIN<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//选择输出方式</span><br>GPIO_InitStruct.GPIO_M<span class=\"hljs-attr\">ode</span> <span class=\"hljs-operator\">=</span> GPIO_Mode_Out_PP<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//选择速度</span><br>GPIO_InitStruct.GPIO_S<span class=\"hljs-attr\">peed</span> <span class=\"hljs-operator\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//配置引脚</span><br>GPIO_Init(GPIO_G_PORT,<span class=\"hljs-variable\">&amp;</span>GPIO_InitStruct)<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//启动时钟</span><br>RCC_APB2PeriphClockCmd(GPIO_G_CLK, ENABLE)<span class=\"hljs-punctuation\">;</span><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"STM32程序逻辑及GPIO使用\"><a href=\"#STM32程序逻辑及GPIO使用\" class=\"headerlink\" title=\"STM32程序逻辑及GPIO使用\"></a>STM32程序逻辑及GPIO使用</h1><h2 id=\"程序逻辑\"><a href=\"#程序逻辑\" class=\"headerlink\" title=\"程序逻辑\"></a>程序逻辑</h2><h4 id=\"1-创建在USER文件夹中创建想要的文件夹，例如bsp-led，主要用来存放C文件和h文件\"><a href=\"#1-创建在USER文件夹中创建想要的文件夹，例如bsp-led，主要用来存放C文件和h文件\" class=\"headerlink\" title=\"1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件\"></a>1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件</h4><h4 id=\"bsp-led-c\"><a href=\"#bsp-led-c\" class=\"headerlink\" title=\"bsp_led.c\"></a>bsp_led.c</h4><p>主要用来构建所需程序的函数体（比如配置、驱动等等）</p>\n<p>#include “bsp_led.h”用来调用各种东西</p>\n<h4 id=\"bsp-led-h\"><a href=\"#bsp-led-h\" class=\"headerlink\" title=\"bsp_led.h\"></a>bsp_led.h</h4><p>主要用来给bsp_led.c文件提供库函数支持</p>\n<p>以及bsp_led.c所需的宏定义，都可以放在该文件夹中</p>\n<p>将bsp_led.c中的函数放入</p>\n<p>采用#ifndef和#endif的方式，实现头文件的判断编译，防止多次编译报错</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> __BSP_LED_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __BSP_LED_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stm32f10x.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_PIN         GPIO_Pin_0</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_PORT        GPIOB</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_CLK         RCC_APB2Periph_GPIOB</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delay</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint32_t</span> count)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">LED_GPIO_Config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* __BSP_LED_H */</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-在主函数中调用-include-“bsp-led-h”即可使用bsp-led-c中编写的各类函数\"><a href=\"#2-在主函数中调用-include-“bsp-led-h”即可使用bsp-led-c中编写的各类函数\" class=\"headerlink\" title=\"2.在主函数中调用#include “bsp_led.h”即可使用bsp_led.c中编写的各类函数\"></a>2.在主函数中调用#include “bsp_led.h”即可使用bsp_led.c中编写的各类函数</h4><h2 id=\"GPIO设置\"><a href=\"#GPIO设置\" class=\"headerlink\" title=\"GPIO设置\"></a>GPIO设置</h2><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-comment\">//定义关键字</span><br>GPIO_InitTypeDef  GPIO_InitS<span class=\"hljs-attr\">truct</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//选择引脚，将硬件部分定义成宏，方便移植</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> GPIO_G_PIN         GPIO_Pin_0</span><br>GPIO_InitStruct.GPIO_P<span class=\"hljs-attr\">in</span> <span class=\"hljs-operator\">=</span> GPIO_G_PIN<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//选择输出方式</span><br>GPIO_InitStruct.GPIO_M<span class=\"hljs-attr\">ode</span> <span class=\"hljs-operator\">=</span> GPIO_Mode_Out_PP<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//选择速度</span><br>GPIO_InitStruct.GPIO_S<span class=\"hljs-attr\">peed</span> <span class=\"hljs-operator\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//配置引脚</span><br>GPIO_Init(GPIO_G_PORT,<span class=\"hljs-variable\">&amp;</span>GPIO_InitStruct)<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//启动时钟</span><br>RCC_APB2PeriphClockCmd(GPIO_G_CLK, ENABLE)<span class=\"hljs-punctuation\">;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"3D打印机运行逻辑","date":"2024-07-25T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/hRrLCWXmb3HwpID.png","_content":"\n# 3D打印机运行逻辑\n\n### 打印机初始化\n\n1.获取机器，连接网络，并且在设置里面打开root权限，获得root的账号和密码\n\n```\nroot  //账号\nroot  //密码\n```\n\n2.需要获取机器的IP地址，然后用mobaxtem的ssh进行连接，连接时输入IP地址和账号\n\n```\n172.xx.xxx.xx  //IP地址\n```\n\n3.拷贝所需的文件夹进行安装\n\n```\ncp /tmp/udisk/sda1/fluidd/fluidd.sh /usr/data  //拷贝脚本文件\ncp /tmp/udisk/sda1/fluidd/fluidd.tar /usr/data  //拷贝配置文件\n\t\ncd /usr/data  //进入该文件夹下\n\t\n./fluidd.sh install  //执行安装指令\n```\n\n4.等待结束，即可登录fluidd网站\n\n```\n172.xx.xxx.xx:4408  //fluidd的网址\n```\n\n### 打印机操作\n\nSET_VELOCITY_LIMIT 改变打印机配置文件中指定的速度限制。\n\n```\nSET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] [MINIMUM_CRUISE_RATIO=<value>] [SQUARE_CORNER_VELOCITY=<value>]\n\n[VELOCITY=<value>]  //速度\n[ACCEL=<value>]  //加速度\n[MINIMUM_CRUISE_RATIO=<value>]  //最小巡航速度\n[SQUARE_CORNER_VELOCITY=<value>]  //角速度\n[ACCEL_TO_DECEL]  //加速减速\n```\n\n3D打印机Z轴正值是向下，负值是向上\n\n```\nG1 Z1  //K1-MAX向下位移1mm\nG1 Z-.5  //K1-MAX向上位移到-0.5mm\n```\n\n3D打印机X轴正值是向右，负值是向左\n\n```\nG1 X1  //K1-MAX向右位移1mm\nG1 X-.5  //K1-MAX向左位移到-0.5mm\n```\n\n3D打印机X轴正值是向后，负值是向前\n\n```\nG1 X1  //K1-MAX向后位移1mm\nG1 X-.5  //K1-MAX向前位移到-0.5mm\n```\n\nEXCLUDE_OBJECT_START 表示当前层上一个对象的gcode开始\n\nEXCLUDE_OBJECT_END 表示对象在该层的代码的结束\n\n```\nEXCLUDE_OBJECT_START NAME=对象名称\nEXCLUDE_OBJECT_END [NAME=对象名称]\n```\n\nEXCLUDE_OBJECT_DEFINE\n\n```\nEXCLUDE_OBJECT_DEFINE [NAME =对象名称[中心= X, Y][多边形= [(X, Y),……[reset =1] [json =1]  //提供文件中一个对象的摘要。\n//如果没有提供参数，这将列出Klipper已知的已定义对象。返回字符串列表，除非给出了JSON参数，否则它将以JSON格式返回对象详细信息。\n\n<NAME>  //当包含NAME参数时，将定义要排除的对象。\n\n<CENTER>  //对象的 X，Y 坐标。\n\n<POLYGON>  //提供对象轮廓的 X,Y 坐标数组\n\n//当提供RESET参数时，将清除所有已定义的对象，并重置[exclude_object]模块。\n```\n\n### G-code 打印流程\n\n```\n//这个干嘛没搞明白\nEXCLUDE_OBJECT_DEFINE  NAME=Square_columns_Z_axis.stl_id_0_copy_0 CENTER=163.166,143.573 POLYGON=[[58.702,39.1091],[267.631,39.1091],[267.631,248.038],[58.702,248.038],[58.702,39.1091]]\n\n//报告当前进度给控制器，P0是进度为0%，R1210是当前设定的剩余时间\nM73 P0 R1210\n\n//关闭P0风扇，没有P参数，默认P0，S代表风扇的模拟量为0，范围是0~255，\nM106 S0\n\n//关闭P2风扇\nM106 P2 S0\n\n//关闭热床温度，不进行等待\nM140 S0\n\n//关闭喷头温度，不进行等待，继续执行\nM104 S0 \n\n//执行宏定义，在gcode_macro.cfg配置文件中有宏定义函数，作用为开始打印，对打印机进行自动，调节热床和喷头温度\nSTART_PRINT EXTRUDER_TEMP=220 BED_TEMP=50\n\n//设定机箱温度为35摄氏度\nM141 S35\n\n//将打印机三轴设为绝对坐标系\nG90\n\n//设置移动单位为毫米\nG21\n\n//设置挤出头为绝对坐标系\nM83\n\n//关闭P0风扇\nM106 S0\n\n//关闭P2风扇\nM106 P2 S0\n\n//设置挤出头当前位置为零点\nG92 E0\n\n//使用G1直线移动方式，将挤出头回抽0.6mm，速度为2400mm/min\nG1 E-.6 F2400\n\n//设置加速度为1000mm/min，加减速速度为1000mm/min\nSET_VELOCITY_LIMIT ACCEL=1000 ACCEL_TO_DECEL=1000\n\n//设置角加速度为20rad/min\nSET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=20\n\n//表示当前层开始打印\nEXCLUDE_OBJECT_START NAME=Square_columns_Z_axis.stl_id_0_copy_0\n\n//开始打印，G1直线位移到坐标为(49.789，32.953)位置，速度为30000mm/min\nG1 X49.789 Y32.952 F30000\n\n//Z轴向下移动0.4mm\nG1 Z.4\n\n//开始重复性打印操作\nG1 X50.408 Y32.135 E.037\nG1 X51.103 Y31.381 E.03702\nG1 X51.866 Y30.696 E.03702\nG1 X52.691 Y30.087 E.03702\nG1 X53.57 Y29.56 E.03702\nG1 X54.494 Y29.119 E.03697\nG1 X55.682 Y28.701 E.04545\nG1 X56.731 Y28.45 E.03897\nG1 X57.747 Y28.311 E.03702\nG1 X58.707 Y28.268 E.0347\nG1 X267.625 Y28.268 E7.5432\nG1 X268.655 Y28.317 E.03721\nG1 X269.669 Y28.463 E.03702\nG1 X270.665 Y28.706 E.03702\nG1 X271.632 Y29.041 E.03696\nG1 X272.832 Y29.612 E.04796\nG1 X273.788 Y30.196 E.04045\n...\n\n//打印进度和时长标记位\nM73 P0 R1208\n\n//表示上一层已经打印结束\nEXCLUDE_OBJECT_END NAME=Square_columns_Z_axis.stl_id_0_copy_0\n\n//表示当前层开始打印\nEXCLUDE_OBJECT_START NAME=Square_columns_Z_axis.stl_id_0_copy_0\n\n//关闭P0、P2风扇\nM106 S0\nM106 P2 S0\n\n//结束打印，在gcode_macro.cfg配置文件中有宏定义函数，表示结束打印\nEND_PRINT\n\n//设置机箱温度为0\nM141 S0\n\n//上传打印进度\nM73 P100 R0\n```\n\n","source":"_posts/Work No.7.md","raw":"---\ntitle: 3D打印机运行逻辑\ntag: 3D打印机\ndate: 2024-07-26\ncategories: 3D打印机\nindex_img: https://s2.loli.net/2024/07/31/hRrLCWXmb3HwpID.png\n---\n\n# 3D打印机运行逻辑\n\n### 打印机初始化\n\n1.获取机器，连接网络，并且在设置里面打开root权限，获得root的账号和密码\n\n```\nroot  //账号\nroot  //密码\n```\n\n2.需要获取机器的IP地址，然后用mobaxtem的ssh进行连接，连接时输入IP地址和账号\n\n```\n172.xx.xxx.xx  //IP地址\n```\n\n3.拷贝所需的文件夹进行安装\n\n```\ncp /tmp/udisk/sda1/fluidd/fluidd.sh /usr/data  //拷贝脚本文件\ncp /tmp/udisk/sda1/fluidd/fluidd.tar /usr/data  //拷贝配置文件\n\t\ncd /usr/data  //进入该文件夹下\n\t\n./fluidd.sh install  //执行安装指令\n```\n\n4.等待结束，即可登录fluidd网站\n\n```\n172.xx.xxx.xx:4408  //fluidd的网址\n```\n\n### 打印机操作\n\nSET_VELOCITY_LIMIT 改变打印机配置文件中指定的速度限制。\n\n```\nSET_VELOCITY_LIMIT [VELOCITY=<value>] [ACCEL=<value>] [MINIMUM_CRUISE_RATIO=<value>] [SQUARE_CORNER_VELOCITY=<value>]\n\n[VELOCITY=<value>]  //速度\n[ACCEL=<value>]  //加速度\n[MINIMUM_CRUISE_RATIO=<value>]  //最小巡航速度\n[SQUARE_CORNER_VELOCITY=<value>]  //角速度\n[ACCEL_TO_DECEL]  //加速减速\n```\n\n3D打印机Z轴正值是向下，负值是向上\n\n```\nG1 Z1  //K1-MAX向下位移1mm\nG1 Z-.5  //K1-MAX向上位移到-0.5mm\n```\n\n3D打印机X轴正值是向右，负值是向左\n\n```\nG1 X1  //K1-MAX向右位移1mm\nG1 X-.5  //K1-MAX向左位移到-0.5mm\n```\n\n3D打印机X轴正值是向后，负值是向前\n\n```\nG1 X1  //K1-MAX向后位移1mm\nG1 X-.5  //K1-MAX向前位移到-0.5mm\n```\n\nEXCLUDE_OBJECT_START 表示当前层上一个对象的gcode开始\n\nEXCLUDE_OBJECT_END 表示对象在该层的代码的结束\n\n```\nEXCLUDE_OBJECT_START NAME=对象名称\nEXCLUDE_OBJECT_END [NAME=对象名称]\n```\n\nEXCLUDE_OBJECT_DEFINE\n\n```\nEXCLUDE_OBJECT_DEFINE [NAME =对象名称[中心= X, Y][多边形= [(X, Y),……[reset =1] [json =1]  //提供文件中一个对象的摘要。\n//如果没有提供参数，这将列出Klipper已知的已定义对象。返回字符串列表，除非给出了JSON参数，否则它将以JSON格式返回对象详细信息。\n\n<NAME>  //当包含NAME参数时，将定义要排除的对象。\n\n<CENTER>  //对象的 X，Y 坐标。\n\n<POLYGON>  //提供对象轮廓的 X,Y 坐标数组\n\n//当提供RESET参数时，将清除所有已定义的对象，并重置[exclude_object]模块。\n```\n\n### G-code 打印流程\n\n```\n//这个干嘛没搞明白\nEXCLUDE_OBJECT_DEFINE  NAME=Square_columns_Z_axis.stl_id_0_copy_0 CENTER=163.166,143.573 POLYGON=[[58.702,39.1091],[267.631,39.1091],[267.631,248.038],[58.702,248.038],[58.702,39.1091]]\n\n//报告当前进度给控制器，P0是进度为0%，R1210是当前设定的剩余时间\nM73 P0 R1210\n\n//关闭P0风扇，没有P参数，默认P0，S代表风扇的模拟量为0，范围是0~255，\nM106 S0\n\n//关闭P2风扇\nM106 P2 S0\n\n//关闭热床温度，不进行等待\nM140 S0\n\n//关闭喷头温度，不进行等待，继续执行\nM104 S0 \n\n//执行宏定义，在gcode_macro.cfg配置文件中有宏定义函数，作用为开始打印，对打印机进行自动，调节热床和喷头温度\nSTART_PRINT EXTRUDER_TEMP=220 BED_TEMP=50\n\n//设定机箱温度为35摄氏度\nM141 S35\n\n//将打印机三轴设为绝对坐标系\nG90\n\n//设置移动单位为毫米\nG21\n\n//设置挤出头为绝对坐标系\nM83\n\n//关闭P0风扇\nM106 S0\n\n//关闭P2风扇\nM106 P2 S0\n\n//设置挤出头当前位置为零点\nG92 E0\n\n//使用G1直线移动方式，将挤出头回抽0.6mm，速度为2400mm/min\nG1 E-.6 F2400\n\n//设置加速度为1000mm/min，加减速速度为1000mm/min\nSET_VELOCITY_LIMIT ACCEL=1000 ACCEL_TO_DECEL=1000\n\n//设置角加速度为20rad/min\nSET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=20\n\n//表示当前层开始打印\nEXCLUDE_OBJECT_START NAME=Square_columns_Z_axis.stl_id_0_copy_0\n\n//开始打印，G1直线位移到坐标为(49.789，32.953)位置，速度为30000mm/min\nG1 X49.789 Y32.952 F30000\n\n//Z轴向下移动0.4mm\nG1 Z.4\n\n//开始重复性打印操作\nG1 X50.408 Y32.135 E.037\nG1 X51.103 Y31.381 E.03702\nG1 X51.866 Y30.696 E.03702\nG1 X52.691 Y30.087 E.03702\nG1 X53.57 Y29.56 E.03702\nG1 X54.494 Y29.119 E.03697\nG1 X55.682 Y28.701 E.04545\nG1 X56.731 Y28.45 E.03897\nG1 X57.747 Y28.311 E.03702\nG1 X58.707 Y28.268 E.0347\nG1 X267.625 Y28.268 E7.5432\nG1 X268.655 Y28.317 E.03721\nG1 X269.669 Y28.463 E.03702\nG1 X270.665 Y28.706 E.03702\nG1 X271.632 Y29.041 E.03696\nG1 X272.832 Y29.612 E.04796\nG1 X273.788 Y30.196 E.04045\n...\n\n//打印进度和时长标记位\nM73 P0 R1208\n\n//表示上一层已经打印结束\nEXCLUDE_OBJECT_END NAME=Square_columns_Z_axis.stl_id_0_copy_0\n\n//表示当前层开始打印\nEXCLUDE_OBJECT_START NAME=Square_columns_Z_axis.stl_id_0_copy_0\n\n//关闭P0、P2风扇\nM106 S0\nM106 P2 S0\n\n//结束打印，在gcode_macro.cfg配置文件中有宏定义函数，表示结束打印\nEND_PRINT\n\n//设置机箱温度为0\nM141 S0\n\n//上传打印进度\nM73 P100 R0\n```\n\n","slug":"Work No.7","published":1,"updated":"2024-07-31T03:33:07.117Z","_id":"clz9aaxqh0017ygfb6zza06ch","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"3D打印机运行逻辑\"><a href=\"#3D打印机运行逻辑\" class=\"headerlink\" title=\"3D打印机运行逻辑\"></a>3D打印机运行逻辑</h1><h3 id=\"打印机初始化\"><a href=\"#打印机初始化\" class=\"headerlink\" title=\"打印机初始化\"></a>打印机初始化</h3><p>1.获取机器，连接网络，并且在设置里面打开root权限，获得root的账号和密码</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">root  <span class=\"hljs-comment\">//账号</span><br>root  <span class=\"hljs-comment\">//密码</span><br></code></pre></td></tr></table></figure>\n\n<p>2.需要获取机器的IP地址，然后用mobaxtem的ssh进行连接，连接时输入IP地址和账号</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-number\">172</span><span class=\"hljs-selector-class\">.xx</span><span class=\"hljs-selector-class\">.xxx</span><span class=\"hljs-selector-class\">.xx</span>  <span class=\"hljs-comment\">//IP地址</span><br></code></pre></td></tr></table></figure>\n\n<p>3.拷贝所需的文件夹进行安装</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">cp <span class=\"hljs-regexp\">/tmp/u</span>disk<span class=\"hljs-regexp\">/sda1/</span>fluidd<span class=\"hljs-regexp\">/fluidd.sh /u</span>sr<span class=\"hljs-regexp\">/data  /</span>/拷贝脚本文件<br>cp <span class=\"hljs-regexp\">/tmp/u</span>disk<span class=\"hljs-regexp\">/sda1/</span>fluidd<span class=\"hljs-regexp\">/fluidd.tar /u</span>sr<span class=\"hljs-regexp\">/data  /</span>/拷贝配置文件<br>\t<br>cd <span class=\"hljs-regexp\">/usr/</span>data  <span class=\"hljs-regexp\">//</span>进入该文件夹下<br>\t<br>.<span class=\"hljs-regexp\">/fluidd.sh install  /</span>/执行安装指令<br></code></pre></td></tr></table></figure>\n\n<p>4.等待结束，即可登录fluidd网站</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-number\">172</span><span class=\"hljs-selector-class\">.xx</span><span class=\"hljs-selector-class\">.xxx</span><span class=\"hljs-selector-class\">.xx</span>:<span class=\"hljs-number\">4408</span>  <span class=\"hljs-comment\">//fluidd的网址</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"打印机操作\"><a href=\"#打印机操作\" class=\"headerlink\" title=\"打印机操作\"></a>打印机操作</h3><p>SET_VELOCITY_LIMIT 改变打印机配置文件中指定的速度限制。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">SET_VELOCITY_LIMIT</span> <span class=\"hljs-selector-attr\">[VELOCITY=&lt;value&gt;]</span> <span class=\"hljs-selector-attr\">[ACCEL=&lt;value&gt;]</span> <span class=\"hljs-selector-attr\">[MINIMUM_CRUISE_RATIO=&lt;value&gt;]</span> <span class=\"hljs-selector-attr\">[SQUARE_CORNER_VELOCITY=&lt;value&gt;]</span><br><br><span class=\"hljs-selector-attr\">[VELOCITY=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//速度</span><br><span class=\"hljs-selector-attr\">[ACCEL=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//加速度</span><br><span class=\"hljs-selector-attr\">[MINIMUM_CRUISE_RATIO=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//最小巡航速度</span><br><span class=\"hljs-selector-attr\">[SQUARE_CORNER_VELOCITY=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//角速度</span><br><span class=\"hljs-selector-attr\">[ACCEL_TO_DECEL]</span>  <span class=\"hljs-comment\">//加速减速</span><br></code></pre></td></tr></table></figure>\n\n<p>3D打印机Z轴正值是向下，负值是向上</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">G1</span> Z1  //K1-MAX向下位移<span class=\"hljs-number\">1</span>mm<br><span class=\"hljs-attribute\">G1</span> Z-.<span class=\"hljs-number\">5</span>  //K1-MAX向上位移到-<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5</span>mm<br></code></pre></td></tr></table></figure>\n\n<p>3D打印机X轴正值是向右，负值是向左</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">G1</span> X1  //K1-MAX向右位移<span class=\"hljs-number\">1</span>mm<br><span class=\"hljs-attribute\">G1</span> X-.<span class=\"hljs-number\">5</span>  //K1-MAX向左位移到-<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5</span>mm<br></code></pre></td></tr></table></figure>\n\n<p>3D打印机X轴正值是向后，负值是向前</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">G1</span> X1  //K1-MAX向后位移<span class=\"hljs-number\">1</span>mm<br><span class=\"hljs-attribute\">G1</span> X-.<span class=\"hljs-number\">5</span>  //K1-MAX向前位移到-<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5</span>mm<br></code></pre></td></tr></table></figure>\n\n<p>EXCLUDE_OBJECT_START 表示当前层上一个对象的gcode开始</p>\n<p>EXCLUDE_OBJECT_END 表示对象在该层的代码的结束</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">EXCLUDE_OBJECT_START <span class=\"hljs-attribute\">NAME</span>=对象名称<br>EXCLUDE_OBJECT_END [<span class=\"hljs-attribute\">NAME</span>=对象名称]<br></code></pre></td></tr></table></figure>\n\n<p>EXCLUDE_OBJECT_DEFINE</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">EXCLUDE_OBJECT_DEFINE <span class=\"hljs-selector-attr\">[NAME =对象名称[中心= X, Y]</span><span class=\"hljs-selector-attr\">[多边形= [(X, Y),……[reset =1]</span> <span class=\"hljs-selector-attr\">[json =1]</span>  <span class=\"hljs-comment\">//提供文件中一个对象的摘要。</span><br><span class=\"hljs-comment\">//如果没有提供参数，这将列出Klipper已知的已定义对象。返回字符串列表，除非给出了JSON参数，否则它将以JSON格式返回对象详细信息。</span><br><br>&lt;NAME&gt;  <span class=\"hljs-comment\">//当包含NAME参数时，将定义要排除的对象。</span><br><br>&lt;CENTER&gt;  <span class=\"hljs-comment\">//对象的 X，Y 坐标。</span><br><br>&lt;<span class=\"hljs-selector-tag\">POLYGON</span>&gt;  <span class=\"hljs-comment\">//提供对象轮廓的 X,Y 坐标数组</span><br><br><span class=\"hljs-comment\">//当提供RESET参数时，将清除所有已定义的对象，并重置[exclude_object]模块。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"G-code-打印流程\"><a href=\"#G-code-打印流程\" class=\"headerlink\" title=\"G-code 打印流程\"></a>G-code 打印流程</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-comment\">//这个干嘛没搞明白</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_DEFINE</span>  NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0 CENTER<span class=\"hljs-number\">=163</span>.<span class=\"hljs-number\">166</span>,<span class=\"hljs-number\">143</span>.<span class=\"hljs-number\">573</span> POLYGON=[[<span class=\"hljs-number\">58</span>.<span class=\"hljs-number\">702</span>,<span class=\"hljs-number\">39</span>.<span class=\"hljs-number\">1091</span>],[<span class=\"hljs-number\">267</span>.<span class=\"hljs-number\">631</span>,<span class=\"hljs-number\">39</span>.<span class=\"hljs-number\">1091</span>],[<span class=\"hljs-number\">267</span>.<span class=\"hljs-number\">631</span>,<span class=\"hljs-number\">248</span>.<span class=\"hljs-number\">038</span>],[<span class=\"hljs-number\">58</span>.<span class=\"hljs-number\">702</span>,<span class=\"hljs-number\">248</span>.<span class=\"hljs-number\">038</span>],[<span class=\"hljs-number\">58</span>.<span class=\"hljs-number\">702</span>,<span class=\"hljs-number\">39</span>.<span class=\"hljs-number\">1091</span>]]<br><br><span class=\"hljs-comment\">//报告当前进度给控制器，P0是进度为0%，R1210是当前设定的剩余时间</span><br><span class=\"hljs-symbol\">M73</span> <span class=\"hljs-built_in\">P0</span> R1210<br><br><span class=\"hljs-comment\">//关闭P0风扇，没有P参数，默认P0，S代表风扇的模拟量为0，范围是0~255，</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭P2风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">P2</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭热床温度，不进行等待</span><br><span class=\"hljs-symbol\">M140</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭喷头温度，不进行等待，继续执行</span><br><span class=\"hljs-symbol\">M104</span> <span class=\"hljs-built_in\">S0</span> <br><br><span class=\"hljs-comment\">//执行宏定义，在gcode_macro.cfg配置文件中有宏定义函数，作用为开始打印，对打印机进行自动，调节热床和喷头温度</span><br><span class=\"hljs-symbol\">START_PRINT</span> EXTRUDER_TEMP<span class=\"hljs-number\">=220</span> BED_TEMP<span class=\"hljs-number\">=50</span><br><br><span class=\"hljs-comment\">//设定机箱温度为35摄氏度</span><br><span class=\"hljs-symbol\">M141</span> S35<br><br><span class=\"hljs-comment\">//将打印机三轴设为绝对坐标系</span><br><span class=\"hljs-symbol\">G90</span><br><br><span class=\"hljs-comment\">//设置移动单位为毫米</span><br><span class=\"hljs-symbol\">G21</span><br><br><span class=\"hljs-comment\">//设置挤出头为绝对坐标系</span><br><span class=\"hljs-symbol\">M83</span><br><br><span class=\"hljs-comment\">//关闭P0风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭P2风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">P2</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//设置挤出头当前位置为零点</span><br><span class=\"hljs-symbol\">G92</span> E0<br><br><span class=\"hljs-comment\">//使用G1直线移动方式，将挤出头回抽0.6mm，速度为2400mm/min</span><br><span class=\"hljs-symbol\">G1</span> E-.<span class=\"hljs-number\">6</span> F2400<br><br><span class=\"hljs-comment\">//设置加速度为1000mm/min，加减速速度为1000mm/min</span><br><span class=\"hljs-symbol\">SET_VELOCITY_LIMIT</span> ACCEL<span class=\"hljs-number\">=1000</span> ACCEL_TO_DECEL<span class=\"hljs-number\">=1000</span><br><br><span class=\"hljs-comment\">//设置角加速度为20rad/min</span><br><span class=\"hljs-symbol\">SET_VELOCITY_LIMIT</span> SQUARE_CORNER_VELOCITY<span class=\"hljs-number\">=20</span><br><br><span class=\"hljs-comment\">//表示当前层开始打印</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_START</span> NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class=\"hljs-comment\">//开始打印，G1直线位移到坐标为(49.789，32.953)位置，速度为30000mm/min</span><br><span class=\"hljs-symbol\">G1</span> X49.<span class=\"hljs-number\">789</span> Y32.<span class=\"hljs-number\">952</span> F30000<br><br><span class=\"hljs-comment\">//Z轴向下移动0.4mm</span><br><span class=\"hljs-symbol\">G1</span> Z.<span class=\"hljs-number\">4</span><br><br><span class=\"hljs-comment\">//开始重复性打印操作</span><br><span class=\"hljs-symbol\">G1</span> X50.<span class=\"hljs-number\">408</span> Y32.<span class=\"hljs-number\">135</span> E.<span class=\"hljs-number\">037</span><br><span class=\"hljs-symbol\">G1</span> X51.<span class=\"hljs-number\">103</span> Y31.<span class=\"hljs-number\">381</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X51.<span class=\"hljs-number\">866</span> Y30.<span class=\"hljs-number\">696</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X52.<span class=\"hljs-number\">691</span> Y30.<span class=\"hljs-number\">087</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X53.<span class=\"hljs-number\">57</span> Y29.<span class=\"hljs-number\">56</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X54.<span class=\"hljs-number\">494</span> Y29.<span class=\"hljs-number\">119</span> E.<span class=\"hljs-number\">03697</span><br><span class=\"hljs-symbol\">G1</span> X55.<span class=\"hljs-number\">682</span> Y28.<span class=\"hljs-number\">701</span> E.<span class=\"hljs-number\">04545</span><br><span class=\"hljs-symbol\">G1</span> X56.<span class=\"hljs-number\">731</span> Y28.<span class=\"hljs-number\">45</span> E.<span class=\"hljs-number\">03897</span><br><span class=\"hljs-symbol\">G1</span> X57.<span class=\"hljs-number\">747</span> Y28.<span class=\"hljs-number\">311</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X58.<span class=\"hljs-number\">707</span> Y28.<span class=\"hljs-number\">268</span> E.<span class=\"hljs-number\">0347</span><br><span class=\"hljs-symbol\">G1</span> X267.<span class=\"hljs-number\">625</span> Y28.<span class=\"hljs-number\">268</span> E7.<span class=\"hljs-number\">5432</span><br><span class=\"hljs-symbol\">G1</span> X268.<span class=\"hljs-number\">655</span> Y28.<span class=\"hljs-number\">317</span> E.<span class=\"hljs-number\">03721</span><br><span class=\"hljs-symbol\">G1</span> X269.<span class=\"hljs-number\">669</span> Y28.<span class=\"hljs-number\">463</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X270.<span class=\"hljs-number\">665</span> Y28.<span class=\"hljs-number\">706</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X271.<span class=\"hljs-number\">632</span> Y29.<span class=\"hljs-number\">041</span> E.<span class=\"hljs-number\">03696</span><br><span class=\"hljs-symbol\">G1</span> X272.<span class=\"hljs-number\">832</span> Y29.<span class=\"hljs-number\">612</span> E.<span class=\"hljs-number\">04796</span><br><span class=\"hljs-symbol\">G1</span> X273.<span class=\"hljs-number\">788</span> Y30.<span class=\"hljs-number\">196</span> E.<span class=\"hljs-number\">04045</span><br><span class=\"hljs-symbol\">...</span><br><br><span class=\"hljs-comment\">//打印进度和时长标记位</span><br><span class=\"hljs-symbol\">M73</span> <span class=\"hljs-built_in\">P0</span> R1208<br><br><span class=\"hljs-comment\">//表示上一层已经打印结束</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_END</span> NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class=\"hljs-comment\">//表示当前层开始打印</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_START</span> NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class=\"hljs-comment\">//关闭P0、P2风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">S0</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">P2</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//结束打印，在gcode_macro.cfg配置文件中有宏定义函数，表示结束打印</span><br><span class=\"hljs-symbol\">END_PRINT</span><br><br><span class=\"hljs-comment\">//设置机箱温度为0</span><br><span class=\"hljs-symbol\">M141</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//上传打印进度</span><br><span class=\"hljs-symbol\">M73</span> P100 <span class=\"hljs-built_in\">R0</span><br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"3D打印机运行逻辑\"><a href=\"#3D打印机运行逻辑\" class=\"headerlink\" title=\"3D打印机运行逻辑\"></a>3D打印机运行逻辑</h1><h3 id=\"打印机初始化\"><a href=\"#打印机初始化\" class=\"headerlink\" title=\"打印机初始化\"></a>打印机初始化</h3><p>1.获取机器，连接网络，并且在设置里面打开root权限，获得root的账号和密码</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">root  <span class=\"hljs-comment\">//账号</span><br>root  <span class=\"hljs-comment\">//密码</span><br></code></pre></td></tr></table></figure>\n\n<p>2.需要获取机器的IP地址，然后用mobaxtem的ssh进行连接，连接时输入IP地址和账号</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-number\">172</span><span class=\"hljs-selector-class\">.xx</span><span class=\"hljs-selector-class\">.xxx</span><span class=\"hljs-selector-class\">.xx</span>  <span class=\"hljs-comment\">//IP地址</span><br></code></pre></td></tr></table></figure>\n\n<p>3.拷贝所需的文件夹进行安装</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">cp <span class=\"hljs-regexp\">/tmp/u</span>disk<span class=\"hljs-regexp\">/sda1/</span>fluidd<span class=\"hljs-regexp\">/fluidd.sh /u</span>sr<span class=\"hljs-regexp\">/data  /</span>/拷贝脚本文件<br>cp <span class=\"hljs-regexp\">/tmp/u</span>disk<span class=\"hljs-regexp\">/sda1/</span>fluidd<span class=\"hljs-regexp\">/fluidd.tar /u</span>sr<span class=\"hljs-regexp\">/data  /</span>/拷贝配置文件<br>\t<br>cd <span class=\"hljs-regexp\">/usr/</span>data  <span class=\"hljs-regexp\">//</span>进入该文件夹下<br>\t<br>.<span class=\"hljs-regexp\">/fluidd.sh install  /</span>/执行安装指令<br></code></pre></td></tr></table></figure>\n\n<p>4.等待结束，即可登录fluidd网站</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-number\">172</span><span class=\"hljs-selector-class\">.xx</span><span class=\"hljs-selector-class\">.xxx</span><span class=\"hljs-selector-class\">.xx</span>:<span class=\"hljs-number\">4408</span>  <span class=\"hljs-comment\">//fluidd的网址</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"打印机操作\"><a href=\"#打印机操作\" class=\"headerlink\" title=\"打印机操作\"></a>打印机操作</h3><p>SET_VELOCITY_LIMIT 改变打印机配置文件中指定的速度限制。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">SET_VELOCITY_LIMIT</span> <span class=\"hljs-selector-attr\">[VELOCITY=&lt;value&gt;]</span> <span class=\"hljs-selector-attr\">[ACCEL=&lt;value&gt;]</span> <span class=\"hljs-selector-attr\">[MINIMUM_CRUISE_RATIO=&lt;value&gt;]</span> <span class=\"hljs-selector-attr\">[SQUARE_CORNER_VELOCITY=&lt;value&gt;]</span><br><br><span class=\"hljs-selector-attr\">[VELOCITY=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//速度</span><br><span class=\"hljs-selector-attr\">[ACCEL=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//加速度</span><br><span class=\"hljs-selector-attr\">[MINIMUM_CRUISE_RATIO=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//最小巡航速度</span><br><span class=\"hljs-selector-attr\">[SQUARE_CORNER_VELOCITY=&lt;value&gt;]</span>  <span class=\"hljs-comment\">//角速度</span><br><span class=\"hljs-selector-attr\">[ACCEL_TO_DECEL]</span>  <span class=\"hljs-comment\">//加速减速</span><br></code></pre></td></tr></table></figure>\n\n<p>3D打印机Z轴正值是向下，负值是向上</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">G1</span> Z1  //K1-MAX向下位移<span class=\"hljs-number\">1</span>mm<br><span class=\"hljs-attribute\">G1</span> Z-.<span class=\"hljs-number\">5</span>  //K1-MAX向上位移到-<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5</span>mm<br></code></pre></td></tr></table></figure>\n\n<p>3D打印机X轴正值是向右，负值是向左</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">G1</span> X1  //K1-MAX向右位移<span class=\"hljs-number\">1</span>mm<br><span class=\"hljs-attribute\">G1</span> X-.<span class=\"hljs-number\">5</span>  //K1-MAX向左位移到-<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5</span>mm<br></code></pre></td></tr></table></figure>\n\n<p>3D打印机X轴正值是向后，负值是向前</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">G1</span> X1  //K1-MAX向后位移<span class=\"hljs-number\">1</span>mm<br><span class=\"hljs-attribute\">G1</span> X-.<span class=\"hljs-number\">5</span>  //K1-MAX向前位移到-<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">5</span>mm<br></code></pre></td></tr></table></figure>\n\n<p>EXCLUDE_OBJECT_START 表示当前层上一个对象的gcode开始</p>\n<p>EXCLUDE_OBJECT_END 表示对象在该层的代码的结束</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">EXCLUDE_OBJECT_START <span class=\"hljs-attribute\">NAME</span>=对象名称<br>EXCLUDE_OBJECT_END [<span class=\"hljs-attribute\">NAME</span>=对象名称]<br></code></pre></td></tr></table></figure>\n\n<p>EXCLUDE_OBJECT_DEFINE</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">EXCLUDE_OBJECT_DEFINE <span class=\"hljs-selector-attr\">[NAME =对象名称[中心= X, Y]</span><span class=\"hljs-selector-attr\">[多边形= [(X, Y),……[reset =1]</span> <span class=\"hljs-selector-attr\">[json =1]</span>  <span class=\"hljs-comment\">//提供文件中一个对象的摘要。</span><br><span class=\"hljs-comment\">//如果没有提供参数，这将列出Klipper已知的已定义对象。返回字符串列表，除非给出了JSON参数，否则它将以JSON格式返回对象详细信息。</span><br><br>&lt;NAME&gt;  <span class=\"hljs-comment\">//当包含NAME参数时，将定义要排除的对象。</span><br><br>&lt;CENTER&gt;  <span class=\"hljs-comment\">//对象的 X，Y 坐标。</span><br><br>&lt;<span class=\"hljs-selector-tag\">POLYGON</span>&gt;  <span class=\"hljs-comment\">//提供对象轮廓的 X,Y 坐标数组</span><br><br><span class=\"hljs-comment\">//当提供RESET参数时，将清除所有已定义的对象，并重置[exclude_object]模块。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"G-code-打印流程\"><a href=\"#G-code-打印流程\" class=\"headerlink\" title=\"G-code 打印流程\"></a>G-code 打印流程</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-comment\">//这个干嘛没搞明白</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_DEFINE</span>  NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0 CENTER<span class=\"hljs-number\">=163</span>.<span class=\"hljs-number\">166</span>,<span class=\"hljs-number\">143</span>.<span class=\"hljs-number\">573</span> POLYGON=[[<span class=\"hljs-number\">58</span>.<span class=\"hljs-number\">702</span>,<span class=\"hljs-number\">39</span>.<span class=\"hljs-number\">1091</span>],[<span class=\"hljs-number\">267</span>.<span class=\"hljs-number\">631</span>,<span class=\"hljs-number\">39</span>.<span class=\"hljs-number\">1091</span>],[<span class=\"hljs-number\">267</span>.<span class=\"hljs-number\">631</span>,<span class=\"hljs-number\">248</span>.<span class=\"hljs-number\">038</span>],[<span class=\"hljs-number\">58</span>.<span class=\"hljs-number\">702</span>,<span class=\"hljs-number\">248</span>.<span class=\"hljs-number\">038</span>],[<span class=\"hljs-number\">58</span>.<span class=\"hljs-number\">702</span>,<span class=\"hljs-number\">39</span>.<span class=\"hljs-number\">1091</span>]]<br><br><span class=\"hljs-comment\">//报告当前进度给控制器，P0是进度为0%，R1210是当前设定的剩余时间</span><br><span class=\"hljs-symbol\">M73</span> <span class=\"hljs-built_in\">P0</span> R1210<br><br><span class=\"hljs-comment\">//关闭P0风扇，没有P参数，默认P0，S代表风扇的模拟量为0，范围是0~255，</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭P2风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">P2</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭热床温度，不进行等待</span><br><span class=\"hljs-symbol\">M140</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭喷头温度，不进行等待，继续执行</span><br><span class=\"hljs-symbol\">M104</span> <span class=\"hljs-built_in\">S0</span> <br><br><span class=\"hljs-comment\">//执行宏定义，在gcode_macro.cfg配置文件中有宏定义函数，作用为开始打印，对打印机进行自动，调节热床和喷头温度</span><br><span class=\"hljs-symbol\">START_PRINT</span> EXTRUDER_TEMP<span class=\"hljs-number\">=220</span> BED_TEMP<span class=\"hljs-number\">=50</span><br><br><span class=\"hljs-comment\">//设定机箱温度为35摄氏度</span><br><span class=\"hljs-symbol\">M141</span> S35<br><br><span class=\"hljs-comment\">//将打印机三轴设为绝对坐标系</span><br><span class=\"hljs-symbol\">G90</span><br><br><span class=\"hljs-comment\">//设置移动单位为毫米</span><br><span class=\"hljs-symbol\">G21</span><br><br><span class=\"hljs-comment\">//设置挤出头为绝对坐标系</span><br><span class=\"hljs-symbol\">M83</span><br><br><span class=\"hljs-comment\">//关闭P0风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//关闭P2风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">P2</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//设置挤出头当前位置为零点</span><br><span class=\"hljs-symbol\">G92</span> E0<br><br><span class=\"hljs-comment\">//使用G1直线移动方式，将挤出头回抽0.6mm，速度为2400mm/min</span><br><span class=\"hljs-symbol\">G1</span> E-.<span class=\"hljs-number\">6</span> F2400<br><br><span class=\"hljs-comment\">//设置加速度为1000mm/min，加减速速度为1000mm/min</span><br><span class=\"hljs-symbol\">SET_VELOCITY_LIMIT</span> ACCEL<span class=\"hljs-number\">=1000</span> ACCEL_TO_DECEL<span class=\"hljs-number\">=1000</span><br><br><span class=\"hljs-comment\">//设置角加速度为20rad/min</span><br><span class=\"hljs-symbol\">SET_VELOCITY_LIMIT</span> SQUARE_CORNER_VELOCITY<span class=\"hljs-number\">=20</span><br><br><span class=\"hljs-comment\">//表示当前层开始打印</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_START</span> NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class=\"hljs-comment\">//开始打印，G1直线位移到坐标为(49.789，32.953)位置，速度为30000mm/min</span><br><span class=\"hljs-symbol\">G1</span> X49.<span class=\"hljs-number\">789</span> Y32.<span class=\"hljs-number\">952</span> F30000<br><br><span class=\"hljs-comment\">//Z轴向下移动0.4mm</span><br><span class=\"hljs-symbol\">G1</span> Z.<span class=\"hljs-number\">4</span><br><br><span class=\"hljs-comment\">//开始重复性打印操作</span><br><span class=\"hljs-symbol\">G1</span> X50.<span class=\"hljs-number\">408</span> Y32.<span class=\"hljs-number\">135</span> E.<span class=\"hljs-number\">037</span><br><span class=\"hljs-symbol\">G1</span> X51.<span class=\"hljs-number\">103</span> Y31.<span class=\"hljs-number\">381</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X51.<span class=\"hljs-number\">866</span> Y30.<span class=\"hljs-number\">696</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X52.<span class=\"hljs-number\">691</span> Y30.<span class=\"hljs-number\">087</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X53.<span class=\"hljs-number\">57</span> Y29.<span class=\"hljs-number\">56</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X54.<span class=\"hljs-number\">494</span> Y29.<span class=\"hljs-number\">119</span> E.<span class=\"hljs-number\">03697</span><br><span class=\"hljs-symbol\">G1</span> X55.<span class=\"hljs-number\">682</span> Y28.<span class=\"hljs-number\">701</span> E.<span class=\"hljs-number\">04545</span><br><span class=\"hljs-symbol\">G1</span> X56.<span class=\"hljs-number\">731</span> Y28.<span class=\"hljs-number\">45</span> E.<span class=\"hljs-number\">03897</span><br><span class=\"hljs-symbol\">G1</span> X57.<span class=\"hljs-number\">747</span> Y28.<span class=\"hljs-number\">311</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X58.<span class=\"hljs-number\">707</span> Y28.<span class=\"hljs-number\">268</span> E.<span class=\"hljs-number\">0347</span><br><span class=\"hljs-symbol\">G1</span> X267.<span class=\"hljs-number\">625</span> Y28.<span class=\"hljs-number\">268</span> E7.<span class=\"hljs-number\">5432</span><br><span class=\"hljs-symbol\">G1</span> X268.<span class=\"hljs-number\">655</span> Y28.<span class=\"hljs-number\">317</span> E.<span class=\"hljs-number\">03721</span><br><span class=\"hljs-symbol\">G1</span> X269.<span class=\"hljs-number\">669</span> Y28.<span class=\"hljs-number\">463</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X270.<span class=\"hljs-number\">665</span> Y28.<span class=\"hljs-number\">706</span> E.<span class=\"hljs-number\">03702</span><br><span class=\"hljs-symbol\">G1</span> X271.<span class=\"hljs-number\">632</span> Y29.<span class=\"hljs-number\">041</span> E.<span class=\"hljs-number\">03696</span><br><span class=\"hljs-symbol\">G1</span> X272.<span class=\"hljs-number\">832</span> Y29.<span class=\"hljs-number\">612</span> E.<span class=\"hljs-number\">04796</span><br><span class=\"hljs-symbol\">G1</span> X273.<span class=\"hljs-number\">788</span> Y30.<span class=\"hljs-number\">196</span> E.<span class=\"hljs-number\">04045</span><br><span class=\"hljs-symbol\">...</span><br><br><span class=\"hljs-comment\">//打印进度和时长标记位</span><br><span class=\"hljs-symbol\">M73</span> <span class=\"hljs-built_in\">P0</span> R1208<br><br><span class=\"hljs-comment\">//表示上一层已经打印结束</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_END</span> NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class=\"hljs-comment\">//表示当前层开始打印</span><br><span class=\"hljs-symbol\">EXCLUDE_OBJECT_START</span> NAME<span class=\"hljs-symbol\">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class=\"hljs-comment\">//关闭P0、P2风扇</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">S0</span><br><span class=\"hljs-symbol\">M106</span> <span class=\"hljs-built_in\">P2</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//结束打印，在gcode_macro.cfg配置文件中有宏定义函数，表示结束打印</span><br><span class=\"hljs-symbol\">END_PRINT</span><br><br><span class=\"hljs-comment\">//设置机箱温度为0</span><br><span class=\"hljs-symbol\">M141</span> <span class=\"hljs-built_in\">S0</span><br><br><span class=\"hljs-comment\">//上传打印进度</span><br><span class=\"hljs-symbol\">M73</span> P100 <span class=\"hljs-built_in\">R0</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"Git使用","date":"2024-07-18T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/mBz1ZMHwft8nRUc.jpg","_content":"# Git使用\n\n## git基本了解\n\n### 学习资料\n\n[超详细的Git使用教程(图文)-CSDN博客](https://blog.csdn.net/qq_37883866/article/details/105349257)\n\n[Git基本使用教程（一）：入门及第一次基本完整操作_git的使用-CSDN博客](https://blog.csdn.net/qq_35206244/article/details/97698815)\n\n[git--一文弄懂git的工作区、索引区、本地仓库、远程仓库以及add、commit、push三个操作 - at_today - 博客园 (cnblogs.com)](https://www.cnblogs.com/Jing-Wang/p/10991008.html)\n\n[【原创】Git删除暂存区或版本库中的文件 - cposture - 博客园 (cnblogs.com)](https://www.cnblogs.com/cposture/p/git.html)\n\n[Git如何从暂存区（index/cache）中移除文件|极客教程 (geek-docs.com)](https://geek-docs.com/git/git-questions/611_git_how_to_remove_a_file_from_the_staging_area_index_cache_in_git.html)\n\n[git status 状态命令——查看文件状态_git status 看非新增文件-CSDN博客](https://blog.csdn.net/weixin_44567318/article/details/119701438)\n\n[Git 学习（三）本地仓库操作——git add & commit - feesland - 博客园 (cnblogs.com)](https://www.cnblogs.com/feeland/p/4500721.html)\n\n[git branch的详细使用，10个常见用法_git branch -vv-CSDN博客](https://blog.csdn.net/chaogu94/article/details/111057918)\n\n[Git基础 - git tag 一文真正的搞懂git标签的使用-CSDN博客](https://blog.csdn.net/qq_39505245/article/details/124705850)\n\n### git下载\n\n**官网：** https://git-scm.com/downloads\n\n## git使用方法\n\n#### 注册GitHub账号\n\n账号：1\n\n密码：1\n\n#### git注册\n\n```\n\t//设置账号，如果去掉 --global 参数只对当前仓库有效。\n\t$ git config --global user.name \"zhengyiyang\"\n\t\n\t//设置邮箱，如果去掉 --global 参数只对当前仓库有效。\n\t$ git config --global user.email \"903372205@qq.com\"\n\t\n\t//设置SSH，如果去掉 --global 参数只对当前仓库有效。\n\t$ ssh-keygen -t rsa -C \"903372205@qq.com\"\n\t\n\t储存位置：/c/Users/114008/.ssh/id_rsa\n\t\n\tid_rsa.pub为公共密钥\n\tid_rsa为私人密钥\n```\n\n#### github配置SSH\n\n**打开id_rsa.pub文件，全选，复制全文**\n\n\n```\n\tssh-rsa AAAAB3NzaC1yc2EA...\n```\n\n**github->账户->setting**\n\nTitle：1\n\nKey type：Authentication Key\n\n#### 测试是否成功连接\n\n```\n\t$ ssh -T git@github.com\n\t//代表成功连接\n\tHi yangyangdeyi0119! You've successfully authenticated, but GitHub does not provide shell access.  \n```\n\n#### 建立Github云端仓库\n\n[github仓库建立及配置教程新手教程_github创建仓库-CSDN博客](https://blog.csdn.net/qq_44722674/article/details/117200397)\n\n修改用户名\n\n[GitHub修改昵称和用户名（图解详细教程）_github改名-CSDN博客](https://blog.csdn.net/weixin_44285445/article/details/107833418)\n\n#### 创建本地仓库\n\n```\n\t//首先需要新建一个文件夹作为本地仓库\n\t//初始化该文件为本地仓库\n\t$ git init  \n\t\n\t//下载下来的test文件夹也是本地仓库\n\t$ git clone https://github.com/yangyangdeyi0119/test.git  \n```\n\n#### 将文件加入暂存区\n\n文件本身在工作区，需要通过文件锁定，将其加入暂存区\n\n```\n\t//可以同时添加多个文件夹\n\t$ git add /test /test1\n\t\n\t//添加单个文件\n\t$ git add README.md \n    \n    //将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除  \n\t$ git add .   \n\t\n\t//将文件包的所有文件加入暂存区\n\t$ git add -f .\n    \n    //将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。 \n\t$ git add -u \n\t\n\t//表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。\n\t$ git add -A\n\t\n\t//暂存区各类状态\n\t- untracked 未跟踪（未被纳入版本控制）\n\t- tracked 已跟踪（被纳入版本控制）\n\t- Unmodified 未修改状态\n\t- Modified 已修改状态\n\t- Staged 已暂存状态\n```\n\n#### 将文件移除暂存区\n\n```\n\t//仅删除暂存区的文件，不影响工作区的文件\n\t$ git rm --cache <file/aaa>\n\t\n\t//删除暂存区和工作区的文件\n\t$ git rm -f <file/aaa>\n\t\n\t//撤销对暂存区的修改。这个命令主要用于丢弃或还原文件的更改(测试未成功)\n\t$ git restore --staged <file/aaa>\n\t\n\t//将分支回退到之前的提交，并且还可以选择是否保留暂存区的更改\n\t$ git reset\n\t\n\t//撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是工作区\n\t$ git checkout 文件名\n\t\n```\n\n#### 查看文件状态\n\n```\n\t//获取文件状态-完整\n\t$ git status\n\t\n\t//获取文件状态-简洁\n\t$ git status -s 更加简洁\n\t\t' ' （空格）表示文件未发生更改\n\t\tM 表示文件发生改动。\n\t\tA 表示新增文件。\n\t\tD 表示删除文件。\n\t\tR 表示重命名。\n\t\tC 表示复制。\n\t\tU 表示更新但未合并。\n\t\t? 表示未跟踪文件。\n\t\t! 表示忽略文件。\n\t\n\t//显示分支和跟踪信息 --branch\n\t$ git status -s -b\n\t\n\t//显示变更的文本内容，在不使用 -s 选项时才会显示变更内容\n\t//只有一个 -v 选项时，显示版本库和暂存区之间比较发生变更的内容。\n\t$ git status -v\n\t//而有两个 -v 选项时，显示暂存区和工作区之间比较发生变更的内容。\n\t$ git status -v -v\n\t\n\t//显示未跟踪文件\n\t$ git status -s -u[<mode>]\n\t\tno —— 不显示未跟踪的文件\n\t\tnormal —— 显示未跟踪的文件和目录。\n\t\tall —— 还显示了未跟踪目录下的文件\n\t\t\n\t//用来查看暂存区中文件信息\n\t$ git ls-files -参数\n\t\t--cached(-c)显示暂存区中的文件，git ls-files命令默认的参数\n\t\t--deleted(-d)显示删除的文件\n\t\t--modified(-m) 显示修改过的文件\n\t\t--other(-o)显示没有被git跟踪的文件\n\t\t--stage(-s) 显示mode以及文件对应的Blob对象，进而我们可以获取暂存区中对应文件里面的内容。\n```\n\n#### 文件加入分支\n\n提交更改，实际上就是把暂存区的所有内容提交到当前分支，需要提交的文件修改通通放到暂存区；然后，一次性提交暂存区的所有修改\n\n```\n\t// 把暂存区的所有修改提交到分支，须输入描述信息\n\t$ git commit -m \"描述信息\"\n\t\n\t//更改之前一次commit的描述信息\n\t$ git commit --amend\n\t\n\t//提交暂存区的指定文件到仓库区（不行，最好单个提交git add，然后在git commit）\n\t$ git commit <file1> <file2> ... -m \"message\"\n\t\n\t//-a 参数设置修改文件后不需要执行 git add 命令，直接来提交（不好用）\n\t$ git commit -a\n\t\n\t出现报错\"nothing to commit, working tree clean\"\n    只需要修改该文件夹下的任意一个文件，因为检测到版本未发生改变\n    \n    //查找推送版本号\n    $ git log \n    \n    //选择回退版本，回退后，版本之后的将会丢失\n    git reset --hard <目标版本号>\n    \n    //软回退，不修改代码，回到暂存区\n    git reset --soft HEAD~n\n    \n    //只显示一行信息\n    git log --oneline\n```\n\n#### 分支管理\n\n```\n\t//创建分支命令\n\t$ git branch <branchname>\n\t\n\t//切换分支命令\n\t$ git checkout <branchname>\n\t\n\t//列出分支\n\tgit branch\n\t//查看本地分支+上次提交的信息\n\t$ git branch -v\n\t//查看本地分支+远程分支\n\t$ git branch -a\n\t\t- 红色代表云端仓库分支\n\t\t- 白色代表本地仓库分支\n\t\t- 绿色代表目前所在分支\n\t//查看本地分支+上次提交的信息+本地和远程分支的关系\n\t$ git branch -vv\n\t//查看本地分支+上次提交的信息+本地和远程分支的关系+远程分支\n\t$ git branch -vv -a\n\t//只查看远程分支\n\t$ git branch -r\n\t\n\t//创建新分支并立即切换到该分支下\n\t$ git checkout -b <branchname>\n\t\n\t//删除本地分支\n\t$ git branch -d <branchname>\n\t//强制删除分支\n\t$ git branch -D aaa\n\t\n\t//合并分支\n\t$ git merge <branchname>\n\t\n\t//删除远程分支\n\t$ git push <主机名> -d <分支名>\n\t\n\t//将本地分支推送到远程分支，如果远程分支不存在，则创建。\n\t$ git push <远程主机名> <本地分支名>:<远程分支名>\n\t$ git push --set-upstream origin dev\n\t\n\t//跟踪远程分支\n\tgit checkout -b zhanghanlun origin/zhanghanlun\n\t//用于解决远程 HEAD 指向一个不存在的引用，无法检出。\n```\n\n#### 将文件推送到云端仓库\n\n```\n\t//第一次推送代码指令\n\t$ git push -u origin <branchname>\n\t//-u参数可以在推送的同时,将origin仓库的master分支设置为本地仓库当前分支的upstream(上游)。添加了这个参数,将来运行git pull命令从远程仓库获取内容时,本地仓库的的这个分支就可以直接从origin的master分支获取内容,省去了另外添加参数的麻烦。\n\t\n\t//之后推送\n\t$ git push origin master\n\t\n\t//不同分支之间推送\n\t$ git push -u origin <branchname1>:origin/<branchname2>\n\t\n\t//云端仓库分支更新到本地仓库\n\t$ git remote update origin\n\t\t后缀加上 --prune则可以与云端仓库分支一致，多余的会被删除\n\t\t\n\t//报错\n\terror: failed to push some refs to 'https://github.com/yangyangdeyi0119/Learning.git'\n\thint: Updates were rejected because the remote contains work that you do not\n\thint: have locally. This is usually caused by another repository pushing to\n\thint: the same ref. If you want to integrate the remote changes, use\n\thint: 'git pull' before pushing again.\n\thint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\t直接git pull之后就可以了\n\t\n\t//删除现有远程仓库\n\t$ git remote rm origin\n\t\n\t//添加新远程仓库\n\t$ git remote add origin url\n\t\n\t//查看远程仓库的地址\n\t$ git remote -v\n\t\n\t//更换远程仓库地址，URL为新地址\n\t$ git remote set-url origin URL\n```\n\n#### 暂存空间使用\n\nstash是本地的，不会通过git push命令上传到git server上\n\n发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑git stash。\n\n使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用git stash就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用git stash apply将以前一半的工作应用回来。\n\n经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。\n\n```\n\t//将未提交的修改保存至堆栈中\n\t$ git stash\n\t\n\t//为此次stash添加说明信息，便于以后查看\n\t$ git stash save \"stash message info\"  \n\t\n\t//查看stash栈中的内容\n\t$ git stash list\n\t\n\t//将stash中的内容弹出，并应用到当前分支对应的工作目录上，该命令将堆栈中最近保存的内容删除（出栈操作）\n\t$ git stash pop\n\t\n\t//将指定id的内容应用到当前分支的工作目录，内容不会删除，可以在多个分支上重复进行操作\n\t$ git stash apply stash名称\n\t\n\t//从堆栈中移除某个指定的stash\n\t$ git stash drop stash名称\n\t\n\t//清除堆栈中的所有内容\n\t$ git stash clear\n\t\n\t//查看堆栈中最新保存的stash和当前目录的差异。\n\t$ git stash show\n\t\n\t//从最新的stash创建分支。\n\t$ git stash branch\n```\n\n#### 代码标签\n\ntag 中文我们可以称它为标签，tag 就是 对某次 commit 的一个标识，相当于起了一个别名。\n\n【轻量标签 】： 只是某个commit 的引用，可以理解为是一个commit的别名；\n\n【附注标签】 ：是存储在git仓库中的一个完整对象，包含打标签者的名字、电子邮件地址、日期时间以及其他的标签信息。它是可以被校验的，可以使用 GNU Privacy Guard (GPG) 签名并验证。\n\n```\n\t//直接列出所有的标签\n\t$ git tag\n\t\n\t//可以根据<tagname>进行标签的筛选\n\t$ git tag -l <tagname*>\n\t\n\t//查看标签的提交信息\n\t$ git show 标签名\n\t\n\t//在提交历史中查看标签\n\t$ git log --online --graph\n\t\n\t//创建轻量标签\n\t$ git tag 标签名\n\t$ git tag 标签名 提交版本\n\t\n\t//创建附注标签\n\t$ git tag -a 标签名称 -m 附注信息\n\t$ git tag -a 标签名称 提交版本号 -m 附注信息\n\t\t-a : 理解为 annotated 的首字符，表示 附注标签\n\t\t\n\t//删除标签\n\tgit tag -d 标签名称\n\t\n\t//将指定的标签上传到远程仓库\n\t$ git push origin <tagname>\n\t\n\t//将所有不在远程仓库中的标签上传到远程仓库\n\t$ git push origin --tags\n\t\n\t//删除远程仓库中的 指定标签\n\t$ git push origin  :regs/tags/<tagname>\n\t$ git push origin --delete <tagname>\n```\n\n#### 一台电脑多个ssh账号的注册\n\n情况所有的ssh，不清空也行，清空更快一些\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n```\n\n注册两个账号\n\n```\n# 生成github的ssh-key，注册邮箱填github的注册邮箱，然后在用户主目录下/.ssh/下会生成id_rsa(私钥)、id_rsa.pub(公钥)\n$ ssh-keygen -t rsa -C \"注册邮箱\" -f ~/.ssh/id_rsa \n# 生成gitlab的ssh-key，注册邮箱填gitlab的注册邮箱,然后在用户主目录下/.ssh/下会生成id_rsa_work(私钥)、id_rsa_work.pub(公钥)\n$ ssh-keygen -t rsa -C \"注册邮箱\" -f ~/.ssh/id_rsa_work\n```\n\n添加全局权限，可以不用每次都输密码\n\n```\n$ ssh-agent bash\n$ ssh-add ~/.ssh/id_rsa\n$ ssh-add ~/.ssh/id_rsa_work\n$ ssh-add -l \n#如果添加成功，这里会打印对应的配置信息\n```\n\n配置config文件\n\n```\n$ vim ~/.ssh/config  //创建配置文件\n\n# 账号1-github\nHOST github.com #github别名\nhostname github.com  #github地址\nUser githubUsername #github用户名\nIdentityFile /home/user/.ssh/id_rsa_work #github私钥地址\nPreferredAuthentications publickey #首选认证方式\n\n# 账号2-creality\nHOST gerrit #gitlab私服别名\nhostname xxx.xx.xxx.xx #gitlab私服地址\nPort xxxx #端口\nUser xxxxxxxxxx #填写gitlab私服的用户名\nIdentityFile /home/user/.ssh/id_rsa_work #gitlab私钥地址\nPreferredAuthentications publickey #首选认证方式\n```\n\n需要去网站上面配置ssh，参照最上面内容\n\n测试是否连接成功\n\n```\n$ ssh -T git@github.com\n$ ssh -T git@git.gitlab.com\n```\n\n遇到的问题\n1.测试Gitlab的SSH Key是否连接成功，出现Permission denied (publickey).\n\n```\n$ ssh -T git@git.gitlab.com\ngit@git.gitlab.com: Permission denied (publickey).\n\n#使用ssh -v查看详细日志\n$ ssh -vT git@git.gitlab.com\n...\n...\ndebug1: send_pubkey_test: no mutual signature algorithm\ndebug1: No more authentication methods to try.\ngit@git.gitlab.com: Permission denied (publickey).\n```\n\n关注的最后面三行日志，显示没有匹配的算法，查阅相关资料，openssh8.2版本之后，默认关闭SSH-RSA算法，该算法存在安全隐患（OpenSSH to deprecate SHA-1 logins due to security risk | ZDNet），当然我们可以重新启用它，但存在安全风险。在config的Gitlab配置中添加如下一行\n\n```\nPubkeyAcceptedKeyTypes +ssh-rsa\n再次运行\n```\n\n```\n$ ssh -T git@git.gitlab.com\n出现 You’ve successfully authenticated, but GitHub does not provide shell access，连接成功！\n```\n\n最后在对应的项目下设置对应的用户名以及邮箱名就可以快乐的提交代码了\n\n```\ngit config  user.email \"useremail\"\ngit config  user.name \"username\"\n```\n\n## 私有库的访问\n\n私有库的访问需要设置token，在git clone 的时候输入密码时把token输入进去，才可以实现git clone出来\n\n```\nSettings->Developer settings->Personal access tokens->Generate new token。\n创建新的访问密钥，勾选repo栏，选择有效期，为密钥命名。\n复制这段密钥。（注意，密钥只显示一次，记得妥善保管）\ngit push时，作为用户密码来使用。\n```\n\n私有库每次都需要输入账号密码的解决办法\n\n全局设置（只有一个账号）\n\n```\ngit config --global credential.helper store\n\ngit config --global user.email \"email\"\ngit confgi --global user.name \"name\"\n```\n\n局部设置（多个账号）\n\n```\n## local\ngit config --local credential.helper store\n\ngit config --local user.email \"email\"\ngit config --local user.name \"name\"\n```\n\n之后配置token\n\n```\ngit remote set-url origin https://github.com/xxx/xxx.git\n```\n\n","source":"_posts/Work No.5.md","raw":"---\ntitle: Git使用\ntag: git\ndate: 2024-07-19\ncategories: Git\nindex_img: https://s2.loli.net/2024/07/31/mBz1ZMHwft8nRUc.jpg\n---\n# Git使用\n\n## git基本了解\n\n### 学习资料\n\n[超详细的Git使用教程(图文)-CSDN博客](https://blog.csdn.net/qq_37883866/article/details/105349257)\n\n[Git基本使用教程（一）：入门及第一次基本完整操作_git的使用-CSDN博客](https://blog.csdn.net/qq_35206244/article/details/97698815)\n\n[git--一文弄懂git的工作区、索引区、本地仓库、远程仓库以及add、commit、push三个操作 - at_today - 博客园 (cnblogs.com)](https://www.cnblogs.com/Jing-Wang/p/10991008.html)\n\n[【原创】Git删除暂存区或版本库中的文件 - cposture - 博客园 (cnblogs.com)](https://www.cnblogs.com/cposture/p/git.html)\n\n[Git如何从暂存区（index/cache）中移除文件|极客教程 (geek-docs.com)](https://geek-docs.com/git/git-questions/611_git_how_to_remove_a_file_from_the_staging_area_index_cache_in_git.html)\n\n[git status 状态命令——查看文件状态_git status 看非新增文件-CSDN博客](https://blog.csdn.net/weixin_44567318/article/details/119701438)\n\n[Git 学习（三）本地仓库操作——git add & commit - feesland - 博客园 (cnblogs.com)](https://www.cnblogs.com/feeland/p/4500721.html)\n\n[git branch的详细使用，10个常见用法_git branch -vv-CSDN博客](https://blog.csdn.net/chaogu94/article/details/111057918)\n\n[Git基础 - git tag 一文真正的搞懂git标签的使用-CSDN博客](https://blog.csdn.net/qq_39505245/article/details/124705850)\n\n### git下载\n\n**官网：** https://git-scm.com/downloads\n\n## git使用方法\n\n#### 注册GitHub账号\n\n账号：1\n\n密码：1\n\n#### git注册\n\n```\n\t//设置账号，如果去掉 --global 参数只对当前仓库有效。\n\t$ git config --global user.name \"zhengyiyang\"\n\t\n\t//设置邮箱，如果去掉 --global 参数只对当前仓库有效。\n\t$ git config --global user.email \"903372205@qq.com\"\n\t\n\t//设置SSH，如果去掉 --global 参数只对当前仓库有效。\n\t$ ssh-keygen -t rsa -C \"903372205@qq.com\"\n\t\n\t储存位置：/c/Users/114008/.ssh/id_rsa\n\t\n\tid_rsa.pub为公共密钥\n\tid_rsa为私人密钥\n```\n\n#### github配置SSH\n\n**打开id_rsa.pub文件，全选，复制全文**\n\n\n```\n\tssh-rsa AAAAB3NzaC1yc2EA...\n```\n\n**github->账户->setting**\n\nTitle：1\n\nKey type：Authentication Key\n\n#### 测试是否成功连接\n\n```\n\t$ ssh -T git@github.com\n\t//代表成功连接\n\tHi yangyangdeyi0119! You've successfully authenticated, but GitHub does not provide shell access.  \n```\n\n#### 建立Github云端仓库\n\n[github仓库建立及配置教程新手教程_github创建仓库-CSDN博客](https://blog.csdn.net/qq_44722674/article/details/117200397)\n\n修改用户名\n\n[GitHub修改昵称和用户名（图解详细教程）_github改名-CSDN博客](https://blog.csdn.net/weixin_44285445/article/details/107833418)\n\n#### 创建本地仓库\n\n```\n\t//首先需要新建一个文件夹作为本地仓库\n\t//初始化该文件为本地仓库\n\t$ git init  \n\t\n\t//下载下来的test文件夹也是本地仓库\n\t$ git clone https://github.com/yangyangdeyi0119/test.git  \n```\n\n#### 将文件加入暂存区\n\n文件本身在工作区，需要通过文件锁定，将其加入暂存区\n\n```\n\t//可以同时添加多个文件夹\n\t$ git add /test /test1\n\t\n\t//添加单个文件\n\t$ git add README.md \n    \n    //将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除  \n\t$ git add .   \n\t\n\t//将文件包的所有文件加入暂存区\n\t$ git add -f .\n    \n    //将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。 \n\t$ git add -u \n\t\n\t//表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。\n\t$ git add -A\n\t\n\t//暂存区各类状态\n\t- untracked 未跟踪（未被纳入版本控制）\n\t- tracked 已跟踪（被纳入版本控制）\n\t- Unmodified 未修改状态\n\t- Modified 已修改状态\n\t- Staged 已暂存状态\n```\n\n#### 将文件移除暂存区\n\n```\n\t//仅删除暂存区的文件，不影响工作区的文件\n\t$ git rm --cache <file/aaa>\n\t\n\t//删除暂存区和工作区的文件\n\t$ git rm -f <file/aaa>\n\t\n\t//撤销对暂存区的修改。这个命令主要用于丢弃或还原文件的更改(测试未成功)\n\t$ git restore --staged <file/aaa>\n\t\n\t//将分支回退到之前的提交，并且还可以选择是否保留暂存区的更改\n\t$ git reset\n\t\n\t//撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是工作区\n\t$ git checkout 文件名\n\t\n```\n\n#### 查看文件状态\n\n```\n\t//获取文件状态-完整\n\t$ git status\n\t\n\t//获取文件状态-简洁\n\t$ git status -s 更加简洁\n\t\t' ' （空格）表示文件未发生更改\n\t\tM 表示文件发生改动。\n\t\tA 表示新增文件。\n\t\tD 表示删除文件。\n\t\tR 表示重命名。\n\t\tC 表示复制。\n\t\tU 表示更新但未合并。\n\t\t? 表示未跟踪文件。\n\t\t! 表示忽略文件。\n\t\n\t//显示分支和跟踪信息 --branch\n\t$ git status -s -b\n\t\n\t//显示变更的文本内容，在不使用 -s 选项时才会显示变更内容\n\t//只有一个 -v 选项时，显示版本库和暂存区之间比较发生变更的内容。\n\t$ git status -v\n\t//而有两个 -v 选项时，显示暂存区和工作区之间比较发生变更的内容。\n\t$ git status -v -v\n\t\n\t//显示未跟踪文件\n\t$ git status -s -u[<mode>]\n\t\tno —— 不显示未跟踪的文件\n\t\tnormal —— 显示未跟踪的文件和目录。\n\t\tall —— 还显示了未跟踪目录下的文件\n\t\t\n\t//用来查看暂存区中文件信息\n\t$ git ls-files -参数\n\t\t--cached(-c)显示暂存区中的文件，git ls-files命令默认的参数\n\t\t--deleted(-d)显示删除的文件\n\t\t--modified(-m) 显示修改过的文件\n\t\t--other(-o)显示没有被git跟踪的文件\n\t\t--stage(-s) 显示mode以及文件对应的Blob对象，进而我们可以获取暂存区中对应文件里面的内容。\n```\n\n#### 文件加入分支\n\n提交更改，实际上就是把暂存区的所有内容提交到当前分支，需要提交的文件修改通通放到暂存区；然后，一次性提交暂存区的所有修改\n\n```\n\t// 把暂存区的所有修改提交到分支，须输入描述信息\n\t$ git commit -m \"描述信息\"\n\t\n\t//更改之前一次commit的描述信息\n\t$ git commit --amend\n\t\n\t//提交暂存区的指定文件到仓库区（不行，最好单个提交git add，然后在git commit）\n\t$ git commit <file1> <file2> ... -m \"message\"\n\t\n\t//-a 参数设置修改文件后不需要执行 git add 命令，直接来提交（不好用）\n\t$ git commit -a\n\t\n\t出现报错\"nothing to commit, working tree clean\"\n    只需要修改该文件夹下的任意一个文件，因为检测到版本未发生改变\n    \n    //查找推送版本号\n    $ git log \n    \n    //选择回退版本，回退后，版本之后的将会丢失\n    git reset --hard <目标版本号>\n    \n    //软回退，不修改代码，回到暂存区\n    git reset --soft HEAD~n\n    \n    //只显示一行信息\n    git log --oneline\n```\n\n#### 分支管理\n\n```\n\t//创建分支命令\n\t$ git branch <branchname>\n\t\n\t//切换分支命令\n\t$ git checkout <branchname>\n\t\n\t//列出分支\n\tgit branch\n\t//查看本地分支+上次提交的信息\n\t$ git branch -v\n\t//查看本地分支+远程分支\n\t$ git branch -a\n\t\t- 红色代表云端仓库分支\n\t\t- 白色代表本地仓库分支\n\t\t- 绿色代表目前所在分支\n\t//查看本地分支+上次提交的信息+本地和远程分支的关系\n\t$ git branch -vv\n\t//查看本地分支+上次提交的信息+本地和远程分支的关系+远程分支\n\t$ git branch -vv -a\n\t//只查看远程分支\n\t$ git branch -r\n\t\n\t//创建新分支并立即切换到该分支下\n\t$ git checkout -b <branchname>\n\t\n\t//删除本地分支\n\t$ git branch -d <branchname>\n\t//强制删除分支\n\t$ git branch -D aaa\n\t\n\t//合并分支\n\t$ git merge <branchname>\n\t\n\t//删除远程分支\n\t$ git push <主机名> -d <分支名>\n\t\n\t//将本地分支推送到远程分支，如果远程分支不存在，则创建。\n\t$ git push <远程主机名> <本地分支名>:<远程分支名>\n\t$ git push --set-upstream origin dev\n\t\n\t//跟踪远程分支\n\tgit checkout -b zhanghanlun origin/zhanghanlun\n\t//用于解决远程 HEAD 指向一个不存在的引用，无法检出。\n```\n\n#### 将文件推送到云端仓库\n\n```\n\t//第一次推送代码指令\n\t$ git push -u origin <branchname>\n\t//-u参数可以在推送的同时,将origin仓库的master分支设置为本地仓库当前分支的upstream(上游)。添加了这个参数,将来运行git pull命令从远程仓库获取内容时,本地仓库的的这个分支就可以直接从origin的master分支获取内容,省去了另外添加参数的麻烦。\n\t\n\t//之后推送\n\t$ git push origin master\n\t\n\t//不同分支之间推送\n\t$ git push -u origin <branchname1>:origin/<branchname2>\n\t\n\t//云端仓库分支更新到本地仓库\n\t$ git remote update origin\n\t\t后缀加上 --prune则可以与云端仓库分支一致，多余的会被删除\n\t\t\n\t//报错\n\terror: failed to push some refs to 'https://github.com/yangyangdeyi0119/Learning.git'\n\thint: Updates were rejected because the remote contains work that you do not\n\thint: have locally. This is usually caused by another repository pushing to\n\thint: the same ref. If you want to integrate the remote changes, use\n\thint: 'git pull' before pushing again.\n\thint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\t直接git pull之后就可以了\n\t\n\t//删除现有远程仓库\n\t$ git remote rm origin\n\t\n\t//添加新远程仓库\n\t$ git remote add origin url\n\t\n\t//查看远程仓库的地址\n\t$ git remote -v\n\t\n\t//更换远程仓库地址，URL为新地址\n\t$ git remote set-url origin URL\n```\n\n#### 暂存空间使用\n\nstash是本地的，不会通过git push命令上传到git server上\n\n发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑git stash。\n\n使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用git stash就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用git stash apply将以前一半的工作应用回来。\n\n经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。\n\n```\n\t//将未提交的修改保存至堆栈中\n\t$ git stash\n\t\n\t//为此次stash添加说明信息，便于以后查看\n\t$ git stash save \"stash message info\"  \n\t\n\t//查看stash栈中的内容\n\t$ git stash list\n\t\n\t//将stash中的内容弹出，并应用到当前分支对应的工作目录上，该命令将堆栈中最近保存的内容删除（出栈操作）\n\t$ git stash pop\n\t\n\t//将指定id的内容应用到当前分支的工作目录，内容不会删除，可以在多个分支上重复进行操作\n\t$ git stash apply stash名称\n\t\n\t//从堆栈中移除某个指定的stash\n\t$ git stash drop stash名称\n\t\n\t//清除堆栈中的所有内容\n\t$ git stash clear\n\t\n\t//查看堆栈中最新保存的stash和当前目录的差异。\n\t$ git stash show\n\t\n\t//从最新的stash创建分支。\n\t$ git stash branch\n```\n\n#### 代码标签\n\ntag 中文我们可以称它为标签，tag 就是 对某次 commit 的一个标识，相当于起了一个别名。\n\n【轻量标签 】： 只是某个commit 的引用，可以理解为是一个commit的别名；\n\n【附注标签】 ：是存储在git仓库中的一个完整对象，包含打标签者的名字、电子邮件地址、日期时间以及其他的标签信息。它是可以被校验的，可以使用 GNU Privacy Guard (GPG) 签名并验证。\n\n```\n\t//直接列出所有的标签\n\t$ git tag\n\t\n\t//可以根据<tagname>进行标签的筛选\n\t$ git tag -l <tagname*>\n\t\n\t//查看标签的提交信息\n\t$ git show 标签名\n\t\n\t//在提交历史中查看标签\n\t$ git log --online --graph\n\t\n\t//创建轻量标签\n\t$ git tag 标签名\n\t$ git tag 标签名 提交版本\n\t\n\t//创建附注标签\n\t$ git tag -a 标签名称 -m 附注信息\n\t$ git tag -a 标签名称 提交版本号 -m 附注信息\n\t\t-a : 理解为 annotated 的首字符，表示 附注标签\n\t\t\n\t//删除标签\n\tgit tag -d 标签名称\n\t\n\t//将指定的标签上传到远程仓库\n\t$ git push origin <tagname>\n\t\n\t//将所有不在远程仓库中的标签上传到远程仓库\n\t$ git push origin --tags\n\t\n\t//删除远程仓库中的 指定标签\n\t$ git push origin  :regs/tags/<tagname>\n\t$ git push origin --delete <tagname>\n```\n\n#### 一台电脑多个ssh账号的注册\n\n情况所有的ssh，不清空也行，清空更快一些\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n```\n\n注册两个账号\n\n```\n# 生成github的ssh-key，注册邮箱填github的注册邮箱，然后在用户主目录下/.ssh/下会生成id_rsa(私钥)、id_rsa.pub(公钥)\n$ ssh-keygen -t rsa -C \"注册邮箱\" -f ~/.ssh/id_rsa \n# 生成gitlab的ssh-key，注册邮箱填gitlab的注册邮箱,然后在用户主目录下/.ssh/下会生成id_rsa_work(私钥)、id_rsa_work.pub(公钥)\n$ ssh-keygen -t rsa -C \"注册邮箱\" -f ~/.ssh/id_rsa_work\n```\n\n添加全局权限，可以不用每次都输密码\n\n```\n$ ssh-agent bash\n$ ssh-add ~/.ssh/id_rsa\n$ ssh-add ~/.ssh/id_rsa_work\n$ ssh-add -l \n#如果添加成功，这里会打印对应的配置信息\n```\n\n配置config文件\n\n```\n$ vim ~/.ssh/config  //创建配置文件\n\n# 账号1-github\nHOST github.com #github别名\nhostname github.com  #github地址\nUser githubUsername #github用户名\nIdentityFile /home/user/.ssh/id_rsa_work #github私钥地址\nPreferredAuthentications publickey #首选认证方式\n\n# 账号2-creality\nHOST gerrit #gitlab私服别名\nhostname xxx.xx.xxx.xx #gitlab私服地址\nPort xxxx #端口\nUser xxxxxxxxxx #填写gitlab私服的用户名\nIdentityFile /home/user/.ssh/id_rsa_work #gitlab私钥地址\nPreferredAuthentications publickey #首选认证方式\n```\n\n需要去网站上面配置ssh，参照最上面内容\n\n测试是否连接成功\n\n```\n$ ssh -T git@github.com\n$ ssh -T git@git.gitlab.com\n```\n\n遇到的问题\n1.测试Gitlab的SSH Key是否连接成功，出现Permission denied (publickey).\n\n```\n$ ssh -T git@git.gitlab.com\ngit@git.gitlab.com: Permission denied (publickey).\n\n#使用ssh -v查看详细日志\n$ ssh -vT git@git.gitlab.com\n...\n...\ndebug1: send_pubkey_test: no mutual signature algorithm\ndebug1: No more authentication methods to try.\ngit@git.gitlab.com: Permission denied (publickey).\n```\n\n关注的最后面三行日志，显示没有匹配的算法，查阅相关资料，openssh8.2版本之后，默认关闭SSH-RSA算法，该算法存在安全隐患（OpenSSH to deprecate SHA-1 logins due to security risk | ZDNet），当然我们可以重新启用它，但存在安全风险。在config的Gitlab配置中添加如下一行\n\n```\nPubkeyAcceptedKeyTypes +ssh-rsa\n再次运行\n```\n\n```\n$ ssh -T git@git.gitlab.com\n出现 You’ve successfully authenticated, but GitHub does not provide shell access，连接成功！\n```\n\n最后在对应的项目下设置对应的用户名以及邮箱名就可以快乐的提交代码了\n\n```\ngit config  user.email \"useremail\"\ngit config  user.name \"username\"\n```\n\n## 私有库的访问\n\n私有库的访问需要设置token，在git clone 的时候输入密码时把token输入进去，才可以实现git clone出来\n\n```\nSettings->Developer settings->Personal access tokens->Generate new token。\n创建新的访问密钥，勾选repo栏，选择有效期，为密钥命名。\n复制这段密钥。（注意，密钥只显示一次，记得妥善保管）\ngit push时，作为用户密码来使用。\n```\n\n私有库每次都需要输入账号密码的解决办法\n\n全局设置（只有一个账号）\n\n```\ngit config --global credential.helper store\n\ngit config --global user.email \"email\"\ngit confgi --global user.name \"name\"\n```\n\n局部设置（多个账号）\n\n```\n## local\ngit config --local credential.helper store\n\ngit config --local user.email \"email\"\ngit config --local user.name \"name\"\n```\n\n之后配置token\n\n```\ngit remote set-url origin https://github.com/xxx/xxx.git\n```\n\n","slug":"Work No.5","published":1,"updated":"2024-09-02T02:31:27.866Z","_id":"clz9aaxqi0019ygfb1w411dit","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Git使用\"><a href=\"#Git使用\" class=\"headerlink\" title=\"Git使用\"></a>Git使用</h1><h2 id=\"git基本了解\"><a href=\"#git基本了解\" class=\"headerlink\" title=\"git基本了解\"></a>git基本了解</h2><h3 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h3><p><a href=\"https://blog.csdn.net/qq_37883866/article/details/105349257\">超详细的Git使用教程(图文)-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_35206244/article/details/97698815\">Git基本使用教程（一）：入门及第一次基本完整操作_git的使用-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/Jing-Wang/p/10991008.html\">git–一文弄懂git的工作区、索引区、本地仓库、远程仓库以及add、commit、push三个操作 - at_today - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/cposture/p/git.html\">【原创】Git删除暂存区或版本库中的文件 - cposture - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://geek-docs.com/git/git-questions/611_git_how_to_remove_a_file_from_the_staging_area_index_cache_in_git.html\">Git如何从暂存区（index&#x2F;cache）中移除文件|极客教程 (geek-docs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_44567318/article/details/119701438\">git status 状态命令——查看文件状态_git status 看非新增文件-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/feeland/p/4500721.html\">Git 学习（三）本地仓库操作——git add &amp; commit - feesland - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/chaogu94/article/details/111057918\">git branch的详细使用，10个常见用法_git branch -vv-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_39505245/article/details/124705850\">Git基础 - git tag 一文真正的搞懂git标签的使用-CSDN博客</a></p>\n<h3 id=\"git下载\"><a href=\"#git下载\" class=\"headerlink\" title=\"git下载\"></a>git下载</h3><p><strong>官网：</strong> <a href=\"https://git-scm.com/downloads\">https://git-scm.com/downloads</a></p>\n<h2 id=\"git使用方法\"><a href=\"#git使用方法\" class=\"headerlink\" title=\"git使用方法\"></a>git使用方法</h2><h4 id=\"注册GitHub账号\"><a href=\"#注册GitHub账号\" class=\"headerlink\" title=\"注册GitHub账号\"></a>注册GitHub账号</h4><p>账号：1</p>\n<p>密码：1</p>\n<h4 id=\"git注册\"><a href=\"#git注册\" class=\"headerlink\" title=\"git注册\"></a>git注册</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-string\">//</span>设置账号，如果去掉 <span class=\"hljs-params\">--global</span> 参数只对当前仓库有效。<br>$ git config <span class=\"hljs-params\">--global</span> user.name <span class=\"hljs-string\">&quot;zhengyiyang&quot;</span><br><br><span class=\"hljs-string\">//</span>设置邮箱，如果去掉 <span class=\"hljs-params\">--global</span> 参数只对当前仓库有效。<br>$ git config <span class=\"hljs-params\">--global</span> user.email <span class=\"hljs-string\">&quot;903372205@qq.com&quot;</span><br><br><span class=\"hljs-string\">//</span>设置SSH，如果去掉 <span class=\"hljs-params\">--global</span> 参数只对当前仓库有效。<br>$ ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;903372205@qq.com&quot;</span><br><br>储存位置：<span class=\"hljs-string\">/c/Users/114008/.ssh/id_rsa</span><br><br>id_rsa.pub为公共密钥<br>id_rsa为私人密钥<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"github配置SSH\"><a href=\"#github配置SSH\" class=\"headerlink\" title=\"github配置SSH\"></a>github配置SSH</h4><p><strong>打开id_rsa.pub文件，全选，复制全文</strong></p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-function\"><span class=\"hljs-title\">ssh</span></span>-rsa AAAAB3NzaC1yc2EA...<br></code></pre></td></tr></table></figure>\n\n<p><strong>github-&gt;账户-&gt;setting</strong></p>\n<p>Title：1</p>\n<p>Key type：Authentication Key</p>\n<h4 id=\"测试是否成功连接\"><a href=\"#测试是否成功连接\" class=\"headerlink\" title=\"测试是否成功连接\"></a>测试是否成功连接</h4><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">$ ssh -T git@github.com<br>//代表成功连接<br>Hi yangyangdeyi0119! You<span class=\"hljs-symbol\">&#x27;ve</span> successfully authenticated, but GitHub does <span class=\"hljs-keyword\">not</span> provide shell <span class=\"hljs-keyword\">access</span>.  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"建立Github云端仓库\"><a href=\"#建立Github云端仓库\" class=\"headerlink\" title=\"建立Github云端仓库\"></a>建立Github云端仓库</h4><p><a href=\"https://blog.csdn.net/qq_44722674/article/details/117200397\">github仓库建立及配置教程新手教程_github创建仓库-CSDN博客</a></p>\n<p>修改用户名</p>\n<p><a href=\"https://blog.csdn.net/weixin_44285445/article/details/107833418\">GitHub修改昵称和用户名（图解详细教程）_github改名-CSDN博客</a></p>\n<h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//首先需要新建一个文件夹作为本地仓库</span><br><span class=\"hljs-comment\">//初始化该文件为本地仓库</span><br><span class=\"hljs-symbol\">$</span> git init  <br><br><span class=\"hljs-comment\">//下载下来的test文件夹也是本地仓库</span><br><span class=\"hljs-symbol\">$</span> git clone https:<span class=\"hljs-comment\">//github.com/yangyangdeyi0119/test.git  </span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"将文件加入暂存区\"><a href=\"#将文件加入暂存区\" class=\"headerlink\" title=\"将文件加入暂存区\"></a>将文件加入暂存区</h4><p>文件本身在工作区，需要通过文件锁定，将其加入暂存区</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-comment\">//可以同时添加多个文件夹</span><br>$ git <span class=\"hljs-keyword\">add</span> /test /test1<br><br><span class=\"hljs-comment\">//添加单个文件</span><br>$ git <span class=\"hljs-keyword\">add</span> README.md <br>   <br>   <span class=\"hljs-comment\">//将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除  </span><br>$ git <span class=\"hljs-keyword\">add</span> .   <br><br><span class=\"hljs-comment\">//将文件包的所有文件加入暂存区</span><br>$ git <span class=\"hljs-keyword\">add</span> -f .<br>   <br>   <span class=\"hljs-comment\">//将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。 </span><br>$ git <span class=\"hljs-keyword\">add</span> -u <br><br><span class=\"hljs-comment\">//表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。</span><br>$ git <span class=\"hljs-keyword\">add</span> -A<br><br><span class=\"hljs-comment\">//暂存区各类状态</span><br>- untracked 未跟踪（未被纳入版本控制）<br>- tracked 已跟踪（被纳入版本控制）<br>- Unmodified 未修改状态<br>- Modified 已修改状态<br>- Staged 已暂存状态<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"将文件移除暂存区\"><a href=\"#将文件移除暂存区\" class=\"headerlink\" title=\"将文件移除暂存区\"></a>将文件移除暂存区</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//仅删除暂存区的文件，不影响工作区的文件</span><br><span class=\"hljs-symbol\">$</span> git rm --cache &lt;<span class=\"hljs-keyword\">file</span>/aaa&gt;<br><br><span class=\"hljs-comment\">//删除暂存区和工作区的文件</span><br><span class=\"hljs-symbol\">$</span> git rm -f &lt;<span class=\"hljs-keyword\">file</span>/aaa&gt;<br><br><span class=\"hljs-comment\">//撤销对暂存区的修改。这个命令主要用于丢弃或还原文件的更改(测试未成功)</span><br><span class=\"hljs-symbol\">$</span> git restore --staged &lt;<span class=\"hljs-keyword\">file</span>/aaa&gt;<br><br><span class=\"hljs-comment\">//将分支回退到之前的提交，并且还可以选择是否保留暂存区的更改</span><br><span class=\"hljs-symbol\">$</span> git reset<br><br><span class=\"hljs-comment\">//撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是工作区</span><br><span class=\"hljs-symbol\">$</span> git checkout 文件名<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"查看文件状态\"><a href=\"#查看文件状态\" class=\"headerlink\" title=\"查看文件状态\"></a>查看文件状态</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//获取文件状态-完整</span><br><span class=\"hljs-symbol\">$</span> git status<br><br><span class=\"hljs-comment\">//获取文件状态-简洁</span><br><span class=\"hljs-symbol\">$</span> git status -s 更加简洁<br>\t<span class=\"hljs-string\">&#x27; &#x27;</span> （空格）表示文件未发生更改<br>\tM 表示文件发生改动。<br>\tA 表示新增文件。<br>\tD 表示删除文件。<br>\tR 表示重命名。<br>\tC 表示复制。<br>\tU 表示更新但未合并。<br>\t? 表示未跟踪文件。<br>\t! 表示忽略文件。<br><br><span class=\"hljs-comment\">//显示分支和跟踪信息 --branch</span><br><span class=\"hljs-symbol\">$</span> git status -s -b<br><br><span class=\"hljs-comment\">//显示变更的文本内容，在不使用 -s 选项时才会显示变更内容</span><br><span class=\"hljs-comment\">//只有一个 -v 选项时，显示版本库和暂存区之间比较发生变更的内容。</span><br><span class=\"hljs-symbol\">$</span> git status -v<br><span class=\"hljs-comment\">//而有两个 -v 选项时，显示暂存区和工作区之间比较发生变更的内容。</span><br><span class=\"hljs-symbol\">$</span> git status -v -v<br><br><span class=\"hljs-comment\">//显示未跟踪文件</span><br><span class=\"hljs-symbol\">$</span> git status -s -u[&lt;mode&gt;]<br>\t<span class=\"hljs-keyword\">no</span> —— 不显示未跟踪的文件<br>\t<span class=\"hljs-built_in\">normal</span> —— 显示未跟踪的文件和目录。<br>\t<span class=\"hljs-keyword\">all</span> —— 还显示了未跟踪目录下的文件<br>\t<br><span class=\"hljs-comment\">//用来查看暂存区中文件信息</span><br><span class=\"hljs-symbol\">$</span> git ls-<span class=\"hljs-keyword\">files</span> -参数<br>\t--cached(-c)显示暂存区中的文件，git ls-<span class=\"hljs-keyword\">files</span>命令默认的参数<br>\t--deleted(-d)显示删除的文件<br>\t--modified(-m) 显示修改过的文件<br>\t--other(-o)显示没有被git跟踪的文件<br>\t--stage(-s) 显示mode以及文件对应的Blob对象，进而我们可以获取暂存区中对应文件里面的内容。<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"文件加入分支\"><a href=\"#文件加入分支\" class=\"headerlink\" title=\"文件加入分支\"></a>文件加入分支</h4><p>提交更改，实际上就是把暂存区的所有内容提交到当前分支，需要提交的文件修改通通放到暂存区；然后，一次性提交暂存区的所有修改</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">// 把暂存区的所有修改提交到分支，须输入描述信息</span><br><span class=\"hljs-symbol\">$</span> git commit -m <span class=\"hljs-string\">&quot;描述信息&quot;</span><br><br><span class=\"hljs-comment\">//更改之前一次commit的描述信息</span><br><span class=\"hljs-symbol\">$</span> git commit --amend<br><br><span class=\"hljs-comment\">//提交暂存区的指定文件到仓库区（不行，最好单个提交git add，然后在git commit）</span><br><span class=\"hljs-symbol\">$</span> git commit &lt;file1&gt; &lt;file2&gt; ... -m <span class=\"hljs-string\">&quot;message&quot;</span><br><br><span class=\"hljs-comment\">//-a 参数设置修改文件后不需要执行 git add 命令，直接来提交（不好用）</span><br><span class=\"hljs-symbol\">$</span> git commit -a<br><br>出现报错<span class=\"hljs-string\">&quot;nothing to commit, working tree clean&quot;</span><br>   只需要修改该文件夹下的任意一个文件，因为检测到版本未发生改变<br>   <br>   <span class=\"hljs-comment\">//查找推送版本号</span><br>   <span class=\"hljs-symbol\">$</span> git <span class=\"hljs-built_in\">log</span> <br>   <br>   <span class=\"hljs-comment\">//选择回退版本，回退后，版本之后的将会丢失</span><br>   git reset --hard &lt;目标版本号&gt;<br>   <br>   <span class=\"hljs-comment\">//软回退，不修改代码，回到暂存区</span><br>   git reset --soft HEAD~n<br>   <br>   <span class=\"hljs-comment\">//只显示一行信息</span><br>   git <span class=\"hljs-built_in\">log</span> --oneline<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//创建分支命令</span><br><span class=\"hljs-symbol\">$</span> git branch &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//切换分支命令</span><br><span class=\"hljs-symbol\">$</span> git checkout &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//列出分支</span><br>git branch<br><span class=\"hljs-comment\">//查看本地分支+上次提交的信息</span><br><span class=\"hljs-symbol\">$</span> git branch -v<br><span class=\"hljs-comment\">//查看本地分支+远程分支</span><br><span class=\"hljs-symbol\">$</span> git branch -a<br>\t- 红色代表云端仓库分支<br>\t- 白色代表本地仓库分支<br>\t- 绿色代表目前所在分支<br><span class=\"hljs-comment\">//查看本地分支+上次提交的信息+本地和远程分支的关系</span><br><span class=\"hljs-symbol\">$</span> git branch -vv<br><span class=\"hljs-comment\">//查看本地分支+上次提交的信息+本地和远程分支的关系+远程分支</span><br><span class=\"hljs-symbol\">$</span> git branch -vv -a<br><span class=\"hljs-comment\">//只查看远程分支</span><br><span class=\"hljs-symbol\">$</span> git branch -r<br><br><span class=\"hljs-comment\">//创建新分支并立即切换到该分支下</span><br><span class=\"hljs-symbol\">$</span> git checkout -b &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//删除本地分支</span><br><span class=\"hljs-symbol\">$</span> git branch -d &lt;branchname&gt;<br><span class=\"hljs-comment\">//强制删除分支</span><br><span class=\"hljs-symbol\">$</span> git branch -D aaa<br><br><span class=\"hljs-comment\">//合并分支</span><br><span class=\"hljs-symbol\">$</span> git merge &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//删除远程分支</span><br><span class=\"hljs-symbol\">$</span> git push &lt;主机名&gt; -d &lt;分支名&gt;<br><br><span class=\"hljs-comment\">//将本地分支推送到远程分支，如果远程分支不存在，则创建。</span><br><span class=\"hljs-symbol\">$</span> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br><span class=\"hljs-symbol\">$</span> git push --<span class=\"hljs-keyword\">set</span>-upstream <span class=\"hljs-comment\">origin dev</span><br><br><span class=\"hljs-comment\">//跟踪远程分支</span><br>git <span class=\"hljs-comment\">checkout -b zhanghanlun origin</span>/zhanghanlun<br><span class=\"hljs-comment\">//用于解决远程 HEAD 指向一个不存在的引用，无法检出。</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"将文件推送到云端仓库\"><a href=\"#将文件推送到云端仓库\" class=\"headerlink\" title=\"将文件推送到云端仓库\"></a>将文件推送到云端仓库</h4><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">//第一次推送代码指令<br>$ git push -u origin &lt;branchname&gt;<span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//-u参数可以在推送的同时,将origin仓库的master分支设置为本地仓库当前分支的upstream(上游)。添加了这个参数,将来运行git pull命令从远程仓库获取内容时,本地仓库的的这个分支就可以直接从origin的master分支获取内容,省去了另外添加参数的麻烦。</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//之后推送</span><br>$ git push origin master<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//不同分支之间推送</span><br>$ git push -u origin &lt;branchname1&gt;:origin/&lt;branchname2&gt;<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//云端仓库分支更新到本地仓库</span><br>$ git remote update origin<br>\t后缀加上 <span class=\"hljs-comment\">--prune则可以与云端仓库分支一致，多余的会被删除</span><br>\t<span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//报错</span><br>error: failed <span class=\"hljs-built_in\">to</span> push some refs <span class=\"hljs-built_in\">to</span> <span class=\"hljs-string\">&#x27;https://github.com/yangyangdeyi0119/Learning.git&#x27;</span><br>hint: Updates were rejected because <span class=\"hljs-keyword\">the</span> remote <span class=\"hljs-keyword\">contains</span> work that you <span class=\"hljs-built_in\">do</span> <span class=\"hljs-keyword\">not</span><br>hint: have locally. This is usually caused <span class=\"hljs-keyword\">by</span> another repository pushing <span class=\"hljs-built_in\">to</span><br>hint: <span class=\"hljs-keyword\">the</span> same ref. If you want <span class=\"hljs-built_in\">to</span> integrate <span class=\"hljs-keyword\">the</span> remote changes, use<br>hint: <span class=\"hljs-string\">&#x27;git pull&#x27;</span> <span class=\"hljs-keyword\">before</span> pushing again.<br>hint: See <span class=\"hljs-keyword\">the</span> <span class=\"hljs-string\">&#x27;Note about fast-forwards&#x27;</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&#x27;git push --help&#x27;</span> <span class=\"hljs-keyword\">for</span> details.<br>直接git pull之后就可以了<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//删除现有远程仓库</span><br>$ git remote rm origin<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//添加新远程仓库</span><br>$ git remote <span class=\"hljs-built_in\">add</span> origin url<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//查看远程仓库的地址</span><br>$ git remote -v<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//更换远程仓库地址，URL为新地址</span><br>$ git remote <span class=\"hljs-built_in\">set</span>-url origin <span class=\"hljs-built_in\">URL</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"暂存空间使用\"><a href=\"#暂存空间使用\" class=\"headerlink\" title=\"暂存空间使用\"></a>暂存空间使用</h4><p>stash是本地的，不会通过git push命令上传到git server上</p>\n<p>发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑git stash。</p>\n<p>使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用git stash就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用git stash apply将以前一半的工作应用回来。</p>\n<p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//将未提交的修改保存至堆栈中</span><br><span class=\"hljs-symbol\">$</span> git stash<br><br><span class=\"hljs-comment\">//为此次stash添加说明信息，便于以后查看</span><br><span class=\"hljs-symbol\">$</span> git stash save <span class=\"hljs-string\">&quot;stash message info&quot;</span>  <br><br><span class=\"hljs-comment\">//查看stash栈中的内容</span><br><span class=\"hljs-symbol\">$</span> git stash list<br><br><span class=\"hljs-comment\">//将stash中的内容弹出，并应用到当前分支对应的工作目录上，该命令将堆栈中最近保存的内容删除（出栈操作）</span><br><span class=\"hljs-symbol\">$</span> git stash pop<br><br><span class=\"hljs-comment\">//将指定id的内容应用到当前分支的工作目录，内容不会删除，可以在多个分支上重复进行操作</span><br><span class=\"hljs-symbol\">$</span> git stash apply stash名称<br><br><span class=\"hljs-comment\">//从堆栈中移除某个指定的stash</span><br><span class=\"hljs-symbol\">$</span> git stash drop stash名称<br><br><span class=\"hljs-comment\">//清除堆栈中的所有内容</span><br><span class=\"hljs-symbol\">$</span> git stash clear<br><br><span class=\"hljs-comment\">//查看堆栈中最新保存的stash和当前目录的差异。</span><br><span class=\"hljs-symbol\">$</span> git stash show<br><br><span class=\"hljs-comment\">//从最新的stash创建分支。</span><br><span class=\"hljs-symbol\">$</span> git stash branch<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"代码标签\"><a href=\"#代码标签\" class=\"headerlink\" title=\"代码标签\"></a>代码标签</h4><p>tag 中文我们可以称它为标签，tag 就是 对某次 commit 的一个标识，相当于起了一个别名。</p>\n<p>【轻量标签 】： 只是某个commit 的引用，可以理解为是一个commit的别名；</p>\n<p>【附注标签】 ：是存储在git仓库中的一个完整对象，包含打标签者的名字、电子邮件地址、日期时间以及其他的标签信息。它是可以被校验的，可以使用 GNU Privacy Guard (GPG) 签名并验证。</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//直接列出所有的标签</span><br><span class=\"hljs-symbol\">$</span> git tag<br><br><span class=\"hljs-comment\">//可以根据&lt;tagname&gt;进行标签的筛选</span><br><span class=\"hljs-symbol\">$</span> git tag -l &lt;tagname*&gt;<br><br><span class=\"hljs-comment\">//查看标签的提交信息</span><br><span class=\"hljs-symbol\">$</span> git show 标签名<br><br><span class=\"hljs-comment\">//在提交历史中查看标签</span><br><span class=\"hljs-symbol\">$</span> git <span class=\"hljs-built_in\">log</span> --online --graph<br><br><span class=\"hljs-comment\">//创建轻量标签</span><br><span class=\"hljs-symbol\">$</span> git tag 标签名<br><span class=\"hljs-symbol\">$</span> git tag 标签名 提交版本<br><br><span class=\"hljs-comment\">//创建附注标签</span><br><span class=\"hljs-symbol\">$</span> git tag -a 标签名称 -m 附注信息<br><span class=\"hljs-symbol\">$</span> git tag -a 标签名称 提交版本号 -m 附注信息<br>\t-a : 理解为 annotated 的首字符，表示 附注标签<br>\t<br><span class=\"hljs-comment\">//删除标签</span><br>git tag -d 标签名称<br><br><span class=\"hljs-comment\">//将指定的标签上传到远程仓库</span><br><span class=\"hljs-symbol\">$</span> git push origin &lt;tagname&gt;<br><br><span class=\"hljs-comment\">//将所有不在远程仓库中的标签上传到远程仓库</span><br><span class=\"hljs-symbol\">$</span> git push origin --tags<br><br><span class=\"hljs-comment\">//删除远程仓库中的 指定标签</span><br><span class=\"hljs-symbol\">$</span> git push origin  :regs/tags/&lt;tagname&gt;<br><span class=\"hljs-symbol\">$</span> git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"一台电脑多个ssh账号的注册\"><a href=\"#一台电脑多个ssh账号的注册\" class=\"headerlink\" title=\"一台电脑多个ssh账号的注册\"></a>一台电脑多个ssh账号的注册</h4><p>情况所有的ssh，不清空也行，清空更快一些</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">git config <span class=\"hljs-attr\">--global</span> <span class=\"hljs-attr\">--unset</span> user<span class=\"hljs-selector-class\">.name</span><br>git config <span class=\"hljs-attr\">--global</span> <span class=\"hljs-attr\">--unset</span> user.email<br></code></pre></td></tr></table></figure>\n\n<p>注册两个账号</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">生成github的ssh-key，注册邮箱填github的注册邮箱，然后在用户主目录下/.ssh/下会生成id_rsa(私钥)、id_rsa.pub(公钥)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;注册邮箱&quot;</span> -f ~/.ssh/id_rsa</span> <br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">生成gitlab的ssh-key，注册邮箱填gitlab的注册邮箱,然后在用户主目录下/.ssh/下会生成id_rsa_work(私钥)、id_rsa_work.pub(公钥)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;注册邮箱&quot;</span> -f ~/.ssh/id_rsa_work</span><br></code></pre></td></tr></table></figure>\n\n<p>添加全局权限，可以不用每次都输密码</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>ssh-agent bash<br><span class=\"hljs-variable\">$ </span>ssh-add ~<span class=\"hljs-regexp\">/.ssh/id</span>_rsa<br><span class=\"hljs-variable\">$ </span>ssh-add ~<span class=\"hljs-regexp\">/.ssh/id</span>_rsa_work<br><span class=\"hljs-variable\">$ </span>ssh-add -l <br><span class=\"hljs-comment\">#如果添加成功，这里会打印对应的配置信息</span><br></code></pre></td></tr></table></figure>\n\n<p>配置config文件</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">$ vim ~<span class=\"hljs-regexp\">/.ssh/</span>config  <span class=\"hljs-regexp\">//</span>创建配置文件<br><br><span class=\"hljs-comment\"># 账号1-github</span><br>HOST github.com <span class=\"hljs-comment\">#github别名</span><br>hostname github.com  <span class=\"hljs-comment\">#github地址</span><br>User githubUsername <span class=\"hljs-comment\">#github用户名</span><br>IdentityFile <span class=\"hljs-regexp\">/home/u</span>ser<span class=\"hljs-regexp\">/.ssh/i</span>d_rsa_work <span class=\"hljs-comment\">#github私钥地址</span><br>PreferredAuthentications publickey <span class=\"hljs-comment\">#首选认证方式</span><br><br><span class=\"hljs-comment\"># 账号2-creality</span><br>HOST gerrit <span class=\"hljs-comment\">#gitlab私服别名</span><br>hostname xxx.xx.xxx.xx <span class=\"hljs-comment\">#gitlab私服地址</span><br>Port xxxx <span class=\"hljs-comment\">#端口</span><br>User xxxxxxxxxx <span class=\"hljs-comment\">#填写gitlab私服的用户名</span><br>IdentityFile <span class=\"hljs-regexp\">/home/u</span>ser<span class=\"hljs-regexp\">/.ssh/i</span>d_rsa_work <span class=\"hljs-comment\">#gitlab私钥地址</span><br>PreferredAuthentications publickey <span class=\"hljs-comment\">#首选认证方式</span><br></code></pre></td></tr></table></figure>\n\n<p>需要去网站上面配置ssh，参照最上面内容</p>\n<p>测试是否连接成功</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>ssh -T git<span class=\"hljs-variable\">@github</span>.com<br><span class=\"hljs-variable\">$ </span>ssh -T git<span class=\"hljs-variable\">@git</span>.gitlab.com<br></code></pre></td></tr></table></figure>\n\n<p>遇到的问题<br>1.测试Gitlab的SSH Key是否连接成功，出现Permission denied (publickey).</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang\"><span class=\"hljs-string\">$ </span>ssh -T git@git.gitlab.com<br>git@git.gitlab.com: Permission denied (publickey).<br><br>#使用ssh -v查看详细日志<br><span class=\"hljs-string\">$ </span>ssh -vT git@git.gitlab.com<br>...<br>...<br>debug1: send_pubkey_test: no mutual signature algorithm<br>debug1: No more authentication methods to <span class=\"hljs-keyword\">try</span>.<br>git@git.gitlab.com: Permission denied (publickey).<br></code></pre></td></tr></table></figure>\n\n<p>关注的最后面三行日志，显示没有匹配的算法，查阅相关资料，openssh8.2版本之后，默认关闭SSH-RSA算法，该算法存在安全隐患（OpenSSH to deprecate SHA-1 logins due to security risk | ZDNet），当然我们可以重新启用它，但存在安全风险。在config的Gitlab配置中添加如下一行</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">PubkeyAcceptedKeyTypes</span> +ssh-rsa<br>再次运行<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">$ ssh -T git@git.gitlab.<span class=\"hljs-keyword\">com</span><br>出现 You’<span class=\"hljs-keyword\">ve</span> successfully authenticated, but GitHub does not provide <span class=\"hljs-keyword\">shell</span> access，连接成功！<br></code></pre></td></tr></table></figure>\n\n<p>最后在对应的项目下设置对应的用户名以及邮箱名就可以快乐的提交代码了</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git config  <span class=\"hljs-keyword\">user</span>.email &quot;useremail&quot;<br>git config  <span class=\"hljs-keyword\">user</span>.name &quot;username&quot;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"私有库的访问\"><a href=\"#私有库的访问\" class=\"headerlink\" title=\"私有库的访问\"></a>私有库的访问</h2><p>私有库的访问需要设置token，在git clone 的时候输入密码时把token输入进去，才可以实现git clone出来</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">S<span class=\"hljs-function\"><span class=\"hljs-title\">ettings</span>-&gt;</span>D<span class=\"hljs-function\"><span class=\"hljs-title\">eveloper</span> settings-&gt;</span>P<span class=\"hljs-function\"><span class=\"hljs-title\">ersonal</span> access tokens-&gt;</span>Generate new token。<br>创建新的访问密钥，勾选repo栏，选择有效期，为密钥命名。<br>复制这段密钥。（注意，密钥只显示一次，记得妥善保管）<br>git push时，作为用户密码来使用。<br></code></pre></td></tr></table></figure>\n\n<p>私有库每次都需要输入账号密码的解决办法</p>\n<p>全局设置（只有一个账号）</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">git config <span class=\"hljs-attr\">--global</span> credential<span class=\"hljs-selector-class\">.helper</span> store<br><br>git config <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.email</span> <span class=\"hljs-string\">&quot;email&quot;</span><br>git confgi <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.name</span> <span class=\"hljs-string\">&quot;name&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>局部设置（多个账号）</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\">## <span class=\"hljs-keyword\">local</span><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">local</span> credential<span class=\"hljs-variable\">.helper</span> store<br><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">local</span> user<span class=\"hljs-variable\">.email</span> <span class=\"hljs-string\">&quot;email&quot;</span><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">local</span> user<span class=\"hljs-variable\">.name</span> <span class=\"hljs-string\">&quot;name&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>之后配置token</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\"><span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">https</span>://<span class=\"hljs-string\">github</span>.<span class=\"hljs-string\">com</span>/<span class=\"hljs-string\">xxx</span>/<span class=\"hljs-string\">xxx</span>.<span class=\"hljs-string\">git</span><br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"Git使用\"><a href=\"#Git使用\" class=\"headerlink\" title=\"Git使用\"></a>Git使用</h1><h2 id=\"git基本了解\"><a href=\"#git基本了解\" class=\"headerlink\" title=\"git基本了解\"></a>git基本了解</h2><h3 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h3><p><a href=\"https://blog.csdn.net/qq_37883866/article/details/105349257\">超详细的Git使用教程(图文)-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_35206244/article/details/97698815\">Git基本使用教程（一）：入门及第一次基本完整操作_git的使用-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/Jing-Wang/p/10991008.html\">git–一文弄懂git的工作区、索引区、本地仓库、远程仓库以及add、commit、push三个操作 - at_today - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/cposture/p/git.html\">【原创】Git删除暂存区或版本库中的文件 - cposture - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://geek-docs.com/git/git-questions/611_git_how_to_remove_a_file_from_the_staging_area_index_cache_in_git.html\">Git如何从暂存区（index&#x2F;cache）中移除文件|极客教程 (geek-docs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_44567318/article/details/119701438\">git status 状态命令——查看文件状态_git status 看非新增文件-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/feeland/p/4500721.html\">Git 学习（三）本地仓库操作——git add &amp; commit - feesland - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/chaogu94/article/details/111057918\">git branch的详细使用，10个常见用法_git branch -vv-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_39505245/article/details/124705850\">Git基础 - git tag 一文真正的搞懂git标签的使用-CSDN博客</a></p>\n<h3 id=\"git下载\"><a href=\"#git下载\" class=\"headerlink\" title=\"git下载\"></a>git下载</h3><p><strong>官网：</strong> <a href=\"https://git-scm.com/downloads\">https://git-scm.com/downloads</a></p>\n<h2 id=\"git使用方法\"><a href=\"#git使用方法\" class=\"headerlink\" title=\"git使用方法\"></a>git使用方法</h2><h4 id=\"注册GitHub账号\"><a href=\"#注册GitHub账号\" class=\"headerlink\" title=\"注册GitHub账号\"></a>注册GitHub账号</h4><p>账号：1</p>\n<p>密码：1</p>\n<h4 id=\"git注册\"><a href=\"#git注册\" class=\"headerlink\" title=\"git注册\"></a>git注册</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-string\">//</span>设置账号，如果去掉 <span class=\"hljs-params\">--global</span> 参数只对当前仓库有效。<br>$ git config <span class=\"hljs-params\">--global</span> user.name <span class=\"hljs-string\">&quot;zhengyiyang&quot;</span><br><br><span class=\"hljs-string\">//</span>设置邮箱，如果去掉 <span class=\"hljs-params\">--global</span> 参数只对当前仓库有效。<br>$ git config <span class=\"hljs-params\">--global</span> user.email <span class=\"hljs-string\">&quot;903372205@qq.com&quot;</span><br><br><span class=\"hljs-string\">//</span>设置SSH，如果去掉 <span class=\"hljs-params\">--global</span> 参数只对当前仓库有效。<br>$ ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;903372205@qq.com&quot;</span><br><br>储存位置：<span class=\"hljs-string\">/c/Users/114008/.ssh/id_rsa</span><br><br>id_rsa.pub为公共密钥<br>id_rsa为私人密钥<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"github配置SSH\"><a href=\"#github配置SSH\" class=\"headerlink\" title=\"github配置SSH\"></a>github配置SSH</h4><p><strong>打开id_rsa.pub文件，全选，复制全文</strong></p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-function\"><span class=\"hljs-title\">ssh</span></span>-rsa AAAAB3NzaC1yc2EA...<br></code></pre></td></tr></table></figure>\n\n<p><strong>github-&gt;账户-&gt;setting</strong></p>\n<p>Title：1</p>\n<p>Key type：Authentication Key</p>\n<h4 id=\"测试是否成功连接\"><a href=\"#测试是否成功连接\" class=\"headerlink\" title=\"测试是否成功连接\"></a>测试是否成功连接</h4><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">$ ssh -T git@github.com<br>//代表成功连接<br>Hi yangyangdeyi0119! You<span class=\"hljs-symbol\">&#x27;ve</span> successfully authenticated, but GitHub does <span class=\"hljs-keyword\">not</span> provide shell <span class=\"hljs-keyword\">access</span>.  <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"建立Github云端仓库\"><a href=\"#建立Github云端仓库\" class=\"headerlink\" title=\"建立Github云端仓库\"></a>建立Github云端仓库</h4><p><a href=\"https://blog.csdn.net/qq_44722674/article/details/117200397\">github仓库建立及配置教程新手教程_github创建仓库-CSDN博客</a></p>\n<p>修改用户名</p>\n<p><a href=\"https://blog.csdn.net/weixin_44285445/article/details/107833418\">GitHub修改昵称和用户名（图解详细教程）_github改名-CSDN博客</a></p>\n<h4 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//首先需要新建一个文件夹作为本地仓库</span><br><span class=\"hljs-comment\">//初始化该文件为本地仓库</span><br><span class=\"hljs-symbol\">$</span> git init  <br><br><span class=\"hljs-comment\">//下载下来的test文件夹也是本地仓库</span><br><span class=\"hljs-symbol\">$</span> git clone https:<span class=\"hljs-comment\">//github.com/yangyangdeyi0119/test.git  </span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"将文件加入暂存区\"><a href=\"#将文件加入暂存区\" class=\"headerlink\" title=\"将文件加入暂存区\"></a>将文件加入暂存区</h4><p>文件本身在工作区，需要通过文件锁定，将其加入暂存区</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-comment\">//可以同时添加多个文件夹</span><br>$ git <span class=\"hljs-keyword\">add</span> /test /test1<br><br><span class=\"hljs-comment\">//添加单个文件</span><br>$ git <span class=\"hljs-keyword\">add</span> README.md <br>   <br>   <span class=\"hljs-comment\">//将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除  </span><br>$ git <span class=\"hljs-keyword\">add</span> .   <br><br><span class=\"hljs-comment\">//将文件包的所有文件加入暂存区</span><br>$ git <span class=\"hljs-keyword\">add</span> -f .<br>   <br>   <span class=\"hljs-comment\">//将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。 </span><br>$ git <span class=\"hljs-keyword\">add</span> -u <br><br><span class=\"hljs-comment\">//表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。</span><br>$ git <span class=\"hljs-keyword\">add</span> -A<br><br><span class=\"hljs-comment\">//暂存区各类状态</span><br>- untracked 未跟踪（未被纳入版本控制）<br>- tracked 已跟踪（被纳入版本控制）<br>- Unmodified 未修改状态<br>- Modified 已修改状态<br>- Staged 已暂存状态<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"将文件移除暂存区\"><a href=\"#将文件移除暂存区\" class=\"headerlink\" title=\"将文件移除暂存区\"></a>将文件移除暂存区</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//仅删除暂存区的文件，不影响工作区的文件</span><br><span class=\"hljs-symbol\">$</span> git rm --cache &lt;<span class=\"hljs-keyword\">file</span>/aaa&gt;<br><br><span class=\"hljs-comment\">//删除暂存区和工作区的文件</span><br><span class=\"hljs-symbol\">$</span> git rm -f &lt;<span class=\"hljs-keyword\">file</span>/aaa&gt;<br><br><span class=\"hljs-comment\">//撤销对暂存区的修改。这个命令主要用于丢弃或还原文件的更改(测试未成功)</span><br><span class=\"hljs-symbol\">$</span> git restore --staged &lt;<span class=\"hljs-keyword\">file</span>/aaa&gt;<br><br><span class=\"hljs-comment\">//将分支回退到之前的提交，并且还可以选择是否保留暂存区的更改</span><br><span class=\"hljs-symbol\">$</span> git reset<br><br><span class=\"hljs-comment\">//撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是工作区</span><br><span class=\"hljs-symbol\">$</span> git checkout 文件名<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"查看文件状态\"><a href=\"#查看文件状态\" class=\"headerlink\" title=\"查看文件状态\"></a>查看文件状态</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//获取文件状态-完整</span><br><span class=\"hljs-symbol\">$</span> git status<br><br><span class=\"hljs-comment\">//获取文件状态-简洁</span><br><span class=\"hljs-symbol\">$</span> git status -s 更加简洁<br>\t<span class=\"hljs-string\">&#x27; &#x27;</span> （空格）表示文件未发生更改<br>\tM 表示文件发生改动。<br>\tA 表示新增文件。<br>\tD 表示删除文件。<br>\tR 表示重命名。<br>\tC 表示复制。<br>\tU 表示更新但未合并。<br>\t? 表示未跟踪文件。<br>\t! 表示忽略文件。<br><br><span class=\"hljs-comment\">//显示分支和跟踪信息 --branch</span><br><span class=\"hljs-symbol\">$</span> git status -s -b<br><br><span class=\"hljs-comment\">//显示变更的文本内容，在不使用 -s 选项时才会显示变更内容</span><br><span class=\"hljs-comment\">//只有一个 -v 选项时，显示版本库和暂存区之间比较发生变更的内容。</span><br><span class=\"hljs-symbol\">$</span> git status -v<br><span class=\"hljs-comment\">//而有两个 -v 选项时，显示暂存区和工作区之间比较发生变更的内容。</span><br><span class=\"hljs-symbol\">$</span> git status -v -v<br><br><span class=\"hljs-comment\">//显示未跟踪文件</span><br><span class=\"hljs-symbol\">$</span> git status -s -u[&lt;mode&gt;]<br>\t<span class=\"hljs-keyword\">no</span> —— 不显示未跟踪的文件<br>\t<span class=\"hljs-built_in\">normal</span> —— 显示未跟踪的文件和目录。<br>\t<span class=\"hljs-keyword\">all</span> —— 还显示了未跟踪目录下的文件<br>\t<br><span class=\"hljs-comment\">//用来查看暂存区中文件信息</span><br><span class=\"hljs-symbol\">$</span> git ls-<span class=\"hljs-keyword\">files</span> -参数<br>\t--cached(-c)显示暂存区中的文件，git ls-<span class=\"hljs-keyword\">files</span>命令默认的参数<br>\t--deleted(-d)显示删除的文件<br>\t--modified(-m) 显示修改过的文件<br>\t--other(-o)显示没有被git跟踪的文件<br>\t--stage(-s) 显示mode以及文件对应的Blob对象，进而我们可以获取暂存区中对应文件里面的内容。<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"文件加入分支\"><a href=\"#文件加入分支\" class=\"headerlink\" title=\"文件加入分支\"></a>文件加入分支</h4><p>提交更改，实际上就是把暂存区的所有内容提交到当前分支，需要提交的文件修改通通放到暂存区；然后，一次性提交暂存区的所有修改</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">// 把暂存区的所有修改提交到分支，须输入描述信息</span><br><span class=\"hljs-symbol\">$</span> git commit -m <span class=\"hljs-string\">&quot;描述信息&quot;</span><br><br><span class=\"hljs-comment\">//更改之前一次commit的描述信息</span><br><span class=\"hljs-symbol\">$</span> git commit --amend<br><br><span class=\"hljs-comment\">//提交暂存区的指定文件到仓库区（不行，最好单个提交git add，然后在git commit）</span><br><span class=\"hljs-symbol\">$</span> git commit &lt;file1&gt; &lt;file2&gt; ... -m <span class=\"hljs-string\">&quot;message&quot;</span><br><br><span class=\"hljs-comment\">//-a 参数设置修改文件后不需要执行 git add 命令，直接来提交（不好用）</span><br><span class=\"hljs-symbol\">$</span> git commit -a<br><br>出现报错<span class=\"hljs-string\">&quot;nothing to commit, working tree clean&quot;</span><br>   只需要修改该文件夹下的任意一个文件，因为检测到版本未发生改变<br>   <br>   <span class=\"hljs-comment\">//查找推送版本号</span><br>   <span class=\"hljs-symbol\">$</span> git <span class=\"hljs-built_in\">log</span> <br>   <br>   <span class=\"hljs-comment\">//选择回退版本，回退后，版本之后的将会丢失</span><br>   git reset --hard &lt;目标版本号&gt;<br>   <br>   <span class=\"hljs-comment\">//软回退，不修改代码，回到暂存区</span><br>   git reset --soft HEAD~n<br>   <br>   <span class=\"hljs-comment\">//只显示一行信息</span><br>   git <span class=\"hljs-built_in\">log</span> --oneline<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h4><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//创建分支命令</span><br><span class=\"hljs-symbol\">$</span> git branch &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//切换分支命令</span><br><span class=\"hljs-symbol\">$</span> git checkout &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//列出分支</span><br>git branch<br><span class=\"hljs-comment\">//查看本地分支+上次提交的信息</span><br><span class=\"hljs-symbol\">$</span> git branch -v<br><span class=\"hljs-comment\">//查看本地分支+远程分支</span><br><span class=\"hljs-symbol\">$</span> git branch -a<br>\t- 红色代表云端仓库分支<br>\t- 白色代表本地仓库分支<br>\t- 绿色代表目前所在分支<br><span class=\"hljs-comment\">//查看本地分支+上次提交的信息+本地和远程分支的关系</span><br><span class=\"hljs-symbol\">$</span> git branch -vv<br><span class=\"hljs-comment\">//查看本地分支+上次提交的信息+本地和远程分支的关系+远程分支</span><br><span class=\"hljs-symbol\">$</span> git branch -vv -a<br><span class=\"hljs-comment\">//只查看远程分支</span><br><span class=\"hljs-symbol\">$</span> git branch -r<br><br><span class=\"hljs-comment\">//创建新分支并立即切换到该分支下</span><br><span class=\"hljs-symbol\">$</span> git checkout -b &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//删除本地分支</span><br><span class=\"hljs-symbol\">$</span> git branch -d &lt;branchname&gt;<br><span class=\"hljs-comment\">//强制删除分支</span><br><span class=\"hljs-symbol\">$</span> git branch -D aaa<br><br><span class=\"hljs-comment\">//合并分支</span><br><span class=\"hljs-symbol\">$</span> git merge &lt;branchname&gt;<br><br><span class=\"hljs-comment\">//删除远程分支</span><br><span class=\"hljs-symbol\">$</span> git push &lt;主机名&gt; -d &lt;分支名&gt;<br><br><span class=\"hljs-comment\">//将本地分支推送到远程分支，如果远程分支不存在，则创建。</span><br><span class=\"hljs-symbol\">$</span> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br><span class=\"hljs-symbol\">$</span> git push --<span class=\"hljs-keyword\">set</span>-upstream <span class=\"hljs-comment\">origin dev</span><br><br><span class=\"hljs-comment\">//跟踪远程分支</span><br>git <span class=\"hljs-comment\">checkout -b zhanghanlun origin</span>/zhanghanlun<br><span class=\"hljs-comment\">//用于解决远程 HEAD 指向一个不存在的引用，无法检出。</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"将文件推送到云端仓库\"><a href=\"#将文件推送到云端仓库\" class=\"headerlink\" title=\"将文件推送到云端仓库\"></a>将文件推送到云端仓库</h4><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">//第一次推送代码指令<br>$ git push -u origin &lt;branchname&gt;<span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//-u参数可以在推送的同时,将origin仓库的master分支设置为本地仓库当前分支的upstream(上游)。添加了这个参数,将来运行git pull命令从远程仓库获取内容时,本地仓库的的这个分支就可以直接从origin的master分支获取内容,省去了另外添加参数的麻烦。</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//之后推送</span><br>$ git push origin master<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//不同分支之间推送</span><br>$ git push -u origin &lt;branchname1&gt;:origin/&lt;branchname2&gt;<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//云端仓库分支更新到本地仓库</span><br>$ git remote update origin<br>\t后缀加上 <span class=\"hljs-comment\">--prune则可以与云端仓库分支一致，多余的会被删除</span><br>\t<span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//报错</span><br>error: failed <span class=\"hljs-built_in\">to</span> push some refs <span class=\"hljs-built_in\">to</span> <span class=\"hljs-string\">&#x27;https://github.com/yangyangdeyi0119/Learning.git&#x27;</span><br>hint: Updates were rejected because <span class=\"hljs-keyword\">the</span> remote <span class=\"hljs-keyword\">contains</span> work that you <span class=\"hljs-built_in\">do</span> <span class=\"hljs-keyword\">not</span><br>hint: have locally. This is usually caused <span class=\"hljs-keyword\">by</span> another repository pushing <span class=\"hljs-built_in\">to</span><br>hint: <span class=\"hljs-keyword\">the</span> same ref. If you want <span class=\"hljs-built_in\">to</span> integrate <span class=\"hljs-keyword\">the</span> remote changes, use<br>hint: <span class=\"hljs-string\">&#x27;git pull&#x27;</span> <span class=\"hljs-keyword\">before</span> pushing again.<br>hint: See <span class=\"hljs-keyword\">the</span> <span class=\"hljs-string\">&#x27;Note about fast-forwards&#x27;</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&#x27;git push --help&#x27;</span> <span class=\"hljs-keyword\">for</span> details.<br>直接git pull之后就可以了<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//删除现有远程仓库</span><br>$ git remote rm origin<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//添加新远程仓库</span><br>$ git remote <span class=\"hljs-built_in\">add</span> origin url<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//查看远程仓库的地址</span><br>$ git remote -v<br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">//更换远程仓库地址，URL为新地址</span><br>$ git remote <span class=\"hljs-built_in\">set</span>-url origin <span class=\"hljs-built_in\">URL</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"暂存空间使用\"><a href=\"#暂存空间使用\" class=\"headerlink\" title=\"暂存空间使用\"></a>暂存空间使用</h4><p>stash是本地的，不会通过git push命令上传到git server上</p>\n<p>发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑git stash。</p>\n<p>使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用git stash就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用git stash apply将以前一半的工作应用回来。</p>\n<p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//将未提交的修改保存至堆栈中</span><br><span class=\"hljs-symbol\">$</span> git stash<br><br><span class=\"hljs-comment\">//为此次stash添加说明信息，便于以后查看</span><br><span class=\"hljs-symbol\">$</span> git stash save <span class=\"hljs-string\">&quot;stash message info&quot;</span>  <br><br><span class=\"hljs-comment\">//查看stash栈中的内容</span><br><span class=\"hljs-symbol\">$</span> git stash list<br><br><span class=\"hljs-comment\">//将stash中的内容弹出，并应用到当前分支对应的工作目录上，该命令将堆栈中最近保存的内容删除（出栈操作）</span><br><span class=\"hljs-symbol\">$</span> git stash pop<br><br><span class=\"hljs-comment\">//将指定id的内容应用到当前分支的工作目录，内容不会删除，可以在多个分支上重复进行操作</span><br><span class=\"hljs-symbol\">$</span> git stash apply stash名称<br><br><span class=\"hljs-comment\">//从堆栈中移除某个指定的stash</span><br><span class=\"hljs-symbol\">$</span> git stash drop stash名称<br><br><span class=\"hljs-comment\">//清除堆栈中的所有内容</span><br><span class=\"hljs-symbol\">$</span> git stash clear<br><br><span class=\"hljs-comment\">//查看堆栈中最新保存的stash和当前目录的差异。</span><br><span class=\"hljs-symbol\">$</span> git stash show<br><br><span class=\"hljs-comment\">//从最新的stash创建分支。</span><br><span class=\"hljs-symbol\">$</span> git stash branch<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"代码标签\"><a href=\"#代码标签\" class=\"headerlink\" title=\"代码标签\"></a>代码标签</h4><p>tag 中文我们可以称它为标签，tag 就是 对某次 commit 的一个标识，相当于起了一个别名。</p>\n<p>【轻量标签 】： 只是某个commit 的引用，可以理解为是一个commit的别名；</p>\n<p>【附注标签】 ：是存储在git仓库中的一个完整对象，包含打标签者的名字、电子邮件地址、日期时间以及其他的标签信息。它是可以被校验的，可以使用 GNU Privacy Guard (GPG) 签名并验证。</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//直接列出所有的标签</span><br><span class=\"hljs-symbol\">$</span> git tag<br><br><span class=\"hljs-comment\">//可以根据&lt;tagname&gt;进行标签的筛选</span><br><span class=\"hljs-symbol\">$</span> git tag -l &lt;tagname*&gt;<br><br><span class=\"hljs-comment\">//查看标签的提交信息</span><br><span class=\"hljs-symbol\">$</span> git show 标签名<br><br><span class=\"hljs-comment\">//在提交历史中查看标签</span><br><span class=\"hljs-symbol\">$</span> git <span class=\"hljs-built_in\">log</span> --online --graph<br><br><span class=\"hljs-comment\">//创建轻量标签</span><br><span class=\"hljs-symbol\">$</span> git tag 标签名<br><span class=\"hljs-symbol\">$</span> git tag 标签名 提交版本<br><br><span class=\"hljs-comment\">//创建附注标签</span><br><span class=\"hljs-symbol\">$</span> git tag -a 标签名称 -m 附注信息<br><span class=\"hljs-symbol\">$</span> git tag -a 标签名称 提交版本号 -m 附注信息<br>\t-a : 理解为 annotated 的首字符，表示 附注标签<br>\t<br><span class=\"hljs-comment\">//删除标签</span><br>git tag -d 标签名称<br><br><span class=\"hljs-comment\">//将指定的标签上传到远程仓库</span><br><span class=\"hljs-symbol\">$</span> git push origin &lt;tagname&gt;<br><br><span class=\"hljs-comment\">//将所有不在远程仓库中的标签上传到远程仓库</span><br><span class=\"hljs-symbol\">$</span> git push origin --tags<br><br><span class=\"hljs-comment\">//删除远程仓库中的 指定标签</span><br><span class=\"hljs-symbol\">$</span> git push origin  :regs/tags/&lt;tagname&gt;<br><span class=\"hljs-symbol\">$</span> git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"一台电脑多个ssh账号的注册\"><a href=\"#一台电脑多个ssh账号的注册\" class=\"headerlink\" title=\"一台电脑多个ssh账号的注册\"></a>一台电脑多个ssh账号的注册</h4><p>情况所有的ssh，不清空也行，清空更快一些</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">git config <span class=\"hljs-attr\">--global</span> <span class=\"hljs-attr\">--unset</span> user<span class=\"hljs-selector-class\">.name</span><br>git config <span class=\"hljs-attr\">--global</span> <span class=\"hljs-attr\">--unset</span> user.email<br></code></pre></td></tr></table></figure>\n\n<p>注册两个账号</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">生成github的ssh-key，注册邮箱填github的注册邮箱，然后在用户主目录下/.ssh/下会生成id_rsa(私钥)、id_rsa.pub(公钥)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;注册邮箱&quot;</span> -f ~/.ssh/id_rsa</span> <br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">生成gitlab的ssh-key，注册邮箱填gitlab的注册邮箱,然后在用户主目录下/.ssh/下会生成id_rsa_work(私钥)、id_rsa_work.pub(公钥)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;注册邮箱&quot;</span> -f ~/.ssh/id_rsa_work</span><br></code></pre></td></tr></table></figure>\n\n<p>添加全局权限，可以不用每次都输密码</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>ssh-agent bash<br><span class=\"hljs-variable\">$ </span>ssh-add ~<span class=\"hljs-regexp\">/.ssh/id</span>_rsa<br><span class=\"hljs-variable\">$ </span>ssh-add ~<span class=\"hljs-regexp\">/.ssh/id</span>_rsa_work<br><span class=\"hljs-variable\">$ </span>ssh-add -l <br><span class=\"hljs-comment\">#如果添加成功，这里会打印对应的配置信息</span><br></code></pre></td></tr></table></figure>\n\n<p>配置config文件</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">$ vim ~<span class=\"hljs-regexp\">/.ssh/</span>config  <span class=\"hljs-regexp\">//</span>创建配置文件<br><br><span class=\"hljs-comment\"># 账号1-github</span><br>HOST github.com <span class=\"hljs-comment\">#github别名</span><br>hostname github.com  <span class=\"hljs-comment\">#github地址</span><br>User githubUsername <span class=\"hljs-comment\">#github用户名</span><br>IdentityFile <span class=\"hljs-regexp\">/home/u</span>ser<span class=\"hljs-regexp\">/.ssh/i</span>d_rsa_work <span class=\"hljs-comment\">#github私钥地址</span><br>PreferredAuthentications publickey <span class=\"hljs-comment\">#首选认证方式</span><br><br><span class=\"hljs-comment\"># 账号2-creality</span><br>HOST gerrit <span class=\"hljs-comment\">#gitlab私服别名</span><br>hostname xxx.xx.xxx.xx <span class=\"hljs-comment\">#gitlab私服地址</span><br>Port xxxx <span class=\"hljs-comment\">#端口</span><br>User xxxxxxxxxx <span class=\"hljs-comment\">#填写gitlab私服的用户名</span><br>IdentityFile <span class=\"hljs-regexp\">/home/u</span>ser<span class=\"hljs-regexp\">/.ssh/i</span>d_rsa_work <span class=\"hljs-comment\">#gitlab私钥地址</span><br>PreferredAuthentications publickey <span class=\"hljs-comment\">#首选认证方式</span><br></code></pre></td></tr></table></figure>\n\n<p>需要去网站上面配置ssh，参照最上面内容</p>\n<p>测试是否连接成功</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>ssh -T git<span class=\"hljs-variable\">@github</span>.com<br><span class=\"hljs-variable\">$ </span>ssh -T git<span class=\"hljs-variable\">@git</span>.gitlab.com<br></code></pre></td></tr></table></figure>\n\n<p>遇到的问题<br>1.测试Gitlab的SSH Key是否连接成功，出现Permission denied (publickey).</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang\"><span class=\"hljs-string\">$ </span>ssh -T git@git.gitlab.com<br>git@git.gitlab.com: Permission denied (publickey).<br><br>#使用ssh -v查看详细日志<br><span class=\"hljs-string\">$ </span>ssh -vT git@git.gitlab.com<br>...<br>...<br>debug1: send_pubkey_test: no mutual signature algorithm<br>debug1: No more authentication methods to <span class=\"hljs-keyword\">try</span>.<br>git@git.gitlab.com: Permission denied (publickey).<br></code></pre></td></tr></table></figure>\n\n<p>关注的最后面三行日志，显示没有匹配的算法，查阅相关资料，openssh8.2版本之后，默认关闭SSH-RSA算法，该算法存在安全隐患（OpenSSH to deprecate SHA-1 logins due to security risk | ZDNet），当然我们可以重新启用它，但存在安全风险。在config的Gitlab配置中添加如下一行</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">PubkeyAcceptedKeyTypes</span> +ssh-rsa<br>再次运行<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">$ ssh -T git@git.gitlab.<span class=\"hljs-keyword\">com</span><br>出现 You’<span class=\"hljs-keyword\">ve</span> successfully authenticated, but GitHub does not provide <span class=\"hljs-keyword\">shell</span> access，连接成功！<br></code></pre></td></tr></table></figure>\n\n<p>最后在对应的项目下设置对应的用户名以及邮箱名就可以快乐的提交代码了</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git config  <span class=\"hljs-keyword\">user</span>.email &quot;useremail&quot;<br>git config  <span class=\"hljs-keyword\">user</span>.name &quot;username&quot;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"私有库的访问\"><a href=\"#私有库的访问\" class=\"headerlink\" title=\"私有库的访问\"></a>私有库的访问</h2><p>私有库的访问需要设置token，在git clone 的时候输入密码时把token输入进去，才可以实现git clone出来</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">S<span class=\"hljs-function\"><span class=\"hljs-title\">ettings</span>-&gt;</span>D<span class=\"hljs-function\"><span class=\"hljs-title\">eveloper</span> settings-&gt;</span>P<span class=\"hljs-function\"><span class=\"hljs-title\">ersonal</span> access tokens-&gt;</span>Generate new token。<br>创建新的访问密钥，勾选repo栏，选择有效期，为密钥命名。<br>复制这段密钥。（注意，密钥只显示一次，记得妥善保管）<br>git push时，作为用户密码来使用。<br></code></pre></td></tr></table></figure>\n\n<p>私有库每次都需要输入账号密码的解决办法</p>\n<p>全局设置（只有一个账号）</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">git config <span class=\"hljs-attr\">--global</span> credential<span class=\"hljs-selector-class\">.helper</span> store<br><br>git config <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.email</span> <span class=\"hljs-string\">&quot;email&quot;</span><br>git confgi <span class=\"hljs-attr\">--global</span> user<span class=\"hljs-selector-class\">.name</span> <span class=\"hljs-string\">&quot;name&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>局部设置（多个账号）</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\">## <span class=\"hljs-keyword\">local</span><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">local</span> credential<span class=\"hljs-variable\">.helper</span> store<br><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">local</span> user<span class=\"hljs-variable\">.email</span> <span class=\"hljs-string\">&quot;email&quot;</span><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">local</span> user<span class=\"hljs-variable\">.name</span> <span class=\"hljs-string\">&quot;name&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>之后配置token</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\"><span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">https</span>://<span class=\"hljs-string\">github</span>.<span class=\"hljs-string\">com</span>/<span class=\"hljs-string\">xxx</span>/<span class=\"hljs-string\">xxx</span>.<span class=\"hljs-string\">git</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"C语言学习","date":"2024-07-30T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/jBIEv4rcQJnSp1K.jpg","_content":"\n# C语言学习\n\n### void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值\n\n```\nvoid *memset(void *str, int c, size_t n);\n*str  //要指向填充的内存区域指针\nc  //代表要填充的值\nn  //要被设置的字节数\n```\n\n```\n    char str[10];\n    memset(str, 'a', 9); //将str字符前九个填入字符a，要注意是''号，不能是\"\"，\"\"代表的是字符串\n    printf(\"output: %s\\n\",str);\n    memset(str, '\\0' ,10); //将str字符前九个填入字符'\\0'或者0，可以将字符串进行清零操作\n    printf(\"output: %s\\n\",str);\n    return 0;\n    \n//output: aaaaaaaaa\n//output:\n```\n\n### return 0\n\n**没有返回值的函数为空类型，用`void`表示**。一旦函数的返回值类型被定义为 void，就不能再接收它的值，即若函数没有返回值\n\n返回值的类型必须与函数定义类型一致。例如：在返回类型是**char的函数**中，return后应该是char类型的值。\n\n```\nreturn 表达式; return (表达式); 为了简明，（）一般不写。例如：return 0\n\nreturn 0；表示程序正常退出，即当return语句提供了一个值时，这个值就成为函数的返回值。\nreturn 1；表示程序异常退出，返回主调函数来处理，继续往下执行。\n```\n\n### void *memcpy(void *str1, const void *str2, size_t n)从存储区 **str2** 复制 **n** 个字节到存储区 str1\n\n```\nstr1  //代表用于存储复制内容的目标数组\nstr2  //代表被复制内容的目标数组\nn  //代表需要从str复制n个字节到str1\n```\n\n```\n    char str_1[256] = \"123456sdadasdadasdasda7454589\";\n    char str_2[256];\n \n    memcpy(&str_2[0] ,str_1 ,strlen(str_1));//strlen(str_1)获取str_1字符串的字节，然后将str_1的字符串复制strlen(str_1)个字节到str_2\n    printf(\"output: %s\\n\",str_2);\n    \n//output: aaaaaaaaa\n//output: aa\n```\n\n### 储存区\n\n```\n内存分配可分为三种：静态存储区、栈区、堆区。\n\n1、静态存储区：该内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，它主要存放静态数据、全局数据和常量。\n\n2、栈区：它的用途是完成函数的调用。在执行函数时，函数内局部变量及函数参数的存储单元在栈上创建，函数调用结束时这些存储单元自动被释放。\n\n3、堆区：程序在运行时使用库函数为变量申请内存，在变量使用结束后再调用库函数释放内存。动态内存的生存期是由我们决定的，如果我们不释放内存，就会导致内存泄漏。\n\nstatic char line[LINE_SIZE] = {0};\n//静态变量的生命周期贯穿整个程序运行期间，适合需要长期保存数据的场景\n\nchat *line = \"0\"\n//多个指针可以共享相同的字符串字面量，节省内存，字符串字面量是不可变的，试图修改会导致未定义行为。\n\nchar str[LINE_SIZE] = \"0\"\n//字符数组在声明时可以初始化为一个特定的字符串，数组的其余部分为未初始化（通常是随机值）。对于局部变量，栈空间有限，大数组可能导致栈溢出\n```\n\n### char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\n\n```\nstr  //所要查询的字符\nc  //代表所要查找的字符，单个字符需要用''符号，否则警告\n```\n\n```\n    char str_1[256] = \"asdfghjklzxcvbnm\";\n    char str_2[256];\n\n    char *find = strchr(str_1, 'z');  //查找str_1里面的z字符，并将指针指向这个位置\n    if(find){  //判断是否找到，如果找到，则将其替换成换行符，等于舍弃后面的内容\n        *find = '\\0';\n    }\n    memcpy(str_2 ,str_1 ,strlen(str_1));  //将str_1的字符全部复制给str_2，由于上述指针指的位置替换成了换行符，所以到此字符进行截断\n    printf(\"output: %s\\n\",str_2);  //所以输出的是z前面的字符\n    \n//output\noutput: asdfghjkl\n```\n\n#### char \\*strcpy(char \\*dest, const char \\*src)把 **src** 所指向的字符串复制到 dest\n\n```\nchar *strcpy(char *dest, const char *src)\n\n//dest -- 指向用于存储复制内容的目标数组。\n//src -- 要复制的字符串。\n\n\tchar str_1[256] = \"123456sdadasdadasdasda7454589\";\n    char str_3[256];\n    printf(\"output: %s\\n\",str_1);\n    \n    strcpy(str_3,str_1);\n    printf(\"output: %s\\n\",str_3);\n    \n//output\noutput: 123456sdadasdadasdasda7454589\noutput: 123456sdadasdadasdasda7454589\n```\n\nstrcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等\n\nstrcpy不需要指定长度，它遇到被复制字符的串结束符\"\\0\"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度\n\n### strcat()\n\n```\n//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾\nchar *strcat(char *dest, const char *src) \n\t//dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。\n\t//src -- 指向要追加的字符串，该字符串不会覆盖目标字符串。\n```\n\n### strcmp()\n\n```\n//把 str1 所指向的字符串和 str2 所指向的字符串进行比较\nint strcmp(const char *str1, const char *str2) \n\t//str1 -- 要进行比较的第一个字符串。\n\t//str2 -- 要进行比较的第二个字符串。\n\t\n\t//返回值\n\t如果返回值小于 0，则表示 str1 小于 str2。\n\t如果返回值大于 0，则表示 str1 大于 str2。\n\t如果返回值等于 0，则表示 str1 等于 str2。\n```\n\n### 判断式if\n\n根据上面的内容进行假设，由于strchr如果找到，则返回该值所在的位置，如果没有找到，则返回NULL空值\n\n如果我想要他返回真值时定义操作，我的函数可以写为\n\n```\nif(find){\n    *find = '\\0';\n}\n或者\nif(find != NULL){\n    *find = '\\0';\n}\n```\n\n如果我想要发返回空值时定义操作，函数可以写为\n\n```\nif(find = NULL){\n    *find = '\\0';\n}\n或者\nif(!find){\n    *find = '\\0';\n}\n```\n\n### 正则表达式\n\n正则表达式的使用流程\n\n```\n编译正则表达式 regcomp()\n匹配正则表达式 regexec()\n释放正则表达式 regfree()\n```\n\n#### 1.regcomp()\n\n```\n//把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效\nint regcomp (regex_t *compiled, const char *pattern, int cflags)\n\n//regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。\n//pattern 是指向我们写好的正则表达式的指针。\n//cflags 有如下4个值或者是它们或运算(|)后的值：\n\t//REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。\n\t//REG_ICASE 匹配字母时忽略大小写。\n\t//REG_NOSUB 不用存储匹配后的结果。\n\t//REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配。\n```\n\n#### 2.regexec()\n\n```\n//在编译正则表达式的时候没有指定cflags的参数REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。\nint regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags)\n\n//compiled 是已经用regcomp函数编译好的正则表达式。\n//string 是目标文本串。\n//nmatch 是regmatch_t结构体数组的长度。\n//matchptr regmatch_t类型的结构体数组，存放匹配文本串的位置信息。\n//eflags 有两个值\n\t//REG_NOTBOL 按我的理解是如果指定了这个值，那么’^’就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义；\n\t//REG_NOTEOL 和上边那个作用差不多，不过这个指定结束end of line。\n\t\n//通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。\t\ntypedef struct\n{\n   regoff_t rm_so;\n   regoff_t rm_eo;\n} regmatch_t;\n//成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。\n\n```\n\n#### 3.regfree()\n\n```\n//如果是重新编译的话，一定要先清空regex_t结构体。\nvoid regfree (regex_t *compiled)\n```\n\n#### 4.regerror\n\n```\n//当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。\nsize_t regerror (int errcode, regex_t *compiled, char *buffer, size_t length)\n\n//errcode 是由regcomp 和 regexec 函数返回的错误代号。\n//compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。\n//buffer 指向用来存放错误信息的字符串的内存空间。\n//length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。\n```\n\n### void bzero(void \\*s, int n);将内存块（字符串）的前n个字节清零\n\n```\n    char str_1[256] = \"123456sdadasdadasdasda7454589\";\n    printf(\"str_1:%s\\n\",str_1);\n    char str_2[256] = bzero(str_1,sizeof(str_1));\n    printf(\"str_2:%s\\n\",str_2);\n\n//bzero不是标准C库，逐渐被memset替代\n```\n\n### int atoi(const char *str)把参数 **str** 所指向的字符串转换为一个整数（类型为 int 型）\n\n```\n    char str_1[] = \"2147483647\";//int的整数值只能是4字节，所以不能超过2147483647\n    printf(\"str_1:%s\\n\",str_1);\n\n    int str_2 = atoi(&str_1);//转换成整数型\n    printf(\"str_2:%d\\n\",str_2);\n    printf(\"Size of int = %ld bytes \\n\", sizeof(str_2));//输出字符的字节长度\n```\n\n### 位、字节的关系\n\n```\n1 Byte = 8 bit\n1 KB = 1024 Byte\n1 MB = 1024 KB\n1 GB = 1024 MB\n\n8位无符号的最大值就是1111 1111，最大值是255，即就是 (2^8)-1。\n然而有符号只是在此基础上让8位中的第一位充当符号位，0代表正数，1代表负数。\n8位有符号的最大值就是0111 1111，最大值是+127，即就是 (2^7)-1，\n8位有符号的最小值就是1000 0000，最小值是-128，即就是 -2^7，\n\n4字节（32位）\n最大值 （2^31）- 1   2147483647\n最小值 - 2^31  -2147483648\n```\n\n### 指针配合while循环函数实现无限循环处理不同消息\n\n    // 解析数据，定义*answer指针指向klipperAcceptBuffer接收数据\n    char *answer = klipperAcceptBuffer;\n    //进入字符读取过程循环，读完利用指针指向下一帧，继续开始循环\n    while (answer)\n    {\n    \t// 查找数据帧结束符‘0x03’\n    \tchar *answerEnd = strchr(answer, 0x03);\n    \t\n    \t......\n    \t\n    \t// 继续处理下一个数据帧\n    \tanswer = answerEnd + 1;  \n    }\n\n### strstr() 查找第一次出现字符串的位置\n\n```\n//在字符串 haystack 中查找第一次出现字符串 needle 的位置\nchar *strstr(const char *haystack, const char *needle) \n```\n\n### snprintf()\n\n```\n//将可变参数(...)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断，最多写入 size-1 个字符。\nint snprintf(char *str, size_t size, const char *format, ...) \n\t//str -- 目标字符串，用于存储格式化后的字符串的字符数组的指针。\n\t//size -- 字符数组的大小。\n\t//format -- 格式化字符串。\n```\n\n","source":"_posts/Work No.8.md","raw":"---\ntitle: C语言学习\ntag: C/C++\ndate: 2024-07-31\ncategories: C/C++\nindex_img: https://s2.loli.net/2024/07/31/jBIEv4rcQJnSp1K.jpg\n---\n\n# C语言学习\n\n### void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值\n\n```\nvoid *memset(void *str, int c, size_t n);\n*str  //要指向填充的内存区域指针\nc  //代表要填充的值\nn  //要被设置的字节数\n```\n\n```\n    char str[10];\n    memset(str, 'a', 9); //将str字符前九个填入字符a，要注意是''号，不能是\"\"，\"\"代表的是字符串\n    printf(\"output: %s\\n\",str);\n    memset(str, '\\0' ,10); //将str字符前九个填入字符'\\0'或者0，可以将字符串进行清零操作\n    printf(\"output: %s\\n\",str);\n    return 0;\n    \n//output: aaaaaaaaa\n//output:\n```\n\n### return 0\n\n**没有返回值的函数为空类型，用`void`表示**。一旦函数的返回值类型被定义为 void，就不能再接收它的值，即若函数没有返回值\n\n返回值的类型必须与函数定义类型一致。例如：在返回类型是**char的函数**中，return后应该是char类型的值。\n\n```\nreturn 表达式; return (表达式); 为了简明，（）一般不写。例如：return 0\n\nreturn 0；表示程序正常退出，即当return语句提供了一个值时，这个值就成为函数的返回值。\nreturn 1；表示程序异常退出，返回主调函数来处理，继续往下执行。\n```\n\n### void *memcpy(void *str1, const void *str2, size_t n)从存储区 **str2** 复制 **n** 个字节到存储区 str1\n\n```\nstr1  //代表用于存储复制内容的目标数组\nstr2  //代表被复制内容的目标数组\nn  //代表需要从str复制n个字节到str1\n```\n\n```\n    char str_1[256] = \"123456sdadasdadasdasda7454589\";\n    char str_2[256];\n \n    memcpy(&str_2[0] ,str_1 ,strlen(str_1));//strlen(str_1)获取str_1字符串的字节，然后将str_1的字符串复制strlen(str_1)个字节到str_2\n    printf(\"output: %s\\n\",str_2);\n    \n//output: aaaaaaaaa\n//output: aa\n```\n\n### 储存区\n\n```\n内存分配可分为三种：静态存储区、栈区、堆区。\n\n1、静态存储区：该内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，它主要存放静态数据、全局数据和常量。\n\n2、栈区：它的用途是完成函数的调用。在执行函数时，函数内局部变量及函数参数的存储单元在栈上创建，函数调用结束时这些存储单元自动被释放。\n\n3、堆区：程序在运行时使用库函数为变量申请内存，在变量使用结束后再调用库函数释放内存。动态内存的生存期是由我们决定的，如果我们不释放内存，就会导致内存泄漏。\n\nstatic char line[LINE_SIZE] = {0};\n//静态变量的生命周期贯穿整个程序运行期间，适合需要长期保存数据的场景\n\nchat *line = \"0\"\n//多个指针可以共享相同的字符串字面量，节省内存，字符串字面量是不可变的，试图修改会导致未定义行为。\n\nchar str[LINE_SIZE] = \"0\"\n//字符数组在声明时可以初始化为一个特定的字符串，数组的其余部分为未初始化（通常是随机值）。对于局部变量，栈空间有限，大数组可能导致栈溢出\n```\n\n### char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\n\n```\nstr  //所要查询的字符\nc  //代表所要查找的字符，单个字符需要用''符号，否则警告\n```\n\n```\n    char str_1[256] = \"asdfghjklzxcvbnm\";\n    char str_2[256];\n\n    char *find = strchr(str_1, 'z');  //查找str_1里面的z字符，并将指针指向这个位置\n    if(find){  //判断是否找到，如果找到，则将其替换成换行符，等于舍弃后面的内容\n        *find = '\\0';\n    }\n    memcpy(str_2 ,str_1 ,strlen(str_1));  //将str_1的字符全部复制给str_2，由于上述指针指的位置替换成了换行符，所以到此字符进行截断\n    printf(\"output: %s\\n\",str_2);  //所以输出的是z前面的字符\n    \n//output\noutput: asdfghjkl\n```\n\n#### char \\*strcpy(char \\*dest, const char \\*src)把 **src** 所指向的字符串复制到 dest\n\n```\nchar *strcpy(char *dest, const char *src)\n\n//dest -- 指向用于存储复制内容的目标数组。\n//src -- 要复制的字符串。\n\n\tchar str_1[256] = \"123456sdadasdadasdasda7454589\";\n    char str_3[256];\n    printf(\"output: %s\\n\",str_1);\n    \n    strcpy(str_3,str_1);\n    printf(\"output: %s\\n\",str_3);\n    \n//output\noutput: 123456sdadasdadasdasda7454589\noutput: 123456sdadasdadasdasda7454589\n```\n\nstrcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等\n\nstrcpy不需要指定长度，它遇到被复制字符的串结束符\"\\0\"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度\n\n### strcat()\n\n```\n//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾\nchar *strcat(char *dest, const char *src) \n\t//dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。\n\t//src -- 指向要追加的字符串，该字符串不会覆盖目标字符串。\n```\n\n### strcmp()\n\n```\n//把 str1 所指向的字符串和 str2 所指向的字符串进行比较\nint strcmp(const char *str1, const char *str2) \n\t//str1 -- 要进行比较的第一个字符串。\n\t//str2 -- 要进行比较的第二个字符串。\n\t\n\t//返回值\n\t如果返回值小于 0，则表示 str1 小于 str2。\n\t如果返回值大于 0，则表示 str1 大于 str2。\n\t如果返回值等于 0，则表示 str1 等于 str2。\n```\n\n### 判断式if\n\n根据上面的内容进行假设，由于strchr如果找到，则返回该值所在的位置，如果没有找到，则返回NULL空值\n\n如果我想要他返回真值时定义操作，我的函数可以写为\n\n```\nif(find){\n    *find = '\\0';\n}\n或者\nif(find != NULL){\n    *find = '\\0';\n}\n```\n\n如果我想要发返回空值时定义操作，函数可以写为\n\n```\nif(find = NULL){\n    *find = '\\0';\n}\n或者\nif(!find){\n    *find = '\\0';\n}\n```\n\n### 正则表达式\n\n正则表达式的使用流程\n\n```\n编译正则表达式 regcomp()\n匹配正则表达式 regexec()\n释放正则表达式 regfree()\n```\n\n#### 1.regcomp()\n\n```\n//把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效\nint regcomp (regex_t *compiled, const char *pattern, int cflags)\n\n//regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。\n//pattern 是指向我们写好的正则表达式的指针。\n//cflags 有如下4个值或者是它们或运算(|)后的值：\n\t//REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。\n\t//REG_ICASE 匹配字母时忽略大小写。\n\t//REG_NOSUB 不用存储匹配后的结果。\n\t//REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配。\n```\n\n#### 2.regexec()\n\n```\n//在编译正则表达式的时候没有指定cflags的参数REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。\nint regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags)\n\n//compiled 是已经用regcomp函数编译好的正则表达式。\n//string 是目标文本串。\n//nmatch 是regmatch_t结构体数组的长度。\n//matchptr regmatch_t类型的结构体数组，存放匹配文本串的位置信息。\n//eflags 有两个值\n\t//REG_NOTBOL 按我的理解是如果指定了这个值，那么’^’就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义；\n\t//REG_NOTEOL 和上边那个作用差不多，不过这个指定结束end of line。\n\t\n//通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。\t\ntypedef struct\n{\n   regoff_t rm_so;\n   regoff_t rm_eo;\n} regmatch_t;\n//成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。\n\n```\n\n#### 3.regfree()\n\n```\n//如果是重新编译的话，一定要先清空regex_t结构体。\nvoid regfree (regex_t *compiled)\n```\n\n#### 4.regerror\n\n```\n//当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。\nsize_t regerror (int errcode, regex_t *compiled, char *buffer, size_t length)\n\n//errcode 是由regcomp 和 regexec 函数返回的错误代号。\n//compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。\n//buffer 指向用来存放错误信息的字符串的内存空间。\n//length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。\n```\n\n### void bzero(void \\*s, int n);将内存块（字符串）的前n个字节清零\n\n```\n    char str_1[256] = \"123456sdadasdadasdasda7454589\";\n    printf(\"str_1:%s\\n\",str_1);\n    char str_2[256] = bzero(str_1,sizeof(str_1));\n    printf(\"str_2:%s\\n\",str_2);\n\n//bzero不是标准C库，逐渐被memset替代\n```\n\n### int atoi(const char *str)把参数 **str** 所指向的字符串转换为一个整数（类型为 int 型）\n\n```\n    char str_1[] = \"2147483647\";//int的整数值只能是4字节，所以不能超过2147483647\n    printf(\"str_1:%s\\n\",str_1);\n\n    int str_2 = atoi(&str_1);//转换成整数型\n    printf(\"str_2:%d\\n\",str_2);\n    printf(\"Size of int = %ld bytes \\n\", sizeof(str_2));//输出字符的字节长度\n```\n\n### 位、字节的关系\n\n```\n1 Byte = 8 bit\n1 KB = 1024 Byte\n1 MB = 1024 KB\n1 GB = 1024 MB\n\n8位无符号的最大值就是1111 1111，最大值是255，即就是 (2^8)-1。\n然而有符号只是在此基础上让8位中的第一位充当符号位，0代表正数，1代表负数。\n8位有符号的最大值就是0111 1111，最大值是+127，即就是 (2^7)-1，\n8位有符号的最小值就是1000 0000，最小值是-128，即就是 -2^7，\n\n4字节（32位）\n最大值 （2^31）- 1   2147483647\n最小值 - 2^31  -2147483648\n```\n\n### 指针配合while循环函数实现无限循环处理不同消息\n\n    // 解析数据，定义*answer指针指向klipperAcceptBuffer接收数据\n    char *answer = klipperAcceptBuffer;\n    //进入字符读取过程循环，读完利用指针指向下一帧，继续开始循环\n    while (answer)\n    {\n    \t// 查找数据帧结束符‘0x03’\n    \tchar *answerEnd = strchr(answer, 0x03);\n    \t\n    \t......\n    \t\n    \t// 继续处理下一个数据帧\n    \tanswer = answerEnd + 1;  \n    }\n\n### strstr() 查找第一次出现字符串的位置\n\n```\n//在字符串 haystack 中查找第一次出现字符串 needle 的位置\nchar *strstr(const char *haystack, const char *needle) \n```\n\n### snprintf()\n\n```\n//将可变参数(...)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断，最多写入 size-1 个字符。\nint snprintf(char *str, size_t size, const char *format, ...) \n\t//str -- 目标字符串，用于存储格式化后的字符串的字符数组的指针。\n\t//size -- 字符数组的大小。\n\t//format -- 格式化字符串。\n```\n\n","slug":"Work No.8","published":1,"updated":"2024-07-31T03:32:44.866Z","_id":"clz9aaxqp002gygfb7ahub0e1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"C语言学习\"><a href=\"#C语言学习\" class=\"headerlink\" title=\"C语言学习\"></a>C语言学习</h1><h3 id=\"void-memset-void-str-int-c-size-t-n-用于将一段内存区域设置为指定的值\"><a href=\"#void-memset-void-str-int-c-size-t-n-用于将一段内存区域设置为指定的值\" class=\"headerlink\" title=\"void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值\"></a>void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title\">memset</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *str, <span class=\"hljs-type\">int</span> c, <span class=\"hljs-type\">size_t</span> n)</span></span>;<br>*str  <span class=\"hljs-comment\">//要指向填充的内存区域指针</span><br>c  <span class=\"hljs-comment\">//代表要填充的值</span><br>n  <span class=\"hljs-comment\">//要被设置的字节数</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">    char str[<span class=\"hljs-number\">10</span>];<br>    memset(str, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">9</span>); <span class=\"hljs-regexp\">//</span>将str字符前九个填入字符a，要注意是<span class=\"hljs-string\">&#x27;&#x27;</span>号，不能是<span class=\"hljs-string\">&quot;&quot;</span>，<span class=\"hljs-string\">&quot;&quot;</span>代表的是字符串<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;output: <span class=\"hljs-variable\">%s</span>\\n&quot;</span>,str);<br>    memset(str, <span class=\"hljs-string\">&#x27;\\0&#x27;</span> ,<span class=\"hljs-number\">10</span>); <span class=\"hljs-regexp\">//</span>将str字符前九个填入字符<span class=\"hljs-string\">&#x27;\\0&#x27;</span>或者<span class=\"hljs-number\">0</span>，可以将字符串进行清零操作<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;output: <span class=\"hljs-variable\">%s</span>\\n&quot;</span>,str);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <br><span class=\"hljs-regexp\">//</span>output: aaaaaaaaa<br>//output:<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"return-0\"><a href=\"#return-0\" class=\"headerlink\" title=\"return 0\"></a>return 0</h3><p><strong>没有返回值的函数为空类型，用<code>void</code>表示</strong>。一旦函数的返回值类型被定义为 void，就不能再接收它的值，即若函数没有返回值</p>\n<p>返回值的类型必须与函数定义类型一致。例如：在返回类型是<strong>char的函数</strong>中，return后应该是char类型的值。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">return</span> 表达式; <span class=\"hljs-keyword\">return</span> (表达式); 为了简明，（）一般不写。例如：<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>；表示程序正常退出，即当<span class=\"hljs-keyword\">return</span>语句提供了一个值时，这个值就成为函数的返回值。<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>；表示程序异常退出，返回主调函数来处理，继续往下执行。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"void-memcpy-void-str1-const-void-str2-size-t-n-从存储区-str2-复制-n-个字节到存储区-str1\"><a href=\"#void-memcpy-void-str1-const-void-str2-size-t-n-从存储区-str2-复制-n-个字节到存储区-str1\" class=\"headerlink\" title=\"void *memcpy(void *str1, const void *str2, size_t n)从存储区 str2 复制 n 个字节到存储区 str1\"></a>void *memcpy(void *str1, const void *str2, size_t n)从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 str1</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">str1  <span class=\"hljs-comment\">//代表用于存储复制内容的目标数组</span><br>str2  <span class=\"hljs-comment\">//代表被复制内容的目标数组</span><br>n  <span class=\"hljs-comment\">//代表需要从str复制n个字节到str1</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">    <span class=\"hljs-type\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class=\"hljs-type\">char</span> str_2[<span class=\"hljs-number\">256</span>];<br> <br>    <span class=\"hljs-built_in\">memcpy</span>(&amp;str_2[<span class=\"hljs-number\">0</span>] ,str_1 ,<span class=\"hljs-built_in\">strlen</span>(str_1));<span class=\"hljs-comment\">//strlen(str_1)获取str_1字符串的字节，然后将str_1的字符串复制strlen(str_1)个字节到str_2</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_2);<br>    <br><span class=\"hljs-comment\">//output: aaaaaaaaa</span><br><span class=\"hljs-comment\">//output: aa</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"储存区\"><a href=\"#储存区\" class=\"headerlink\" title=\"储存区\"></a>储存区</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">内存分配可分为三种：静态存储区、栈区、堆区。<br><br><span class=\"hljs-number\">1</span>、静态存储区：该内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，它主要存放静态数据、全局数据和常量。<br><br><span class=\"hljs-number\">2</span>、栈区：它的用途是完成函数的调用。在执行函数时，函数内局部变量及函数参数的存储单元在栈上创建，函数调用结束时这些存储单元自动被释放。<br><br><span class=\"hljs-number\">3</span>、堆区：程序在运行时使用库函数为变量申请内存，在变量使用结束后再调用库函数释放内存。动态内存的生存期是由我们决定的，如果我们不释放内存，就会导致内存泄漏。<br><br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span> <span class=\"hljs-built_in\">line</span>[LINE_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-comment\">//静态变量的生命周期贯穿整个程序运行期间，适合需要长期保存数据的场景</span><br><br>chat *<span class=\"hljs-built_in\">line</span> = <span class=\"hljs-string\">&quot;0&quot;</span><br><span class=\"hljs-comment\">//多个指针可以共享相同的字符串字面量，节省内存，字符串字面量是不可变的，试图修改会导致未定义行为。</span><br><br><span class=\"hljs-type\">char</span> <span class=\"hljs-built_in\">str</span>[LINE_SIZE] = <span class=\"hljs-string\">&quot;0&quot;</span><br><span class=\"hljs-comment\">//字符数组在声明时可以初始化为一个特定的字符串，数组的其余部分为未初始化（通常是随机值）。对于局部变量，栈空间有限，大数组可能导致栈溢出</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"char-strchr-const-char-str-int-c-用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\"><a href=\"#char-strchr-const-char-str-int-c-用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\" class=\"headerlink\" title=\"char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\"></a>char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-keyword\">str</span>  <span class=\"hljs-comment\">//所要查询的字符</span><br>c  <span class=\"hljs-comment\">//代表所要查找的字符，单个字符需要用&#x27;&#x27;符号，否则警告</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">    <span class=\"hljs-type\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;asdfghjklzxcvbnm&quot;</span>;<br>    <span class=\"hljs-type\">char</span> str_2[<span class=\"hljs-number\">256</span>];<br><br>    <span class=\"hljs-type\">char</span> *find = <span class=\"hljs-built_in\">strchr</span>(str_1, <span class=\"hljs-string\">&#x27;z&#x27;</span>);  <span class=\"hljs-comment\">//查找str_1里面的z字符，并将指针指向这个位置</span><br>    <span class=\"hljs-keyword\">if</span>(find)&#123;  <span class=\"hljs-comment\">//判断是否找到，如果找到，则将其替换成换行符，等于舍弃后面的内容</span><br>        *find = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">memcpy</span>(str_2 ,str_1 ,<span class=\"hljs-built_in\">strlen</span>(str_1));  <span class=\"hljs-comment\">//将str_1的字符全部复制给str_2，由于上述指针指的位置替换成了换行符，所以到此字符进行截断</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_2);  <span class=\"hljs-comment\">//所以输出的是z前面的字符</span><br>    <br><span class=\"hljs-comment\">//output</span><br>output: asdfghjkl<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"char-strcpy-char-dest-const-char-src-把-src-所指向的字符串复制到-dest\"><a href=\"#char-strcpy-char-dest-const-char-src-把-src-所指向的字符串复制到-dest\" class=\"headerlink\" title=\"char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest\"></a>char *strcpy(char *dest, const char *src)把 <strong>src</strong> 所指向的字符串复制到 dest</h4><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\"><span class=\"hljs-built_in\">char</span> *strcpy(<span class=\"hljs-built_in\">char</span> *dest, const <span class=\"hljs-built_in\">char</span> *src)<br><br>//dest <span class=\"hljs-comment\">-- 指向用于存储复制内容的目标数组。</span><br>//src <span class=\"hljs-comment\">-- 要复制的字符串。</span><br><br>\t<span class=\"hljs-built_in\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class=\"hljs-built_in\">char</span> str_3[<span class=\"hljs-number\">256</span>];<br>    printf(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_1);<br>    <br>    strcpy(str_3,str_1);<br>    printf(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_3);<br>    <br>//<span class=\"hljs-built_in\">output</span><br><span class=\"hljs-built_in\">output</span>: <span class=\"hljs-number\">123456</span>sdadasdadasdasda7454589<br><span class=\"hljs-built_in\">output</span>: <span class=\"hljs-number\">123456</span>sdadasdadasdasda7454589<br></code></pre></td></tr></table></figure>\n\n<p>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等</p>\n<p>strcpy不需要指定长度，它遇到被复制字符的串结束符”\\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度</p>\n<h3 id=\"strcat\"><a href=\"#strcat\" class=\"headerlink\" title=\"strcat()\"></a>strcat()</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span> *<span class=\"hljs-title\">strcat</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> *dest, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *src)</span> </span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//src -- 指向要追加的字符串，该字符串不会覆盖目标字符串。</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"strcmp\"><a href=\"#strcmp\" class=\"headerlink\" title=\"strcmp()\"></a>strcmp()</h3><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//把 str1 所指向的字符串和 str2 所指向的字符串进行比较</span><br><span class=\"hljs-keyword\">int</span> strcmp(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">char</span> *str1, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">char</span> *str2) <br>\t<span class=\"hljs-comment\">//str1 -- 要进行比较的第一个字符串。</span><br>\t<span class=\"hljs-comment\">//str2 -- 要进行比较的第二个字符串。</span><br>\t<br>\t<span class=\"hljs-comment\">//返回值</span><br>\t如果返回值小于 <span class=\"hljs-number\">0</span>，则表示 str1 小于 str2。<br>\t如果返回值大于 <span class=\"hljs-number\">0</span>，则表示 str1 大于 str2。<br>\t如果返回值等于 <span class=\"hljs-number\">0</span>，则表示 str1 等于 str2。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"判断式if\"><a href=\"#判断式if\" class=\"headerlink\" title=\"判断式if\"></a>判断式if</h3><p>根据上面的内容进行假设，由于strchr如果找到，则返回该值所在的位置，如果没有找到，则返回NULL空值</p>\n<p>如果我想要他返回真值时定义操作，我的函数可以写为</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">find</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br>或者<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">find</span> != <span class=\"hljs-literal\">NULL</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果我想要发返回空值时定义操作，函数可以写为</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-literal\">NULL</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br>或者<br><span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-built_in\">find</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>正则表达式的使用流程</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\">编译正则表达式 <span class=\"hljs-function\"><span class=\"hljs-title\">regcomp</span>()</span><br>匹配正则表达式 <span class=\"hljs-function\"><span class=\"hljs-title\">regexec</span>()</span><br>释放正则表达式 <span class=\"hljs-function\"><span class=\"hljs-title\">regfree</span>()</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-regcomp\"><a href=\"#1-regcomp\" class=\"headerlink\" title=\"1.regcomp()\"></a>1.regcomp()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">regcomp</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">regex_t</span> *compiled, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *pattern, <span class=\"hljs-type\">int</span> cflags)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//pattern 是指向我们写好的正则表达式的指针。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//cflags 有如下4个值或者是它们或运算(|)后的值：</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_ICASE 匹配字母时忽略大小写。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NOSUB 不用存储匹配后的结果。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配。</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-regexec\"><a href=\"#2-regexec\" class=\"headerlink\" title=\"2.regexec()\"></a>2.regexec()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//在编译正则表达式的时候没有指定cflags的参数REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">regexec</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">regex_t</span> *compiled, <span class=\"hljs-type\">char</span> *string, <span class=\"hljs-type\">size_t</span> nmatch, <span class=\"hljs-type\">regmatch_t</span> matchptr [], <span class=\"hljs-type\">int</span> eflags)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//compiled 是已经用regcomp函数编译好的正则表达式。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//string 是目标文本串。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//nmatch 是regmatch_t结构体数组的长度。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//matchptr regmatch_t类型的结构体数组，存放匹配文本串的位置信息。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//eflags 有两个值</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NOTBOL 按我的理解是如果指定了这个值，那么’^’就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义；</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NOTEOL 和上边那个作用差不多，不过这个指定结束end of line。</span></span><br><span class=\"hljs-function\">\t</span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。\t</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span></span><br><span class=\"hljs-function\"></span>&#123;<br>   <span class=\"hljs-type\">regoff_t</span> rm_so;<br>   <span class=\"hljs-type\">regoff_t</span> rm_eo;<br>&#125; <span class=\"hljs-type\">regmatch_t</span>;<br><span class=\"hljs-comment\">//成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。</span><br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-regfree\"><a href=\"#3-regfree\" class=\"headerlink\" title=\"3.regfree()\"></a>3.regfree()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//如果是重新编译的话，一定要先清空regex_t结构体。</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">regfree</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">regex_t</span> *compiled)</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-regerror\"><a href=\"#4-regerror\" class=\"headerlink\" title=\"4.regerror\"></a>4.regerror</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">regerror</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> errcode, <span class=\"hljs-type\">regex_t</span> *compiled, <span class=\"hljs-type\">char</span> *buffer, <span class=\"hljs-type\">size_t</span> length)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//errcode 是由regcomp 和 regexec 函数返回的错误代号。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//buffer 指向用来存放错误信息的字符串的内存空间。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"void-bzero-void-s-int-n-将内存块（字符串）的前n个字节清零\"><a href=\"#void-bzero-void-s-int-n-将内存块（字符串）的前n个字节清零\" class=\"headerlink\" title=\"void bzero(void *s, int n);将内存块（字符串）的前n个字节清零\"></a>void bzero(void *s, int n);将内存块（字符串）的前n个字节清零</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">    <span class=\"hljs-type\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str_1:%s\\n&quot;</span>,str_1);<br>    <span class=\"hljs-type\">char</span> str_2[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-built_in\">bzero</span>(str_1,<span class=\"hljs-built_in\">sizeof</span>(str_1));<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str_2:%s\\n&quot;</span>,str_2);<br><br><span class=\"hljs-comment\">//bzero不是标准C库，逐渐被memset替代</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"int-atoi-const-char-str-把参数-str-所指向的字符串转换为一个整数（类型为-int-型）\"><a href=\"#int-atoi-const-char-str-把参数-str-所指向的字符串转换为一个整数（类型为-int-型）\" class=\"headerlink\" title=\"int atoi(const char *str)把参数 str 所指向的字符串转换为一个整数（类型为 int 型）\"></a>int atoi(const char *str)把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">char str_1[] = <span class=\"hljs-string\">&quot;2147483647&quot;</span>;<span class=\"hljs-regexp\">//in</span>t的整数值只能是<span class=\"hljs-number\">4</span>字节，所以不能超过<span class=\"hljs-number\">2147483647</span><br><span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;str_1:<span class=\"hljs-variable\">%s</span>\\n&quot;</span>,str_1);<br><br><span class=\"hljs-keyword\">int</span> str_2 = atoi(&amp;str_1);<span class=\"hljs-regexp\">//</span>转换成整数型<br><span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;str_2:<span class=\"hljs-variable\">%d</span>\\n&quot;</span>,str_2);<br><span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Size of int = <span class=\"hljs-variable\">%ld</span> bytes \\n&quot;</span>, sizeof(str_2));<span class=\"hljs-regexp\">//</span>输出字符的字节长度<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"位、字节的关系\"><a href=\"#位、字节的关系\" class=\"headerlink\" title=\"位、字节的关系\"></a>位、字节的关系</h3><figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs subunit\">1 Byte = 8 bit<br>1 KB = 1024 Byte<br>1 MB = 1024 KB<br>1 GB = 1024 MB<br><br>8位无符号的最大值就是1111 1111，最大值是255，即就是 (2^8)<span class=\"hljs-string\">-1</span>。<br>然而有符号只是在此基础上让8位中的第一位充当符号位，0代表正数，1代表负数。<br>8位有符号的最大值就是0111 1111，最大值是<span class=\"hljs-string\">+127</span>，即就是 (2^7)<span class=\"hljs-string\">-1</span>，<br>8位有符号的最小值就是1000 0000，最小值是<span class=\"hljs-string\">-128</span>，即就是 <span class=\"hljs-string\">-2</span>^7，<br><br>4字节（32位）<br>最大值 （2^31）- 1   2147483647<br>最小值 - 2^31  <span class=\"hljs-string\">-2147483648</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"指针配合while循环函数实现无限循环处理不同消息\"><a href=\"#指针配合while循环函数实现无限循环处理不同消息\" class=\"headerlink\" title=\"指针配合while循环函数实现无限循环处理不同消息\"></a>指针配合while循环函数实现无限循环处理不同消息</h3><pre><code class=\"hljs\">// 解析数据，定义*answer指针指向klipperAcceptBuffer接收数据\nchar *answer = klipperAcceptBuffer;\n//进入字符读取过程循环，读完利用指针指向下一帧，继续开始循环\nwhile (answer)\n&#123;\n    // 查找数据帧结束符‘0x03’\n    char *answerEnd = strchr(answer, 0x03);\n    \n    ......\n    \n    // 继续处理下一个数据帧\n    answer = answerEnd + 1;  \n&#125;\n</code></pre>\n<h3 id=\"strstr-查找第一次出现字符串的位置\"><a href=\"#strstr-查找第一次出现字符串的位置\" class=\"headerlink\" title=\"strstr() 查找第一次出现字符串的位置\"></a>strstr() 查找第一次出现字符串的位置</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//在字符串 haystack 中查找第一次出现字符串 needle 的位置</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span> *<span class=\"hljs-title\">strstr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *haystack, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *needle)</span> </span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"snprintf\"><a href=\"#snprintf\" class=\"headerlink\" title=\"snprintf()\"></a>snprintf()</h3><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fortran\">//将可变参数(...)按照 <span class=\"hljs-keyword\">format</span> 格式化成字符串，并将字符串复制到 str 中，<span class=\"hljs-built_in\">size</span> 为要写入的字符的最大数目，超过 <span class=\"hljs-built_in\">size</span> 会被截断，最多写入 <span class=\"hljs-built_in\">size</span>-<span class=\"hljs-number\">1</span> 个字符。<br><span class=\"hljs-built_in\">int</span> snprintf(<span class=\"hljs-built_in\">char</span> *str, size_t <span class=\"hljs-built_in\">size</span>, const <span class=\"hljs-built_in\">char</span> *<span class=\"hljs-keyword\">format</span>, ...) <br>\t//str -- 目标字符串，用于存储格式化后的字符串的字符数组的指针。<br>\t//<span class=\"hljs-built_in\">size</span> -- 字符数组的大小。<br>\t//<span class=\"hljs-keyword\">format</span> -- 格式化字符串。<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"C语言学习\"><a href=\"#C语言学习\" class=\"headerlink\" title=\"C语言学习\"></a>C语言学习</h1><h3 id=\"void-memset-void-str-int-c-size-t-n-用于将一段内存区域设置为指定的值\"><a href=\"#void-memset-void-str-int-c-size-t-n-用于将一段内存区域设置为指定的值\" class=\"headerlink\" title=\"void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值\"></a>void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title\">memset</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *str, <span class=\"hljs-type\">int</span> c, <span class=\"hljs-type\">size_t</span> n)</span></span>;<br>*str  <span class=\"hljs-comment\">//要指向填充的内存区域指针</span><br>c  <span class=\"hljs-comment\">//代表要填充的值</span><br>n  <span class=\"hljs-comment\">//要被设置的字节数</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">    char str[<span class=\"hljs-number\">10</span>];<br>    memset(str, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">9</span>); <span class=\"hljs-regexp\">//</span>将str字符前九个填入字符a，要注意是<span class=\"hljs-string\">&#x27;&#x27;</span>号，不能是<span class=\"hljs-string\">&quot;&quot;</span>，<span class=\"hljs-string\">&quot;&quot;</span>代表的是字符串<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;output: <span class=\"hljs-variable\">%s</span>\\n&quot;</span>,str);<br>    memset(str, <span class=\"hljs-string\">&#x27;\\0&#x27;</span> ,<span class=\"hljs-number\">10</span>); <span class=\"hljs-regexp\">//</span>将str字符前九个填入字符<span class=\"hljs-string\">&#x27;\\0&#x27;</span>或者<span class=\"hljs-number\">0</span>，可以将字符串进行清零操作<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;output: <span class=\"hljs-variable\">%s</span>\\n&quot;</span>,str);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <br><span class=\"hljs-regexp\">//</span>output: aaaaaaaaa<br>//output:<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"return-0\"><a href=\"#return-0\" class=\"headerlink\" title=\"return 0\"></a>return 0</h3><p><strong>没有返回值的函数为空类型，用<code>void</code>表示</strong>。一旦函数的返回值类型被定义为 void，就不能再接收它的值，即若函数没有返回值</p>\n<p>返回值的类型必须与函数定义类型一致。例如：在返回类型是<strong>char的函数</strong>中，return后应该是char类型的值。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">return</span> 表达式; <span class=\"hljs-keyword\">return</span> (表达式); 为了简明，（）一般不写。例如：<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>；表示程序正常退出，即当<span class=\"hljs-keyword\">return</span>语句提供了一个值时，这个值就成为函数的返回值。<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>；表示程序异常退出，返回主调函数来处理，继续往下执行。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"void-memcpy-void-str1-const-void-str2-size-t-n-从存储区-str2-复制-n-个字节到存储区-str1\"><a href=\"#void-memcpy-void-str1-const-void-str2-size-t-n-从存储区-str2-复制-n-个字节到存储区-str1\" class=\"headerlink\" title=\"void *memcpy(void *str1, const void *str2, size_t n)从存储区 str2 复制 n 个字节到存储区 str1\"></a>void *memcpy(void *str1, const void *str2, size_t n)从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 str1</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">str1  <span class=\"hljs-comment\">//代表用于存储复制内容的目标数组</span><br>str2  <span class=\"hljs-comment\">//代表被复制内容的目标数组</span><br>n  <span class=\"hljs-comment\">//代表需要从str复制n个字节到str1</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">    <span class=\"hljs-type\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class=\"hljs-type\">char</span> str_2[<span class=\"hljs-number\">256</span>];<br> <br>    <span class=\"hljs-built_in\">memcpy</span>(&amp;str_2[<span class=\"hljs-number\">0</span>] ,str_1 ,<span class=\"hljs-built_in\">strlen</span>(str_1));<span class=\"hljs-comment\">//strlen(str_1)获取str_1字符串的字节，然后将str_1的字符串复制strlen(str_1)个字节到str_2</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_2);<br>    <br><span class=\"hljs-comment\">//output: aaaaaaaaa</span><br><span class=\"hljs-comment\">//output: aa</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"储存区\"><a href=\"#储存区\" class=\"headerlink\" title=\"储存区\"></a>储存区</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">内存分配可分为三种：静态存储区、栈区、堆区。<br><br><span class=\"hljs-number\">1</span>、静态存储区：该内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，它主要存放静态数据、全局数据和常量。<br><br><span class=\"hljs-number\">2</span>、栈区：它的用途是完成函数的调用。在执行函数时，函数内局部变量及函数参数的存储单元在栈上创建，函数调用结束时这些存储单元自动被释放。<br><br><span class=\"hljs-number\">3</span>、堆区：程序在运行时使用库函数为变量申请内存，在变量使用结束后再调用库函数释放内存。动态内存的生存期是由我们决定的，如果我们不释放内存，就会导致内存泄漏。<br><br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span> <span class=\"hljs-built_in\">line</span>[LINE_SIZE] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-comment\">//静态变量的生命周期贯穿整个程序运行期间，适合需要长期保存数据的场景</span><br><br>chat *<span class=\"hljs-built_in\">line</span> = <span class=\"hljs-string\">&quot;0&quot;</span><br><span class=\"hljs-comment\">//多个指针可以共享相同的字符串字面量，节省内存，字符串字面量是不可变的，试图修改会导致未定义行为。</span><br><br><span class=\"hljs-type\">char</span> <span class=\"hljs-built_in\">str</span>[LINE_SIZE] = <span class=\"hljs-string\">&quot;0&quot;</span><br><span class=\"hljs-comment\">//字符数组在声明时可以初始化为一个特定的字符串，数组的其余部分为未初始化（通常是随机值）。对于局部变量，栈空间有限，大数组可能导致栈溢出</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"char-strchr-const-char-str-int-c-用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\"><a href=\"#char-strchr-const-char-str-int-c-用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\" class=\"headerlink\" title=\"char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置\"></a>char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置</h3><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-keyword\">str</span>  <span class=\"hljs-comment\">//所要查询的字符</span><br>c  <span class=\"hljs-comment\">//代表所要查找的字符，单个字符需要用&#x27;&#x27;符号，否则警告</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">    <span class=\"hljs-type\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;asdfghjklzxcvbnm&quot;</span>;<br>    <span class=\"hljs-type\">char</span> str_2[<span class=\"hljs-number\">256</span>];<br><br>    <span class=\"hljs-type\">char</span> *find = <span class=\"hljs-built_in\">strchr</span>(str_1, <span class=\"hljs-string\">&#x27;z&#x27;</span>);  <span class=\"hljs-comment\">//查找str_1里面的z字符，并将指针指向这个位置</span><br>    <span class=\"hljs-keyword\">if</span>(find)&#123;  <span class=\"hljs-comment\">//判断是否找到，如果找到，则将其替换成换行符，等于舍弃后面的内容</span><br>        *find = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">memcpy</span>(str_2 ,str_1 ,<span class=\"hljs-built_in\">strlen</span>(str_1));  <span class=\"hljs-comment\">//将str_1的字符全部复制给str_2，由于上述指针指的位置替换成了换行符，所以到此字符进行截断</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_2);  <span class=\"hljs-comment\">//所以输出的是z前面的字符</span><br>    <br><span class=\"hljs-comment\">//output</span><br>output: asdfghjkl<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"char-strcpy-char-dest-const-char-src-把-src-所指向的字符串复制到-dest\"><a href=\"#char-strcpy-char-dest-const-char-src-把-src-所指向的字符串复制到-dest\" class=\"headerlink\" title=\"char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest\"></a>char *strcpy(char *dest, const char *src)把 <strong>src</strong> 所指向的字符串复制到 dest</h4><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\"><span class=\"hljs-built_in\">char</span> *strcpy(<span class=\"hljs-built_in\">char</span> *dest, const <span class=\"hljs-built_in\">char</span> *src)<br><br>//dest <span class=\"hljs-comment\">-- 指向用于存储复制内容的目标数组。</span><br>//src <span class=\"hljs-comment\">-- 要复制的字符串。</span><br><br>\t<span class=\"hljs-built_in\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class=\"hljs-built_in\">char</span> str_3[<span class=\"hljs-number\">256</span>];<br>    printf(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_1);<br>    <br>    strcpy(str_3,str_1);<br>    printf(<span class=\"hljs-string\">&quot;output: %s\\n&quot;</span>,str_3);<br>    <br>//<span class=\"hljs-built_in\">output</span><br><span class=\"hljs-built_in\">output</span>: <span class=\"hljs-number\">123456</span>sdadasdadasdasda7454589<br><span class=\"hljs-built_in\">output</span>: <span class=\"hljs-number\">123456</span>sdadasdadasdasda7454589<br></code></pre></td></tr></table></figure>\n\n<p>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等</p>\n<p>strcpy不需要指定长度，它遇到被复制字符的串结束符”\\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度</p>\n<h3 id=\"strcat\"><a href=\"#strcat\" class=\"headerlink\" title=\"strcat()\"></a>strcat()</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span> *<span class=\"hljs-title\">strcat</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> *dest, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *src)</span> </span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//src -- 指向要追加的字符串，该字符串不会覆盖目标字符串。</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"strcmp\"><a href=\"#strcmp\" class=\"headerlink\" title=\"strcmp()\"></a>strcmp()</h3><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//把 str1 所指向的字符串和 str2 所指向的字符串进行比较</span><br><span class=\"hljs-keyword\">int</span> strcmp(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">char</span> *str1, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">char</span> *str2) <br>\t<span class=\"hljs-comment\">//str1 -- 要进行比较的第一个字符串。</span><br>\t<span class=\"hljs-comment\">//str2 -- 要进行比较的第二个字符串。</span><br>\t<br>\t<span class=\"hljs-comment\">//返回值</span><br>\t如果返回值小于 <span class=\"hljs-number\">0</span>，则表示 str1 小于 str2。<br>\t如果返回值大于 <span class=\"hljs-number\">0</span>，则表示 str1 大于 str2。<br>\t如果返回值等于 <span class=\"hljs-number\">0</span>，则表示 str1 等于 str2。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"判断式if\"><a href=\"#判断式if\" class=\"headerlink\" title=\"判断式if\"></a>判断式if</h3><p>根据上面的内容进行假设，由于strchr如果找到，则返回该值所在的位置，如果没有找到，则返回NULL空值</p>\n<p>如果我想要他返回真值时定义操作，我的函数可以写为</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">find</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br>或者<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">find</span> != <span class=\"hljs-literal\">NULL</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果我想要发返回空值时定义操作，函数可以写为</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-literal\">NULL</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br>或者<br><span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-built_in\">find</span>)&#123;<br>    *<span class=\"hljs-built_in\">find</span> = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>正则表达式的使用流程</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\">编译正则表达式 <span class=\"hljs-function\"><span class=\"hljs-title\">regcomp</span>()</span><br>匹配正则表达式 <span class=\"hljs-function\"><span class=\"hljs-title\">regexec</span>()</span><br>释放正则表达式 <span class=\"hljs-function\"><span class=\"hljs-title\">regfree</span>()</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-regcomp\"><a href=\"#1-regcomp\" class=\"headerlink\" title=\"1.regcomp()\"></a>1.regcomp()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">regcomp</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">regex_t</span> *compiled, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *pattern, <span class=\"hljs-type\">int</span> cflags)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//pattern 是指向我们写好的正则表达式的指针。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//cflags 有如下4个值或者是它们或运算(|)后的值：</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_ICASE 匹配字母时忽略大小写。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NOSUB 不用存储匹配后的结果。</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配。</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-regexec\"><a href=\"#2-regexec\" class=\"headerlink\" title=\"2.regexec()\"></a>2.regexec()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//在编译正则表达式的时候没有指定cflags的参数REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">regexec</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">regex_t</span> *compiled, <span class=\"hljs-type\">char</span> *string, <span class=\"hljs-type\">size_t</span> nmatch, <span class=\"hljs-type\">regmatch_t</span> matchptr [], <span class=\"hljs-type\">int</span> eflags)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//compiled 是已经用regcomp函数编译好的正则表达式。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//string 是目标文本串。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//nmatch 是regmatch_t结构体数组的长度。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//matchptr regmatch_t类型的结构体数组，存放匹配文本串的位置信息。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//eflags 有两个值</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NOTBOL 按我的理解是如果指定了这个值，那么’^’就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义；</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-comment\">//REG_NOTEOL 和上边那个作用差不多，不过这个指定结束end of line。</span></span><br><span class=\"hljs-function\">\t</span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。\t</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span></span><br><span class=\"hljs-function\"></span>&#123;<br>   <span class=\"hljs-type\">regoff_t</span> rm_so;<br>   <span class=\"hljs-type\">regoff_t</span> rm_eo;<br>&#125; <span class=\"hljs-type\">regmatch_t</span>;<br><span class=\"hljs-comment\">//成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。</span><br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-regfree\"><a href=\"#3-regfree\" class=\"headerlink\" title=\"3.regfree()\"></a>3.regfree()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//如果是重新编译的话，一定要先清空regex_t结构体。</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">regfree</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">regex_t</span> *compiled)</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-regerror\"><a href=\"#4-regerror\" class=\"headerlink\" title=\"4.regerror\"></a>4.regerror</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">regerror</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> errcode, <span class=\"hljs-type\">regex_t</span> *compiled, <span class=\"hljs-type\">char</span> *buffer, <span class=\"hljs-type\">size_t</span> length)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//errcode 是由regcomp 和 regexec 函数返回的错误代号。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//buffer 指向用来存放错误信息的字符串的内存空间。</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"void-bzero-void-s-int-n-将内存块（字符串）的前n个字节清零\"><a href=\"#void-bzero-void-s-int-n-将内存块（字符串）的前n个字节清零\" class=\"headerlink\" title=\"void bzero(void *s, int n);将内存块（字符串）的前n个字节清零\"></a>void bzero(void *s, int n);将内存块（字符串）的前n个字节清零</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">    <span class=\"hljs-type\">char</span> str_1[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-string\">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str_1:%s\\n&quot;</span>,str_1);<br>    <span class=\"hljs-type\">char</span> str_2[<span class=\"hljs-number\">256</span>] = <span class=\"hljs-built_in\">bzero</span>(str_1,<span class=\"hljs-built_in\">sizeof</span>(str_1));<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str_2:%s\\n&quot;</span>,str_2);<br><br><span class=\"hljs-comment\">//bzero不是标准C库，逐渐被memset替代</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"int-atoi-const-char-str-把参数-str-所指向的字符串转换为一个整数（类型为-int-型）\"><a href=\"#int-atoi-const-char-str-把参数-str-所指向的字符串转换为一个整数（类型为-int-型）\" class=\"headerlink\" title=\"int atoi(const char *str)把参数 str 所指向的字符串转换为一个整数（类型为 int 型）\"></a>int atoi(const char *str)把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">char str_1[] = <span class=\"hljs-string\">&quot;2147483647&quot;</span>;<span class=\"hljs-regexp\">//in</span>t的整数值只能是<span class=\"hljs-number\">4</span>字节，所以不能超过<span class=\"hljs-number\">2147483647</span><br><span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;str_1:<span class=\"hljs-variable\">%s</span>\\n&quot;</span>,str_1);<br><br><span class=\"hljs-keyword\">int</span> str_2 = atoi(&amp;str_1);<span class=\"hljs-regexp\">//</span>转换成整数型<br><span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;str_2:<span class=\"hljs-variable\">%d</span>\\n&quot;</span>,str_2);<br><span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Size of int = <span class=\"hljs-variable\">%ld</span> bytes \\n&quot;</span>, sizeof(str_2));<span class=\"hljs-regexp\">//</span>输出字符的字节长度<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"位、字节的关系\"><a href=\"#位、字节的关系\" class=\"headerlink\" title=\"位、字节的关系\"></a>位、字节的关系</h3><figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs subunit\">1 Byte = 8 bit<br>1 KB = 1024 Byte<br>1 MB = 1024 KB<br>1 GB = 1024 MB<br><br>8位无符号的最大值就是1111 1111，最大值是255，即就是 (2^8)<span class=\"hljs-string\">-1</span>。<br>然而有符号只是在此基础上让8位中的第一位充当符号位，0代表正数，1代表负数。<br>8位有符号的最大值就是0111 1111，最大值是<span class=\"hljs-string\">+127</span>，即就是 (2^7)<span class=\"hljs-string\">-1</span>，<br>8位有符号的最小值就是1000 0000，最小值是<span class=\"hljs-string\">-128</span>，即就是 <span class=\"hljs-string\">-2</span>^7，<br><br>4字节（32位）<br>最大值 （2^31）- 1   2147483647<br>最小值 - 2^31  <span class=\"hljs-string\">-2147483648</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"指针配合while循环函数实现无限循环处理不同消息\"><a href=\"#指针配合while循环函数实现无限循环处理不同消息\" class=\"headerlink\" title=\"指针配合while循环函数实现无限循环处理不同消息\"></a>指针配合while循环函数实现无限循环处理不同消息</h3><pre><code>// 解析数据，定义*answer指针指向klipperAcceptBuffer接收数据\nchar *answer = klipperAcceptBuffer;\n//进入字符读取过程循环，读完利用指针指向下一帧，继续开始循环\nwhile (answer)\n&#123;\n    // 查找数据帧结束符‘0x03’\n    char *answerEnd = strchr(answer, 0x03);\n    \n    ......\n    \n    // 继续处理下一个数据帧\n    answer = answerEnd + 1;  \n&#125;\n</code></pre>\n<h3 id=\"strstr-查找第一次出现字符串的位置\"><a href=\"#strstr-查找第一次出现字符串的位置\" class=\"headerlink\" title=\"strstr() 查找第一次出现字符串的位置\"></a>strstr() 查找第一次出现字符串的位置</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//在字符串 haystack 中查找第一次出现字符串 needle 的位置</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span> *<span class=\"hljs-title\">strstr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *haystack, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *needle)</span> </span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"snprintf\"><a href=\"#snprintf\" class=\"headerlink\" title=\"snprintf()\"></a>snprintf()</h3><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fortran\">//将可变参数(...)按照 <span class=\"hljs-keyword\">format</span> 格式化成字符串，并将字符串复制到 str 中，<span class=\"hljs-built_in\">size</span> 为要写入的字符的最大数目，超过 <span class=\"hljs-built_in\">size</span> 会被截断，最多写入 <span class=\"hljs-built_in\">size</span>-<span class=\"hljs-number\">1</span> 个字符。<br><span class=\"hljs-built_in\">int</span> snprintf(<span class=\"hljs-built_in\">char</span> *str, size_t <span class=\"hljs-built_in\">size</span>, const <span class=\"hljs-built_in\">char</span> *<span class=\"hljs-keyword\">format</span>, ...) <br>\t//str -- 目标字符串，用于存储格式化后的字符串的字符数组的指针。<br>\t//<span class=\"hljs-built_in\">size</span> -- 字符数组的大小。<br>\t//<span class=\"hljs-keyword\">format</span> -- 格式化字符串。<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Json数据包收发测试","date":"2024-07-31T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/erFMNIURnl5YdSk.jpg","_content":"\n# Json收发测试\n\n## Json构建\n\n首先定义一个Json的创建函数，函数的返回类型要是字符串格式，因为json最后的发送都是以字符串进行发送的\n\n首先要设计好Json格式的内容层次，然后再去写代码，我的Json包的层次如下\n\n```\n|params\n\t|mtype：1\n\t|buf：\n\t\t|method：BELT_TEST\n\t\t|beltNum：\n\t\t\t|name_1：90\n\t\t\t|name_2：45\n\t\t|message:\n\t\t\t|error:0\n\t\t\t|other：aaaa\n```\n\n我们需要观察在这个层次里面，哪些是包含多个参数，哪些是只有一个参数的，如果是多个参数的，我们可以把它想成一个小的json包用来装载，如果只是单个参数的，直接进行装载进去就行\n\n**记住json包的顺序定义，观察哪些是多参数的先定义，然后装载单参数，再从里往外装载多参数，最后转换格式进行发送**\n\n根据上面定义的层次定义，首先要使用`json_object_new_object()`函数创建一个params的json结构，用来装载接下来的内容\n\n```\n    //创建一个json对象\n    json_object *params = json_object_new_object();\n    \n    //创建json子对象buf\n    json_object *buf = json_object_new_object();\n    \n    //创建json子对象beltNum\n    json_object *beltNum = json_object_new_object();\n    \n    //创建json子对象message\n    json_object *message = json_object_new_object();\n```\n\n之后观察哪些是单参数，依次装载进去即可，mtype相对于params是单参数，method相对于buf是单参数，name_1和name_2相对于beltNum是单参数，error和other相对于message是单参数，所以对单参数进行装载\n\n这里面需要注意的是，如果装载的是字符，需要用json_object_new_string，如果是整数型，则用json_object_new_int\n\n```\n    //在params对象中加入键位mtype，并写入整数值1\n    json_object_object_add(params, \"mtype\", json_object_new_int(1));\n    \n    //在buf对象中加入键位method，并写入字符格式“BELT_TEST”\n    json_object_object_add(buf, \"method\", json_object_new_string(\"BELT_TEST\"));\n    \n    //在beltNum对象中加入键位name_1，并写入整数值90\n    json_object_object_add(beltNum, name_1, json_object_new_int(90));\n    \n    //在beltNum对象中加入键位name_2，并写入整数值45\n    json_object_object_add(beltNum, name_2, json_object_new_int(45));\n    \n    //在message对象中加入键位error，并写入整数值0\n    //json_object_object_add(message, \"error\", json_object_new_int(0));\n    \n    //在message对象中加入键位other，并写入字符格式“aaaaa”\n    json_object_object_add(message, \"other\", json_object_new_string(\"aaaaa\"));\n```\n\n之后，我们将多参数从层次最里面的往外进行装载即可\n\n```\n    //将belt_name的子对象加入到buf中\n    json_object_object_add(buf, \"beltNum\", beltNum);\n    \n    //将message的子对象加入到buf中\n    json_object_object_add(buf, \"message\", message);\n    \n    //将buf的子对象加入到params中\n    json_object_object_add(params, \"buf\", buf);\n```\n\n最后，我们已经完成整个json包的构建，但是在json包的收发必须通过字符串格式，而不是通过json包的格式，所以需要对格式进行转换\n\n```\n\t//将params转换成字符串格式\n    const char* cmdJsonStr = json_object_to_json_string_ext(params, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);\n    //JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。\n    //JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /\n    \n    //最后的输出格式为\n    //cmdJsonStr = {\"mtype\":1,\"buf\":{\"method\":\"BELT_TEST\",\"beltNum\":{\"name_1\":90,\"name_2\":\"45\"}\"message\":{\"error\":0,\"other\":\"aaaaa\"}}}\n```\n\n最终，我们的代码整体如下\n\n```\nstatic const char* Jsontest(char *name)\n{\n    //创建一个json对象params\n    json_object *params = json_object_new_object();\n    \n    //创建json子对象buf\n    json_object *buf = json_object_new_object();\n    \n    //创建json子对象beltNum\n    json_object *beltNum = json_object_new_object();\n    \n    //创建json子对象message\n    json_object *message = json_object_new_object();\n\n    //在params对象中加入键位mtype，并写入整数值1\n    json_object_object_add(params, \"mtype\", json_object_new_int(1));\n    \n    //在buf对象中加入键位method，并写入字符格式“BELT_TEST”\n    json_object_object_add(buf, \"method\", json_object_new_string(\"BELT_TEST\"));\n    \n    //在beltNum对象中加入键位name_1，并写入整数值90\n    json_object_object_add(beltNum, name_1, json_object_new_int(90));\n    \n    //在beltNum对象中加入键位name_2，并写入整数值45\n    json_object_object_add(beltNum, name_2, json_object_new_int(45));\n    \n    //在message对象中加入键位error，并写入整数值0\n    //json_object_object_add(message, \"error\", json_object_new_int(0));\n    \n    //在message对象中加入键位other，并写入字符格式“aaaaa”\n    json_object_object_add(message, \"other\", json_object_new_string(\"aaaaa\"));\n    \n    //将belt_name的子对象加入到buf中\n    json_object_object_add(buf, \"beltNum\", beltNum);\n    \n    //将message的子对象加入到buf中\n    json_object_object_add(buf, \"message\", message);\n    \n    //将buf的子对象加入到params中\n    json_object_object_add(params, \"buf\", buf);\n    \n    //将params转换成字符串格式\n    const char* cmdJsonStr = json_object_to_json_string_ext(params, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);\n    //JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。\n    //JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /\n    \n    //输出日志作为测试\n    CrLogI(\"cmdJsonStr = %s\\n\",cmdJsonStr);\n\n    //返回cmdJsonStr字符\n    return cmdJsonStr;\n}\n```\n\n## Json的解析\n\n解析json数据包的时候要找关键信息，因为数据包的有些数据并不会在该函数进行解析，可能会在别的函数去判断，所以我们首先要找准我们要哪些数据\n\n首先我需要获取这个数据包里面的mtype作为标志位，来判断是否接收到了这个数据包，然后去解析buf中的message的error，看看是否包含了所需的数据，然后进行判断，罗列我们所要的数据\n\n```\n|params\n\t|mtype：1\n\t|buf：\n\t\t|message:\n\t\t\t|error:0\n```\n\n根据上面所列，我们开始对json数据进行解析\n\n首先使用对整个json数据包进行解析，因为发送过来的json包如果不解析的话，无法使用接下来的json语句抓取其中的关键值\n\n```\n//首先使用上面的发送函数，来获取一个json包\nconst char* str_2 = Jsontest(name);\n\n//定义一个json格式的值用来储存json包\njson_object *recv = json_tokener_parse(str_2);\n```\n\n之后我们获得了整个json的数据，我们只需要对里面的内容进行查找即可，解包只需要一次，之后只需要不断查找判断即可\n\n我们获取的数据需要对他进行验证判断，首先需要判断是否包含该键，之后验证其格式是否正确，其携带的值是什么\n\n```\n//定义一个值来储存从recv中查找\"mtype\"键所携带的值\njson_object *mtype = json_object_object_get(recv,\"mtype\");\n\n//判断是否查找到该键，该键的格式是否为整数型，该键的值是否为1，如果有一个不符合，说明解包错误\nif(mytpe != NULL && json_object_is_type(mtype, json_type_int) && json_object_get_int(mytpe) == 1)\n```\n\n刚刚的mytpe是单参数的，多参数的也类似，不过也需要一层一层的解开，而不是直接解到最底层\n\n```\n//定义一个值来储存从recv中查找\"buf\"键所携带的值\njson_object *buf = json_object_object_get(recv,\"buf\");\n\n//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误\nif(buf != NULL && json_object_is_type(buf, json_type_object))\n{\n\t//完成第一层解包后，需要进行第二层解包，定义一个值来储存从buf中查找\"message\"键所携带的值\n\tjson_object *message = json_object_object_get(buf,\"message\");\n\t\n\t//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误\n\tif(message != NULL && json_object_is_type(message, json_type_object))\n\t{\n\t\t//继续解包，定义一个值来储存从message中查找\"error\"键所携带的值\n\t\tjson_object *error = json_object_object_get(message,\"error\");\n\t\tif(error == NULL && json_object_get_int(error) == 0)\n\t\t{\n\t\t\tCrLogI(\"belt tension no match\\n\");//有error键值，说明不合格\n\t\t}\n\t}\n\tjson_object_put(buf);//释放json空间\n}\n```\n\n最后，我们就完成了整个json的解读，获取关键值进行判断，其中如果多参数的键，我们不能让其输出值，而是需要判断其格式是否符合多参数的格式，如果是单参数的键，可以利用`json_object_get_int(error) == 0`输出值并进行比较。\n","source":"_posts/Work No.12.md","raw":"---\ntitle: Json数据包收发测试\ntag: Json\ndate: 2024-08-01\ncategories: C/C++\nindex_img: https://s2.loli.net/2024/07/31/erFMNIURnl5YdSk.jpg\n---\n\n# Json收发测试\n\n## Json构建\n\n首先定义一个Json的创建函数，函数的返回类型要是字符串格式，因为json最后的发送都是以字符串进行发送的\n\n首先要设计好Json格式的内容层次，然后再去写代码，我的Json包的层次如下\n\n```\n|params\n\t|mtype：1\n\t|buf：\n\t\t|method：BELT_TEST\n\t\t|beltNum：\n\t\t\t|name_1：90\n\t\t\t|name_2：45\n\t\t|message:\n\t\t\t|error:0\n\t\t\t|other：aaaa\n```\n\n我们需要观察在这个层次里面，哪些是包含多个参数，哪些是只有一个参数的，如果是多个参数的，我们可以把它想成一个小的json包用来装载，如果只是单个参数的，直接进行装载进去就行\n\n**记住json包的顺序定义，观察哪些是多参数的先定义，然后装载单参数，再从里往外装载多参数，最后转换格式进行发送**\n\n根据上面定义的层次定义，首先要使用`json_object_new_object()`函数创建一个params的json结构，用来装载接下来的内容\n\n```\n    //创建一个json对象\n    json_object *params = json_object_new_object();\n    \n    //创建json子对象buf\n    json_object *buf = json_object_new_object();\n    \n    //创建json子对象beltNum\n    json_object *beltNum = json_object_new_object();\n    \n    //创建json子对象message\n    json_object *message = json_object_new_object();\n```\n\n之后观察哪些是单参数，依次装载进去即可，mtype相对于params是单参数，method相对于buf是单参数，name_1和name_2相对于beltNum是单参数，error和other相对于message是单参数，所以对单参数进行装载\n\n这里面需要注意的是，如果装载的是字符，需要用json_object_new_string，如果是整数型，则用json_object_new_int\n\n```\n    //在params对象中加入键位mtype，并写入整数值1\n    json_object_object_add(params, \"mtype\", json_object_new_int(1));\n    \n    //在buf对象中加入键位method，并写入字符格式“BELT_TEST”\n    json_object_object_add(buf, \"method\", json_object_new_string(\"BELT_TEST\"));\n    \n    //在beltNum对象中加入键位name_1，并写入整数值90\n    json_object_object_add(beltNum, name_1, json_object_new_int(90));\n    \n    //在beltNum对象中加入键位name_2，并写入整数值45\n    json_object_object_add(beltNum, name_2, json_object_new_int(45));\n    \n    //在message对象中加入键位error，并写入整数值0\n    //json_object_object_add(message, \"error\", json_object_new_int(0));\n    \n    //在message对象中加入键位other，并写入字符格式“aaaaa”\n    json_object_object_add(message, \"other\", json_object_new_string(\"aaaaa\"));\n```\n\n之后，我们将多参数从层次最里面的往外进行装载即可\n\n```\n    //将belt_name的子对象加入到buf中\n    json_object_object_add(buf, \"beltNum\", beltNum);\n    \n    //将message的子对象加入到buf中\n    json_object_object_add(buf, \"message\", message);\n    \n    //将buf的子对象加入到params中\n    json_object_object_add(params, \"buf\", buf);\n```\n\n最后，我们已经完成整个json包的构建，但是在json包的收发必须通过字符串格式，而不是通过json包的格式，所以需要对格式进行转换\n\n```\n\t//将params转换成字符串格式\n    const char* cmdJsonStr = json_object_to_json_string_ext(params, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);\n    //JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。\n    //JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /\n    \n    //最后的输出格式为\n    //cmdJsonStr = {\"mtype\":1,\"buf\":{\"method\":\"BELT_TEST\",\"beltNum\":{\"name_1\":90,\"name_2\":\"45\"}\"message\":{\"error\":0,\"other\":\"aaaaa\"}}}\n```\n\n最终，我们的代码整体如下\n\n```\nstatic const char* Jsontest(char *name)\n{\n    //创建一个json对象params\n    json_object *params = json_object_new_object();\n    \n    //创建json子对象buf\n    json_object *buf = json_object_new_object();\n    \n    //创建json子对象beltNum\n    json_object *beltNum = json_object_new_object();\n    \n    //创建json子对象message\n    json_object *message = json_object_new_object();\n\n    //在params对象中加入键位mtype，并写入整数值1\n    json_object_object_add(params, \"mtype\", json_object_new_int(1));\n    \n    //在buf对象中加入键位method，并写入字符格式“BELT_TEST”\n    json_object_object_add(buf, \"method\", json_object_new_string(\"BELT_TEST\"));\n    \n    //在beltNum对象中加入键位name_1，并写入整数值90\n    json_object_object_add(beltNum, name_1, json_object_new_int(90));\n    \n    //在beltNum对象中加入键位name_2，并写入整数值45\n    json_object_object_add(beltNum, name_2, json_object_new_int(45));\n    \n    //在message对象中加入键位error，并写入整数值0\n    //json_object_object_add(message, \"error\", json_object_new_int(0));\n    \n    //在message对象中加入键位other，并写入字符格式“aaaaa”\n    json_object_object_add(message, \"other\", json_object_new_string(\"aaaaa\"));\n    \n    //将belt_name的子对象加入到buf中\n    json_object_object_add(buf, \"beltNum\", beltNum);\n    \n    //将message的子对象加入到buf中\n    json_object_object_add(buf, \"message\", message);\n    \n    //将buf的子对象加入到params中\n    json_object_object_add(params, \"buf\", buf);\n    \n    //将params转换成字符串格式\n    const char* cmdJsonStr = json_object_to_json_string_ext(params, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);\n    //JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。\n    //JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /\n    \n    //输出日志作为测试\n    CrLogI(\"cmdJsonStr = %s\\n\",cmdJsonStr);\n\n    //返回cmdJsonStr字符\n    return cmdJsonStr;\n}\n```\n\n## Json的解析\n\n解析json数据包的时候要找关键信息，因为数据包的有些数据并不会在该函数进行解析，可能会在别的函数去判断，所以我们首先要找准我们要哪些数据\n\n首先我需要获取这个数据包里面的mtype作为标志位，来判断是否接收到了这个数据包，然后去解析buf中的message的error，看看是否包含了所需的数据，然后进行判断，罗列我们所要的数据\n\n```\n|params\n\t|mtype：1\n\t|buf：\n\t\t|message:\n\t\t\t|error:0\n```\n\n根据上面所列，我们开始对json数据进行解析\n\n首先使用对整个json数据包进行解析，因为发送过来的json包如果不解析的话，无法使用接下来的json语句抓取其中的关键值\n\n```\n//首先使用上面的发送函数，来获取一个json包\nconst char* str_2 = Jsontest(name);\n\n//定义一个json格式的值用来储存json包\njson_object *recv = json_tokener_parse(str_2);\n```\n\n之后我们获得了整个json的数据，我们只需要对里面的内容进行查找即可，解包只需要一次，之后只需要不断查找判断即可\n\n我们获取的数据需要对他进行验证判断，首先需要判断是否包含该键，之后验证其格式是否正确，其携带的值是什么\n\n```\n//定义一个值来储存从recv中查找\"mtype\"键所携带的值\njson_object *mtype = json_object_object_get(recv,\"mtype\");\n\n//判断是否查找到该键，该键的格式是否为整数型，该键的值是否为1，如果有一个不符合，说明解包错误\nif(mytpe != NULL && json_object_is_type(mtype, json_type_int) && json_object_get_int(mytpe) == 1)\n```\n\n刚刚的mytpe是单参数的，多参数的也类似，不过也需要一层一层的解开，而不是直接解到最底层\n\n```\n//定义一个值来储存从recv中查找\"buf\"键所携带的值\njson_object *buf = json_object_object_get(recv,\"buf\");\n\n//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误\nif(buf != NULL && json_object_is_type(buf, json_type_object))\n{\n\t//完成第一层解包后，需要进行第二层解包，定义一个值来储存从buf中查找\"message\"键所携带的值\n\tjson_object *message = json_object_object_get(buf,\"message\");\n\t\n\t//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误\n\tif(message != NULL && json_object_is_type(message, json_type_object))\n\t{\n\t\t//继续解包，定义一个值来储存从message中查找\"error\"键所携带的值\n\t\tjson_object *error = json_object_object_get(message,\"error\");\n\t\tif(error == NULL && json_object_get_int(error) == 0)\n\t\t{\n\t\t\tCrLogI(\"belt tension no match\\n\");//有error键值，说明不合格\n\t\t}\n\t}\n\tjson_object_put(buf);//释放json空间\n}\n```\n\n最后，我们就完成了整个json的解读，获取关键值进行判断，其中如果多参数的键，我们不能让其输出值，而是需要判断其格式是否符合多参数的格式，如果是单参数的键，可以利用`json_object_get_int(error) == 0`输出值并进行比较。\n","slug":"Work No.12","published":1,"updated":"2024-08-01T11:14:09.075Z","comments":1,"layout":"post","photos":[],"_id":"clzb8b8u90000tofb7hr06cac","content":"<h1 id=\"Json收发测试\"><a href=\"#Json收发测试\" class=\"headerlink\" title=\"Json收发测试\"></a>Json收发测试</h1><h2 id=\"Json构建\"><a href=\"#Json构建\" class=\"headerlink\" title=\"Json构建\"></a>Json构建</h2><p>首先定义一个Json的创建函数，函数的返回类型要是字符串格式，因为json最后的发送都是以字符串进行发送的</p>\n<p>首先要设计好Json格式的内容层次，然后再去写代码，我的Json包的层次如下</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">|<span class=\"hljs-keyword\">params</span><br>\t|mtype：<span class=\"hljs-number\">1</span><br>\t|buf：<br>\t\t|<span class=\"hljs-keyword\">method</span>：<span class=\"hljs-title function_\">BELT_TEST</span><br>\t\t|<span class=\"hljs-title function_\">beltNum</span>：<br>\t\t\t|<span class=\"hljs-title function_\">name_1</span>：90<br>\t\t\t|<span class=\"hljs-title function_\">name_2</span>：45<br>\t\t|<span class=\"hljs-title function_\">message</span>:<br>\t\t\t|error:<span class=\"hljs-number\">0</span><br>\t\t\t|other：aaaa<br></code></pre></td></tr></table></figure>\n\n<p>我们需要观察在这个层次里面，哪些是包含多个参数，哪些是只有一个参数的，如果是多个参数的，我们可以把它想成一个小的json包用来装载，如果只是单个参数的，直接进行装载进去就行</p>\n<p><strong>记住json包的顺序定义，观察哪些是多参数的先定义，然后装载单参数，再从里往外装载多参数，最后转换格式进行发送</strong></p>\n<p>根据上面定义的层次定义，首先要使用<code>json_object_new_object()</code>函数创建一个params的json结构，用来装载接下来的内容</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//创建一个json对象</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *params = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br><br><span class=\"hljs-comment\">//创建json子对象buf</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *buf = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br><br><span class=\"hljs-comment\">//创建json子对象beltNum</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *beltNum = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br><br><span class=\"hljs-comment\">//创建json子对象message</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *message = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br></code></pre></td></tr></table></figure>\n\n<p>之后观察哪些是单参数，依次装载进去即可，mtype相对于params是单参数，method相对于buf是单参数，name_1和name_2相对于beltNum是单参数，error和other相对于message是单参数，所以对单参数进行装载</p>\n<p>这里面需要注意的是，如果装载的是字符，需要用json_object_new_string，如果是整数型，则用json_object_new_int</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//在params对象中加入键位mtype，并写入整数值1</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(params, <span class=\"hljs-string\">&quot;mtype&quot;</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>int(<span class=\"hljs-number\">1</span>));<br><br><span class=\"hljs-comment\">//在buf对象中加入键位method，并写入字符格式“BELT_TEST”</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(buf, <span class=\"hljs-string\">&quot;method&quot;</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>string(<span class=\"hljs-string\">&quot;BELT_TEST&quot;</span>));<br><br><span class=\"hljs-comment\">//在beltNum对象中加入键位name_1，并写入整数值90</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(beltNum, name<span class=\"hljs-number\">_1</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>int(<span class=\"hljs-number\">90</span>));<br><br><span class=\"hljs-comment\">//在beltNum对象中加入键位name_2，并写入整数值45</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(beltNum, name<span class=\"hljs-number\">_2</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>int(<span class=\"hljs-number\">45</span>));<br><br><span class=\"hljs-comment\">//在message对象中加入键位error，并写入整数值0</span><br><span class=\"hljs-comment\">//json_object_object_add(message, &quot;error&quot;, json_object_new_int(0));</span><br><br><span class=\"hljs-comment\">//在message对象中加入键位other，并写入字符格式“aaaaa”</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(message, <span class=\"hljs-string\">&quot;other&quot;</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>string(<span class=\"hljs-string\">&quot;aaaaa&quot;</span>));<br></code></pre></td></tr></table></figure>\n\n<p>之后，我们将多参数从层次最里面的往外进行装载即可</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//将belt_name的子对象加入到buf中</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(buf, <span class=\"hljs-string\">&quot;beltNum&quot;</span>, beltNum);<br><br><span class=\"hljs-comment\">//将message的子对象加入到buf中</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(buf, <span class=\"hljs-string\">&quot;message&quot;</span>, message);<br><br><span class=\"hljs-comment\">//将buf的子对象加入到params中</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(params, <span class=\"hljs-string\">&quot;buf&quot;</span>, buf);<br></code></pre></td></tr></table></figure>\n\n<p>最后，我们已经完成整个json包的构建，但是在json包的收发必须通过字符串格式，而不是通过json包的格式，所以需要对格式进行转换</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span>将params转换成字符串格式<br>   const char* cmdJsonStr = json_object_to_json_string_ext(params, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);<br>   <span class=\"hljs-regexp\">//</span>JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。<br>   <span class=\"hljs-regexp\">//</span>JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（<span class=\"hljs-regexp\">/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /</span><br>   <br>   <span class=\"hljs-regexp\">//</span>最后的输出格式为<br>   <span class=\"hljs-regexp\">//</span>cmdJsonStr = &#123;<span class=\"hljs-string\">&quot;mtype&quot;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&quot;buf&quot;</span>:&#123;<span class=\"hljs-string\">&quot;method&quot;</span>:<span class=\"hljs-string\">&quot;BELT_TEST&quot;</span>,<span class=\"hljs-string\">&quot;beltNum&quot;</span>:&#123;<span class=\"hljs-string\">&quot;name_1&quot;</span>:<span class=\"hljs-number\">90</span>,<span class=\"hljs-string\">&quot;name_2&quot;</span>:<span class=\"hljs-string\">&quot;45&quot;</span>&#125;<span class=\"hljs-string\">&quot;message&quot;</span>:&#123;<span class=\"hljs-string\">&quot;error&quot;</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&quot;other&quot;</span>:<span class=\"hljs-string\">&quot;aaaaa&quot;</span>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最终，我们的代码整体如下</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">char</span>* Jsontest(<span class=\"hljs-built_in\">char</span> *name)<br>&#123;<br>    <span class=\"hljs-comment\">//创建一个json对象params</span><br>    json_object *<span class=\"hljs-keyword\">params</span> = json_object_new_object();<br>    <br>    <span class=\"hljs-comment\">//创建json子对象buf</span><br>    json_object *buf = json_object_new_object();<br>    <br>    <span class=\"hljs-comment\">//创建json子对象beltNum</span><br>    json_object *beltNum = json_object_new_object();<br>    <br>    <span class=\"hljs-comment\">//创建json子对象message</span><br>    json_object *message = json_object_new_object();<br><br>    <span class=\"hljs-comment\">//在params对象中加入键位mtype，并写入整数值1</span><br>    json_object_object_add(<span class=\"hljs-keyword\">params</span>, <span class=\"hljs-string\">&quot;mtype&quot;</span>, json_object_new_int(<span class=\"hljs-number\">1</span>));<br>    <br>    <span class=\"hljs-comment\">//在buf对象中加入键位method，并写入字符格式“BELT_TEST”</span><br>    json_object_object_add(buf, <span class=\"hljs-string\">&quot;method&quot;</span>, json_object_new_string(<span class=\"hljs-string\">&quot;BELT_TEST&quot;</span>));<br>    <br>    <span class=\"hljs-comment\">//在beltNum对象中加入键位name_1，并写入整数值90</span><br>    json_object_object_add(beltNum, name_1, json_object_new_int(<span class=\"hljs-number\">90</span>));<br>    <br>    <span class=\"hljs-comment\">//在beltNum对象中加入键位name_2，并写入整数值45</span><br>    json_object_object_add(beltNum, name_2, json_object_new_int(<span class=\"hljs-number\">45</span>));<br>    <br>    <span class=\"hljs-comment\">//在message对象中加入键位error，并写入整数值0</span><br>    <span class=\"hljs-comment\">//json_object_object_add(message, &quot;error&quot;, json_object_new_int(0));</span><br>    <br>    <span class=\"hljs-comment\">//在message对象中加入键位other，并写入字符格式“aaaaa”</span><br>    json_object_object_add(message, <span class=\"hljs-string\">&quot;other&quot;</span>, json_object_new_string(<span class=\"hljs-string\">&quot;aaaaa&quot;</span>));<br>    <br>    <span class=\"hljs-comment\">//将belt_name的子对象加入到buf中</span><br>    json_object_object_add(buf, <span class=\"hljs-string\">&quot;beltNum&quot;</span>, beltNum);<br>    <br>    <span class=\"hljs-comment\">//将message的子对象加入到buf中</span><br>    json_object_object_add(buf, <span class=\"hljs-string\">&quot;message&quot;</span>, message);<br>    <br>    <span class=\"hljs-comment\">//将buf的子对象加入到params中</span><br>    json_object_object_add(<span class=\"hljs-keyword\">params</span>, <span class=\"hljs-string\">&quot;buf&quot;</span>, buf);<br>    <br>    <span class=\"hljs-comment\">//将params转换成字符串格式</span><br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">char</span>* cmdJsonStr = json_object_to_json_string_ext(<span class=\"hljs-keyword\">params</span>, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);<br>    <span class=\"hljs-comment\">//JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。</span><br>    <span class=\"hljs-comment\">//JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /</span><br>    <br>    <span class=\"hljs-comment\">//输出日志作为测试</span><br>    CrLogI(<span class=\"hljs-string\">&quot;cmdJsonStr = %s\\n&quot;</span>,cmdJsonStr);<br><br>    <span class=\"hljs-comment\">//返回cmdJsonStr字符</span><br>    <span class=\"hljs-keyword\">return</span> cmdJsonStr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Json的解析\"><a href=\"#Json的解析\" class=\"headerlink\" title=\"Json的解析\"></a>Json的解析</h2><p>解析json数据包的时候要找关键信息，因为数据包的有些数据并不会在该函数进行解析，可能会在别的函数去判断，所以我们首先要找准我们要哪些数据</p>\n<p>首先我需要获取这个数据包里面的mtype作为标志位，来判断是否接收到了这个数据包，然后去解析buf中的message的error，看看是否包含了所需的数据，然后进行判断，罗列我们所要的数据</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">|params</span><br>\t<span class=\"hljs-string\">|mtype：1</span><br>\t<span class=\"hljs-string\">|buf：</span><br>\t\t<span class=\"hljs-string\">|message:</span><br>\t\t\t<span class=\"hljs-string\">|error:0</span><br></code></pre></td></tr></table></figure>\n\n<p>根据上面所列，我们开始对json数据进行解析</p>\n<p>首先使用对整个json数据包进行解析，因为发送过来的json包如果不解析的话，无法使用接下来的json语句抓取其中的关键值</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">//首先使用上面的发送函数，来获取一个<span class=\"hljs-type\">json</span>包<br>const <span class=\"hljs-type\">char</span>* str_2 = Jsontest(<span class=\"hljs-type\">name</span>);<br><br>//定义一个<span class=\"hljs-type\">json</span>格式的值用来储存<span class=\"hljs-type\">json</span>包<br>json_object *recv = json_tokener_parse(str_2);<br></code></pre></td></tr></table></figure>\n\n<p>之后我们获得了整个json的数据，我们只需要对里面的内容进行查找即可，解包只需要一次，之后只需要不断查找判断即可</p>\n<p>我们获取的数据需要对他进行验证判断，首先需要判断是否包含该键，之后验证其格式是否正确，其携带的值是什么</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//定义一个值来储存从recv中查找&quot;mtype&quot;键所携带的值</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *mtype = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>get(recv,<span class=\"hljs-string\">&quot;mtype&quot;</span>);<br><br><span class=\"hljs-comment\">//判断是否查找到该键，该键的格式是否为整数型，该键的值是否为1，如果有一个不符合，说明解包错误</span><br><span class=\"hljs-keyword\">if</span>(mytpe != NULL &amp;&amp; json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">is</span><span class=\"hljs-number\">_</span>type(mtype, json<span class=\"hljs-number\">_</span>type<span class=\"hljs-number\">_</span>int) &amp;&amp; json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>get<span class=\"hljs-number\">_</span>int(mytpe) == <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>刚刚的mytpe是单参数的，多参数的也类似，不过也需要一层一层的解开，而不是直接解到最底层</p>\n<figure class=\"highlight sas\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sas\">//定义一个值来储存从recv中查找<span class=\"hljs-string\">&quot;buf&quot;</span>键所携带的值<br>json_object <span class=\"hljs-comment\">*buf = json_object_object_get(recv,&quot;buf&quot;);</span><br><br>//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误<br><span class=\"hljs-keyword\">if</span>(buf != <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-variable\">&amp;&amp;</span> json_object_is_type(buf, json_type_object))<br>&#123;<br>\t//完成第一层解包后，需要进行第二层解包，定义一个值来储存从buf中查找<span class=\"hljs-string\">&quot;message&quot;</span>键所携带的值<br>\tjson_object <span class=\"hljs-comment\">*message = json_object_object_get(buf,&quot;message&quot;);</span><br>\t<br>\t//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误<br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">message</span> != <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-variable\">&amp;&amp;</span> json_object_is_type(<span class=\"hljs-keyword\">message</span>, json_type_object))<br>\t&#123;<br>\t\t//继续解包，定义一个值来储存从<span class=\"hljs-keyword\">message</span>中查找<span class=\"hljs-string\">&quot;error&quot;</span>键所携带的值<br>\t\tjson_object <span class=\"hljs-comment\">*error = json_object_object_get(message,&quot;error&quot;);</span><br>\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">error</span> == <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-variable\">&amp;&amp;</span> json_object_get_<span class=\"hljs-meta\">int</span>(<span class=\"hljs-keyword\">error</span>) == 0)<br>\t\t&#123;<br>\t\t\tCrLogI(<span class=\"hljs-string\">&quot;belt tension no match\\n&quot;</span>);//有<span class=\"hljs-keyword\">error</span>键值，说明不合格<br>\t\t&#125;<br>\t&#125;<br>\tjson_object_<span class=\"hljs-meta\">put</span>(buf);//释放json空间<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最后，我们就完成了整个json的解读，获取关键值进行判断，其中如果多参数的键，我们不能让其输出值，而是需要判断其格式是否符合多参数的格式，如果是单参数的键，可以利用<code>json_object_get_int(error) == 0</code>输出值并进行比较。</p>\n","excerpt":"","more":"<h1 id=\"Json收发测试\"><a href=\"#Json收发测试\" class=\"headerlink\" title=\"Json收发测试\"></a>Json收发测试</h1><h2 id=\"Json构建\"><a href=\"#Json构建\" class=\"headerlink\" title=\"Json构建\"></a>Json构建</h2><p>首先定义一个Json的创建函数，函数的返回类型要是字符串格式，因为json最后的发送都是以字符串进行发送的</p>\n<p>首先要设计好Json格式的内容层次，然后再去写代码，我的Json包的层次如下</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">|<span class=\"hljs-keyword\">params</span><br>\t|mtype：<span class=\"hljs-number\">1</span><br>\t|buf：<br>\t\t|<span class=\"hljs-keyword\">method</span>：<span class=\"hljs-title function_\">BELT_TEST</span><br>\t\t|<span class=\"hljs-title function_\">beltNum</span>：<br>\t\t\t|<span class=\"hljs-title function_\">name_1</span>：90<br>\t\t\t|<span class=\"hljs-title function_\">name_2</span>：45<br>\t\t|<span class=\"hljs-title function_\">message</span>:<br>\t\t\t|error:<span class=\"hljs-number\">0</span><br>\t\t\t|other：aaaa<br></code></pre></td></tr></table></figure>\n\n<p>我们需要观察在这个层次里面，哪些是包含多个参数，哪些是只有一个参数的，如果是多个参数的，我们可以把它想成一个小的json包用来装载，如果只是单个参数的，直接进行装载进去就行</p>\n<p><strong>记住json包的顺序定义，观察哪些是多参数的先定义，然后装载单参数，再从里往外装载多参数，最后转换格式进行发送</strong></p>\n<p>根据上面定义的层次定义，首先要使用<code>json_object_new_object()</code>函数创建一个params的json结构，用来装载接下来的内容</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//创建一个json对象</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *params = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br><br><span class=\"hljs-comment\">//创建json子对象buf</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *buf = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br><br><span class=\"hljs-comment\">//创建json子对象beltNum</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *beltNum = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br><br><span class=\"hljs-comment\">//创建json子对象message</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *message = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span>();<br></code></pre></td></tr></table></figure>\n\n<p>之后观察哪些是单参数，依次装载进去即可，mtype相对于params是单参数，method相对于buf是单参数，name_1和name_2相对于beltNum是单参数，error和other相对于message是单参数，所以对单参数进行装载</p>\n<p>这里面需要注意的是，如果装载的是字符，需要用json_object_new_string，如果是整数型，则用json_object_new_int</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//在params对象中加入键位mtype，并写入整数值1</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(params, <span class=\"hljs-string\">&quot;mtype&quot;</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>int(<span class=\"hljs-number\">1</span>));<br><br><span class=\"hljs-comment\">//在buf对象中加入键位method，并写入字符格式“BELT_TEST”</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(buf, <span class=\"hljs-string\">&quot;method&quot;</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>string(<span class=\"hljs-string\">&quot;BELT_TEST&quot;</span>));<br><br><span class=\"hljs-comment\">//在beltNum对象中加入键位name_1，并写入整数值90</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(beltNum, name<span class=\"hljs-number\">_1</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>int(<span class=\"hljs-number\">90</span>));<br><br><span class=\"hljs-comment\">//在beltNum对象中加入键位name_2，并写入整数值45</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(beltNum, name<span class=\"hljs-number\">_2</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>int(<span class=\"hljs-number\">45</span>));<br><br><span class=\"hljs-comment\">//在message对象中加入键位error，并写入整数值0</span><br><span class=\"hljs-comment\">//json_object_object_add(message, &quot;error&quot;, json_object_new_int(0));</span><br><br><span class=\"hljs-comment\">//在message对象中加入键位other，并写入字符格式“aaaaa”</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(message, <span class=\"hljs-string\">&quot;other&quot;</span>, json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_n</span>ew<span class=\"hljs-number\">_</span>string(<span class=\"hljs-string\">&quot;aaaaa&quot;</span>));<br></code></pre></td></tr></table></figure>\n\n<p>之后，我们将多参数从层次最里面的往外进行装载即可</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//将belt_name的子对象加入到buf中</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(buf, <span class=\"hljs-string\">&quot;beltNum&quot;</span>, beltNum);<br><br><span class=\"hljs-comment\">//将message的子对象加入到buf中</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(buf, <span class=\"hljs-string\">&quot;message&quot;</span>, message);<br><br><span class=\"hljs-comment\">//将buf的子对象加入到params中</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>add(params, <span class=\"hljs-string\">&quot;buf&quot;</span>, buf);<br></code></pre></td></tr></table></figure>\n\n<p>最后，我们已经完成整个json包的构建，但是在json包的收发必须通过字符串格式，而不是通过json包的格式，所以需要对格式进行转换</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span>将params转换成字符串格式<br>   const char* cmdJsonStr = json_object_to_json_string_ext(params, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);<br>   <span class=\"hljs-regexp\">//</span>JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。<br>   <span class=\"hljs-regexp\">//</span>JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（<span class=\"hljs-regexp\">/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /</span><br>   <br>   <span class=\"hljs-regexp\">//</span>最后的输出格式为<br>   <span class=\"hljs-regexp\">//</span>cmdJsonStr = &#123;<span class=\"hljs-string\">&quot;mtype&quot;</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&quot;buf&quot;</span>:&#123;<span class=\"hljs-string\">&quot;method&quot;</span>:<span class=\"hljs-string\">&quot;BELT_TEST&quot;</span>,<span class=\"hljs-string\">&quot;beltNum&quot;</span>:&#123;<span class=\"hljs-string\">&quot;name_1&quot;</span>:<span class=\"hljs-number\">90</span>,<span class=\"hljs-string\">&quot;name_2&quot;</span>:<span class=\"hljs-string\">&quot;45&quot;</span>&#125;<span class=\"hljs-string\">&quot;message&quot;</span>:&#123;<span class=\"hljs-string\">&quot;error&quot;</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&quot;other&quot;</span>:<span class=\"hljs-string\">&quot;aaaaa&quot;</span>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最终，我们的代码整体如下</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">char</span>* Jsontest(<span class=\"hljs-built_in\">char</span> *name)<br>&#123;<br>    <span class=\"hljs-comment\">//创建一个json对象params</span><br>    json_object *<span class=\"hljs-keyword\">params</span> = json_object_new_object();<br>    <br>    <span class=\"hljs-comment\">//创建json子对象buf</span><br>    json_object *buf = json_object_new_object();<br>    <br>    <span class=\"hljs-comment\">//创建json子对象beltNum</span><br>    json_object *beltNum = json_object_new_object();<br>    <br>    <span class=\"hljs-comment\">//创建json子对象message</span><br>    json_object *message = json_object_new_object();<br><br>    <span class=\"hljs-comment\">//在params对象中加入键位mtype，并写入整数值1</span><br>    json_object_object_add(<span class=\"hljs-keyword\">params</span>, <span class=\"hljs-string\">&quot;mtype&quot;</span>, json_object_new_int(<span class=\"hljs-number\">1</span>));<br>    <br>    <span class=\"hljs-comment\">//在buf对象中加入键位method，并写入字符格式“BELT_TEST”</span><br>    json_object_object_add(buf, <span class=\"hljs-string\">&quot;method&quot;</span>, json_object_new_string(<span class=\"hljs-string\">&quot;BELT_TEST&quot;</span>));<br>    <br>    <span class=\"hljs-comment\">//在beltNum对象中加入键位name_1，并写入整数值90</span><br>    json_object_object_add(beltNum, name_1, json_object_new_int(<span class=\"hljs-number\">90</span>));<br>    <br>    <span class=\"hljs-comment\">//在beltNum对象中加入键位name_2，并写入整数值45</span><br>    json_object_object_add(beltNum, name_2, json_object_new_int(<span class=\"hljs-number\">45</span>));<br>    <br>    <span class=\"hljs-comment\">//在message对象中加入键位error，并写入整数值0</span><br>    <span class=\"hljs-comment\">//json_object_object_add(message, &quot;error&quot;, json_object_new_int(0));</span><br>    <br>    <span class=\"hljs-comment\">//在message对象中加入键位other，并写入字符格式“aaaaa”</span><br>    json_object_object_add(message, <span class=\"hljs-string\">&quot;other&quot;</span>, json_object_new_string(<span class=\"hljs-string\">&quot;aaaaa&quot;</span>));<br>    <br>    <span class=\"hljs-comment\">//将belt_name的子对象加入到buf中</span><br>    json_object_object_add(buf, <span class=\"hljs-string\">&quot;beltNum&quot;</span>, beltNum);<br>    <br>    <span class=\"hljs-comment\">//将message的子对象加入到buf中</span><br>    json_object_object_add(buf, <span class=\"hljs-string\">&quot;message&quot;</span>, message);<br>    <br>    <span class=\"hljs-comment\">//将buf的子对象加入到params中</span><br>    json_object_object_add(<span class=\"hljs-keyword\">params</span>, <span class=\"hljs-string\">&quot;buf&quot;</span>, buf);<br>    <br>    <span class=\"hljs-comment\">//将params转换成字符串格式</span><br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">char</span>* cmdJsonStr = json_object_to_json_string_ext(<span class=\"hljs-keyword\">params</span>, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);<br>    <span class=\"hljs-comment\">//JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。</span><br>    <span class=\"hljs-comment\">//JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（/）进行转义。在 JSON 标准中，斜杠可以被转义为 \\/，但这个标志会使输出保持为 /</span><br>    <br>    <span class=\"hljs-comment\">//输出日志作为测试</span><br>    CrLogI(<span class=\"hljs-string\">&quot;cmdJsonStr = %s\\n&quot;</span>,cmdJsonStr);<br><br>    <span class=\"hljs-comment\">//返回cmdJsonStr字符</span><br>    <span class=\"hljs-keyword\">return</span> cmdJsonStr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Json的解析\"><a href=\"#Json的解析\" class=\"headerlink\" title=\"Json的解析\"></a>Json的解析</h2><p>解析json数据包的时候要找关键信息，因为数据包的有些数据并不会在该函数进行解析，可能会在别的函数去判断，所以我们首先要找准我们要哪些数据</p>\n<p>首先我需要获取这个数据包里面的mtype作为标志位，来判断是否接收到了这个数据包，然后去解析buf中的message的error，看看是否包含了所需的数据，然后进行判断，罗列我们所要的数据</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">|params</span><br>\t<span class=\"hljs-string\">|mtype：1</span><br>\t<span class=\"hljs-string\">|buf：</span><br>\t\t<span class=\"hljs-string\">|message:</span><br>\t\t\t<span class=\"hljs-string\">|error:0</span><br></code></pre></td></tr></table></figure>\n\n<p>根据上面所列，我们开始对json数据进行解析</p>\n<p>首先使用对整个json数据包进行解析，因为发送过来的json包如果不解析的话，无法使用接下来的json语句抓取其中的关键值</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">//首先使用上面的发送函数，来获取一个<span class=\"hljs-type\">json</span>包<br>const <span class=\"hljs-type\">char</span>* str_2 = Jsontest(<span class=\"hljs-type\">name</span>);<br><br>//定义一个<span class=\"hljs-type\">json</span>格式的值用来储存<span class=\"hljs-type\">json</span>包<br>json_object *recv = json_tokener_parse(str_2);<br></code></pre></td></tr></table></figure>\n\n<p>之后我们获得了整个json的数据，我们只需要对里面的内容进行查找即可，解包只需要一次，之后只需要不断查找判断即可</p>\n<p>我们获取的数据需要对他进行验证判断，首先需要判断是否包含该键，之后验证其格式是否正确，其携带的值是什么</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ceylon\"><span class=\"hljs-comment\">//定义一个值来储存从recv中查找&quot;mtype&quot;键所携带的值</span><br>json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span> *mtype = json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>get(recv,<span class=\"hljs-string\">&quot;mtype&quot;</span>);<br><br><span class=\"hljs-comment\">//判断是否查找到该键，该键的格式是否为整数型，该键的值是否为1，如果有一个不符合，说明解包错误</span><br><span class=\"hljs-keyword\">if</span>(mytpe != NULL &amp;&amp; json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">is</span><span class=\"hljs-number\">_</span>type(mtype, json<span class=\"hljs-number\">_</span>type<span class=\"hljs-number\">_</span>int) &amp;&amp; json<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">object</span><span class=\"hljs-number\">_</span>get<span class=\"hljs-number\">_</span>int(mytpe) == <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>刚刚的mytpe是单参数的，多参数的也类似，不过也需要一层一层的解开，而不是直接解到最底层</p>\n<figure class=\"highlight sas\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sas\">//定义一个值来储存从recv中查找<span class=\"hljs-string\">&quot;buf&quot;</span>键所携带的值<br>json_object <span class=\"hljs-comment\">*buf = json_object_object_get(recv,&quot;buf&quot;);</span><br><br>//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误<br><span class=\"hljs-keyword\">if</span>(buf != <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-variable\">&amp;&amp;</span> json_object_is_type(buf, json_type_object))<br>&#123;<br>\t//完成第一层解包后，需要进行第二层解包，定义一个值来储存从buf中查找<span class=\"hljs-string\">&quot;message&quot;</span>键所携带的值<br>\tjson_object <span class=\"hljs-comment\">*message = json_object_object_get(buf,&quot;message&quot;);</span><br>\t<br>\t//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误<br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">message</span> != <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-variable\">&amp;&amp;</span> json_object_is_type(<span class=\"hljs-keyword\">message</span>, json_type_object))<br>\t&#123;<br>\t\t//继续解包，定义一个值来储存从<span class=\"hljs-keyword\">message</span>中查找<span class=\"hljs-string\">&quot;error&quot;</span>键所携带的值<br>\t\tjson_object <span class=\"hljs-comment\">*error = json_object_object_get(message,&quot;error&quot;);</span><br>\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">error</span> == <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-variable\">&amp;&amp;</span> json_object_get_<span class=\"hljs-meta\">int</span>(<span class=\"hljs-keyword\">error</span>) == 0)<br>\t\t&#123;<br>\t\t\tCrLogI(<span class=\"hljs-string\">&quot;belt tension no match\\n&quot;</span>);//有<span class=\"hljs-keyword\">error</span>键值，说明不合格<br>\t\t&#125;<br>\t&#125;<br>\tjson_object_<span class=\"hljs-meta\">put</span>(buf);//释放json空间<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最后，我们就完成了整个json的解读，获取关键值进行判断，其中如果多参数的键，我们不能让其输出值，而是需要判断其格式是否符合多参数的格式，如果是单参数的键，可以利用<code>json_object_get_int(error) == 0</code>输出值并进行比较。</p>\n"},{"title":"C语言指针学习","date":"2024-08-01T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/b1YNChod7EyzTsF.jpg","_content":"\n# C语言指针学习\n\n## 感谢博主：\n\n[指针基础知识理解（简单、易懂、超详细！！！！）_史上最全指针解释-CSDN博客](https://blog.csdn.net/weixin_45031801/article/details/127017272)\n\n[让你不再害怕指针——C指针详解(经典,非常详细)_c语言指针-CSDN博客](https://blog.csdn.net/soonfly/article/details/51131141)\n\n## 计算机的语言表示\n\n在现代的计算机中主要采用的数字集成电路完成，数字电路通过高低电平只能表示**0和1**，所以就出现了，计算机只会识别**0和1**。无论是存储还是计算，计算机均采用二进制体系完成。\n\n例如：十进制 **4** ---------- 用二进制表示为 00000**100**\n\n在C语言中，一个`int`类型的整数占用的字节数是固定的，并且与具体数值（例如`1`）无关。通常情况下，`int`类型的大小是4字节（32位）。不过，这个大小可能会因平台或编译器的不同而有所变化。\n\n## 计算机基础单位和数据类型\n\n```\n \t1. bit------------ 比特 ------------- 位\n    2. byte --------- 字节 ------------- 1byte = 8bit\n    3. KB ------------ 千字节 ---------- 1KB = 1024byte\n    4. MB ----------- 兆 ---------------- 1MB = 1024KB\n    5. GB ----------- 吉字节 ---------- 1GB = 1024MB\n    6. TB  ----------- 太字节 ---------- 1TB = 1024GB\n    7. PB ----------- 拍字节 ----------- 1PB = 1024TB\n```\n\n其中在C语言中的一些特定的数据类型存储也是有一定的范围的：\n\n```\n    1. char -------- 1字节\n    2. short --------- 2字节\n    3. int -------- 4字节   \n    4. long ---------- 4字节\n    5. long long -------- 8字节\n    6. float ---------- 4字节\n```\n\n## 二进制数\n\n  **1. 二进制数是带符号的，即分正、负数。其中若是正数最高位显示 0 ，若是负数最高位显示 1**\n\n  **2. 二进制位通常也会受到数据类型的限制，比如 char 型 1 个字节 8 个比特位。**\n\n```\n  举例：int 2 ;  ------------------二进制表示：00000000 00000000 00000000 00000010\n```\n\n## 指针\n\n**int \\*p;** -- 首先从 p 处开始，先与 ***** 结合，所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。\n\n **int \\*p[3];** -- 首先从 p 处开始, 先与 [] 结合，因为其优先级比 ***** 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。\n\n**int \\**p;** -- 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针\n\n我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；\n\n指针的类型(即指针本身的类型)和指针所指向的类型是两个概念\n\n只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型\n\n```\n1、int *ptr; : 指针的类型是 int*\n2、char *ptr; : 指针的类型是 char*\n3、int **ptr; : 指针的类型是 int**\n4、int (*ptr)[3]; : 指针的类型是 int(*)[3]\n5、int *(*ptr)[4]; : 指针的类型是 int*(*)[4]\n```\n\n指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。\n\n```\n1、int*ptr; : 指针所指向的类型是 int\n2、char*ptr; : 指针所指向的的类型是 char\n3、int**ptr; : 指针所指向的的类型是 int*\n4、int(*ptr)[3]; : 指针所指向的的类型是 int()[3]\n5、int*(*ptr)[4]; : 指针所指向的的类型是 int*()[4]\n```\n\n指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度\n\n&符号代表地址的符号，是内存地址，然后内存地址上面会存放内容，地址不代表是内存空间\n\n*代表指向，p代表内存地址，`*p`指向这片内存地址上面的内容\n\n#### 指针是什么？\n\n内存：就是存放东西的空间\n\n![8eafbb6548c929bc99f94ef018128c1a.png](https://s2.loli.net/2024/08/05/NIi8RQXMkglrqeC.png)![dba3cdc29d8127ee60c8ca0446bf23fe.png](https://s2.loli.net/2024/08/05/Si3Oj5NPpr6Lz1h.png)\n\n左图就是内存，这个内存中有9个空间，一个空间代表一个字节\n\n右图就是在这个内存空间中，去创建两个变量 int a 和一个 char ch 根据基础知识，可以知道int 占4个字节 char 占1个字节，注意内存中间的每一个小空间（就是1个字节）是有编号的（1，2，3，4，5，6，7，8，9），内存的编号就是地址，地址也叫指针。\n\n```\n1. 内存的编号就是地址，地址也叫指针。\n2. 指针是内存中最小单元的编号，也就是地址。\n3. 编号-------->地址---------->指针\n```\n\n#### 指针的类型\n\n```\n1. 指针类型：决定了指针进行解引用操作的时候，访问几个字节（权限）\n2. char * 的指针引用字节访问1个字节\n3. int * 的指针引用字节访问4个字节\n4. double * 的指针引用字节访问8个字节\n```\n\n0x开头的就表示十六进制，1个十六进制位表示4个二进制位\n\n```\n\tint a = 0x11223344; //这是一个16进制数，一共是8位，所以代表二进制的32位，换算也就是4个字节，一个字节8位\n\tint *pa=&a; //定义成int类型，就可以访问4个字节的权限\n\t*pa = 0; //重新替换成零，所以结果是0x00000000\n\t\n\tchar* pc = &a;  //定义成int类型，就可以访问1个字节的权限\n\t*pc = 0;  //重新替换成零，所以结果是0x11223300，他只能替换一个字节，也就是八位，两个十六进制位\n```\n\n#### 指针打印数组\n\n```\n\tint a[10] = { 0 };  //内存中创建了10个整型，所以一个数组所占的空间就是40个字节，40b\n \n\tint* pa = a;  //数组名就是首元素的地址\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\t*pa = i + 1;   // 数值+1\n\t\t pa++;         //地址+1\n\t\t //*(pa+i)=i+1\n\t\t // pa表示pa中存放的地址  *pa表示：指向存放地址的内容，也就是解用\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tprintf(\"%d \", a[i]);\n\t\t//printf(\"%d \", *(pa+i));如果要使用这种输出的话，需要考虑的是，在上一个for循环后，*pa就已经不是指向首地址，而是指向尾地址\n\t}\n\t\n\tint a[5] = {5,6,7,8,9};//定义一个数组\n\tint* arr = &a[4];//这个指向的是地址类型上面的内容，也就是数组a的第五个数据\n\t//输出结果：9\n\t\n\tint *arr = &a;//这个指向的是数组a的地址类型上面的内容，也就是数组里面的全部数据\n\t//输出结果：5，6，7，8，9\n\t\n\tint *arr;//定义指针类型为int\n\tarr = a;//指向的是数组a的全部数据地址\n\t//输出结果：000000000061FDF0 000000000061FDF4 000000000061FDF8 000000000061FDFC 000000000061FE00\n```\n\n`void aaaaaa(char* name)` 和 `void aaaaaa(char *name)` 这两种函数声明在 C 语言中实际上是等效的。它们的功能和行为是相同的。\n","source":"_posts/Work No.13.md","raw":"---\ntitle: C语言指针学习\ntag: C/C++\ndate: 2024-08-02\ncategories: C/C++\nindex_img: https://s2.loli.net/2024/07/31/b1YNChod7EyzTsF.jpg\n---\n\n# C语言指针学习\n\n## 感谢博主：\n\n[指针基础知识理解（简单、易懂、超详细！！！！）_史上最全指针解释-CSDN博客](https://blog.csdn.net/weixin_45031801/article/details/127017272)\n\n[让你不再害怕指针——C指针详解(经典,非常详细)_c语言指针-CSDN博客](https://blog.csdn.net/soonfly/article/details/51131141)\n\n## 计算机的语言表示\n\n在现代的计算机中主要采用的数字集成电路完成，数字电路通过高低电平只能表示**0和1**，所以就出现了，计算机只会识别**0和1**。无论是存储还是计算，计算机均采用二进制体系完成。\n\n例如：十进制 **4** ---------- 用二进制表示为 00000**100**\n\n在C语言中，一个`int`类型的整数占用的字节数是固定的，并且与具体数值（例如`1`）无关。通常情况下，`int`类型的大小是4字节（32位）。不过，这个大小可能会因平台或编译器的不同而有所变化。\n\n## 计算机基础单位和数据类型\n\n```\n \t1. bit------------ 比特 ------------- 位\n    2. byte --------- 字节 ------------- 1byte = 8bit\n    3. KB ------------ 千字节 ---------- 1KB = 1024byte\n    4. MB ----------- 兆 ---------------- 1MB = 1024KB\n    5. GB ----------- 吉字节 ---------- 1GB = 1024MB\n    6. TB  ----------- 太字节 ---------- 1TB = 1024GB\n    7. PB ----------- 拍字节 ----------- 1PB = 1024TB\n```\n\n其中在C语言中的一些特定的数据类型存储也是有一定的范围的：\n\n```\n    1. char -------- 1字节\n    2. short --------- 2字节\n    3. int -------- 4字节   \n    4. long ---------- 4字节\n    5. long long -------- 8字节\n    6. float ---------- 4字节\n```\n\n## 二进制数\n\n  **1. 二进制数是带符号的，即分正、负数。其中若是正数最高位显示 0 ，若是负数最高位显示 1**\n\n  **2. 二进制位通常也会受到数据类型的限制，比如 char 型 1 个字节 8 个比特位。**\n\n```\n  举例：int 2 ;  ------------------二进制表示：00000000 00000000 00000000 00000010\n```\n\n## 指针\n\n**int \\*p;** -- 首先从 p 处开始，先与 ***** 结合，所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。\n\n **int \\*p[3];** -- 首先从 p 处开始, 先与 [] 结合，因为其优先级比 ***** 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。\n\n**int \\**p;** -- 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针\n\n我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；\n\n指针的类型(即指针本身的类型)和指针所指向的类型是两个概念\n\n只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型\n\n```\n1、int *ptr; : 指针的类型是 int*\n2、char *ptr; : 指针的类型是 char*\n3、int **ptr; : 指针的类型是 int**\n4、int (*ptr)[3]; : 指针的类型是 int(*)[3]\n5、int *(*ptr)[4]; : 指针的类型是 int*(*)[4]\n```\n\n指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。\n\n```\n1、int*ptr; : 指针所指向的类型是 int\n2、char*ptr; : 指针所指向的的类型是 char\n3、int**ptr; : 指针所指向的的类型是 int*\n4、int(*ptr)[3]; : 指针所指向的的类型是 int()[3]\n5、int*(*ptr)[4]; : 指针所指向的的类型是 int*()[4]\n```\n\n指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度\n\n&符号代表地址的符号，是内存地址，然后内存地址上面会存放内容，地址不代表是内存空间\n\n*代表指向，p代表内存地址，`*p`指向这片内存地址上面的内容\n\n#### 指针是什么？\n\n内存：就是存放东西的空间\n\n![8eafbb6548c929bc99f94ef018128c1a.png](https://s2.loli.net/2024/08/05/NIi8RQXMkglrqeC.png)![dba3cdc29d8127ee60c8ca0446bf23fe.png](https://s2.loli.net/2024/08/05/Si3Oj5NPpr6Lz1h.png)\n\n左图就是内存，这个内存中有9个空间，一个空间代表一个字节\n\n右图就是在这个内存空间中，去创建两个变量 int a 和一个 char ch 根据基础知识，可以知道int 占4个字节 char 占1个字节，注意内存中间的每一个小空间（就是1个字节）是有编号的（1，2，3，4，5，6，7，8，9），内存的编号就是地址，地址也叫指针。\n\n```\n1. 内存的编号就是地址，地址也叫指针。\n2. 指针是内存中最小单元的编号，也就是地址。\n3. 编号-------->地址---------->指针\n```\n\n#### 指针的类型\n\n```\n1. 指针类型：决定了指针进行解引用操作的时候，访问几个字节（权限）\n2. char * 的指针引用字节访问1个字节\n3. int * 的指针引用字节访问4个字节\n4. double * 的指针引用字节访问8个字节\n```\n\n0x开头的就表示十六进制，1个十六进制位表示4个二进制位\n\n```\n\tint a = 0x11223344; //这是一个16进制数，一共是8位，所以代表二进制的32位，换算也就是4个字节，一个字节8位\n\tint *pa=&a; //定义成int类型，就可以访问4个字节的权限\n\t*pa = 0; //重新替换成零，所以结果是0x00000000\n\t\n\tchar* pc = &a;  //定义成int类型，就可以访问1个字节的权限\n\t*pc = 0;  //重新替换成零，所以结果是0x11223300，他只能替换一个字节，也就是八位，两个十六进制位\n```\n\n#### 指针打印数组\n\n```\n\tint a[10] = { 0 };  //内存中创建了10个整型，所以一个数组所占的空间就是40个字节，40b\n \n\tint* pa = a;  //数组名就是首元素的地址\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\t*pa = i + 1;   // 数值+1\n\t\t pa++;         //地址+1\n\t\t //*(pa+i)=i+1\n\t\t // pa表示pa中存放的地址  *pa表示：指向存放地址的内容，也就是解用\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tprintf(\"%d \", a[i]);\n\t\t//printf(\"%d \", *(pa+i));如果要使用这种输出的话，需要考虑的是，在上一个for循环后，*pa就已经不是指向首地址，而是指向尾地址\n\t}\n\t\n\tint a[5] = {5,6,7,8,9};//定义一个数组\n\tint* arr = &a[4];//这个指向的是地址类型上面的内容，也就是数组a的第五个数据\n\t//输出结果：9\n\t\n\tint *arr = &a;//这个指向的是数组a的地址类型上面的内容，也就是数组里面的全部数据\n\t//输出结果：5，6，7，8，9\n\t\n\tint *arr;//定义指针类型为int\n\tarr = a;//指向的是数组a的全部数据地址\n\t//输出结果：000000000061FDF0 000000000061FDF4 000000000061FDF8 000000000061FDFC 000000000061FE00\n```\n\n`void aaaaaa(char* name)` 和 `void aaaaaa(char *name)` 这两种函数声明在 C 语言中实际上是等效的。它们的功能和行为是相同的。\n","slug":"Work No.13","published":1,"updated":"2024-08-09T04:05:47.759Z","_id":"clzc67ewo0000xofb63g641zq","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"C语言指针学习\"><a href=\"#C语言指针学习\" class=\"headerlink\" title=\"C语言指针学习\"></a>C语言指针学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/weixin_45031801/article/details/127017272\">指针基础知识理解（简单、易懂、超详细！！！！）_史上最全指针解释-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/soonfly/article/details/51131141\">让你不再害怕指针——C指针详解(经典,非常详细)_c语言指针-CSDN博客</a></p>\n<h2 id=\"计算机的语言表示\"><a href=\"#计算机的语言表示\" class=\"headerlink\" title=\"计算机的语言表示\"></a>计算机的语言表示</h2><p>在现代的计算机中主要采用的数字集成电路完成，数字电路通过高低电平只能表示<strong>0和1</strong>，所以就出现了，计算机只会识别<strong>0和1</strong>。无论是存储还是计算，计算机均采用二进制体系完成。</p>\n<p>例如：十进制 <strong>4</strong> ———- 用二进制表示为 00000<strong>100</strong></p>\n<p>在C语言中，一个<code>int</code>类型的整数占用的字节数是固定的，并且与具体数值（例如<code>1</code>）无关。通常情况下，<code>int</code>类型的大小是4字节（32位）。不过，这个大小可能会因平台或编译器的不同而有所变化。</p>\n<h2 id=\"计算机基础单位和数据类型\"><a href=\"#计算机基础单位和数据类型\" class=\"headerlink\" title=\"计算机基础单位和数据类型\"></a>计算机基础单位和数据类型</h2><figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs brainfuck\"><span class=\"hljs-comment\">1</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">bit</span><span class=\"hljs-literal\">------------</span> <span class=\"hljs-comment\">比特</span> <span class=\"hljs-literal\">-------------</span> <span class=\"hljs-comment\">位</span><br>  <span class=\"hljs-comment\">2</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">byte</span> <span class=\"hljs-literal\">---------</span> <span class=\"hljs-comment\">字节</span> <span class=\"hljs-literal\">-------------</span> <span class=\"hljs-comment\">1byte = 8bit</span><br>  <span class=\"hljs-comment\">3</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">KB</span> <span class=\"hljs-literal\">------------</span> <span class=\"hljs-comment\">千字节</span> <span class=\"hljs-literal\">----------</span> <span class=\"hljs-comment\">1KB = 1024byte</span><br>  <span class=\"hljs-comment\">4</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">MB</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">兆</span> <span class=\"hljs-literal\">----------------</span> <span class=\"hljs-comment\">1MB = 1024KB</span><br>  <span class=\"hljs-comment\">5</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">GB</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">吉字节</span> <span class=\"hljs-literal\">----------</span> <span class=\"hljs-comment\">1GB = 1024MB</span><br>  <span class=\"hljs-comment\">6</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">TB</span>  <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">太字节</span> <span class=\"hljs-literal\">----------</span> <span class=\"hljs-comment\">1TB = 1024GB</span><br>  <span class=\"hljs-comment\">7</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">PB</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">拍字节</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">1PB = 1024TB</span><br></code></pre></td></tr></table></figure>\n\n<p>其中在C语言中的一些特定的数据类型存储也是有一定的范围的：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">char</span> <span class=\"hljs-comment\">-------- 1字节</span><br><span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">short</span> <span class=\"hljs-comment\">--------- 2字节</span><br><span class=\"hljs-number\">3.</span> int <span class=\"hljs-comment\">-------- 4字节   </span><br><span class=\"hljs-number\">4.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">---------- 4字节</span><br><span class=\"hljs-number\">5.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">-------- 8字节</span><br><span class=\"hljs-number\">6.</span> float <span class=\"hljs-comment\">---------- 4字节</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二进制数\"><a href=\"#二进制数\" class=\"headerlink\" title=\"二进制数\"></a>二进制数</h2><p>  <strong>1. 二进制数是带符号的，即分正、负数。其中若是正数最高位显示 0 ，若是负数最高位显示 1</strong></p>\n<p>  <strong>2. 二进制位通常也会受到数据类型的限制，比如 char 型 1 个字节 8 个比特位。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">举例：<span class=\"hljs-type\">int</span> <span class=\"hljs-number\">2</span> ;  <span class=\"hljs-comment\">------------------二进制表示：00000000 00000000 00000000 00000010</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><p><strong>int *p;</strong> – 首先从 p 处开始，先与 ***** 结合，所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。</p>\n<p> <strong>int *p[3];</strong> – 首先从 p 处开始, 先与 [] 结合，因为其优先级比 ***** 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。</p>\n<p>*<em>int *<em>p;</em></em> – 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针</p>\n<p>我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；</p>\n<p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念</p>\n<p>只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\"><span class=\"hljs-number\">1</span>、int *ptr; : 指针的类型是 int*<br><span class=\"hljs-number\">2</span>、char *ptr; : 指针的类型是 char*<br><span class=\"hljs-number\">3</span>、int **ptr; : 指针的类型是 int**<br><span class=\"hljs-number\">4</span>、int <span class=\"hljs-comment\">(*ptr)[3]; : 指针的类型是 int(*)</span>[<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-number\">5</span>、int *<span class=\"hljs-comment\">(*ptr)[4]; : 指针的类型是 int*(*)</span>[<span class=\"hljs-number\">4</span>]<br></code></pre></td></tr></table></figure>\n\n<p>指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\"><span class=\"hljs-number\">1</span>、<span class=\"hljs-type\">int</span>*<span class=\"hljs-keyword\">ptr</span>; : 指针所指向的类型是 <span class=\"hljs-type\">int</span><br><span class=\"hljs-number\">2</span>、<span class=\"hljs-type\">char</span>*<span class=\"hljs-keyword\">ptr</span>; : 指针所指向的的类型是 <span class=\"hljs-type\">char</span><br><span class=\"hljs-number\">3</span>、<span class=\"hljs-type\">int</span>**<span class=\"hljs-keyword\">ptr</span>; : 指针所指向的的类型是 <span class=\"hljs-type\">int</span>*<br><span class=\"hljs-number\">4</span>、<span class=\"hljs-type\">int</span>(*<span class=\"hljs-keyword\">ptr</span>)[<span class=\"hljs-number\">3</span>]; : 指针所指向的的类型是 <span class=\"hljs-type\">int</span>()[<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-number\">5</span>、<span class=\"hljs-type\">int</span>*(*<span class=\"hljs-keyword\">ptr</span>)[<span class=\"hljs-number\">4</span>]; : 指针所指向的的类型是 <span class=\"hljs-type\">int</span>*()[<span class=\"hljs-number\">4</span>]<br></code></pre></td></tr></table></figure>\n\n<p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度</p>\n<p>&amp;符号代表地址的符号，是内存地址，然后内存地址上面会存放内容，地址不代表是内存空间</p>\n<p>*代表指向，p代表内存地址，<code>*p</code>指向这片内存地址上面的内容</p>\n<h4 id=\"指针是什么？\"><a href=\"#指针是什么？\" class=\"headerlink\" title=\"指针是什么？\"></a>指针是什么？</h4><p>内存：就是存放东西的空间</p>\n<p><img src=\"https://s2.loli.net/2024/08/05/NIi8RQXMkglrqeC.png\" alt=\"8eafbb6548c929bc99f94ef018128c1a.png\"><img src=\"https://s2.loli.net/2024/08/05/Si3Oj5NPpr6Lz1h.png\" alt=\"dba3cdc29d8127ee60c8ca0446bf23fe.png\"></p>\n<p>左图就是内存，这个内存中有9个空间，一个空间代表一个字节</p>\n<p>右图就是在这个内存空间中，去创建两个变量 int a 和一个 char ch 根据基础知识，可以知道int 占4个字节 char 占1个字节，注意内存中间的每一个小空间（就是1个字节）是有编号的（1，2，3，4，5，6，7，8，9），内存的编号就是地址，地址也叫指针。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 内存的编号就是地址，地址也叫指针。<br><span class=\"hljs-bullet\">2.</span> 指针是内存中最小单元的编号，也就是地址。<br><span class=\"hljs-bullet\">3.</span> 编号--------&gt;地址----------&gt;指针<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"指针的类型\"><a href=\"#指针的类型\" class=\"headerlink\" title=\"指针的类型\"></a>指针的类型</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 指针类型：决定了指针进行解引用操作的时候，访问几个字节（权限）<br><span class=\"hljs-bullet\">2.</span> char * 的指针引用字节访问1个字节<br><span class=\"hljs-bullet\">3.</span> int * 的指针引用字节访问4个字节<br><span class=\"hljs-bullet\">4.</span> double * 的指针引用字节访问8个字节<br></code></pre></td></tr></table></figure>\n\n<p>0x开头的就表示十六进制，1个十六进制位表示4个二进制位</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\"><span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0x11223344</span>; <span class=\"hljs-regexp\">//</span>这是一个<span class=\"hljs-number\">16</span>进制数，一共是<span class=\"hljs-number\">8</span>位，所以代表二进制的<span class=\"hljs-number\">32</span>位，换算也就是<span class=\"hljs-number\">4</span>个字节，一个字节<span class=\"hljs-number\">8</span>位<br><span class=\"hljs-keyword\">int</span> *pa=&amp;a; <span class=\"hljs-regexp\">//</span>定义成<span class=\"hljs-keyword\">int</span>类型，就可以访问<span class=\"hljs-number\">4</span>个字节的权限<br>*pa = <span class=\"hljs-number\">0</span>; <span class=\"hljs-regexp\">//</span>重新替换成零，所以结果是<span class=\"hljs-number\">0x00000000</span><br><br>char* pc = &amp;a;  <span class=\"hljs-regexp\">//</span>定义成<span class=\"hljs-keyword\">int</span>类型，就可以访问<span class=\"hljs-number\">1</span>个字节的权限<br>*pc = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-regexp\">//</span>重新替换成零，所以结果是<span class=\"hljs-number\">0x11223300</span>，他只能替换一个字节，也就是八位，两个十六进制位<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"指针打印数组\"><a href=\"#指针打印数组\" class=\"headerlink\" title=\"指针打印数组\"></a>指针打印数组</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">10</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;  <span class=\"hljs-comment\">//内存中创建了10个整型，所以一个数组所占的空间就是40个字节，40b</span><br><br><span class=\"hljs-type\">int</span>* pa = a;  <span class=\"hljs-comment\">//数组名就是首元素的地址</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>&#123;<br>\t*pa = i + <span class=\"hljs-number\">1</span>;   <span class=\"hljs-comment\">// 数值+1</span><br>\t pa++;         <span class=\"hljs-comment\">//地址+1</span><br>\t <span class=\"hljs-comment\">//*(pa+i)=i+1</span><br>\t <span class=\"hljs-comment\">// pa表示pa中存放的地址  *pa表示：指向存放地址的内容，也就是解用</span><br>&#125;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, a[i]);<br>\t<span class=\"hljs-comment\">//printf(&quot;%d &quot;, *(pa+i));如果要使用这种输出的话，需要考虑的是，在上一个for循环后，*pa就已经不是指向首地址，而是指向尾地址</span><br>&#125;<br><br><span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">5</span>] = &#123;<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>&#125;;<span class=\"hljs-comment\">//定义一个数组</span><br><span class=\"hljs-type\">int</span>* arr = &amp;a[<span class=\"hljs-number\">4</span>];<span class=\"hljs-comment\">//这个指向的是地址类型上面的内容，也就是数组a的第五个数据</span><br><span class=\"hljs-comment\">//输出结果：9</span><br><br><span class=\"hljs-type\">int</span> *arr = &amp;a;<span class=\"hljs-comment\">//这个指向的是数组a的地址类型上面的内容，也就是数组里面的全部数据</span><br><span class=\"hljs-comment\">//输出结果：5，6，7，8，9</span><br><br><span class=\"hljs-type\">int</span> *arr;<span class=\"hljs-comment\">//定义指针类型为int</span><br>arr = a;<span class=\"hljs-comment\">//指向的是数组a的全部数据地址</span><br><span class=\"hljs-comment\">//输出结果：000000000061FDF0 000000000061FDF4 000000000061FDF8 000000000061FDFC 000000000061FE00</span><br></code></pre></td></tr></table></figure>\n\n<p><code>void aaaaaa(char* name)</code> 和 <code>void aaaaaa(char *name)</code> 这两种函数声明在 C 语言中实际上是等效的。它们的功能和行为是相同的。</p>\n","excerpt":"","more":"<h1 id=\"C语言指针学习\"><a href=\"#C语言指针学习\" class=\"headerlink\" title=\"C语言指针学习\"></a>C语言指针学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/weixin_45031801/article/details/127017272\">指针基础知识理解（简单、易懂、超详细！！！！）_史上最全指针解释-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/soonfly/article/details/51131141\">让你不再害怕指针——C指针详解(经典,非常详细)_c语言指针-CSDN博客</a></p>\n<h2 id=\"计算机的语言表示\"><a href=\"#计算机的语言表示\" class=\"headerlink\" title=\"计算机的语言表示\"></a>计算机的语言表示</h2><p>在现代的计算机中主要采用的数字集成电路完成，数字电路通过高低电平只能表示<strong>0和1</strong>，所以就出现了，计算机只会识别<strong>0和1</strong>。无论是存储还是计算，计算机均采用二进制体系完成。</p>\n<p>例如：十进制 <strong>4</strong> ———- 用二进制表示为 00000<strong>100</strong></p>\n<p>在C语言中，一个<code>int</code>类型的整数占用的字节数是固定的，并且与具体数值（例如<code>1</code>）无关。通常情况下，<code>int</code>类型的大小是4字节（32位）。不过，这个大小可能会因平台或编译器的不同而有所变化。</p>\n<h2 id=\"计算机基础单位和数据类型\"><a href=\"#计算机基础单位和数据类型\" class=\"headerlink\" title=\"计算机基础单位和数据类型\"></a>计算机基础单位和数据类型</h2><figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs brainfuck\"><span class=\"hljs-comment\">1</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">bit</span><span class=\"hljs-literal\">------------</span> <span class=\"hljs-comment\">比特</span> <span class=\"hljs-literal\">-------------</span> <span class=\"hljs-comment\">位</span><br>  <span class=\"hljs-comment\">2</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">byte</span> <span class=\"hljs-literal\">---------</span> <span class=\"hljs-comment\">字节</span> <span class=\"hljs-literal\">-------------</span> <span class=\"hljs-comment\">1byte = 8bit</span><br>  <span class=\"hljs-comment\">3</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">KB</span> <span class=\"hljs-literal\">------------</span> <span class=\"hljs-comment\">千字节</span> <span class=\"hljs-literal\">----------</span> <span class=\"hljs-comment\">1KB = 1024byte</span><br>  <span class=\"hljs-comment\">4</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">MB</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">兆</span> <span class=\"hljs-literal\">----------------</span> <span class=\"hljs-comment\">1MB = 1024KB</span><br>  <span class=\"hljs-comment\">5</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">GB</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">吉字节</span> <span class=\"hljs-literal\">----------</span> <span class=\"hljs-comment\">1GB = 1024MB</span><br>  <span class=\"hljs-comment\">6</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">TB</span>  <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">太字节</span> <span class=\"hljs-literal\">----------</span> <span class=\"hljs-comment\">1TB = 1024GB</span><br>  <span class=\"hljs-comment\">7</span><span class=\"hljs-string\">.</span> <span class=\"hljs-comment\">PB</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">拍字节</span> <span class=\"hljs-literal\">-----------</span> <span class=\"hljs-comment\">1PB = 1024TB</span><br></code></pre></td></tr></table></figure>\n\n<p>其中在C语言中的一些特定的数据类型存储也是有一定的范围的：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">char</span> <span class=\"hljs-comment\">-------- 1字节</span><br><span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">short</span> <span class=\"hljs-comment\">--------- 2字节</span><br><span class=\"hljs-number\">3.</span> int <span class=\"hljs-comment\">-------- 4字节   </span><br><span class=\"hljs-number\">4.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">---------- 4字节</span><br><span class=\"hljs-number\">5.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">-------- 8字节</span><br><span class=\"hljs-number\">6.</span> float <span class=\"hljs-comment\">---------- 4字节</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二进制数\"><a href=\"#二进制数\" class=\"headerlink\" title=\"二进制数\"></a>二进制数</h2><p>  <strong>1. 二进制数是带符号的，即分正、负数。其中若是正数最高位显示 0 ，若是负数最高位显示 1</strong></p>\n<p>  <strong>2. 二进制位通常也会受到数据类型的限制，比如 char 型 1 个字节 8 个比特位。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">举例：<span class=\"hljs-type\">int</span> <span class=\"hljs-number\">2</span> ;  <span class=\"hljs-comment\">------------------二进制表示：00000000 00000000 00000000 00000010</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><p><strong>int *p;</strong> – 首先从 p 处开始，先与 ***** 结合，所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。</p>\n<p> <strong>int *p[3];</strong> – 首先从 p 处开始, 先与 [] 结合，因为其优先级比 ***** 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。</p>\n<p>*<em>int *<em>p;</em></em> – 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针</p>\n<p>我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；</p>\n<p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念</p>\n<p>只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\"><span class=\"hljs-number\">1</span>、int *ptr; : 指针的类型是 int*<br><span class=\"hljs-number\">2</span>、char *ptr; : 指针的类型是 char*<br><span class=\"hljs-number\">3</span>、int **ptr; : 指针的类型是 int**<br><span class=\"hljs-number\">4</span>、int <span class=\"hljs-comment\">(*ptr)[3]; : 指针的类型是 int(*)</span>[<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-number\">5</span>、int *<span class=\"hljs-comment\">(*ptr)[4]; : 指针的类型是 int*(*)</span>[<span class=\"hljs-number\">4</span>]<br></code></pre></td></tr></table></figure>\n\n<p>指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\"><span class=\"hljs-number\">1</span>、<span class=\"hljs-type\">int</span>*<span class=\"hljs-keyword\">ptr</span>; : 指针所指向的类型是 <span class=\"hljs-type\">int</span><br><span class=\"hljs-number\">2</span>、<span class=\"hljs-type\">char</span>*<span class=\"hljs-keyword\">ptr</span>; : 指针所指向的的类型是 <span class=\"hljs-type\">char</span><br><span class=\"hljs-number\">3</span>、<span class=\"hljs-type\">int</span>**<span class=\"hljs-keyword\">ptr</span>; : 指针所指向的的类型是 <span class=\"hljs-type\">int</span>*<br><span class=\"hljs-number\">4</span>、<span class=\"hljs-type\">int</span>(*<span class=\"hljs-keyword\">ptr</span>)[<span class=\"hljs-number\">3</span>]; : 指针所指向的的类型是 <span class=\"hljs-type\">int</span>()[<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-number\">5</span>、<span class=\"hljs-type\">int</span>*(*<span class=\"hljs-keyword\">ptr</span>)[<span class=\"hljs-number\">4</span>]; : 指针所指向的的类型是 <span class=\"hljs-type\">int</span>*()[<span class=\"hljs-number\">4</span>]<br></code></pre></td></tr></table></figure>\n\n<p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度</p>\n<p>&amp;符号代表地址的符号，是内存地址，然后内存地址上面会存放内容，地址不代表是内存空间</p>\n<p>*代表指向，p代表内存地址，<code>*p</code>指向这片内存地址上面的内容</p>\n<h4 id=\"指针是什么？\"><a href=\"#指针是什么？\" class=\"headerlink\" title=\"指针是什么？\"></a>指针是什么？</h4><p>内存：就是存放东西的空间</p>\n<p><img src=\"https://s2.loli.net/2024/08/05/NIi8RQXMkglrqeC.png\" alt=\"8eafbb6548c929bc99f94ef018128c1a.png\"><img src=\"https://s2.loli.net/2024/08/05/Si3Oj5NPpr6Lz1h.png\" alt=\"dba3cdc29d8127ee60c8ca0446bf23fe.png\"></p>\n<p>左图就是内存，这个内存中有9个空间，一个空间代表一个字节</p>\n<p>右图就是在这个内存空间中，去创建两个变量 int a 和一个 char ch 根据基础知识，可以知道int 占4个字节 char 占1个字节，注意内存中间的每一个小空间（就是1个字节）是有编号的（1，2，3，4，5，6，7，8，9），内存的编号就是地址，地址也叫指针。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 内存的编号就是地址，地址也叫指针。<br><span class=\"hljs-bullet\">2.</span> 指针是内存中最小单元的编号，也就是地址。<br><span class=\"hljs-bullet\">3.</span> 编号--------&gt;地址----------&gt;指针<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"指针的类型\"><a href=\"#指针的类型\" class=\"headerlink\" title=\"指针的类型\"></a>指针的类型</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 指针类型：决定了指针进行解引用操作的时候，访问几个字节（权限）<br><span class=\"hljs-bullet\">2.</span> char * 的指针引用字节访问1个字节<br><span class=\"hljs-bullet\">3.</span> int * 的指针引用字节访问4个字节<br><span class=\"hljs-bullet\">4.</span> double * 的指针引用字节访问8个字节<br></code></pre></td></tr></table></figure>\n\n<p>0x开头的就表示十六进制，1个十六进制位表示4个二进制位</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\"><span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">0x11223344</span>; <span class=\"hljs-regexp\">//</span>这是一个<span class=\"hljs-number\">16</span>进制数，一共是<span class=\"hljs-number\">8</span>位，所以代表二进制的<span class=\"hljs-number\">32</span>位，换算也就是<span class=\"hljs-number\">4</span>个字节，一个字节<span class=\"hljs-number\">8</span>位<br><span class=\"hljs-keyword\">int</span> *pa=&amp;a; <span class=\"hljs-regexp\">//</span>定义成<span class=\"hljs-keyword\">int</span>类型，就可以访问<span class=\"hljs-number\">4</span>个字节的权限<br>*pa = <span class=\"hljs-number\">0</span>; <span class=\"hljs-regexp\">//</span>重新替换成零，所以结果是<span class=\"hljs-number\">0x00000000</span><br><br>char* pc = &amp;a;  <span class=\"hljs-regexp\">//</span>定义成<span class=\"hljs-keyword\">int</span>类型，就可以访问<span class=\"hljs-number\">1</span>个字节的权限<br>*pc = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-regexp\">//</span>重新替换成零，所以结果是<span class=\"hljs-number\">0x11223300</span>，他只能替换一个字节，也就是八位，两个十六进制位<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"指针打印数组\"><a href=\"#指针打印数组\" class=\"headerlink\" title=\"指针打印数组\"></a>指针打印数组</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">10</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;  <span class=\"hljs-comment\">//内存中创建了10个整型，所以一个数组所占的空间就是40个字节，40b</span><br><br><span class=\"hljs-type\">int</span>* pa = a;  <span class=\"hljs-comment\">//数组名就是首元素的地址</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>&#123;<br>\t*pa = i + <span class=\"hljs-number\">1</span>;   <span class=\"hljs-comment\">// 数值+1</span><br>\t pa++;         <span class=\"hljs-comment\">//地址+1</span><br>\t <span class=\"hljs-comment\">//*(pa+i)=i+1</span><br>\t <span class=\"hljs-comment\">// pa表示pa中存放的地址  *pa表示：指向存放地址的内容，也就是解用</span><br>&#125;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, a[i]);<br>\t<span class=\"hljs-comment\">//printf(&quot;%d &quot;, *(pa+i));如果要使用这种输出的话，需要考虑的是，在上一个for循环后，*pa就已经不是指向首地址，而是指向尾地址</span><br>&#125;<br><br><span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">5</span>] = &#123;<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>&#125;;<span class=\"hljs-comment\">//定义一个数组</span><br><span class=\"hljs-type\">int</span>* arr = &amp;a[<span class=\"hljs-number\">4</span>];<span class=\"hljs-comment\">//这个指向的是地址类型上面的内容，也就是数组a的第五个数据</span><br><span class=\"hljs-comment\">//输出结果：9</span><br><br><span class=\"hljs-type\">int</span> *arr = &amp;a;<span class=\"hljs-comment\">//这个指向的是数组a的地址类型上面的内容，也就是数组里面的全部数据</span><br><span class=\"hljs-comment\">//输出结果：5，6，7，8，9</span><br><br><span class=\"hljs-type\">int</span> *arr;<span class=\"hljs-comment\">//定义指针类型为int</span><br>arr = a;<span class=\"hljs-comment\">//指向的是数组a的全部数据地址</span><br><span class=\"hljs-comment\">//输出结果：000000000061FDF0 000000000061FDF4 000000000061FDF8 000000000061FDFC 000000000061FE00</span><br></code></pre></td></tr></table></figure>\n\n<p><code>void aaaaaa(char* name)</code> 和 <code>void aaaaaa(char *name)</code> 这两种函数声明在 C 语言中实际上是等效的。它们的功能和行为是相同的。</p>\n"},{"title":"C语言数组学习","date":"2024-08-04T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/OocearM37hWYHTp.jpg","_content":"\n# C语言数组学习\n\n## 感谢博主：\n\n[【C语言 | 数组】C语言数组详解(经典，超详细)-CSDN博客](https://blog.csdn.net/wkd_007/article/details/134400060)\n\n[C 数组 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-arrays.html)\n\n## 计算机基础单位和数据类型\n\n其中在C语言中的一些特定的数据类型存储也是有一定的范围的：\n\n```\n    1. char -------- 1字节\n    2. short --------- 2字节\n    3. int -------- 4字节   \n    4. long ---------- 4字节\n    5. long long -------- 8字节\n    6. float ---------- 4字节\n```\n\n## 数组的储存空间大小和位置\n\n数组的储存空间定义上也和数据类型有关，比如\n\n```\nint arr[5] = {0,1,2,3,4}\n```\n\n那么，这个数组的数据类型是整数型，一共有五个整数型，所以总占空间为20字节\n\n```\nchar arr[5] = {'a','b','v','d','h'}\n```\n\n这个字符型所占总空间为5字节\n\n二维数组的地址其实也是连续性的，就比如\n\n```\nint arr[2][3] = {{1,2,3},{4,5,6}};\nint arr[2][3] = {1,2,3,4,5,6}\n```\n\n这两种的类型和输出结果都是一致的，第一种定义方法采用{}将行进行隔开，更加清晰明了，而且，如果这个行一共需要3个数据，但是我只定义1个数据，这种写法是符合的，第二种就不符合，第二种的写法是因为二维数组的地址也是连续的，所以第一行结束之后自动承接第二行的第一个数据\n\n当然也可以直接查看他们的地址输出，可以发现地址都是占用四个字节\n\n```\nint arr[2][3] = {{1,2,3},{4,5,6}};\n\nfor(int i=0;i<2;i++)\n{\n\tfor(int j=0;j<3;j++)\n\t{\n\t\tprintf(\"%p\",&arr[i][j]);\n\t}\n}\n\n//output\n    000000000061FE00\n    000000000061FE04\n    000000000061FE08\n    000000000061FE0C\n    000000000061FE10\n    000000000061FE14\n```\n\nC语言中，在定义数组时，都需要明确的给出数组元素个数。如果要查询数组的大小，可以采用这种方式进行计算\n\n```\nint arr[6] = { 1,2,3,4,5,6 };\n//数组的大小：sizeof（数组名）/sizeof（数据类型）\nint ret = sizeof(arr)/sizeof(arr[0]);\n```\n\n其中sizeof的使用上也是有区分的\n\n```\nsizeof(arr);//这个是输出整个数组的大小\nsizeof(&arr);//这个是输出首地址的大小\nsizeof(a[0]);//这个是输出首地址的大小\n```\n\n## 数组定义类型\n\n如果要定义类似这种数组，那么hello占数组的五个数据还是只是一个数据呢\n\n```\nchar str[] = \"Hello\"; \n```\n\n我们可以将str的字符进行逐个输出可以发现，我们定义一整串字符串的时候，系统会自动帮我们拆分整个字符串，然后判断这个数组的大小\n\n```\nint ret = sizeof(str)/sizeof(str[0]);\nfor(int k=0;k<ret;k++)\n{\n    printf(\"str[%d]=%c\\n\",k,str[k]);\n}\n    \n//output\n    str[0]=H\n    str[1]=e\n    str[2]=l\n    str[3]=l\n    str[4]=o\n    str[5]=\"\\0\"//空字符\n```\n\n**数组中必须有元素，不可能为0个元素个数。**\n\n**数组里的元素必须相同，不可能出现两种不同类型的元素，如不能同时出现int和char。**\n\n数组的定义分为完全初始化和不完全初始化，完全初始化就是将数据值定义和数组长度相匹配，定义了数组是五个整数型，那填充的也是五个整数型，不完全初始化就是我定义了数据是五个整数型，但是我只填充了三个整数型，那么剩下的两个整数型都是空值，系统默认为0，后续我们可以在往里面写数值\n\n数组的指定输出可以直接用数组名+[数组位置]，二维数组也是类似，地址也是类似\n\n```\nint arr[5]={1,2,3,4,5};\nint arr1[2][3]={{1,2},{3,4,5}};\nprintf(\"%d\\n\",arr[1]);//输出是2\nprintf(\"%d\\n\",arr1[1][1]);//输出是4\nprintf(\"%p\\n\",&arr[1]);//输出是000000000061FE04\n```\n\n## 指针和数组的区别\n\n**数组**：数组是用于储存多个相同类型数据的集合。\n\n**指针**：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。\n\n**数组**：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。数组的存储空间，不是在静态区就是在栈上。\n\n**指针**：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。\n\n## 数组传参时，会退化为指针\n\n退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。\n\n因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。\n\n```\nint main()\n{\n    int arr[10] = {1,2,3,4,5,6,7,8,9};\n    int *p = arr;\n    int sz = sizeof(arr)/sizeof(arr[0]);\n    //一级指针p，传给函数\n    \n    for(int i=0; i<sz; i++)\n    {\n       printf(\"%d\\n\", *(p+i));\n    }\n    \n    return 0;\n}\n```\n\n","source":"_posts/Work No.14.md","raw":"---\ntitle: C语言数组学习\ntag: C/C++\ndate: 2024-08-05\ncategories: C/C++\nindex_img: https://s2.loli.net/2024/07/31/OocearM37hWYHTp.jpg\n---\n\n# C语言数组学习\n\n## 感谢博主：\n\n[【C语言 | 数组】C语言数组详解(经典，超详细)-CSDN博客](https://blog.csdn.net/wkd_007/article/details/134400060)\n\n[C 数组 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-arrays.html)\n\n## 计算机基础单位和数据类型\n\n其中在C语言中的一些特定的数据类型存储也是有一定的范围的：\n\n```\n    1. char -------- 1字节\n    2. short --------- 2字节\n    3. int -------- 4字节   \n    4. long ---------- 4字节\n    5. long long -------- 8字节\n    6. float ---------- 4字节\n```\n\n## 数组的储存空间大小和位置\n\n数组的储存空间定义上也和数据类型有关，比如\n\n```\nint arr[5] = {0,1,2,3,4}\n```\n\n那么，这个数组的数据类型是整数型，一共有五个整数型，所以总占空间为20字节\n\n```\nchar arr[5] = {'a','b','v','d','h'}\n```\n\n这个字符型所占总空间为5字节\n\n二维数组的地址其实也是连续性的，就比如\n\n```\nint arr[2][3] = {{1,2,3},{4,5,6}};\nint arr[2][3] = {1,2,3,4,5,6}\n```\n\n这两种的类型和输出结果都是一致的，第一种定义方法采用{}将行进行隔开，更加清晰明了，而且，如果这个行一共需要3个数据，但是我只定义1个数据，这种写法是符合的，第二种就不符合，第二种的写法是因为二维数组的地址也是连续的，所以第一行结束之后自动承接第二行的第一个数据\n\n当然也可以直接查看他们的地址输出，可以发现地址都是占用四个字节\n\n```\nint arr[2][3] = {{1,2,3},{4,5,6}};\n\nfor(int i=0;i<2;i++)\n{\n\tfor(int j=0;j<3;j++)\n\t{\n\t\tprintf(\"%p\",&arr[i][j]);\n\t}\n}\n\n//output\n    000000000061FE00\n    000000000061FE04\n    000000000061FE08\n    000000000061FE0C\n    000000000061FE10\n    000000000061FE14\n```\n\nC语言中，在定义数组时，都需要明确的给出数组元素个数。如果要查询数组的大小，可以采用这种方式进行计算\n\n```\nint arr[6] = { 1,2,3,4,5,6 };\n//数组的大小：sizeof（数组名）/sizeof（数据类型）\nint ret = sizeof(arr)/sizeof(arr[0]);\n```\n\n其中sizeof的使用上也是有区分的\n\n```\nsizeof(arr);//这个是输出整个数组的大小\nsizeof(&arr);//这个是输出首地址的大小\nsizeof(a[0]);//这个是输出首地址的大小\n```\n\n## 数组定义类型\n\n如果要定义类似这种数组，那么hello占数组的五个数据还是只是一个数据呢\n\n```\nchar str[] = \"Hello\"; \n```\n\n我们可以将str的字符进行逐个输出可以发现，我们定义一整串字符串的时候，系统会自动帮我们拆分整个字符串，然后判断这个数组的大小\n\n```\nint ret = sizeof(str)/sizeof(str[0]);\nfor(int k=0;k<ret;k++)\n{\n    printf(\"str[%d]=%c\\n\",k,str[k]);\n}\n    \n//output\n    str[0]=H\n    str[1]=e\n    str[2]=l\n    str[3]=l\n    str[4]=o\n    str[5]=\"\\0\"//空字符\n```\n\n**数组中必须有元素，不可能为0个元素个数。**\n\n**数组里的元素必须相同，不可能出现两种不同类型的元素，如不能同时出现int和char。**\n\n数组的定义分为完全初始化和不完全初始化，完全初始化就是将数据值定义和数组长度相匹配，定义了数组是五个整数型，那填充的也是五个整数型，不完全初始化就是我定义了数据是五个整数型，但是我只填充了三个整数型，那么剩下的两个整数型都是空值，系统默认为0，后续我们可以在往里面写数值\n\n数组的指定输出可以直接用数组名+[数组位置]，二维数组也是类似，地址也是类似\n\n```\nint arr[5]={1,2,3,4,5};\nint arr1[2][3]={{1,2},{3,4,5}};\nprintf(\"%d\\n\",arr[1]);//输出是2\nprintf(\"%d\\n\",arr1[1][1]);//输出是4\nprintf(\"%p\\n\",&arr[1]);//输出是000000000061FE04\n```\n\n## 指针和数组的区别\n\n**数组**：数组是用于储存多个相同类型数据的集合。\n\n**指针**：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。\n\n**数组**：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。数组的存储空间，不是在静态区就是在栈上。\n\n**指针**：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。\n\n## 数组传参时，会退化为指针\n\n退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。\n\n因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。\n\n```\nint main()\n{\n    int arr[10] = {1,2,3,4,5,6,7,8,9};\n    int *p = arr;\n    int sz = sizeof(arr)/sizeof(arr[0]);\n    //一级指针p，传给函数\n    \n    for(int i=0; i<sz; i++)\n    {\n       printf(\"%d\\n\", *(p+i));\n    }\n    \n    return 0;\n}\n```\n\n","slug":"Work No.14","published":1,"updated":"2024-08-09T04:05:31.973Z","_id":"clzgwz9520000e0fb5yql89z8","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"C语言数组学习\"><a href=\"#C语言数组学习\" class=\"headerlink\" title=\"C语言数组学习\"></a>C语言数组学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/wkd_007/article/details/134400060\">【C语言 | 数组】C语言数组详解(经典，超详细)-CSDN博客</a></p>\n<p><a href=\"https://www.runoob.com/cprogramming/c-arrays.html\">C 数组 | 菜鸟教程 (runoob.com)</a></p>\n<h2 id=\"计算机基础单位和数据类型\"><a href=\"#计算机基础单位和数据类型\" class=\"headerlink\" title=\"计算机基础单位和数据类型\"></a>计算机基础单位和数据类型</h2><p>其中在C语言中的一些特定的数据类型存储也是有一定的范围的：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">char</span> <span class=\"hljs-comment\">-------- 1字节</span><br><span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">short</span> <span class=\"hljs-comment\">--------- 2字节</span><br><span class=\"hljs-number\">3.</span> int <span class=\"hljs-comment\">-------- 4字节   </span><br><span class=\"hljs-number\">4.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">---------- 4字节</span><br><span class=\"hljs-number\">5.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">-------- 8字节</span><br><span class=\"hljs-number\">6.</span> float <span class=\"hljs-comment\">---------- 4字节</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组的储存空间大小和位置\"><a href=\"#数组的储存空间大小和位置\" class=\"headerlink\" title=\"数组的储存空间大小和位置\"></a>数组的储存空间大小和位置</h2><p>数组的储存空间定义上也和数据类型有关，比如</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">5</span>] = &#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>那么，这个数组的数据类型是整数型，一共有五个整数型，所以总占空间为20字节</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-type\">char</span> arr[<span class=\"hljs-number\">5</span>] = &#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;v&#x27;</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>,<span class=\"hljs-string\">&#x27;h&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个字符型所占总空间为5字节</p>\n<p>二维数组的地址其实也是连续性的，就比如</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>] = &#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;;<br><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>] = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这两种的类型和输出结果都是一致的，第一种定义方法采用{}将行进行隔开，更加清晰明了，而且，如果这个行一共需要3个数据，但是我只定义1个数据，这种写法是符合的，第二种就不符合，第二种的写法是因为二维数组的地址也是连续的，所以第一行结束之后自动承接第二行的第一个数据</p>\n<p>当然也可以直接查看他们的地址输出，可以发现地址都是占用四个字节</p>\n<figure class=\"highlight twig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs twig\"><span class=\"language-xml\">int arr[2][3] = </span><span class=\"hljs-template-variable\">&#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;</span><span class=\"language-xml\">;</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">for(int i=0;i&lt;2;i++)</span><br><span class=\"language-xml\">&#123;</span><br><span class=\"language-xml\">\tfor(int j=0;j&lt;3;j++)</span><br><span class=\"language-xml\">\t&#123;</span><br><span class=\"language-xml\">\t\tprintf(&quot;%p&quot;,&amp;arr[i][j]);</span><br><span class=\"language-xml\">\t&#125;</span><br><span class=\"language-xml\">&#125;</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">//output</span><br><span class=\"language-xml\">    000000000061FE00</span><br><span class=\"language-xml\">    000000000061FE04</span><br><span class=\"language-xml\">    000000000061FE08</span><br><span class=\"language-xml\">    000000000061FE0C</span><br><span class=\"language-xml\">    000000000061FE10</span><br><span class=\"language-xml\">    000000000061FE14</span><br></code></pre></td></tr></table></figure>\n\n<p>C语言中，在定义数组时，都需要明确的给出数组元素个数。如果要查询数组的大小，可以采用这种方式进行计算</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">int</span> arr[<span class=\"hljs-number\">6</span>] = &#123; <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span> &#125;;<br><span class=\"hljs-comment\">//数组的大小：sizeof（数组名）/sizeof（数据类型）</span><br><span class=\"hljs-built_in\">int</span> ret = <span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]);<br></code></pre></td></tr></table></figure>\n\n<p>其中sizeof的使用上也是有区分的</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">sizeof</span>(arr);<span class=\"hljs-comment\">//这个是输出整个数组的大小</span><br><span class=\"hljs-built_in\">sizeof</span>(&amp;arr);<span class=\"hljs-comment\">//这个是输出首地址的大小</span><br><span class=\"hljs-built_in\">sizeof</span>(a[<span class=\"hljs-number\">0</span>]);<span class=\"hljs-comment\">//这个是输出首地址的大小</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组定义类型\"><a href=\"#数组定义类型\" class=\"headerlink\" title=\"数组定义类型\"></a>数组定义类型</h2><p>如果要定义类似这种数组，那么hello占数组的五个数据还是只是一个数据呢</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">char str[] <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello&quot;</span><span class=\"hljs-comment\">; </span><br></code></pre></td></tr></table></figure>\n\n<p>我们可以将str的字符进行逐个输出可以发现，我们定义一整串字符串的时候，系统会自动帮我们拆分整个字符串，然后判断这个数组的大小</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\"><span class=\"hljs-built_in\">int</span> ret = sizeof(<span class=\"hljs-built_in\">str</span>)/sizeof(<span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;ret;k++)<br>&#123;<br>    printf(<span class=\"hljs-string\">&quot;str[%d]=%c\\n&quot;</span>,k,<span class=\"hljs-built_in\">str</span>[k]);<br>&#125;<br>    <br><span class=\"hljs-comment\">//output</span><br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">0</span>]=H<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">1</span>]=e<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">2</span>]=l<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">3</span>]=l<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">4</span>]=o<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">5</span>]=<span class=\"hljs-string\">&quot;\\0&quot;</span><span class=\"hljs-comment\">//空字符</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>数组中必须有元素，不可能为0个元素个数。</strong></p>\n<p><strong>数组里的元素必须相同，不可能出现两种不同类型的元素，如不能同时出现int和char。</strong></p>\n<p>数组的定义分为完全初始化和不完全初始化，完全初始化就是将数据值定义和数组长度相匹配，定义了数组是五个整数型，那填充的也是五个整数型，不完全初始化就是我定义了数据是五个整数型，但是我只填充了三个整数型，那么剩下的两个整数型都是空值，系统默认为0，后续我们可以在往里面写数值</p>\n<p>数组的指定输出可以直接用数组名+[数组位置]，二维数组也是类似，地址也是类似</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;;<br><span class=\"hljs-attribute\">int</span> arr1[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>]=&#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>&#125;,&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;&#125;;<br><span class=\"hljs-attribute\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,arr[<span class=\"hljs-number\">1</span>]);//输出是<span class=\"hljs-number\">2</span><br><span class=\"hljs-attribute\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,arr1[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>]);//输出是<span class=\"hljs-number\">4</span><br><span class=\"hljs-attribute\">printf</span>(<span class=\"hljs-string\">&quot;%p\\n&quot;</span>,&amp;arr[<span class=\"hljs-number\">1</span>]);//输出是<span class=\"hljs-number\">000000000061</span>FE04<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"指针和数组的区别\"><a href=\"#指针和数组的区别\" class=\"headerlink\" title=\"指针和数组的区别\"></a>指针和数组的区别</h2><p><strong>数组</strong>：数组是用于储存多个相同类型数据的集合。</p>\n<p><strong>指针</strong>：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。</p>\n<p><strong>数组</strong>：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。数组的存储空间，不是在静态区就是在栈上。</p>\n<p><strong>指针</strong>：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p>\n<h2 id=\"数组传参时，会退化为指针\"><a href=\"#数组传参时，会退化为指针\" class=\"headerlink\" title=\"数组传参时，会退化为指针\"></a>数组传参时，会退化为指针</h2><p>退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。</p>\n<p>因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">main</span>()</span><br>&#123;<br>    <span class=\"hljs-built_in\">int</span> arr[<span class=\"hljs-number\">10</span>] = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>&#125;;<br>    <span class=\"hljs-built_in\">int</span> *p = arr;<br>    <span class=\"hljs-built_in\">int</span> sz = <span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]);<br>    <span class=\"hljs-comment\">//一级指针p，传给函数</span><br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;sz; i++)<br>    &#123;<br>       printf(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, *(p+i));<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"C语言数组学习\"><a href=\"#C语言数组学习\" class=\"headerlink\" title=\"C语言数组学习\"></a>C语言数组学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/wkd_007/article/details/134400060\">【C语言 | 数组】C语言数组详解(经典，超详细)-CSDN博客</a></p>\n<p><a href=\"https://www.runoob.com/cprogramming/c-arrays.html\">C 数组 | 菜鸟教程 (runoob.com)</a></p>\n<h2 id=\"计算机基础单位和数据类型\"><a href=\"#计算机基础单位和数据类型\" class=\"headerlink\" title=\"计算机基础单位和数据类型\"></a>计算机基础单位和数据类型</h2><p>其中在C语言中的一些特定的数据类型存储也是有一定的范围的：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">char</span> <span class=\"hljs-comment\">-------- 1字节</span><br><span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">short</span> <span class=\"hljs-comment\">--------- 2字节</span><br><span class=\"hljs-number\">3.</span> int <span class=\"hljs-comment\">-------- 4字节   </span><br><span class=\"hljs-number\">4.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">---------- 4字节</span><br><span class=\"hljs-number\">5.</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-comment\">-------- 8字节</span><br><span class=\"hljs-number\">6.</span> float <span class=\"hljs-comment\">---------- 4字节</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组的储存空间大小和位置\"><a href=\"#数组的储存空间大小和位置\" class=\"headerlink\" title=\"数组的储存空间大小和位置\"></a>数组的储存空间大小和位置</h2><p>数组的储存空间定义上也和数据类型有关，比如</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">5</span>] = &#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>那么，这个数组的数据类型是整数型，一共有五个整数型，所以总占空间为20字节</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-type\">char</span> arr[<span class=\"hljs-number\">5</span>] = &#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;v&#x27;</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>,<span class=\"hljs-string\">&#x27;h&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个字符型所占总空间为5字节</p>\n<p>二维数组的地址其实也是连续性的，就比如</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>] = &#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;;<br><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>] = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这两种的类型和输出结果都是一致的，第一种定义方法采用{}将行进行隔开，更加清晰明了，而且，如果这个行一共需要3个数据，但是我只定义1个数据，这种写法是符合的，第二种就不符合，第二种的写法是因为二维数组的地址也是连续的，所以第一行结束之后自动承接第二行的第一个数据</p>\n<p>当然也可以直接查看他们的地址输出，可以发现地址都是占用四个字节</p>\n<figure class=\"highlight twig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs twig\"><span class=\"language-xml\">int arr[2][3] = </span><span class=\"hljs-template-variable\">&#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;,&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>&#125;&#125;</span><span class=\"language-xml\">;</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">for(int i=0;i&lt;2;i++)</span><br><span class=\"language-xml\">&#123;</span><br><span class=\"language-xml\">\tfor(int j=0;j&lt;3;j++)</span><br><span class=\"language-xml\">\t&#123;</span><br><span class=\"language-xml\">\t\tprintf(&quot;%p&quot;,&amp;arr[i][j]);</span><br><span class=\"language-xml\">\t&#125;</span><br><span class=\"language-xml\">&#125;</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">//output</span><br><span class=\"language-xml\">    000000000061FE00</span><br><span class=\"language-xml\">    000000000061FE04</span><br><span class=\"language-xml\">    000000000061FE08</span><br><span class=\"language-xml\">    000000000061FE0C</span><br><span class=\"language-xml\">    000000000061FE10</span><br><span class=\"language-xml\">    000000000061FE14</span><br></code></pre></td></tr></table></figure>\n\n<p>C语言中，在定义数组时，都需要明确的给出数组元素个数。如果要查询数组的大小，可以采用这种方式进行计算</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">int</span> arr[<span class=\"hljs-number\">6</span>] = &#123; <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span> &#125;;<br><span class=\"hljs-comment\">//数组的大小：sizeof（数组名）/sizeof（数据类型）</span><br><span class=\"hljs-built_in\">int</span> ret = <span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]);<br></code></pre></td></tr></table></figure>\n\n<p>其中sizeof的使用上也是有区分的</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">sizeof</span>(arr);<span class=\"hljs-comment\">//这个是输出整个数组的大小</span><br><span class=\"hljs-built_in\">sizeof</span>(&amp;arr);<span class=\"hljs-comment\">//这个是输出首地址的大小</span><br><span class=\"hljs-built_in\">sizeof</span>(a[<span class=\"hljs-number\">0</span>]);<span class=\"hljs-comment\">//这个是输出首地址的大小</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组定义类型\"><a href=\"#数组定义类型\" class=\"headerlink\" title=\"数组定义类型\"></a>数组定义类型</h2><p>如果要定义类似这种数组，那么hello占数组的五个数据还是只是一个数据呢</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">char str[] <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Hello&quot;</span><span class=\"hljs-comment\">; </span><br></code></pre></td></tr></table></figure>\n\n<p>我们可以将str的字符进行逐个输出可以发现，我们定义一整串字符串的时候，系统会自动帮我们拆分整个字符串，然后判断这个数组的大小</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\"><span class=\"hljs-built_in\">int</span> ret = sizeof(<span class=\"hljs-built_in\">str</span>)/sizeof(<span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;ret;k++)<br>&#123;<br>    printf(<span class=\"hljs-string\">&quot;str[%d]=%c\\n&quot;</span>,k,<span class=\"hljs-built_in\">str</span>[k]);<br>&#125;<br>    <br><span class=\"hljs-comment\">//output</span><br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">0</span>]=H<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">1</span>]=e<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">2</span>]=l<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">3</span>]=l<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">4</span>]=o<br>    <span class=\"hljs-built_in\">str</span>[<span class=\"hljs-number\">5</span>]=<span class=\"hljs-string\">&quot;\\0&quot;</span><span class=\"hljs-comment\">//空字符</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>数组中必须有元素，不可能为0个元素个数。</strong></p>\n<p><strong>数组里的元素必须相同，不可能出现两种不同类型的元素，如不能同时出现int和char。</strong></p>\n<p>数组的定义分为完全初始化和不完全初始化，完全初始化就是将数据值定义和数组长度相匹配，定义了数组是五个整数型，那填充的也是五个整数型，不完全初始化就是我定义了数据是五个整数型，但是我只填充了三个整数型，那么剩下的两个整数型都是空值，系统默认为0，后续我们可以在往里面写数值</p>\n<p>数组的指定输出可以直接用数组名+[数组位置]，二维数组也是类似，地址也是类似</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">int</span> arr[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;;<br><span class=\"hljs-attribute\">int</span> arr1[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>]=&#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>&#125;,&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;&#125;;<br><span class=\"hljs-attribute\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,arr[<span class=\"hljs-number\">1</span>]);//输出是<span class=\"hljs-number\">2</span><br><span class=\"hljs-attribute\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,arr1[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>]);//输出是<span class=\"hljs-number\">4</span><br><span class=\"hljs-attribute\">printf</span>(<span class=\"hljs-string\">&quot;%p\\n&quot;</span>,&amp;arr[<span class=\"hljs-number\">1</span>]);//输出是<span class=\"hljs-number\">000000000061</span>FE04<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"指针和数组的区别\"><a href=\"#指针和数组的区别\" class=\"headerlink\" title=\"指针和数组的区别\"></a>指针和数组的区别</h2><p><strong>数组</strong>：数组是用于储存多个相同类型数据的集合。</p>\n<p><strong>指针</strong>：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。</p>\n<p><strong>数组</strong>：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。数组的存储空间，不是在静态区就是在栈上。</p>\n<p><strong>指针</strong>：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p>\n<h2 id=\"数组传参时，会退化为指针\"><a href=\"#数组传参时，会退化为指针\" class=\"headerlink\" title=\"数组传参时，会退化为指针\"></a>数组传参时，会退化为指针</h2><p>退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。</p>\n<p>因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">main</span>()</span><br>&#123;<br>    <span class=\"hljs-built_in\">int</span> arr[<span class=\"hljs-number\">10</span>] = &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>&#125;;<br>    <span class=\"hljs-built_in\">int</span> *p = arr;<br>    <span class=\"hljs-built_in\">int</span> sz = <span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]);<br>    <span class=\"hljs-comment\">//一级指针p，传给函数</span><br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;sz; i++)<br>    &#123;<br>       printf(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, *(p+i));<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"C语言结构体学习","date":"2024-08-04T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/huNLZglFzj65MmO.jpg","_content":"\n# C语言结构体学习\n\n## 感谢博主：\n\n[C语言详解：结构体_c语言结构体语法-CSDN博客](https://blog.csdn.net/yourfriendyo/article/details/119544221)\n\n[C语言结构体（struct）最全的讲解（万字干货）_struct a *b(const char *name)-CSDN博客](https://blog.csdn.net/lyh290188/article/details/104326450)\n\n## 结构体理论知识\n\n结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。\n\n研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。\n\n**结构体的大小不是结构体元素单纯相加就行的**，因为我们现在主流的计算机使用的都是32Bit字长的CPU，**对这类型的CPU取4个字节的数要比取一个字节要高效**，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是**内存对齐**的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。**程序员可以通过预编译命令#pragmapack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。**\n\n```\nstruct S1\n{\n\tchar c1;\n\tint i;\n\tchar c2\n};\n\nstruct S2\n{\n\tchar c1;\n\tchar c2;\n\tint i;\n};\n```\n\n`S1`和`S2`类型的成员一样，但是`S1`和`S2`所占用的空间不一样，`S2`相较于`S1`所占空间较小。\n\n**所以，让占用空间小的成员尽量集中在一起，这样会使整个内存空间变小**\n\n在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。\n\n在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。\n\n在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。\n\n## 结构体声明\n\n使用匿名结构体类型创建变量就**只能在变量列表中创建，而且只能一次**，不能在`main()`函数中创建变量了\n\n```\n//匿名结构体类型，不完全声明\nstruct\n{\n\tchar c;\n\tint i;\n\tdouble d;\n}s1,s2;//匿名结构体类型创建变量的唯一方式，就是在变量列表中创建\n```\n\n首先使用关键字struct，它表示接下来是一个结构体。在结构体声明中，struct book所起到的作用就像int等基础数据类型名作用一样。\n\n后面是一个可选的标志（student），它是用来引用该结构体的快速标记。\n\n接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；\n\n在结束花括号后的分号表示结构体设计定义的结束\n\n封号后面额外添加使用字符例如CXSW，这个变量就包含了其student结构体中的所有元素\n\n```\nstruct tag {//tag 是结构体标签。\n    member-list//member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。\n    member-list\n    member-list  \n    ...\n} variable-list ;//variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。\n\nstruct tag variable-list;//等效于上面定义\n```\n\n## 结构体初始化\n\n结构体变量的**初始化**有2种方式，但是也有区别：\n\n在结构体变量的创建时，用`{}`进行初始化。此时必须严格按声明中成员变量的顺序来初始化\n\n```\nstruct Stu\n{\n char name[20];//名字\n int age;//年龄\n char sex[5];//性别\n char id[20];//学号\n};\n\nstruct Stu s = { \"张三\", 20, \"男\", \"20230818001\" };\n```\n\n或者在结构体后直接定义\n\n```\nstruct Books\n{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;\n} book = {\"C 语言\", \"RUNOOB\", \"编程语言\", 123456};\n```\n\n用`{.成员变量 = , .成员变量 = }`(使用到`.`操作符)来初始化变量。\n\n```\nstruct Stu\n{\n char name[20];//名字\n int age;//年龄\n char sex[5];//性别\n char id[20];//学号\n};\n\nstruct Stu s2 = { .age = 18, .name = \"lisi\", .id = \"20230818002\", .sex = \"⼥\" };\n```\n\n**浮点数在内存中有可能是不能精确保存的。**那根据这一点，在我们对浮点数进行比较大小时，我们就不能简单地对2个数据进行 `==`是否相等的判断，而是有**一定的误差**。\n\n## 结构体的引用\n\n结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。\n\n```\n//此结构体的声明包含了其他的结构体\nstruct COMPLEX\n{\n    char string[100];\n    struct SIMPLE a;\n};\n\n//此结构体的声明包含了指向自己类型的指针\nstruct NODE\n{\n    char string[100];\n    struct NODE *next_node;\n};\n```\n\n在结构中包含一个类型为该结构本身的成员\n\n```\n//错误的定义\nstruct Node//定义了一个节点。节点本身要包涵自己的数据，和指向下一节点\n{\n \tint data;\n \tstruct Node next;//“next”使用未定义的 struct“Node”,这是错误的写法\n};\n```\n\n这个结构体类型的大小我们是否可以得出来,通过`sizeof(struct Node)`分析可以知道因为**一个结构体中再包含一个同类型的结构体变量**，这样会使得结构体的大小**无穷大**，这是不合理的。\n\n```\n//正确的定义\nstruct Node//定义了一个节点。节点本身要包涵，自己的数据和指向下一节点的指针\n{\n \tint data;//数据域,大小为4个字节\n \tstruct Node* next;//指针域，大小为4或8个字节\n};\n```\n\n我们需要定义一个指针类型，准确的指向所需要的位置，这样的结构体大小是可以进行计算的，就不会出现错误\n\n## typedef 重定义结构体\n\n该结构体就有了两种创建变量的方式`struct human man`和`hu man`都行，只是将`struct human`重新取个名字叫`hu`。本质上还是类型是不占用空间的，只有创建变量时才会开辟空间。当然使用`typedef`就不能在声明结构体的后面直接创建全局变量了。\n\n```\ntypedef struct human\n{\n\tchar name[20];\n\tint age;\n\tchar sex[10];\n\tchar id[20];\n}hu;\nint main() {\n    //1.\n\tstruct human man;\n\t//2.\n    hu man;\n\treturn 0;\n}\n\n```\n\n## 结构体访问\n\n有的时候有可能我们得到的是一个指向该结构体的指针。这时候我们就需要操作符`->`，同样也是两个操作数，`->`是专门在访问结构体时使用指针的方法，更高效。\n\n```\nstruct S {\n\tint a;\n\tchar c;\n\tdouble d;\n};\nstruct T {\n\tstruct S s;\n\tchar name[20];\n\tint num;\n};\n\nstruct T t = { {10, 'x', 1.00}, \"yourfriendyo\", 21 };\nstruct T* pt = &t;\nprintf(\"%d %c %lf %s %d\\n\", pt->s.a, pt->s.c, pt->s.d, pt->name, pt->num);\n```\n\n## 结构体的位段\n\n位段就是限制结构体里面每个参数所要占用的字节，比如一个变量`age`表示一个人的年龄，设定1-100岁，**那么给int变量占4个字节就有点浪费空间了，那么我们可以限制一下**。`位段`可以在一定程度上减少空间的浪费\n\n```\nstruct A1\n{\n int _a:2;//数字部分表示变量只占多少个2进制位，也就是占多少比特位\n int _b:5;\n int _c:10;\n int _d:30;\n int _e:50;//这一行是错误的，int类型的比特位数就只有32位，50超出了限制，会报错\n};\n\nstruct A2\n{\n int _a;\n int _b;\n int _c;\n int _d;\n};\n\n\nint main()\n{\n\tprintf(\"%zd\\n\",sizeof(struct A1));//结果为8\n\tprintf(\"%zd\\n\",sizeof(struct A2));//结果为16\n\treturn 0;\n}\n```\n\n## 枚举\n\n枚举就是一一列举，把所有可能的值都按照顺序罗列，其实也就是统一的宏定义，而且不需要从1输到100，他会自己安装顺序进行排序，并且如果在中间进行取值定义，后面的值也会发送改变，可以从下面看出来整体的变化，**修改了初始值的常量**开始后面的枚举常量表示的数字都递增+1，前面的保持不变\n\n```\nenum Sex//性别\n{\n\t//该枚举类型的三种可能取值\n\t//它们都是常量，被称为枚举常量,默认从0开始，递增+1\n \tMALE,//0\n \tFEMALE,//1\n \tSECRET//2\n};\nenum Sex//性别\n{\n\t\n \tMALE=7,//7\n \tFEMALE=9,//9\n \tSECRET=6//6\n};\nenum Sex//性别\n{\n\t\n \tMALE,//0\n \tFEMALE=8,//8\n \tSECRET//9\n};\n```\n\n并且，枚举也遵循typedef的重定义，可以利用变量进行对其中的值进行输入或者调整\n\n```\ntypedef enum {\n\tX,\n\tY,\n    SIZE\n}t;\n```\n\n","source":"_posts/Work No.15.md","raw":"---\ntitle: C语言结构体学习\ntag: C/C++\ndate: 2024-08-05\ncategories: C/C++\nindex_img: https://s2.loli.net/2024/08/02/huNLZglFzj65MmO.jpg\n---\n\n# C语言结构体学习\n\n## 感谢博主：\n\n[C语言详解：结构体_c语言结构体语法-CSDN博客](https://blog.csdn.net/yourfriendyo/article/details/119544221)\n\n[C语言结构体（struct）最全的讲解（万字干货）_struct a *b(const char *name)-CSDN博客](https://blog.csdn.net/lyh290188/article/details/104326450)\n\n## 结构体理论知识\n\n结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。\n\n研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。\n\n**结构体的大小不是结构体元素单纯相加就行的**，因为我们现在主流的计算机使用的都是32Bit字长的CPU，**对这类型的CPU取4个字节的数要比取一个字节要高效**，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是**内存对齐**的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。**程序员可以通过预编译命令#pragmapack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。**\n\n```\nstruct S1\n{\n\tchar c1;\n\tint i;\n\tchar c2\n};\n\nstruct S2\n{\n\tchar c1;\n\tchar c2;\n\tint i;\n};\n```\n\n`S1`和`S2`类型的成员一样，但是`S1`和`S2`所占用的空间不一样，`S2`相较于`S1`所占空间较小。\n\n**所以，让占用空间小的成员尽量集中在一起，这样会使整个内存空间变小**\n\n在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。\n\n在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。\n\n在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。\n\n## 结构体声明\n\n使用匿名结构体类型创建变量就**只能在变量列表中创建，而且只能一次**，不能在`main()`函数中创建变量了\n\n```\n//匿名结构体类型，不完全声明\nstruct\n{\n\tchar c;\n\tint i;\n\tdouble d;\n}s1,s2;//匿名结构体类型创建变量的唯一方式，就是在变量列表中创建\n```\n\n首先使用关键字struct，它表示接下来是一个结构体。在结构体声明中，struct book所起到的作用就像int等基础数据类型名作用一样。\n\n后面是一个可选的标志（student），它是用来引用该结构体的快速标记。\n\n接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；\n\n在结束花括号后的分号表示结构体设计定义的结束\n\n封号后面额外添加使用字符例如CXSW，这个变量就包含了其student结构体中的所有元素\n\n```\nstruct tag {//tag 是结构体标签。\n    member-list//member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。\n    member-list\n    member-list  \n    ...\n} variable-list ;//variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。\n\nstruct tag variable-list;//等效于上面定义\n```\n\n## 结构体初始化\n\n结构体变量的**初始化**有2种方式，但是也有区别：\n\n在结构体变量的创建时，用`{}`进行初始化。此时必须严格按声明中成员变量的顺序来初始化\n\n```\nstruct Stu\n{\n char name[20];//名字\n int age;//年龄\n char sex[5];//性别\n char id[20];//学号\n};\n\nstruct Stu s = { \"张三\", 20, \"男\", \"20230818001\" };\n```\n\n或者在结构体后直接定义\n\n```\nstruct Books\n{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;\n} book = {\"C 语言\", \"RUNOOB\", \"编程语言\", 123456};\n```\n\n用`{.成员变量 = , .成员变量 = }`(使用到`.`操作符)来初始化变量。\n\n```\nstruct Stu\n{\n char name[20];//名字\n int age;//年龄\n char sex[5];//性别\n char id[20];//学号\n};\n\nstruct Stu s2 = { .age = 18, .name = \"lisi\", .id = \"20230818002\", .sex = \"⼥\" };\n```\n\n**浮点数在内存中有可能是不能精确保存的。**那根据这一点，在我们对浮点数进行比较大小时，我们就不能简单地对2个数据进行 `==`是否相等的判断，而是有**一定的误差**。\n\n## 结构体的引用\n\n结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。\n\n```\n//此结构体的声明包含了其他的结构体\nstruct COMPLEX\n{\n    char string[100];\n    struct SIMPLE a;\n};\n\n//此结构体的声明包含了指向自己类型的指针\nstruct NODE\n{\n    char string[100];\n    struct NODE *next_node;\n};\n```\n\n在结构中包含一个类型为该结构本身的成员\n\n```\n//错误的定义\nstruct Node//定义了一个节点。节点本身要包涵自己的数据，和指向下一节点\n{\n \tint data;\n \tstruct Node next;//“next”使用未定义的 struct“Node”,这是错误的写法\n};\n```\n\n这个结构体类型的大小我们是否可以得出来,通过`sizeof(struct Node)`分析可以知道因为**一个结构体中再包含一个同类型的结构体变量**，这样会使得结构体的大小**无穷大**，这是不合理的。\n\n```\n//正确的定义\nstruct Node//定义了一个节点。节点本身要包涵，自己的数据和指向下一节点的指针\n{\n \tint data;//数据域,大小为4个字节\n \tstruct Node* next;//指针域，大小为4或8个字节\n};\n```\n\n我们需要定义一个指针类型，准确的指向所需要的位置，这样的结构体大小是可以进行计算的，就不会出现错误\n\n## typedef 重定义结构体\n\n该结构体就有了两种创建变量的方式`struct human man`和`hu man`都行，只是将`struct human`重新取个名字叫`hu`。本质上还是类型是不占用空间的，只有创建变量时才会开辟空间。当然使用`typedef`就不能在声明结构体的后面直接创建全局变量了。\n\n```\ntypedef struct human\n{\n\tchar name[20];\n\tint age;\n\tchar sex[10];\n\tchar id[20];\n}hu;\nint main() {\n    //1.\n\tstruct human man;\n\t//2.\n    hu man;\n\treturn 0;\n}\n\n```\n\n## 结构体访问\n\n有的时候有可能我们得到的是一个指向该结构体的指针。这时候我们就需要操作符`->`，同样也是两个操作数，`->`是专门在访问结构体时使用指针的方法，更高效。\n\n```\nstruct S {\n\tint a;\n\tchar c;\n\tdouble d;\n};\nstruct T {\n\tstruct S s;\n\tchar name[20];\n\tint num;\n};\n\nstruct T t = { {10, 'x', 1.00}, \"yourfriendyo\", 21 };\nstruct T* pt = &t;\nprintf(\"%d %c %lf %s %d\\n\", pt->s.a, pt->s.c, pt->s.d, pt->name, pt->num);\n```\n\n## 结构体的位段\n\n位段就是限制结构体里面每个参数所要占用的字节，比如一个变量`age`表示一个人的年龄，设定1-100岁，**那么给int变量占4个字节就有点浪费空间了，那么我们可以限制一下**。`位段`可以在一定程度上减少空间的浪费\n\n```\nstruct A1\n{\n int _a:2;//数字部分表示变量只占多少个2进制位，也就是占多少比特位\n int _b:5;\n int _c:10;\n int _d:30;\n int _e:50;//这一行是错误的，int类型的比特位数就只有32位，50超出了限制，会报错\n};\n\nstruct A2\n{\n int _a;\n int _b;\n int _c;\n int _d;\n};\n\n\nint main()\n{\n\tprintf(\"%zd\\n\",sizeof(struct A1));//结果为8\n\tprintf(\"%zd\\n\",sizeof(struct A2));//结果为16\n\treturn 0;\n}\n```\n\n## 枚举\n\n枚举就是一一列举，把所有可能的值都按照顺序罗列，其实也就是统一的宏定义，而且不需要从1输到100，他会自己安装顺序进行排序，并且如果在中间进行取值定义，后面的值也会发送改变，可以从下面看出来整体的变化，**修改了初始值的常量**开始后面的枚举常量表示的数字都递增+1，前面的保持不变\n\n```\nenum Sex//性别\n{\n\t//该枚举类型的三种可能取值\n\t//它们都是常量，被称为枚举常量,默认从0开始，递增+1\n \tMALE,//0\n \tFEMALE,//1\n \tSECRET//2\n};\nenum Sex//性别\n{\n\t\n \tMALE=7,//7\n \tFEMALE=9,//9\n \tSECRET=6//6\n};\nenum Sex//性别\n{\n\t\n \tMALE,//0\n \tFEMALE=8,//8\n \tSECRET//9\n};\n```\n\n并且，枚举也遵循typedef的重定义，可以利用变量进行对其中的值进行输入或者调整\n\n```\ntypedef enum {\n\tX,\n\tY,\n    SIZE\n}t;\n```\n\n","slug":"Work No.15","published":1,"updated":"2024-08-09T04:05:19.845Z","_id":"clzgwz9530002e0fb5wrj4o0f","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"C语言结构体学习\"><a href=\"#C语言结构体学习\" class=\"headerlink\" title=\"C语言结构体学习\"></a>C语言结构体学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/yourfriendyo/article/details/119544221\">C语言详解：结构体_c语言结构体语法-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/lyh290188/article/details/104326450\">C语言结构体（struct）最全的讲解（万字干货）_struct a *b(const char *name)-CSDN博客</a></p>\n<h2 id=\"结构体理论知识\"><a href=\"#结构体理论知识\" class=\"headerlink\" title=\"结构体理论知识\"></a>结构体理论知识</h2><p>结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。</p>\n<p>研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。</p>\n<p><strong>结构体的大小不是结构体元素单纯相加就行的</strong>，因为我们现在主流的计算机使用的都是32Bit字长的CPU，<strong>对这类型的CPU取4个字节的数要比取一个字节要高效</strong>，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是<strong>内存对齐</strong>的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。<strong>程序员可以通过预编译命令#pragmapack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S1</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> c1;<br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-type\">char</span> c2<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S2</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> c1;<br>\t<span class=\"hljs-type\">char</span> c2;<br>\t<span class=\"hljs-type\">int</span> i;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>S1</code>和<code>S2</code>类型的成员一样，但是<code>S1</code>和<code>S2</code>所占用的空间不一样，<code>S2</code>相较于<code>S1</code>所占空间较小。</p>\n<p><strong>所以，让占用空间小的成员尽量集中在一起，这样会使整个内存空间变小</strong></p>\n<p>在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。</p>\n<p>在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。</p>\n<p>在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。</p>\n<h2 id=\"结构体声明\"><a href=\"#结构体声明\" class=\"headerlink\" title=\"结构体声明\"></a>结构体声明</h2><p>使用匿名结构体类型创建变量就<strong>只能在变量列表中创建，而且只能一次</strong>，不能在<code>main()</code>函数中创建变量了</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//匿名结构体类型，不完全声明</span><br><span class=\"hljs-keyword\">struct</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> c;<br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-type\">double</span> d;<br>&#125;s1,s2;<span class=\"hljs-comment\">//匿名结构体类型创建变量的唯一方式，就是在变量列表中创建</span><br></code></pre></td></tr></table></figure>\n\n<p>首先使用关键字struct，它表示接下来是一个结构体。在结构体声明中，struct book所起到的作用就像int等基础数据类型名作用一样。</p>\n<p>后面是一个可选的标志（student），它是用来引用该结构体的快速标记。</p>\n<p>接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；</p>\n<p>在结束花括号后的分号表示结构体设计定义的结束</p>\n<p>封号后面额外添加使用字符例如CXSW，这个变量就包含了其student结构体中的所有元素</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-keyword\">tag</span> &#123;<span class=\"hljs-comment\">//tag 是结构体标签。</span><br>    <span class=\"hljs-keyword\">member</span><span class=\"hljs-operator\">-</span>list<span class=\"hljs-comment\">//member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。</span><br>    <span class=\"hljs-keyword\">member</span><span class=\"hljs-operator\">-</span>list<br>    <span class=\"hljs-keyword\">member</span><span class=\"hljs-operator\">-</span>list  <br>    <span class=\"hljs-operator\">...</span><br>&#125; variable<span class=\"hljs-operator\">-</span>list ;<span class=\"hljs-comment\">//variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</span><br><br><span class=\"hljs-keyword\">struct</span> tag variable<span class=\"hljs-operator\">-</span>list;<span class=\"hljs-comment\">//等效于上面定义</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结构体初始化\"><a href=\"#结构体初始化\" class=\"headerlink\" title=\"结构体初始化\"></a>结构体初始化</h2><p>结构体变量的<strong>初始化</strong>有2种方式，但是也有区别：</p>\n<p>在结构体变量的创建时，用<code>&#123;&#125;</code>进行初始化。此时必须严格按声明中成员变量的顺序来初始化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span><br>&#123;<br> <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//名字</span><br> <span class=\"hljs-type\">int</span> age;<span class=\"hljs-comment\">//年龄</span><br> <span class=\"hljs-type\">char</span> sex[<span class=\"hljs-number\">5</span>];<span class=\"hljs-comment\">//性别</span><br> <span class=\"hljs-type\">char</span> id[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//学号</span><br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span> s = &#123; <span class=\"hljs-string\">&quot;张三&quot;</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;男&quot;</span>, <span class=\"hljs-string\">&quot;20230818001&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>或者在结构体后直接定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Books</span><br>&#123;<br>   <span class=\"hljs-type\">char</span>  title[<span class=\"hljs-number\">50</span>];<br>   <span class=\"hljs-type\">char</span>  author[<span class=\"hljs-number\">50</span>];<br>   <span class=\"hljs-type\">char</span>  subject[<span class=\"hljs-number\">100</span>];<br>   <span class=\"hljs-type\">int</span>   book_id;<br>&#125; book = &#123;<span class=\"hljs-string\">&quot;C 语言&quot;</span>, <span class=\"hljs-string\">&quot;RUNOOB&quot;</span>, <span class=\"hljs-string\">&quot;编程语言&quot;</span>, <span class=\"hljs-number\">123456</span>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>用<code>&#123;.成员变量 = , .成员变量 = &#125;</code>(使用到<code>.</code>操作符)来初始化变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span><br>&#123;<br> <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//名字</span><br> <span class=\"hljs-type\">int</span> age;<span class=\"hljs-comment\">//年龄</span><br> <span class=\"hljs-type\">char</span> sex[<span class=\"hljs-number\">5</span>];<span class=\"hljs-comment\">//性别</span><br> <span class=\"hljs-type\">char</span> id[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//学号</span><br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span> s2 = &#123; .age = <span class=\"hljs-number\">18</span>, .name = <span class=\"hljs-string\">&quot;lisi&quot;</span>, .id = <span class=\"hljs-string\">&quot;20230818002&quot;</span>, .sex = <span class=\"hljs-string\">&quot;⼥&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>浮点数在内存中有可能是不能精确保存的。</strong>那根据这一点，在我们对浮点数进行比较大小时，我们就不能简单地对2个数据进行 <code>==</code>是否相等的判断，而是有<strong>一定的误差</strong>。</p>\n<h2 id=\"结构体的引用\"><a href=\"#结构体的引用\" class=\"headerlink\" title=\"结构体的引用\"></a>结构体的引用</h2><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\"><span class=\"hljs-comment\">//此结构体的声明包含了其他的结构体</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">COMPLEX</span><br>&#123;<br>    char <span class=\"hljs-keyword\">string</span>[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">SIMPLE</span> a;<br>&#125;;<br><br><span class=\"hljs-comment\">//此结构体的声明包含了指向自己类型的指针</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">NODE</span><br>&#123;<br>    char <span class=\"hljs-keyword\">string</span>[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">NODE</span> *next_node;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在结构中包含一个类型为该结构本身的成员</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">//错误的定义<br>struct <span class=\"hljs-keyword\">Node</span><span class=\"hljs-title\">//定义了一个节点。节点本身要包涵自己的数据，和指向下一节点</span><br><span class=\"hljs-title\">&#123;</span><br><span class=\"hljs-title\"> \tint</span> data;<br> \tstruct <span class=\"hljs-keyword\">Node</span> <span class=\"hljs-title\">next</span>;//“next”使用未定义的 struct“<span class=\"hljs-keyword\">Node</span><span class=\"hljs-title\">”,这是错误的写法</span><br><span class=\"hljs-title\">&#125;;</span><br></code></pre></td></tr></table></figure>\n\n<p>这个结构体类型的大小我们是否可以得出来,通过<code>sizeof(struct Node)</code>分析可以知道因为<strong>一个结构体中再包含一个同类型的结构体变量</strong>，这样会使得结构体的大小<strong>无穷大</strong>，这是不合理的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//正确的定义</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><span class=\"hljs-comment\">//定义了一个节点。节点本身要包涵，自己的数据和指向下一节点的指针</span><br>&#123;<br> \t<span class=\"hljs-type\">int</span> data;<span class=\"hljs-comment\">//数据域,大小为4个字节</span><br> \t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>* next;<span class=\"hljs-comment\">//指针域，大小为4或8个字节</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>我们需要定义一个指针类型，准确的指向所需要的位置，这样的结构体大小是可以进行计算的，就不会出现错误</p>\n<h2 id=\"typedef-重定义结构体\"><a href=\"#typedef-重定义结构体\" class=\"headerlink\" title=\"typedef 重定义结构体\"></a>typedef 重定义结构体</h2><p>该结构体就有了两种创建变量的方式<code>struct human man</code>和<code>hu man</code>都行，只是将<code>struct human</code>重新取个名字叫<code>hu</code>。本质上还是类型是不占用空间的，只有创建变量时才会开辟空间。当然使用<code>typedef</code>就不能在声明结构体的后面直接创建全局变量了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">human</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<br>\t<span class=\"hljs-type\">int</span> age;<br>\t<span class=\"hljs-type\">char</span> sex[<span class=\"hljs-number\">10</span>];<br>\t<span class=\"hljs-type\">char</span> id[<span class=\"hljs-number\">20</span>];<br>&#125;hu;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">//1.</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">human</span> man;<br>\t<span class=\"hljs-comment\">//2.</span><br>    hu man;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结构体访问\"><a href=\"#结构体访问\" class=\"headerlink\" title=\"结构体访问\"></a>结构体访问</h2><p>有的时候有可能我们得到的是一个指向该结构体的指针。这时候我们就需要操作符<code>-&gt;</code>，同样也是两个操作数，<code>-&gt;</code>是专门在访问结构体时使用指针的方法，更高效。</p>\n<figure class=\"highlight ocaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ocaml\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">S</span> &#123;<br>\t<span class=\"hljs-built_in\">int</span> a;<br>\t<span class=\"hljs-built_in\">char</span> c;<br>\tdouble d;<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">T</span> &#123;<br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">S</span> s;<br>\t<span class=\"hljs-built_in\">char</span> name[<span class=\"hljs-number\">20</span>];<br>\t<span class=\"hljs-built_in\">int</span> num;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">T</span> t = &#123; &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-number\">1.00</span>&#125;, <span class=\"hljs-string\">&quot;yourfriendyo&quot;</span>, <span class=\"hljs-number\">21</span> &#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">T</span>* pt = &amp;t;<br>printf(<span class=\"hljs-string\">&quot;%d %c %lf %s %d\\n&quot;</span>, pt-&gt;s.a, pt-&gt;s.c, pt-&gt;s.d, pt-&gt;name, pt-&gt;num);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结构体的位段\"><a href=\"#结构体的位段\" class=\"headerlink\" title=\"结构体的位段\"></a>结构体的位段</h2><p>位段就是限制结构体里面每个参数所要占用的字节，比如一个变量<code>age</code>表示一个人的年龄，设定1-100岁，<strong>那么给int变量占4个字节就有点浪费空间了，那么我们可以限制一下</strong>。<code>位段</code>可以在一定程度上减少空间的浪费</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">struct</span> A1<br>&#123;<br> <span class=\"hljs-built_in\">int</span> _a:<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//数字部分表示变量只占多少个2进制位，也就是占多少比特位</span><br> <span class=\"hljs-built_in\">int</span> _b:<span class=\"hljs-number\">5</span>;<br> <span class=\"hljs-built_in\">int</span> _c:<span class=\"hljs-number\">10</span>;<br> <span class=\"hljs-built_in\">int</span> _d:<span class=\"hljs-number\">30</span>;<br> <span class=\"hljs-built_in\">int</span> _e:<span class=\"hljs-number\">50</span>;<span class=\"hljs-comment\">//这一行是错误的，int类型的比特位数就只有32位，50超出了限制，会报错</span><br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> A2<br>&#123;<br> <span class=\"hljs-built_in\">int</span> _a;<br> <span class=\"hljs-built_in\">int</span> _b;<br> <span class=\"hljs-built_in\">int</span> _c;<br> <span class=\"hljs-built_in\">int</span> _d;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">main</span>()</span><br>&#123;<br>\tprintf(<span class=\"hljs-string\">&quot;%zd\\n&quot;</span>,<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> A1));<span class=\"hljs-comment\">//结果为8</span><br>\tprintf(<span class=\"hljs-string\">&quot;%zd\\n&quot;</span>,<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> A2));<span class=\"hljs-comment\">//结果为16</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>枚举就是一一列举，把所有可能的值都按照顺序罗列，其实也就是统一的宏定义，而且不需要从1输到100，他会自己安装顺序进行排序，并且如果在中间进行取值定义，后面的值也会发送改变，可以从下面看出来整体的变化，<strong>修改了初始值的常量</strong>开始后面的枚举常量表示的数字都递增+1，前面的保持不变</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">enum</span> Sex<span class=\"hljs-comment\">//性别</span><br>&#123;<br>\t<span class=\"hljs-comment\">//该枚举类型的三种可能取值</span><br>\t<span class=\"hljs-comment\">//它们都是常量，被称为枚举常量,默认从0开始，递增+1</span><br> \tMALE,<span class=\"hljs-comment\">//0</span><br> \tFEMALE,<span class=\"hljs-comment\">//1</span><br> \tSECRET<span class=\"hljs-comment\">//2</span><br>&#125;;<br><span class=\"hljs-keyword\">enum</span> Sex<span class=\"hljs-comment\">//性别</span><br>&#123;<br>\t<br> \tMALE=<span class=\"hljs-number\">7</span>,<span class=\"hljs-comment\">//7</span><br> \tFEMALE=<span class=\"hljs-number\">9</span>,<span class=\"hljs-comment\">//9</span><br> \tSECRET=<span class=\"hljs-number\">6</span><span class=\"hljs-comment\">//6</span><br>&#125;;<br><span class=\"hljs-keyword\">enum</span> Sex<span class=\"hljs-comment\">//性别</span><br>&#123;<br>\t<br> \tMALE,<span class=\"hljs-comment\">//0</span><br> \tFEMALE=<span class=\"hljs-number\">8</span>,<span class=\"hljs-comment\">//8</span><br> \tSECRET<span class=\"hljs-comment\">//9</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>并且，枚举也遵循typedef的重定义，可以利用变量进行对其中的值进行输入或者调整</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\">typedef enum &#123;<br>\t<span class=\"hljs-type\">X</span>,<br>\t<span class=\"hljs-type\">Y</span>,<br>    <span class=\"hljs-type\">SIZE</span><br>&#125;t;<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"C语言结构体学习\"><a href=\"#C语言结构体学习\" class=\"headerlink\" title=\"C语言结构体学习\"></a>C语言结构体学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/yourfriendyo/article/details/119544221\">C语言详解：结构体_c语言结构体语法-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/lyh290188/article/details/104326450\">C语言结构体（struct）最全的讲解（万字干货）_struct a *b(const char *name)-CSDN博客</a></p>\n<h2 id=\"结构体理论知识\"><a href=\"#结构体理论知识\" class=\"headerlink\" title=\"结构体理论知识\"></a>结构体理论知识</h2><p>结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。</p>\n<p>研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。</p>\n<p><strong>结构体的大小不是结构体元素单纯相加就行的</strong>，因为我们现在主流的计算机使用的都是32Bit字长的CPU，<strong>对这类型的CPU取4个字节的数要比取一个字节要高效</strong>，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是<strong>内存对齐</strong>的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。<strong>程序员可以通过预编译命令#pragmapack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S1</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> c1;<br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-type\">char</span> c2<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">S2</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> c1;<br>\t<span class=\"hljs-type\">char</span> c2;<br>\t<span class=\"hljs-type\">int</span> i;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>S1</code>和<code>S2</code>类型的成员一样，但是<code>S1</code>和<code>S2</code>所占用的空间不一样，<code>S2</code>相较于<code>S1</code>所占空间较小。</p>\n<p><strong>所以，让占用空间小的成员尽量集中在一起，这样会使整个内存空间变小</strong></p>\n<p>在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。</p>\n<p>在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。</p>\n<p>在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。</p>\n<h2 id=\"结构体声明\"><a href=\"#结构体声明\" class=\"headerlink\" title=\"结构体声明\"></a>结构体声明</h2><p>使用匿名结构体类型创建变量就<strong>只能在变量列表中创建，而且只能一次</strong>，不能在<code>main()</code>函数中创建变量了</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//匿名结构体类型，不完全声明</span><br><span class=\"hljs-keyword\">struct</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> c;<br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-type\">double</span> d;<br>&#125;s1,s2;<span class=\"hljs-comment\">//匿名结构体类型创建变量的唯一方式，就是在变量列表中创建</span><br></code></pre></td></tr></table></figure>\n\n<p>首先使用关键字struct，它表示接下来是一个结构体。在结构体声明中，struct book所起到的作用就像int等基础数据类型名作用一样。</p>\n<p>后面是一个可选的标志（student），它是用来引用该结构体的快速标记。</p>\n<p>接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；</p>\n<p>在结束花括号后的分号表示结构体设计定义的结束</p>\n<p>封号后面额外添加使用字符例如CXSW，这个变量就包含了其student结构体中的所有元素</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-keyword\">tag</span> &#123;<span class=\"hljs-comment\">//tag 是结构体标签。</span><br>    <span class=\"hljs-keyword\">member</span><span class=\"hljs-operator\">-</span>list<span class=\"hljs-comment\">//member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。</span><br>    <span class=\"hljs-keyword\">member</span><span class=\"hljs-operator\">-</span>list<br>    <span class=\"hljs-keyword\">member</span><span class=\"hljs-operator\">-</span>list  <br>    <span class=\"hljs-operator\">...</span><br>&#125; variable<span class=\"hljs-operator\">-</span>list ;<span class=\"hljs-comment\">//variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</span><br><br><span class=\"hljs-keyword\">struct</span> tag variable<span class=\"hljs-operator\">-</span>list;<span class=\"hljs-comment\">//等效于上面定义</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结构体初始化\"><a href=\"#结构体初始化\" class=\"headerlink\" title=\"结构体初始化\"></a>结构体初始化</h2><p>结构体变量的<strong>初始化</strong>有2种方式，但是也有区别：</p>\n<p>在结构体变量的创建时，用<code>&#123;&#125;</code>进行初始化。此时必须严格按声明中成员变量的顺序来初始化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span><br>&#123;<br> <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//名字</span><br> <span class=\"hljs-type\">int</span> age;<span class=\"hljs-comment\">//年龄</span><br> <span class=\"hljs-type\">char</span> sex[<span class=\"hljs-number\">5</span>];<span class=\"hljs-comment\">//性别</span><br> <span class=\"hljs-type\">char</span> id[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//学号</span><br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span> s = &#123; <span class=\"hljs-string\">&quot;张三&quot;</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;男&quot;</span>, <span class=\"hljs-string\">&quot;20230818001&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>或者在结构体后直接定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Books</span><br>&#123;<br>   <span class=\"hljs-type\">char</span>  title[<span class=\"hljs-number\">50</span>];<br>   <span class=\"hljs-type\">char</span>  author[<span class=\"hljs-number\">50</span>];<br>   <span class=\"hljs-type\">char</span>  subject[<span class=\"hljs-number\">100</span>];<br>   <span class=\"hljs-type\">int</span>   book_id;<br>&#125; book = &#123;<span class=\"hljs-string\">&quot;C 语言&quot;</span>, <span class=\"hljs-string\">&quot;RUNOOB&quot;</span>, <span class=\"hljs-string\">&quot;编程语言&quot;</span>, <span class=\"hljs-number\">123456</span>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>用<code>&#123;.成员变量 = , .成员变量 = &#125;</code>(使用到<code>.</code>操作符)来初始化变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span><br>&#123;<br> <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//名字</span><br> <span class=\"hljs-type\">int</span> age;<span class=\"hljs-comment\">//年龄</span><br> <span class=\"hljs-type\">char</span> sex[<span class=\"hljs-number\">5</span>];<span class=\"hljs-comment\">//性别</span><br> <span class=\"hljs-type\">char</span> id[<span class=\"hljs-number\">20</span>];<span class=\"hljs-comment\">//学号</span><br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Stu</span> s2 = &#123; .age = <span class=\"hljs-number\">18</span>, .name = <span class=\"hljs-string\">&quot;lisi&quot;</span>, .id = <span class=\"hljs-string\">&quot;20230818002&quot;</span>, .sex = <span class=\"hljs-string\">&quot;⼥&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>浮点数在内存中有可能是不能精确保存的。</strong>那根据这一点，在我们对浮点数进行比较大小时，我们就不能简单地对2个数据进行 <code>==</code>是否相等的判断，而是有<strong>一定的误差</strong>。</p>\n<h2 id=\"结构体的引用\"><a href=\"#结构体的引用\" class=\"headerlink\" title=\"结构体的引用\"></a>结构体的引用</h2><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\"><span class=\"hljs-comment\">//此结构体的声明包含了其他的结构体</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">COMPLEX</span><br>&#123;<br>    char <span class=\"hljs-keyword\">string</span>[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">SIMPLE</span> a;<br>&#125;;<br><br><span class=\"hljs-comment\">//此结构体的声明包含了指向自己类型的指针</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">NODE</span><br>&#123;<br>    char <span class=\"hljs-keyword\">string</span>[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">NODE</span> *next_node;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在结构中包含一个类型为该结构本身的成员</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">//错误的定义<br>struct <span class=\"hljs-keyword\">Node</span><span class=\"hljs-title\">//定义了一个节点。节点本身要包涵自己的数据，和指向下一节点</span><br><span class=\"hljs-title\">&#123;</span><br><span class=\"hljs-title\"> \tint</span> data;<br> \tstruct <span class=\"hljs-keyword\">Node</span> <span class=\"hljs-title\">next</span>;//“next”使用未定义的 struct“<span class=\"hljs-keyword\">Node</span><span class=\"hljs-title\">”,这是错误的写法</span><br><span class=\"hljs-title\">&#125;;</span><br></code></pre></td></tr></table></figure>\n\n<p>这个结构体类型的大小我们是否可以得出来,通过<code>sizeof(struct Node)</code>分析可以知道因为<strong>一个结构体中再包含一个同类型的结构体变量</strong>，这样会使得结构体的大小<strong>无穷大</strong>，这是不合理的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//正确的定义</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span><span class=\"hljs-comment\">//定义了一个节点。节点本身要包涵，自己的数据和指向下一节点的指针</span><br>&#123;<br> \t<span class=\"hljs-type\">int</span> data;<span class=\"hljs-comment\">//数据域,大小为4个字节</span><br> \t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>* next;<span class=\"hljs-comment\">//指针域，大小为4或8个字节</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>我们需要定义一个指针类型，准确的指向所需要的位置，这样的结构体大小是可以进行计算的，就不会出现错误</p>\n<h2 id=\"typedef-重定义结构体\"><a href=\"#typedef-重定义结构体\" class=\"headerlink\" title=\"typedef 重定义结构体\"></a>typedef 重定义结构体</h2><p>该结构体就有了两种创建变量的方式<code>struct human man</code>和<code>hu man</code>都行，只是将<code>struct human</code>重新取个名字叫<code>hu</code>。本质上还是类型是不占用空间的，只有创建变量时才会开辟空间。当然使用<code>typedef</code>就不能在声明结构体的后面直接创建全局变量了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">human</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<br>\t<span class=\"hljs-type\">int</span> age;<br>\t<span class=\"hljs-type\">char</span> sex[<span class=\"hljs-number\">10</span>];<br>\t<span class=\"hljs-type\">char</span> id[<span class=\"hljs-number\">20</span>];<br>&#125;hu;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">//1.</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">human</span> man;<br>\t<span class=\"hljs-comment\">//2.</span><br>    hu man;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结构体访问\"><a href=\"#结构体访问\" class=\"headerlink\" title=\"结构体访问\"></a>结构体访问</h2><p>有的时候有可能我们得到的是一个指向该结构体的指针。这时候我们就需要操作符<code>-&gt;</code>，同样也是两个操作数，<code>-&gt;</code>是专门在访问结构体时使用指针的方法，更高效。</p>\n<figure class=\"highlight ocaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ocaml\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">S</span> &#123;<br>\t<span class=\"hljs-built_in\">int</span> a;<br>\t<span class=\"hljs-built_in\">char</span> c;<br>\tdouble d;<br>&#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">T</span> &#123;<br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">S</span> s;<br>\t<span class=\"hljs-built_in\">char</span> name[<span class=\"hljs-number\">20</span>];<br>\t<span class=\"hljs-built_in\">int</span> num;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">T</span> t = &#123; &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-number\">1.00</span>&#125;, <span class=\"hljs-string\">&quot;yourfriendyo&quot;</span>, <span class=\"hljs-number\">21</span> &#125;;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">T</span>* pt = &amp;t;<br>printf(<span class=\"hljs-string\">&quot;%d %c %lf %s %d\\n&quot;</span>, pt-&gt;s.a, pt-&gt;s.c, pt-&gt;s.d, pt-&gt;name, pt-&gt;num);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结构体的位段\"><a href=\"#结构体的位段\" class=\"headerlink\" title=\"结构体的位段\"></a>结构体的位段</h2><p>位段就是限制结构体里面每个参数所要占用的字节，比如一个变量<code>age</code>表示一个人的年龄，设定1-100岁，<strong>那么给int变量占4个字节就有点浪费空间了，那么我们可以限制一下</strong>。<code>位段</code>可以在一定程度上减少空间的浪费</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">struct</span> A1<br>&#123;<br> <span class=\"hljs-built_in\">int</span> _a:<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//数字部分表示变量只占多少个2进制位，也就是占多少比特位</span><br> <span class=\"hljs-built_in\">int</span> _b:<span class=\"hljs-number\">5</span>;<br> <span class=\"hljs-built_in\">int</span> _c:<span class=\"hljs-number\">10</span>;<br> <span class=\"hljs-built_in\">int</span> _d:<span class=\"hljs-number\">30</span>;<br> <span class=\"hljs-built_in\">int</span> _e:<span class=\"hljs-number\">50</span>;<span class=\"hljs-comment\">//这一行是错误的，int类型的比特位数就只有32位，50超出了限制，会报错</span><br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> A2<br>&#123;<br> <span class=\"hljs-built_in\">int</span> _a;<br> <span class=\"hljs-built_in\">int</span> _b;<br> <span class=\"hljs-built_in\">int</span> _c;<br> <span class=\"hljs-built_in\">int</span> _d;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">main</span>()</span><br>&#123;<br>\tprintf(<span class=\"hljs-string\">&quot;%zd\\n&quot;</span>,<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> A1));<span class=\"hljs-comment\">//结果为8</span><br>\tprintf(<span class=\"hljs-string\">&quot;%zd\\n&quot;</span>,<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> A2));<span class=\"hljs-comment\">//结果为16</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>枚举就是一一列举，把所有可能的值都按照顺序罗列，其实也就是统一的宏定义，而且不需要从1输到100，他会自己安装顺序进行排序，并且如果在中间进行取值定义，后面的值也会发送改变，可以从下面看出来整体的变化，<strong>修改了初始值的常量</strong>开始后面的枚举常量表示的数字都递增+1，前面的保持不变</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">enum</span> Sex<span class=\"hljs-comment\">//性别</span><br>&#123;<br>\t<span class=\"hljs-comment\">//该枚举类型的三种可能取值</span><br>\t<span class=\"hljs-comment\">//它们都是常量，被称为枚举常量,默认从0开始，递增+1</span><br> \tMALE,<span class=\"hljs-comment\">//0</span><br> \tFEMALE,<span class=\"hljs-comment\">//1</span><br> \tSECRET<span class=\"hljs-comment\">//2</span><br>&#125;;<br><span class=\"hljs-keyword\">enum</span> Sex<span class=\"hljs-comment\">//性别</span><br>&#123;<br>\t<br> \tMALE=<span class=\"hljs-number\">7</span>,<span class=\"hljs-comment\">//7</span><br> \tFEMALE=<span class=\"hljs-number\">9</span>,<span class=\"hljs-comment\">//9</span><br> \tSECRET=<span class=\"hljs-number\">6</span><span class=\"hljs-comment\">//6</span><br>&#125;;<br><span class=\"hljs-keyword\">enum</span> Sex<span class=\"hljs-comment\">//性别</span><br>&#123;<br>\t<br> \tMALE,<span class=\"hljs-comment\">//0</span><br> \tFEMALE=<span class=\"hljs-number\">8</span>,<span class=\"hljs-comment\">//8</span><br> \tSECRET<span class=\"hljs-comment\">//9</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>并且，枚举也遵循typedef的重定义，可以利用变量进行对其中的值进行输入或者调整</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\">typedef enum &#123;<br>\t<span class=\"hljs-type\">X</span>,<br>\t<span class=\"hljs-type\">Y</span>,<br>    <span class=\"hljs-type\">SIZE</span><br>&#125;t;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"C语言链表学习","date":"2024-08-05T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/jlE19dhkmfFrO2U.jpg","_content":"\n# C语言链表学习\n\n## 感谢博主：\n\n[数据结构--链表入门超详细解析(简单易懂纯原篇)_链表教学-CSDN博客](https://blog.csdn.net/qq_35664104/article/details/120769681)\n\n## 链表基础知识\n\n链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点\n\n链表都有一个头指针，一般以head来表示，存放的是一个地址。\n\n链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。\n\n链表中每个节点都分为两部分，一个数据域，一个是指针域。\n\nhead指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。\n\n## 链表初始化\n\n#### 创建链表\n\n```\ntypedef struct lint{ //每一个节点其实就是一个结构体，将每个结构体用节点地址关联的方式，进行链接\n\tint score; //数据域，用于存放数据的位置\n\tstruct lint* next; //指针域，定义指向下一个节点地址的指针\n} LinkList;\n```\n\n采用typedef的方式，能够不用每次使用struct student  a，直接LinkList a的方式对a进行定义\n\n链表中有一个特殊的结点–头结点。头结点的数据域一般不用来存放和其他节点同类的数据，它的诞生是为了在实际应用过程中存放一些数据+\n\n***p代表这个地址上面的值，p代表这个地址，a[]代表这个地址上面的值，a代表这个数组的地址**\n\n#### 无头结点的初始化\n\n直接从数据节点开始，直接定义第一个数据节点的值和下一个节点的地址\n\n```\nLint * initLint()\n{\n    // 创建头指针\n    Lint* p = NULL;\n    \n  \t// 创建一个临时指针初始化首元结点，并且用于移动和调整后续结点\n\tLint* temp = (Lint*)malloc(sizeof(Lint));//创建一个结构体，并分配内存空间\n  \ttemp->score = 90;//将数据填入数据域当中\n  \ttemp->next = NULL;//下一节点地址指向NULL\n  \t\n  \t// 头指针需要指向首元结点，这样才能定位这串链表的位置\n  \tp = temp;\n  \t\n  \t// 手动创建10个元素\n    for(int i = 0;i < 10;i++)\n    {\n        // 从第二个结点开始创建\n        Lint * a = (Lint*) malloc(sizeof(Lint));\n        a->score = i + 91;\n        a->next = NULL;\n        \n        // 将当前temp指向的结点的next指向下一个结点\n        temp->next = a; //temp->next这个的意思是在temp中有一个next地址，将他指向a的地址\n        \n        // temp移到下一个结点。这样在下次循环运行到上一行(line17)时能持续\n        temp = temp->next;  // 或 temp = a;\n    }\n    return p;\n}\n```\n\n#### 有头节点的初始化\n\n首先定义一个头结点，头结点没有数据域，只有地址域，直接赋值地址域\n\n```\nLint * initLint()\n{\n    // 创建头指针，并用其创建头结点\n    Lint * p = (Lint*)malloc(sizeof (Lint));\n    // 及时指定指针的指向以确保指针安全\n    p->next = NULL;\n    // 创建一个临时的指针指向头结点以进行后续的操作\n    Lint * temp = p;\n    for(int i = 0;i < 10;i++){\n        // 从首元结点开始创建\n        Lint * a = (Lint*) malloc(sizeof(Lint));\n        a->score = i + 90;\n        a->next = NULL;\n        // 将当前temp指向的next指向下一个结点\n        temp->next = a;\n        // temp移到下一个结点\n        temp = temp->next;  // 或 temp = a;\n    }\n    return p;\n}\n```\n\n## 链表数据改变\n\n#### 输出链表\n\n输出链表其实就是在遍历结构体中的地址域，到达该地址域之后，将其打印出来，然后再跳转指向下一个地址域\n\n```\nvoid showLint(Lint* p){\t\n  \t// 一开始p指针在头结点，这个数据域是空的，因此需要检测其指针域中是否有下一个节点的地址。如果为空，则退出循环\n    while (p->next){\n      \t// p从头结点移出，到首元结点开始输出\n        p = p->next;\n        printf(\"%d\\t\", p->score);\n    }\n    printf(\"\\n\");\n}\n```\n\n#### 增加数据\n\n增加结点的逻辑是：将新增结点的指针域指向后一个结点，然后将原链表中的前一个结点的指针域指向新增的结点。(**注意顺序不能颠倒，否则会导致插入位置后面的结点全部丢失**)\n\n```\nLint* insertLint(Lint* p,int n, int num){\t\t// 将num插入到第n个位置\n    Lint * temp = p;\n    // 通过遍历将temp指针移到指向插入位置的直接前驱结点的位置\n    for (int i = 1;i < n;i++){\n        // 防止超过链表现有长度\n        if (temp->next == NULL){\n            printf(\"位置错误!\\n\");\n            return p;\n        }\n        temp = temp->next;\n    }\n    // 创建插入的新结点\n    Lint * a = (Lint*) malloc(sizeof (Lint));\n    a->score = num;\n  \t// 新节点数据域指向原位置后一个结点\n    a->next = temp->next;\n  \t// temp后移一个结点\n    temp->next = a;\n    return p;\n}\n\n//main函数输出\n    int n, num;\n    printf(\"请输入插入的位置和数字，用空格隔开:\");\n    scanf(\"%d%d\", &n, &num);\n    insertLint(p, n, num);\n    showLint(p);\n```\n\n#### 删除数据\n\n删除链表数据的意思其实也是先找到想要删除的地址域，从节点中一个一个往下遍历，比如想删除第五个节点，那就遍历到第四个节点，然后在第四个节点的地址域上直接指向到第五节点的地址域，这样，第五个节点的地址就在第四个节点上丢失，从而第四个节点地址域获取的就是第六个节点的地址\n\n```\nLint* delLint(Lint* p,int n){\n    Lint * temp = p;\n    // 用于存储临时删除的结点\n    Lint * back = NULL;\n    // temp移到删除结点的前一个节点\n    for (int i = 1;i < n;i++){\n        // 防止越过链表\n        if (temp->next == NULL){\n            printf(\"位置错误!\\n\");\n            return p;\n        }\n        //逐个跳转地址域\n        temp = temp->next;\n    }\n    // 临时存储被删除结点,防止丢失\n    back = temp->next;\n  \t// 指向下下个结点\n    temp->next = temp->next->next;\n    // 手动释放内存防止泄露\n    free(back);\n    return p;\n}\n\n//main函数输出\n    printf(\"请输入删除第几个元素:\");\n    scanf(\"%d\", &n);\n    delLint(p, n);\n    showLint(p);\n```\n\n#### 修改数据\n\n修改数据其实跟上面的一样，指到这个数据域之后，直接对其数据进行修改即可\n\n```\nLint* changeLint(Lint* p,int n, int num){  \t\n\t// temp可以一开始就指向首元结点    \n\tLint * temp = p->next;    \n\tfor (int i = 1;i < n;i++){        \n\t// 防止越过链表        \n\t\tif (temp->next == NULL){            \n\t\t\tprintf(\"位置错误!\\n\");            \n\t\t\treturn p;        \n\t\t}        \n\t\ttemp = temp->next;    \n\t}    \n\t// 修改    \n\ttemp->score = num;    \n\treturn p;\n}\n\n//main函数输出\n    printf(\"请输入修改第几个元素为什么数,空格隔开:\");\n    scanf(\"%d%d\", &n, &num);\n    changeLint(p, n, num);\n    showLint(p);\n```\n\n#### 查找数据\n\n查的基本思想是指针进行遍历链表，对每个节点的数据域进行对比，如果相同就可以直接退出返回结果了。如果一直到链表结束还没有匹配成功就说明没有找到。\n\n```\nint searchLint(Lint* p, int num){\n    Lint * temp = p;\n    int i;  // 用于记数\n    for(i = 1;temp->next != NULL;i++){\n      \t// 因为是从头结点开始的，因此要先移到首元结点\n        temp = temp->next;\n        if (temp->score == num)return i;\t// 返回i表示找到的位置\n    }\n    return 0;\t// 返回0表示未找到\n}\n\n//main函数输出\n    printf(\"请输入需要查询的分数:\");\n    scanf(\"%d\", &num);\n    if (!searchLint(p, num))\n        printf(\"未查询到该分数\");\n    else\n        printf(\"在第%d个元素\", searchLint(p, num));\n```\n\n如果你的头结点直接在数据域上面标记是1，那可以直接利用数据域的数据进行查找数据\n\n```\nint searchLint(Lint* p, int num){\n    Lint * temp = p;\n    for(p->score = 1;temp->next != NULL;p->score++){\n        temp = temp->next;\n        if (temp->score == num)return p->score;\n    }\n    return 0;\n}\n```\n\n## 项目实践总结\n\n链表的使用主要分为5个部分\n\n1.创建数据结构体\n\n```\n// 消息结构体定义\ntypedef struct MsgSend {\n    char *cmdStr;       // 发送命令，实际的命令存储区\n    uint32_t cmdLen;    // 命令长度，该命令长度\n    struct list_head node; //链表节点定义\n}MsgSend_t;\n```\n\n2.创建链表头定义\n\n```\n// 定义链表头结点\nstatic struct list_head External_List;\n```\n\n3.链表初始化\n\n```\n// 初始化链表头\nINIT_LIST_HEAD(&External_List);\n```\n\n4.创建互斥锁或读写锁\n\n```\nstatic pthread_rwlock_t Ext_rwLock; // 声明一个读写锁\n```\n\n5.打开互斥锁或读写锁遍历链表（增删改查）\n\n```\n//计算链表长度\n\t\n\t// 读写锁\n    pthread_rwlock_rdlock(&Ext_rwLock);\n    // 遍历链表\n    list_for_each(list_temp, &External_List)\n    {\n        // 每遍历一个加数值\n        list_len++;\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 删除所有节点\n    \n    // 链表读写锁\n    pthread_rwlock_wrlock(&Ext_rwLock);\n    // 遍历链表并安全删除节点\n    list_for_each_entry_safe(temp, next, &External_List, node)\n    {\n        // 当前节点存在数据，则清空数据\n        if (temp->cmdStr != NULL)\n        {\n            free(temp->cmdStr); // 释放 cmdStr 指针\n            // 再次指向空值，防止清空失败\n            temp->cmdStr = NULL;\n        }\n        // 从链表中删除节点\n        list_del_init(&temp->node);\n        // 链表节点不为空\n        if (temp != NULL)\n        {\n            free(temp);  // 释放节点\n            temp = NULL; // 释放后置为NULL，防止野指针\n        }\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 删除所有节点\n\n\t// 链表读写锁\n    pthread_rwlock_wrlock(&Ext_rwLock);\n    // 遍历链表并安全删除节点\n    list_for_each_entry_safe(temp, next, &External_List, node)\n    {\n        // 寻找链表ID和要删除的ID一致的链表，ID是唯一的\n        if (temp->cmdId == deletelist->cmdId)\n        {\n            // 从链表中删除节点\n            list_del_init(&temp->node);\n            // 当前节点存在数据，则清空数据\n            if (temp->cmdStr != NULL)\n            {\n                free(temp->cmdStr);  // 释放节点\n                temp->cmdStr = NULL; // 释放后置为NULL，防止野指针\n            }\n            // 链表节点不为空\n            if (temp != NULL)\n            {\n                free(temp);  // 释放节点\n                temp = NULL; // 释放后置为NULL，防止野指针\n            }\n            break; // 完成清除后直接退出链表\n        }\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 复制链表到链表\n\n\t// 定义临时节点，用于获取链表数据\n\tExtMsgSend_t *temp = NULL, *snext = NULL;\n\t// 链表读写锁\n\tpthread_rwlock_wrlock(&Ext_rwLock);\n\t// 遍历列表和ID值进行比对\n    list_for_each_entry_safe(temp, snext, &External_List, node)\n    {\n    \t// 找到ID值\n        if (temp->cmdId == id)\n        {\n            // 将所有链表值复制到Send_List链表中\n            memcpy(Send_List, temp, sizeof(ExtMsgSend_t));\n            // 退出遍历\n            break;\n        }\n    \telse\n    \t{\n            // 如果不是则进行提示\n            LogW(\"APP recvjson cmdId is unable to match\\n\");\n        }\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 写入链表\n\n\tpthread_rwlock_wrlock(&Ext_rwLock);              // 上锁\n    list_add_tail(&ExMsgSend->node, &External_List); // 写入\n    pthread_rwlock_unlock(&Ext_rwLock);              // 解锁\n```\n\n","source":"_posts/Work No.16.md","raw":"---\ntitle: C语言链表学习\ntag: C/C++\ndate: 2024-08-06\ncategories: C/C++\nindex_img: https://s2.loli.net/2024/08/02/jlE19dhkmfFrO2U.jpg\n---\n\n# C语言链表学习\n\n## 感谢博主：\n\n[数据结构--链表入门超详细解析(简单易懂纯原篇)_链表教学-CSDN博客](https://blog.csdn.net/qq_35664104/article/details/120769681)\n\n## 链表基础知识\n\n链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点\n\n链表都有一个头指针，一般以head来表示，存放的是一个地址。\n\n链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。\n\n链表中每个节点都分为两部分，一个数据域，一个是指针域。\n\nhead指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。\n\n## 链表初始化\n\n#### 创建链表\n\n```\ntypedef struct lint{ //每一个节点其实就是一个结构体，将每个结构体用节点地址关联的方式，进行链接\n\tint score; //数据域，用于存放数据的位置\n\tstruct lint* next; //指针域，定义指向下一个节点地址的指针\n} LinkList;\n```\n\n采用typedef的方式，能够不用每次使用struct student  a，直接LinkList a的方式对a进行定义\n\n链表中有一个特殊的结点–头结点。头结点的数据域一般不用来存放和其他节点同类的数据，它的诞生是为了在实际应用过程中存放一些数据+\n\n***p代表这个地址上面的值，p代表这个地址，a[]代表这个地址上面的值，a代表这个数组的地址**\n\n#### 无头结点的初始化\n\n直接从数据节点开始，直接定义第一个数据节点的值和下一个节点的地址\n\n```\nLint * initLint()\n{\n    // 创建头指针\n    Lint* p = NULL;\n    \n  \t// 创建一个临时指针初始化首元结点，并且用于移动和调整后续结点\n\tLint* temp = (Lint*)malloc(sizeof(Lint));//创建一个结构体，并分配内存空间\n  \ttemp->score = 90;//将数据填入数据域当中\n  \ttemp->next = NULL;//下一节点地址指向NULL\n  \t\n  \t// 头指针需要指向首元结点，这样才能定位这串链表的位置\n  \tp = temp;\n  \t\n  \t// 手动创建10个元素\n    for(int i = 0;i < 10;i++)\n    {\n        // 从第二个结点开始创建\n        Lint * a = (Lint*) malloc(sizeof(Lint));\n        a->score = i + 91;\n        a->next = NULL;\n        \n        // 将当前temp指向的结点的next指向下一个结点\n        temp->next = a; //temp->next这个的意思是在temp中有一个next地址，将他指向a的地址\n        \n        // temp移到下一个结点。这样在下次循环运行到上一行(line17)时能持续\n        temp = temp->next;  // 或 temp = a;\n    }\n    return p;\n}\n```\n\n#### 有头节点的初始化\n\n首先定义一个头结点，头结点没有数据域，只有地址域，直接赋值地址域\n\n```\nLint * initLint()\n{\n    // 创建头指针，并用其创建头结点\n    Lint * p = (Lint*)malloc(sizeof (Lint));\n    // 及时指定指针的指向以确保指针安全\n    p->next = NULL;\n    // 创建一个临时的指针指向头结点以进行后续的操作\n    Lint * temp = p;\n    for(int i = 0;i < 10;i++){\n        // 从首元结点开始创建\n        Lint * a = (Lint*) malloc(sizeof(Lint));\n        a->score = i + 90;\n        a->next = NULL;\n        // 将当前temp指向的next指向下一个结点\n        temp->next = a;\n        // temp移到下一个结点\n        temp = temp->next;  // 或 temp = a;\n    }\n    return p;\n}\n```\n\n## 链表数据改变\n\n#### 输出链表\n\n输出链表其实就是在遍历结构体中的地址域，到达该地址域之后，将其打印出来，然后再跳转指向下一个地址域\n\n```\nvoid showLint(Lint* p){\t\n  \t// 一开始p指针在头结点，这个数据域是空的，因此需要检测其指针域中是否有下一个节点的地址。如果为空，则退出循环\n    while (p->next){\n      \t// p从头结点移出，到首元结点开始输出\n        p = p->next;\n        printf(\"%d\\t\", p->score);\n    }\n    printf(\"\\n\");\n}\n```\n\n#### 增加数据\n\n增加结点的逻辑是：将新增结点的指针域指向后一个结点，然后将原链表中的前一个结点的指针域指向新增的结点。(**注意顺序不能颠倒，否则会导致插入位置后面的结点全部丢失**)\n\n```\nLint* insertLint(Lint* p,int n, int num){\t\t// 将num插入到第n个位置\n    Lint * temp = p;\n    // 通过遍历将temp指针移到指向插入位置的直接前驱结点的位置\n    for (int i = 1;i < n;i++){\n        // 防止超过链表现有长度\n        if (temp->next == NULL){\n            printf(\"位置错误!\\n\");\n            return p;\n        }\n        temp = temp->next;\n    }\n    // 创建插入的新结点\n    Lint * a = (Lint*) malloc(sizeof (Lint));\n    a->score = num;\n  \t// 新节点数据域指向原位置后一个结点\n    a->next = temp->next;\n  \t// temp后移一个结点\n    temp->next = a;\n    return p;\n}\n\n//main函数输出\n    int n, num;\n    printf(\"请输入插入的位置和数字，用空格隔开:\");\n    scanf(\"%d%d\", &n, &num);\n    insertLint(p, n, num);\n    showLint(p);\n```\n\n#### 删除数据\n\n删除链表数据的意思其实也是先找到想要删除的地址域，从节点中一个一个往下遍历，比如想删除第五个节点，那就遍历到第四个节点，然后在第四个节点的地址域上直接指向到第五节点的地址域，这样，第五个节点的地址就在第四个节点上丢失，从而第四个节点地址域获取的就是第六个节点的地址\n\n```\nLint* delLint(Lint* p,int n){\n    Lint * temp = p;\n    // 用于存储临时删除的结点\n    Lint * back = NULL;\n    // temp移到删除结点的前一个节点\n    for (int i = 1;i < n;i++){\n        // 防止越过链表\n        if (temp->next == NULL){\n            printf(\"位置错误!\\n\");\n            return p;\n        }\n        //逐个跳转地址域\n        temp = temp->next;\n    }\n    // 临时存储被删除结点,防止丢失\n    back = temp->next;\n  \t// 指向下下个结点\n    temp->next = temp->next->next;\n    // 手动释放内存防止泄露\n    free(back);\n    return p;\n}\n\n//main函数输出\n    printf(\"请输入删除第几个元素:\");\n    scanf(\"%d\", &n);\n    delLint(p, n);\n    showLint(p);\n```\n\n#### 修改数据\n\n修改数据其实跟上面的一样，指到这个数据域之后，直接对其数据进行修改即可\n\n```\nLint* changeLint(Lint* p,int n, int num){  \t\n\t// temp可以一开始就指向首元结点    \n\tLint * temp = p->next;    \n\tfor (int i = 1;i < n;i++){        \n\t// 防止越过链表        \n\t\tif (temp->next == NULL){            \n\t\t\tprintf(\"位置错误!\\n\");            \n\t\t\treturn p;        \n\t\t}        \n\t\ttemp = temp->next;    \n\t}    \n\t// 修改    \n\ttemp->score = num;    \n\treturn p;\n}\n\n//main函数输出\n    printf(\"请输入修改第几个元素为什么数,空格隔开:\");\n    scanf(\"%d%d\", &n, &num);\n    changeLint(p, n, num);\n    showLint(p);\n```\n\n#### 查找数据\n\n查的基本思想是指针进行遍历链表，对每个节点的数据域进行对比，如果相同就可以直接退出返回结果了。如果一直到链表结束还没有匹配成功就说明没有找到。\n\n```\nint searchLint(Lint* p, int num){\n    Lint * temp = p;\n    int i;  // 用于记数\n    for(i = 1;temp->next != NULL;i++){\n      \t// 因为是从头结点开始的，因此要先移到首元结点\n        temp = temp->next;\n        if (temp->score == num)return i;\t// 返回i表示找到的位置\n    }\n    return 0;\t// 返回0表示未找到\n}\n\n//main函数输出\n    printf(\"请输入需要查询的分数:\");\n    scanf(\"%d\", &num);\n    if (!searchLint(p, num))\n        printf(\"未查询到该分数\");\n    else\n        printf(\"在第%d个元素\", searchLint(p, num));\n```\n\n如果你的头结点直接在数据域上面标记是1，那可以直接利用数据域的数据进行查找数据\n\n```\nint searchLint(Lint* p, int num){\n    Lint * temp = p;\n    for(p->score = 1;temp->next != NULL;p->score++){\n        temp = temp->next;\n        if (temp->score == num)return p->score;\n    }\n    return 0;\n}\n```\n\n## 项目实践总结\n\n链表的使用主要分为5个部分\n\n1.创建数据结构体\n\n```\n// 消息结构体定义\ntypedef struct MsgSend {\n    char *cmdStr;       // 发送命令，实际的命令存储区\n    uint32_t cmdLen;    // 命令长度，该命令长度\n    struct list_head node; //链表节点定义\n}MsgSend_t;\n```\n\n2.创建链表头定义\n\n```\n// 定义链表头结点\nstatic struct list_head External_List;\n```\n\n3.链表初始化\n\n```\n// 初始化链表头\nINIT_LIST_HEAD(&External_List);\n```\n\n4.创建互斥锁或读写锁\n\n```\nstatic pthread_rwlock_t Ext_rwLock; // 声明一个读写锁\n```\n\n5.打开互斥锁或读写锁遍历链表（增删改查）\n\n```\n//计算链表长度\n\t\n\t// 读写锁\n    pthread_rwlock_rdlock(&Ext_rwLock);\n    // 遍历链表\n    list_for_each(list_temp, &External_List)\n    {\n        // 每遍历一个加数值\n        list_len++;\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 删除所有节点\n    \n    // 链表读写锁\n    pthread_rwlock_wrlock(&Ext_rwLock);\n    // 遍历链表并安全删除节点\n    list_for_each_entry_safe(temp, next, &External_List, node)\n    {\n        // 当前节点存在数据，则清空数据\n        if (temp->cmdStr != NULL)\n        {\n            free(temp->cmdStr); // 释放 cmdStr 指针\n            // 再次指向空值，防止清空失败\n            temp->cmdStr = NULL;\n        }\n        // 从链表中删除节点\n        list_del_init(&temp->node);\n        // 链表节点不为空\n        if (temp != NULL)\n        {\n            free(temp);  // 释放节点\n            temp = NULL; // 释放后置为NULL，防止野指针\n        }\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 删除所有节点\n\n\t// 链表读写锁\n    pthread_rwlock_wrlock(&Ext_rwLock);\n    // 遍历链表并安全删除节点\n    list_for_each_entry_safe(temp, next, &External_List, node)\n    {\n        // 寻找链表ID和要删除的ID一致的链表，ID是唯一的\n        if (temp->cmdId == deletelist->cmdId)\n        {\n            // 从链表中删除节点\n            list_del_init(&temp->node);\n            // 当前节点存在数据，则清空数据\n            if (temp->cmdStr != NULL)\n            {\n                free(temp->cmdStr);  // 释放节点\n                temp->cmdStr = NULL; // 释放后置为NULL，防止野指针\n            }\n            // 链表节点不为空\n            if (temp != NULL)\n            {\n                free(temp);  // 释放节点\n                temp = NULL; // 释放后置为NULL，防止野指针\n            }\n            break; // 完成清除后直接退出链表\n        }\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 复制链表到链表\n\n\t// 定义临时节点，用于获取链表数据\n\tExtMsgSend_t *temp = NULL, *snext = NULL;\n\t// 链表读写锁\n\tpthread_rwlock_wrlock(&Ext_rwLock);\n\t// 遍历列表和ID值进行比对\n    list_for_each_entry_safe(temp, snext, &External_List, node)\n    {\n    \t// 找到ID值\n        if (temp->cmdId == id)\n        {\n            // 将所有链表值复制到Send_List链表中\n            memcpy(Send_List, temp, sizeof(ExtMsgSend_t));\n            // 退出遍历\n            break;\n        }\n    \telse\n    \t{\n            // 如果不是则进行提示\n            LogW(\"APP recvjson cmdId is unable to match\\n\");\n        }\n    }\n    pthread_rwlock_unlock(&Ext_rwLock);\n    \n// 写入链表\n\n\tpthread_rwlock_wrlock(&Ext_rwLock);              // 上锁\n    list_add_tail(&ExMsgSend->node, &External_List); // 写入\n    pthread_rwlock_unlock(&Ext_rwLock);              // 解锁\n```\n\n","slug":"Work No.16","published":1,"updated":"2024-09-02T02:42:49.047Z","_id":"clzl8eduf0000p4fbaoai3ohg","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"C语言链表学习\"><a href=\"#C语言链表学习\" class=\"headerlink\" title=\"C语言链表学习\"></a>C语言链表学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/qq_35664104/article/details/120769681\">数据结构–链表入门超详细解析(简单易懂纯原篇)_链表教学-CSDN博客</a></p>\n<h2 id=\"链表基础知识\"><a href=\"#链表基础知识\" class=\"headerlink\" title=\"链表基础知识\"></a>链表基础知识</h2><p>链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点</p>\n<p>链表都有一个头指针，一般以head来表示，存放的是一个地址。</p>\n<p>链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。</p>\n<p>链表中每个节点都分为两部分，一个数据域，一个是指针域。</p>\n<p>head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。</p>\n<h2 id=\"链表初始化\"><a href=\"#链表初始化\" class=\"headerlink\" title=\"链表初始化\"></a>链表初始化</h2><h4 id=\"创建链表\"><a href=\"#创建链表\" class=\"headerlink\" title=\"创建链表\"></a>创建链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">lint</span>&#123; <span class=\"hljs-comment\">//每一个节点其实就是一个结构体，将每个结构体用节点地址关联的方式，进行链接</span><br>\t<span class=\"hljs-type\">int</span> score; <span class=\"hljs-comment\">//数据域，用于存放数据的位置</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">lint</span>* next; <span class=\"hljs-comment\">//指针域，定义指向下一个节点地址的指针</span><br>&#125; LinkList;<br></code></pre></td></tr></table></figure>\n\n<p>采用typedef的方式，能够不用每次使用struct student  a，直接LinkList a的方式对a进行定义</p>\n<p>链表中有一个特殊的结点–头结点。头结点的数据域一般不用来存放和其他节点同类的数据，它的诞生是为了在实际应用过程中存放一些数据+</p>\n<p>*<strong>p代表这个地址上面的值，p代表这个地址，a[]代表这个地址上面的值，a代表这个数组的地址</strong></p>\n<h4 id=\"无头结点的初始化\"><a href=\"#无头结点的初始化\" class=\"headerlink\" title=\"无头结点的初始化\"></a>无头结点的初始化</h4><p>直接从数据节点开始，直接定义第一个数据节点的值和下一个节点的地址</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">Lint * initLint()<br>&#123;<br>    <span class=\"hljs-comment\">// 创建头指针</span><br>    Lint* p = NULL;<br>    <br>  \t<span class=\"hljs-comment\">// 创建一个临时指针初始化首元结点，并且用于移动和调整后续结点</span><br>\tLint* temp = (Lint*)malloc(sizeof(Lint));<span class=\"hljs-comment\">//创建一个结构体，并分配内存空间</span><br>  \t<span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>score = <span class=\"hljs-number\">90</span>;<span class=\"hljs-comment\">//将数据填入数据域当中</span><br>  \t<span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>next = NULL;<span class=\"hljs-comment\">//下一节点地址指向NULL</span><br>  \t<br>  \t<span class=\"hljs-comment\">// 头指针需要指向首元结点，这样才能定位这串链表的位置</span><br>  \tp = temp;<br>  \t<br>  \t<span class=\"hljs-comment\">// 手动创建10个元素</span><br>    <span class=\"hljs-keyword\">for</span>(int i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// 从第二个结点开始创建</span><br>        Lint * a = (Lint*) malloc(sizeof(Lint));<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>score = i + <span class=\"hljs-number\">91</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>next = NULL;<br>        <br>        <span class=\"hljs-comment\">// 将当前temp指向的结点的next指向下一个结点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">next</span> = a; //temp-&gt;</span>next这个的意思是在temp中有一个next地址，将他指向a的地址<br>        <br>        <span class=\"hljs-comment\">// temp移到下一个结点。这样在下次循环运行到上一行(line17)时能持续</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span> = temp-&gt;</span>next;  <span class=\"hljs-comment\">// 或 temp = a;</span><br>    &#125;<br>    return p;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"有头节点的初始化\"><a href=\"#有头节点的初始化\" class=\"headerlink\" title=\"有头节点的初始化\"></a>有头节点的初始化</h4><p>首先定义一个头结点，头结点没有数据域，只有地址域，直接赋值地址域</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">Lint * initLint()<br>&#123;<br>    <span class=\"hljs-comment\">// 创建头指针，并用其创建头结点</span><br>    Lint * p = (Lint*)malloc(sizeof (Lint));<br>    <span class=\"hljs-comment\">// 及时指定指针的指向以确保指针安全</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">p</span>-&gt;</span>next = NULL;<br>    <span class=\"hljs-comment\">// 创建一个临时的指针指向头结点以进行后续的操作</span><br>    Lint * temp = p;<br>    <span class=\"hljs-keyword\">for</span>(int i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++)&#123;<br>        <span class=\"hljs-comment\">// 从首元结点开始创建</span><br>        Lint * a = (Lint*) malloc(sizeof(Lint));<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>score = i + <span class=\"hljs-number\">90</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>next = NULL;<br>        <span class=\"hljs-comment\">// 将当前temp指向的next指向下一个结点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>next = a;<br>        <span class=\"hljs-comment\">// temp移到下一个结点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span> = temp-&gt;</span>next;  <span class=\"hljs-comment\">// 或 temp = a;</span><br>    &#125;<br>    return p;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"链表数据改变\"><a href=\"#链表数据改变\" class=\"headerlink\" title=\"链表数据改变\"></a>链表数据改变</h2><h4 id=\"输出链表\"><a href=\"#输出链表\" class=\"headerlink\" title=\"输出链表\"></a>输出链表</h4><p>输出链表其实就是在遍历结构体中的地址域，到达该地址域之后，将其打印出来，然后再跳转指向下一个地址域</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">void showLint(Lint* p)&#123;\t<br>  \t<span class=\"hljs-regexp\">//</span> 一开始p指针在头结点，这个数据域是空的，因此需要检测其指针域中是否有下一个节点的地址。如果为空，则退出循环<br>    <span class=\"hljs-keyword\">while</span> (p-&gt;<span class=\"hljs-keyword\">next</span>)&#123;<br>      \t<span class=\"hljs-regexp\">//</span> p从头结点移出，到首元结点开始输出<br>        p = p-&gt;<span class=\"hljs-keyword\">next</span>;<br>        <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">%d</span>\\t&quot;</span>, p-&gt;score);<br>    &#125;<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"增加数据\"><a href=\"#增加数据\" class=\"headerlink\" title=\"增加数据\"></a>增加数据</h4><p>增加结点的逻辑是：将新增结点的指针域指向后一个结点，然后将原链表中的前一个结点的指针域指向新增的结点。(<strong>注意顺序不能颠倒，否则会导致插入位置后面的结点全部丢失</strong>)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">Lint* <span class=\"hljs-title\">insertLint</span><span class=\"hljs-params\">(Lint* p,<span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> num)</span></span>&#123;\t\t<span class=\"hljs-comment\">// 将num插入到第n个位置</span><br>    Lint * temp = p;<br>    <span class=\"hljs-comment\">// 通过遍历将temp指针移到指向插入位置的直接前驱结点的位置</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; n;i++)&#123;<br>        <span class=\"hljs-comment\">// 防止超过链表现有长度</span><br>        <span class=\"hljs-keyword\">if</span> (temp-&gt;next == <span class=\"hljs-literal\">NULL</span>)&#123;<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;位置错误!\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">return</span> p;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class=\"hljs-comment\">// 创建插入的新结点</span><br>    Lint * a = (Lint*) <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span> (Lint));<br>    a-&gt;score = num;<br>  \t<span class=\"hljs-comment\">// 新节点数据域指向原位置后一个结点</span><br>    a-&gt;next = temp-&gt;next;<br>  \t<span class=\"hljs-comment\">// temp后移一个结点</span><br>    temp-&gt;next = a;<br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    <span class=\"hljs-type\">int</span> n, num;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入插入的位置和数字，用空格隔开:&quot;</span>);<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d%d&quot;</span>, &amp;n, &amp;num);<br>    <span class=\"hljs-built_in\">insertLint</span>(p, n, num);<br>    <span class=\"hljs-built_in\">showLint</span>(p);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><p>删除链表数据的意思其实也是先找到想要删除的地址域，从节点中一个一个往下遍历，比如想删除第五个节点，那就遍历到第四个节点，然后在第四个节点的地址域上直接指向到第五节点的地址域，这样，第五个节点的地址就在第四个节点上丢失，从而第四个节点地址域获取的就是第六个节点的地址</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">Lint* delLint(Lint* p,<span class=\"hljs-keyword\">int</span> n)&#123;<br>    Lint * temp = p;<br>    <span class=\"hljs-comment\">// 用于存储临时删除的结点</span><br>    Lint * back = <span class=\"hljs-keyword\">NULL</span>;<br>    <span class=\"hljs-comment\">// temp移到删除结点的前一个节点</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; n;i++)&#123;<br>        <span class=\"hljs-comment\">// 防止越过链表</span><br>        <span class=\"hljs-keyword\">if</span> (temp-&gt;<span class=\"hljs-keyword\">next</span> == <span class=\"hljs-keyword\">NULL</span>)&#123;<br>            printf(<span class=\"hljs-string\">&quot;位置错误!\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">return</span> p;<br>        &#125;<br>        <span class=\"hljs-comment\">//逐个跳转地址域</span><br>        temp = temp-&gt;<span class=\"hljs-keyword\">next</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 临时存储被删除结点,防止丢失</span><br>    back = temp-&gt;<span class=\"hljs-keyword\">next</span>;<br>  \t<span class=\"hljs-comment\">// 指向下下个结点</span><br>    temp-&gt;<span class=\"hljs-keyword\">next</span> = temp-&gt;<span class=\"hljs-keyword\">next</span>-&gt;<span class=\"hljs-keyword\">next</span>;<br>    <span class=\"hljs-comment\">// 手动释放内存防止泄露</span><br>    free(back);<br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    printf(<span class=\"hljs-string\">&quot;请输入删除第几个元素:&quot;</span>);<br>    scanf(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;n);<br>    delLint(p, n);<br>    showLint(p);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h4><p>修改数据其实跟上面的一样，指到这个数据域之后，直接对其数据进行修改即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">Lint* <span class=\"hljs-title\">changeLint</span><span class=\"hljs-params\">(Lint* p,<span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> num)</span></span>&#123;  \t<br>\t<span class=\"hljs-comment\">// temp可以一开始就指向首元结点    </span><br>\tLint * temp = p-&gt;next;    <br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; n;i++)&#123;        <br>\t<span class=\"hljs-comment\">// 防止越过链表        </span><br>\t\t<span class=\"hljs-keyword\">if</span> (temp-&gt;next == <span class=\"hljs-literal\">NULL</span>)&#123;            <br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;位置错误!\\n&quot;</span>);            <br>\t\t\t<span class=\"hljs-keyword\">return</span> p;        <br>\t\t&#125;        <br>\t\ttemp = temp-&gt;next;    <br>\t&#125;    <br>\t<span class=\"hljs-comment\">// 修改    </span><br>\ttemp-&gt;score = num;    <br>\t<span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入修改第几个元素为什么数,空格隔开:&quot;</span>);<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d%d&quot;</span>, &amp;n, &amp;num);<br>    <span class=\"hljs-built_in\">changeLint</span>(p, n, num);<br>    <span class=\"hljs-built_in\">showLint</span>(p);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h4><p>查的基本思想是指针进行遍历链表，对每个节点的数据域进行对比，如果相同就可以直接退出返回结果了。如果一直到链表结束还没有匹配成功就说明没有找到。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">searchLint</span><span class=\"hljs-params\">(Lint* p, <span class=\"hljs-type\">int</span> num)</span></span>&#123;<br>    Lint * temp = p;<br>    <span class=\"hljs-type\">int</span> i;  <span class=\"hljs-comment\">// 用于记数</span><br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>;temp-&gt;next != <span class=\"hljs-literal\">NULL</span>;i++)&#123;<br>      \t<span class=\"hljs-comment\">// 因为是从头结点开始的，因此要先移到首元结点</span><br>        temp = temp-&gt;next;<br>        <span class=\"hljs-keyword\">if</span> (temp-&gt;score == num)<span class=\"hljs-keyword\">return</span> i;\t<span class=\"hljs-comment\">// 返回i表示找到的位置</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\t<span class=\"hljs-comment\">// 返回0表示未找到</span><br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入需要查询的分数:&quot;</span>);<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;num);<br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">searchLint</span>(p, num))<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;未查询到该分数&quot;</span>);<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;在第%d个元素&quot;</span>, <span class=\"hljs-built_in\">searchLint</span>(p, num));<br></code></pre></td></tr></table></figure>\n\n<p>如果你的头结点直接在数据域上面标记是1，那可以直接利用数据域的数据进行查找数据</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">int searchLint(Lint* p, int num)&#123;<br>    Lint * temp = p;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">for</span>(p-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">score</span> = 1;temp-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">next</span> != NULL;p-&gt;</span>score++)&#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span> = temp-&gt;</span>next;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">score</span> == num)return p-&gt;</span>score;<br>    &#125;<br>    return <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"项目实践总结\"><a href=\"#项目实践总结\" class=\"headerlink\" title=\"项目实践总结\"></a>项目实践总结</h2><p>链表的使用主要分为5个部分</p>\n<p>1.创建数据结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 消息结构体定义</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MsgSend</span> &#123;<br>    <span class=\"hljs-type\">char</span> *cmdStr;       <span class=\"hljs-comment\">// 发送命令，实际的命令存储区</span><br>    <span class=\"hljs-type\">uint32_t</span> cmdLen;    <span class=\"hljs-comment\">// 命令长度，该命令长度</span><br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">list_head</span> node; <span class=\"hljs-comment\">//链表节点定义</span><br>&#125;MsgSend_t;<br></code></pre></td></tr></table></figure>\n\n<p>2.创建链表头定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 定义链表头结点</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">list_head</span> External_List;<br></code></pre></td></tr></table></figure>\n\n<p>3.链表初始化</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 初始化链表头</span><br><span class=\"hljs-built_in\">INIT_LIST_HEAD</span>(&amp;External_List);<br></code></pre></td></tr></table></figure>\n\n<p>4.创建互斥锁或读写锁</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">pthread_rwlock_t</span> Ext_rwLock; <span class=\"hljs-comment\">// 声明一个读写锁</span><br></code></pre></td></tr></table></figure>\n\n<p>5.打开互斥锁或读写锁遍历链表（增删改查）</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//计算链表长度</span><br>\t<br>\t<span class=\"hljs-comment\">// 读写锁</span><br>    pthread_rwlock_rdlock(&amp;Ext_rwLock);<br>    <span class=\"hljs-comment\">// 遍历链表</span><br>    list_for_each(list_temp, &amp;External_List)<br>    &#123;<br>        <span class=\"hljs-comment\">// 每遍历一个加数值</span><br>        list_len++;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 删除所有节点</span><br>    <br>    <span class=\"hljs-comment\">// 链表读写锁</span><br>    pthread_rwlock_wrlock(&amp;Ext_rwLock);<br>    <span class=\"hljs-comment\">// 遍历链表并安全删除节点</span><br>    list_for_each_entry_safe(temp, next, &amp;External_List, node)<br>    &#123;<br>        <span class=\"hljs-comment\">// 当前节点存在数据，则清空数据</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span>cmdStr != NULL)<br>        &#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">free</span>(temp-&gt;</span>cmdStr); <span class=\"hljs-comment\">// 释放 cmdStr 指针</span><br>            <span class=\"hljs-comment\">// 再次指向空值，防止清空失败</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>cmdStr = NULL;<br>        &#125;<br>        <span class=\"hljs-comment\">// 从链表中删除节点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">list_del_init</span>(&amp;temp-&gt;</span>node);<br>        <span class=\"hljs-comment\">// 链表节点不为空</span><br>        <span class=\"hljs-keyword\">if</span> (temp != NULL)<br>        &#123;<br>            free(temp);  <span class=\"hljs-comment\">// 释放节点</span><br>            temp = NULL; <span class=\"hljs-comment\">// 释放后置为NULL，防止野指针</span><br>        &#125;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 删除所有节点</span><br><br>\t<span class=\"hljs-comment\">// 链表读写锁</span><br>    pthread_rwlock_wrlock(&amp;Ext_rwLock);<br>    <span class=\"hljs-comment\">// 遍历链表并安全删除节点</span><br>    list_for_each_entry_safe(temp, next, &amp;External_List, node)<br>    &#123;<br>        <span class=\"hljs-comment\">// 寻找链表ID和要删除的ID一致的链表，ID是唯一的</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">cmdId</span> == deletelist-&gt;</span>cmdId)<br>        &#123;<br>            <span class=\"hljs-comment\">// 从链表中删除节点</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">list_del_init</span>(&amp;temp-&gt;</span>node);<br>            <span class=\"hljs-comment\">// 当前节点存在数据，则清空数据</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span>cmdStr != NULL)<br>            &#123;<br>                <span class=\"hljs-function\"><span class=\"hljs-title\">free</span>(temp-&gt;</span>cmdStr);  <span class=\"hljs-comment\">// 释放节点</span><br>                <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>cmdStr = NULL; <span class=\"hljs-comment\">// 释放后置为NULL，防止野指针</span><br>            &#125;<br>            <span class=\"hljs-comment\">// 链表节点不为空</span><br>            <span class=\"hljs-keyword\">if</span> (temp != NULL)<br>            &#123;<br>                free(temp);  <span class=\"hljs-comment\">// 释放节点</span><br>                temp = NULL; <span class=\"hljs-comment\">// 释放后置为NULL，防止野指针</span><br>            &#125;<br>            break; <span class=\"hljs-comment\">// 完成清除后直接退出链表</span><br>        &#125;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 复制链表到链表</span><br><br>\t<span class=\"hljs-comment\">// 定义临时节点，用于获取链表数据</span><br>\tExtMsgSend_t *temp = NULL, *snext = NULL;<br>\t<span class=\"hljs-comment\">// 链表读写锁</span><br>\tpthread_rwlock_wrlock(&amp;Ext_rwLock);<br>\t<span class=\"hljs-comment\">// 遍历列表和ID值进行比对</span><br>    list_for_each_entry_safe(temp, snext, &amp;External_List, node)<br>    &#123;<br>    \t<span class=\"hljs-comment\">// 找到ID值</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span>cmdId == id)<br>        &#123;<br>            <span class=\"hljs-comment\">// 将所有链表值复制到Send_List链表中</span><br>            memcpy(Send_List, temp, sizeof(ExtMsgSend_t));<br>            <span class=\"hljs-comment\">// 退出遍历</span><br>            break;<br>        &#125;<br>    \t<span class=\"hljs-keyword\">else</span><br>    \t&#123;<br>            <span class=\"hljs-comment\">// 如果不是则进行提示</span><br>            LogW(<span class=\"hljs-string\">&quot;APP recvjson cmdId is unable to match\\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 写入链表</span><br><br>\tpthread_rwlock_wrlock(&amp;Ext_rwLock);              <span class=\"hljs-comment\">// 上锁</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">list_add_tail</span>(&amp;ExMsgSend-&gt;</span>node, &amp;External_List); <span class=\"hljs-comment\">// 写入</span><br>    pthread_rwlock_unlock(&amp;Ext_rwLock);              <span class=\"hljs-comment\">// 解锁</span><br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"C语言链表学习\"><a href=\"#C语言链表学习\" class=\"headerlink\" title=\"C语言链表学习\"></a>C语言链表学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/qq_35664104/article/details/120769681\">数据结构–链表入门超详细解析(简单易懂纯原篇)_链表教学-CSDN博客</a></p>\n<h2 id=\"链表基础知识\"><a href=\"#链表基础知识\" class=\"headerlink\" title=\"链表基础知识\"></a>链表基础知识</h2><p>链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点</p>\n<p>链表都有一个头指针，一般以head来表示，存放的是一个地址。</p>\n<p>链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。</p>\n<p>链表中每个节点都分为两部分，一个数据域，一个是指针域。</p>\n<p>head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。</p>\n<h2 id=\"链表初始化\"><a href=\"#链表初始化\" class=\"headerlink\" title=\"链表初始化\"></a>链表初始化</h2><h4 id=\"创建链表\"><a href=\"#创建链表\" class=\"headerlink\" title=\"创建链表\"></a>创建链表</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">lint</span>&#123; <span class=\"hljs-comment\">//每一个节点其实就是一个结构体，将每个结构体用节点地址关联的方式，进行链接</span><br>\t<span class=\"hljs-type\">int</span> score; <span class=\"hljs-comment\">//数据域，用于存放数据的位置</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">lint</span>* next; <span class=\"hljs-comment\">//指针域，定义指向下一个节点地址的指针</span><br>&#125; LinkList;<br></code></pre></td></tr></table></figure>\n\n<p>采用typedef的方式，能够不用每次使用struct student  a，直接LinkList a的方式对a进行定义</p>\n<p>链表中有一个特殊的结点–头结点。头结点的数据域一般不用来存放和其他节点同类的数据，它的诞生是为了在实际应用过程中存放一些数据+</p>\n<p>*<strong>p代表这个地址上面的值，p代表这个地址，a[]代表这个地址上面的值，a代表这个数组的地址</strong></p>\n<h4 id=\"无头结点的初始化\"><a href=\"#无头结点的初始化\" class=\"headerlink\" title=\"无头结点的初始化\"></a>无头结点的初始化</h4><p>直接从数据节点开始，直接定义第一个数据节点的值和下一个节点的地址</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">Lint * initLint()<br>&#123;<br>    <span class=\"hljs-comment\">// 创建头指针</span><br>    Lint* p = NULL;<br>    <br>  \t<span class=\"hljs-comment\">// 创建一个临时指针初始化首元结点，并且用于移动和调整后续结点</span><br>\tLint* temp = (Lint*)malloc(sizeof(Lint));<span class=\"hljs-comment\">//创建一个结构体，并分配内存空间</span><br>  \t<span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>score = <span class=\"hljs-number\">90</span>;<span class=\"hljs-comment\">//将数据填入数据域当中</span><br>  \t<span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>next = NULL;<span class=\"hljs-comment\">//下一节点地址指向NULL</span><br>  \t<br>  \t<span class=\"hljs-comment\">// 头指针需要指向首元结点，这样才能定位这串链表的位置</span><br>  \tp = temp;<br>  \t<br>  \t<span class=\"hljs-comment\">// 手动创建10个元素</span><br>    <span class=\"hljs-keyword\">for</span>(int i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// 从第二个结点开始创建</span><br>        Lint * a = (Lint*) malloc(sizeof(Lint));<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>score = i + <span class=\"hljs-number\">91</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>next = NULL;<br>        <br>        <span class=\"hljs-comment\">// 将当前temp指向的结点的next指向下一个结点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">next</span> = a; //temp-&gt;</span>next这个的意思是在temp中有一个next地址，将他指向a的地址<br>        <br>        <span class=\"hljs-comment\">// temp移到下一个结点。这样在下次循环运行到上一行(line17)时能持续</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span> = temp-&gt;</span>next;  <span class=\"hljs-comment\">// 或 temp = a;</span><br>    &#125;<br>    return p;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"有头节点的初始化\"><a href=\"#有头节点的初始化\" class=\"headerlink\" title=\"有头节点的初始化\"></a>有头节点的初始化</h4><p>首先定义一个头结点，头结点没有数据域，只有地址域，直接赋值地址域</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">Lint * initLint()<br>&#123;<br>    <span class=\"hljs-comment\">// 创建头指针，并用其创建头结点</span><br>    Lint * p = (Lint*)malloc(sizeof (Lint));<br>    <span class=\"hljs-comment\">// 及时指定指针的指向以确保指针安全</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">p</span>-&gt;</span>next = NULL;<br>    <span class=\"hljs-comment\">// 创建一个临时的指针指向头结点以进行后续的操作</span><br>    Lint * temp = p;<br>    <span class=\"hljs-keyword\">for</span>(int i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++)&#123;<br>        <span class=\"hljs-comment\">// 从首元结点开始创建</span><br>        Lint * a = (Lint*) malloc(sizeof(Lint));<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>score = i + <span class=\"hljs-number\">90</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">a</span>-&gt;</span>next = NULL;<br>        <span class=\"hljs-comment\">// 将当前temp指向的next指向下一个结点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>next = a;<br>        <span class=\"hljs-comment\">// temp移到下一个结点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span> = temp-&gt;</span>next;  <span class=\"hljs-comment\">// 或 temp = a;</span><br>    &#125;<br>    return p;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"链表数据改变\"><a href=\"#链表数据改变\" class=\"headerlink\" title=\"链表数据改变\"></a>链表数据改变</h2><h4 id=\"输出链表\"><a href=\"#输出链表\" class=\"headerlink\" title=\"输出链表\"></a>输出链表</h4><p>输出链表其实就是在遍历结构体中的地址域，到达该地址域之后，将其打印出来，然后再跳转指向下一个地址域</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">void showLint(Lint* p)&#123;\t<br>  \t<span class=\"hljs-regexp\">//</span> 一开始p指针在头结点，这个数据域是空的，因此需要检测其指针域中是否有下一个节点的地址。如果为空，则退出循环<br>    <span class=\"hljs-keyword\">while</span> (p-&gt;<span class=\"hljs-keyword\">next</span>)&#123;<br>      \t<span class=\"hljs-regexp\">//</span> p从头结点移出，到首元结点开始输出<br>        p = p-&gt;<span class=\"hljs-keyword\">next</span>;<br>        <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">%d</span>\\t&quot;</span>, p-&gt;score);<br>    &#125;<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"增加数据\"><a href=\"#增加数据\" class=\"headerlink\" title=\"增加数据\"></a>增加数据</h4><p>增加结点的逻辑是：将新增结点的指针域指向后一个结点，然后将原链表中的前一个结点的指针域指向新增的结点。(<strong>注意顺序不能颠倒，否则会导致插入位置后面的结点全部丢失</strong>)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">Lint* <span class=\"hljs-title\">insertLint</span><span class=\"hljs-params\">(Lint* p,<span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> num)</span></span>&#123;\t\t<span class=\"hljs-comment\">// 将num插入到第n个位置</span><br>    Lint * temp = p;<br>    <span class=\"hljs-comment\">// 通过遍历将temp指针移到指向插入位置的直接前驱结点的位置</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; n;i++)&#123;<br>        <span class=\"hljs-comment\">// 防止超过链表现有长度</span><br>        <span class=\"hljs-keyword\">if</span> (temp-&gt;next == <span class=\"hljs-literal\">NULL</span>)&#123;<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;位置错误!\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">return</span> p;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class=\"hljs-comment\">// 创建插入的新结点</span><br>    Lint * a = (Lint*) <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span> (Lint));<br>    a-&gt;score = num;<br>  \t<span class=\"hljs-comment\">// 新节点数据域指向原位置后一个结点</span><br>    a-&gt;next = temp-&gt;next;<br>  \t<span class=\"hljs-comment\">// temp后移一个结点</span><br>    temp-&gt;next = a;<br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    <span class=\"hljs-type\">int</span> n, num;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入插入的位置和数字，用空格隔开:&quot;</span>);<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d%d&quot;</span>, &amp;n, &amp;num);<br>    <span class=\"hljs-built_in\">insertLint</span>(p, n, num);<br>    <span class=\"hljs-built_in\">showLint</span>(p);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><p>删除链表数据的意思其实也是先找到想要删除的地址域，从节点中一个一个往下遍历，比如想删除第五个节点，那就遍历到第四个节点，然后在第四个节点的地址域上直接指向到第五节点的地址域，这样，第五个节点的地址就在第四个节点上丢失，从而第四个节点地址域获取的就是第六个节点的地址</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">Lint* delLint(Lint* p,<span class=\"hljs-keyword\">int</span> n)&#123;<br>    Lint * temp = p;<br>    <span class=\"hljs-comment\">// 用于存储临时删除的结点</span><br>    Lint * back = <span class=\"hljs-keyword\">NULL</span>;<br>    <span class=\"hljs-comment\">// temp移到删除结点的前一个节点</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; n;i++)&#123;<br>        <span class=\"hljs-comment\">// 防止越过链表</span><br>        <span class=\"hljs-keyword\">if</span> (temp-&gt;<span class=\"hljs-keyword\">next</span> == <span class=\"hljs-keyword\">NULL</span>)&#123;<br>            printf(<span class=\"hljs-string\">&quot;位置错误!\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">return</span> p;<br>        &#125;<br>        <span class=\"hljs-comment\">//逐个跳转地址域</span><br>        temp = temp-&gt;<span class=\"hljs-keyword\">next</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 临时存储被删除结点,防止丢失</span><br>    back = temp-&gt;<span class=\"hljs-keyword\">next</span>;<br>  \t<span class=\"hljs-comment\">// 指向下下个结点</span><br>    temp-&gt;<span class=\"hljs-keyword\">next</span> = temp-&gt;<span class=\"hljs-keyword\">next</span>-&gt;<span class=\"hljs-keyword\">next</span>;<br>    <span class=\"hljs-comment\">// 手动释放内存防止泄露</span><br>    free(back);<br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    printf(<span class=\"hljs-string\">&quot;请输入删除第几个元素:&quot;</span>);<br>    scanf(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;n);<br>    delLint(p, n);<br>    showLint(p);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h4><p>修改数据其实跟上面的一样，指到这个数据域之后，直接对其数据进行修改即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">Lint* <span class=\"hljs-title\">changeLint</span><span class=\"hljs-params\">(Lint* p,<span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> num)</span></span>&#123;  \t<br>\t<span class=\"hljs-comment\">// temp可以一开始就指向首元结点    </span><br>\tLint * temp = p-&gt;next;    <br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; n;i++)&#123;        <br>\t<span class=\"hljs-comment\">// 防止越过链表        </span><br>\t\t<span class=\"hljs-keyword\">if</span> (temp-&gt;next == <span class=\"hljs-literal\">NULL</span>)&#123;            <br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;位置错误!\\n&quot;</span>);            <br>\t\t\t<span class=\"hljs-keyword\">return</span> p;        <br>\t\t&#125;        <br>\t\ttemp = temp-&gt;next;    <br>\t&#125;    <br>\t<span class=\"hljs-comment\">// 修改    </span><br>\ttemp-&gt;score = num;    <br>\t<span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入修改第几个元素为什么数,空格隔开:&quot;</span>);<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d%d&quot;</span>, &amp;n, &amp;num);<br>    <span class=\"hljs-built_in\">changeLint</span>(p, n, num);<br>    <span class=\"hljs-built_in\">showLint</span>(p);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h4><p>查的基本思想是指针进行遍历链表，对每个节点的数据域进行对比，如果相同就可以直接退出返回结果了。如果一直到链表结束还没有匹配成功就说明没有找到。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">searchLint</span><span class=\"hljs-params\">(Lint* p, <span class=\"hljs-type\">int</span> num)</span></span>&#123;<br>    Lint * temp = p;<br>    <span class=\"hljs-type\">int</span> i;  <span class=\"hljs-comment\">// 用于记数</span><br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>;temp-&gt;next != <span class=\"hljs-literal\">NULL</span>;i++)&#123;<br>      \t<span class=\"hljs-comment\">// 因为是从头结点开始的，因此要先移到首元结点</span><br>        temp = temp-&gt;next;<br>        <span class=\"hljs-keyword\">if</span> (temp-&gt;score == num)<span class=\"hljs-keyword\">return</span> i;\t<span class=\"hljs-comment\">// 返回i表示找到的位置</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\t<span class=\"hljs-comment\">// 返回0表示未找到</span><br>&#125;<br><br><span class=\"hljs-comment\">//main函数输出</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;请输入需要查询的分数:&quot;</span>);<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;num);<br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">searchLint</span>(p, num))<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;未查询到该分数&quot;</span>);<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;在第%d个元素&quot;</span>, <span class=\"hljs-built_in\">searchLint</span>(p, num));<br></code></pre></td></tr></table></figure>\n\n<p>如果你的头结点直接在数据域上面标记是1，那可以直接利用数据域的数据进行查找数据</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">int searchLint(Lint* p, int num)&#123;<br>    Lint * temp = p;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">for</span>(p-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">score</span> = 1;temp-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">next</span> != NULL;p-&gt;</span>score++)&#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span> = temp-&gt;</span>next;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">score</span> == num)return p-&gt;</span>score;<br>    &#125;<br>    return <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"项目实践总结\"><a href=\"#项目实践总结\" class=\"headerlink\" title=\"项目实践总结\"></a>项目实践总结</h2><p>链表的使用主要分为5个部分</p>\n<p>1.创建数据结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 消息结构体定义</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MsgSend</span> &#123;<br>    <span class=\"hljs-type\">char</span> *cmdStr;       <span class=\"hljs-comment\">// 发送命令，实际的命令存储区</span><br>    <span class=\"hljs-type\">uint32_t</span> cmdLen;    <span class=\"hljs-comment\">// 命令长度，该命令长度</span><br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">list_head</span> node; <span class=\"hljs-comment\">//链表节点定义</span><br>&#125;MsgSend_t;<br></code></pre></td></tr></table></figure>\n\n<p>2.创建链表头定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 定义链表头结点</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">list_head</span> External_List;<br></code></pre></td></tr></table></figure>\n\n<p>3.链表初始化</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 初始化链表头</span><br><span class=\"hljs-built_in\">INIT_LIST_HEAD</span>(&amp;External_List);<br></code></pre></td></tr></table></figure>\n\n<p>4.创建互斥锁或读写锁</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">pthread_rwlock_t</span> Ext_rwLock; <span class=\"hljs-comment\">// 声明一个读写锁</span><br></code></pre></td></tr></table></figure>\n\n<p>5.打开互斥锁或读写锁遍历链表（增删改查）</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//计算链表长度</span><br>\t<br>\t<span class=\"hljs-comment\">// 读写锁</span><br>    pthread_rwlock_rdlock(&amp;Ext_rwLock);<br>    <span class=\"hljs-comment\">// 遍历链表</span><br>    list_for_each(list_temp, &amp;External_List)<br>    &#123;<br>        <span class=\"hljs-comment\">// 每遍历一个加数值</span><br>        list_len++;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 删除所有节点</span><br>    <br>    <span class=\"hljs-comment\">// 链表读写锁</span><br>    pthread_rwlock_wrlock(&amp;Ext_rwLock);<br>    <span class=\"hljs-comment\">// 遍历链表并安全删除节点</span><br>    list_for_each_entry_safe(temp, next, &amp;External_List, node)<br>    &#123;<br>        <span class=\"hljs-comment\">// 当前节点存在数据，则清空数据</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span>cmdStr != NULL)<br>        &#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">free</span>(temp-&gt;</span>cmdStr); <span class=\"hljs-comment\">// 释放 cmdStr 指针</span><br>            <span class=\"hljs-comment\">// 再次指向空值，防止清空失败</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>cmdStr = NULL;<br>        &#125;<br>        <span class=\"hljs-comment\">// 从链表中删除节点</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">list_del_init</span>(&amp;temp-&gt;</span>node);<br>        <span class=\"hljs-comment\">// 链表节点不为空</span><br>        <span class=\"hljs-keyword\">if</span> (temp != NULL)<br>        &#123;<br>            free(temp);  <span class=\"hljs-comment\">// 释放节点</span><br>            temp = NULL; <span class=\"hljs-comment\">// 释放后置为NULL，防止野指针</span><br>        &#125;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 删除所有节点</span><br><br>\t<span class=\"hljs-comment\">// 链表读写锁</span><br>    pthread_rwlock_wrlock(&amp;Ext_rwLock);<br>    <span class=\"hljs-comment\">// 遍历链表并安全删除节点</span><br>    list_for_each_entry_safe(temp, next, &amp;External_List, node)<br>    &#123;<br>        <span class=\"hljs-comment\">// 寻找链表ID和要删除的ID一致的链表，ID是唯一的</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">cmdId</span> == deletelist-&gt;</span>cmdId)<br>        &#123;<br>            <span class=\"hljs-comment\">// 从链表中删除节点</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">list_del_init</span>(&amp;temp-&gt;</span>node);<br>            <span class=\"hljs-comment\">// 当前节点存在数据，则清空数据</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span>cmdStr != NULL)<br>            &#123;<br>                <span class=\"hljs-function\"><span class=\"hljs-title\">free</span>(temp-&gt;</span>cmdStr);  <span class=\"hljs-comment\">// 释放节点</span><br>                <span class=\"hljs-function\"><span class=\"hljs-title\">temp</span>-&gt;</span>cmdStr = NULL; <span class=\"hljs-comment\">// 释放后置为NULL，防止野指针</span><br>            &#125;<br>            <span class=\"hljs-comment\">// 链表节点不为空</span><br>            <span class=\"hljs-keyword\">if</span> (temp != NULL)<br>            &#123;<br>                free(temp);  <span class=\"hljs-comment\">// 释放节点</span><br>                temp = NULL; <span class=\"hljs-comment\">// 释放后置为NULL，防止野指针</span><br>            &#125;<br>            break; <span class=\"hljs-comment\">// 完成清除后直接退出链表</span><br>        &#125;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 复制链表到链表</span><br><br>\t<span class=\"hljs-comment\">// 定义临时节点，用于获取链表数据</span><br>\tExtMsgSend_t *temp = NULL, *snext = NULL;<br>\t<span class=\"hljs-comment\">// 链表读写锁</span><br>\tpthread_rwlock_wrlock(&amp;Ext_rwLock);<br>\t<span class=\"hljs-comment\">// 遍历列表和ID值进行比对</span><br>    list_for_each_entry_safe(temp, snext, &amp;External_List, node)<br>    &#123;<br>    \t<span class=\"hljs-comment\">// 找到ID值</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (temp-&gt;</span>cmdId == id)<br>        &#123;<br>            <span class=\"hljs-comment\">// 将所有链表值复制到Send_List链表中</span><br>            memcpy(Send_List, temp, sizeof(ExtMsgSend_t));<br>            <span class=\"hljs-comment\">// 退出遍历</span><br>            break;<br>        &#125;<br>    \t<span class=\"hljs-keyword\">else</span><br>    \t&#123;<br>            <span class=\"hljs-comment\">// 如果不是则进行提示</span><br>            LogW(<span class=\"hljs-string\">&quot;APP recvjson cmdId is unable to match\\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    pthread_rwlock_unlock(&amp;Ext_rwLock);<br>    <br><span class=\"hljs-comment\">// 写入链表</span><br><br>\tpthread_rwlock_wrlock(&amp;Ext_rwLock);              <span class=\"hljs-comment\">// 上锁</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">list_add_tail</span>(&amp;ExMsgSend-&gt;</span>node, &amp;External_List); <span class=\"hljs-comment\">// 写入</span><br>    pthread_rwlock_unlock(&amp;Ext_rwLock);              <span class=\"hljs-comment\">// 解锁</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"STM32的USART发送测试","date":"2024-07-29T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/ZmH82tMfGquLPEF.jpg","_content":"\n# STM32的USART发送测试\n\n### 通信的基本知识\n\n串行通信：串行是一次性发一个数据过去，所以一般就两根线，一个收一个发，传输距离远，抗干扰能力强，例如UART、IIC、SPI…\n\n并行通信：并行是一次性发多个数据，多根线同时发，传输速度快，但是抗干扰能力弱，传输距离短，例如SDIO(4根线)、FSMC(8根线)…\n\n全双工：可以同时收发数据\n\n半双工：不可以同时收发数据，需要收完再发或者发完再收\n\n单工：只能进行收或者发数据，无法同时进行\n\n同步传输：同步是有时钟信号的，只有时钟使能的时候，信号才有用，但是对时钟要求高，时钟的方波不能有尖峰等\n\n异步传输：有通讯起始位、通讯内容主题、数据校验位、通信停止位\n\n比特率：每秒钟传输二进制位数，bit/s\n\n波特率：每秒钟传输码元个数\n\n码元：要传输的信息\n\nRS232：+15V传输0，-15V传输1，需要DB9接口，使用电平转换芯片，用于工业设备的直接通信，能够利用高电平防止静电干扰\n\n### USART串口初始化配置\n\nUSART_TX：发送数据输出引脚 \n\nUSART_RX：接收数据输入引脚\n\nUSART通常只能收发8位以内数据，最大为9位，第 9 位数据是否有效要取决于 USART控制寄存器 1(USART_CR1) 的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M 位为 1 表示 9位数据字长\n\n接下来是代码的编写，步骤为打开GPIO、USART1的时钟、GPIO口初始化、GPIO_USART初始化、串口中断优先级配置、中断串口使能、串口使能\n\n#### 初始化GPIO和GPIO_USART\n\n这里面基本逻辑跟GPIO的设置几乎一样，要注意的是TX串口的模式要改成复用推挽输出，因为他需要做推挽输出，还要配置USART，所以不能简单的设置为推挽输出\n\nRX串口要设置成浮空输入模式，因为不能上升沿或者下降沿，因为会产生错误信号，导致数据错乱\n\n```\n\tGPIO_InitTypeDef GPIO_InitStructure;  //初始化GPIO结构体\n\tUSART_InitTypeDef USART_InitStructure;  //初始化USART结构体\n\t\n\t//打开GPIOA的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n\t//打开USART的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\t\n\t//初始化TX的GPIO口\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  //定义TX引脚\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //设置输出模式为复用推挽输出\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //设置速度为50MHz\n\tGPIO_Init(GPIOA,&GPIO_InitStructure);  //将结构体进行定义\n\t\n\t//初始化RX的GPIO口\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;  //定义RX引脚\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //设置输入模式位浮空输入\n\tGPIO_Init(GPIOA,&GPIO_InitStructure);  //将结构体进行定义\n```\n\n#### 配置USART\n\n波特率是码元的个数，而不是位数，其他配置可以随便调，但是要注意串口调试助手需要相对应配置\n\n校验位用于对数据正确进行校验，通常是需要的，但是数据较少就无所谓了\n\n```\n\tUSART_InitStructure.USART_BaudRate = 115200;  //配置串口的波特率\n\tUSART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  //配置硬件流控制\n\tUSART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  //配置为全双工模式，可同时收发\n\tUSART_InitStructure.USART_StopBits = USART_StopBits_1;  //设置停止位为1位\n\tUSART_InitStructure.USART_Parity = USART_Parity_No;  //设置校验位不打开\n\tUSART_InitStructure.USART_WordLength =USART_WordLength_8b;  //设置数据长度为8位\n\tUSART_Init(USART1, &USART_InitStructure);  //将结构体进行定义\n\t\n\t// 使能串口\n\tUSART_Cmd(USART1, ENABLE);\t\n```\n\n### USART串口发送数据\n\n#### 发送8位数据\n\n直接调用固件库函数，然后使用TXE标志位进行判断是否完成发送\n\n```\nvoid Usart_SendByte(USART_TypeDef* pUSARTx, uint8_t data)\n{\n\t//使用发送函数对字节进行发送\n\tUSART_SendData(pUSARTx, data);\n\t\n\t//定义循环函数，不断检测TXE位是否为SET，如果为SET则退出循环，完成单次传输\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET );\n}\n```\n\n#### 发送16位数据\n\n由于USART只能发送8位数据，所以需要把数据拆成两个8位进行发送，然后发送两次，在接收端可以写函数进行拼接，依旧是使用TXE标志位进行判断是否完成发送，TXE标志位只能判断单次发送情况，所以需要发送一次判断一次\n\n```\n//发送16位数据\nvoid Usart_SendDoubleByte(USART_TypeDef* pUSARTx, uint16_t data)\n{\n\t//采用高八位第八位分开发送的方式\n\tuint8_t temp_h,temp_l;\n\t\n\t//使用发送函数对字节进行发送\n\ttemp_h = (data&0xff00) >> 8;//先对数据取值高八位，然后进行偏移\n\ttemp_l = data&(0xff);//直接发送低八位\n\t\n\t//使用发送函数对字节进行发送，并利用TXE标志位进行判断\n\tUSART_SendData(pUSARTx, temp_h);\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET );\n\tUSART_SendData(pUSARTx, temp_l);\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET );\n}\n```\n\n#### 发送字符串\n\n需要有数组和指针的概念，直接用指针依次指向每一字节数据，每一字节数据代表8位，依次发送每一字节的数据\n\n这里需要注意的是要采用TC标志位，因为TXE需要每发送一次判断一次，而TC针对大量数据发送结束后，单次判断即可\n\n```\n//发送字符串\nvoid Usart_SendStr(USART_TypeDef* pUSARTx, uint8_t *str)\n{\n\t//定义初始值\n\tuint8_t i=0;\n\t//对数组指针进行循环判断\n\tdo\n  {\n\t\t//单次发送数组的1字节\n\t\tUsart_SendByte(pUSARTx, *(str+i));\n\t\t//发送完对指向下一字节\n\t\ti++;\n\t}while(*(str+i) != '\\0');//判断如果是空行符则退出循环，代表数组的最后一位结束\n\t\n\t//连续发送多个数据的需要采用TC标志位进行判断\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET );\n}\n```\n\n","source":"_posts/STM32的USART发送测试.md","raw":"---\ntitle: STM32的USART发送测试\ntag: USART\ndate: 2024-07-30\ncategories: STM32\nindex_img: https://s2.loli.net/2024/07/31/ZmH82tMfGquLPEF.jpg\n---\n\n# STM32的USART发送测试\n\n### 通信的基本知识\n\n串行通信：串行是一次性发一个数据过去，所以一般就两根线，一个收一个发，传输距离远，抗干扰能力强，例如UART、IIC、SPI…\n\n并行通信：并行是一次性发多个数据，多根线同时发，传输速度快，但是抗干扰能力弱，传输距离短，例如SDIO(4根线)、FSMC(8根线)…\n\n全双工：可以同时收发数据\n\n半双工：不可以同时收发数据，需要收完再发或者发完再收\n\n单工：只能进行收或者发数据，无法同时进行\n\n同步传输：同步是有时钟信号的，只有时钟使能的时候，信号才有用，但是对时钟要求高，时钟的方波不能有尖峰等\n\n异步传输：有通讯起始位、通讯内容主题、数据校验位、通信停止位\n\n比特率：每秒钟传输二进制位数，bit/s\n\n波特率：每秒钟传输码元个数\n\n码元：要传输的信息\n\nRS232：+15V传输0，-15V传输1，需要DB9接口，使用电平转换芯片，用于工业设备的直接通信，能够利用高电平防止静电干扰\n\n### USART串口初始化配置\n\nUSART_TX：发送数据输出引脚 \n\nUSART_RX：接收数据输入引脚\n\nUSART通常只能收发8位以内数据，最大为9位，第 9 位数据是否有效要取决于 USART控制寄存器 1(USART_CR1) 的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M 位为 1 表示 9位数据字长\n\n接下来是代码的编写，步骤为打开GPIO、USART1的时钟、GPIO口初始化、GPIO_USART初始化、串口中断优先级配置、中断串口使能、串口使能\n\n#### 初始化GPIO和GPIO_USART\n\n这里面基本逻辑跟GPIO的设置几乎一样，要注意的是TX串口的模式要改成复用推挽输出，因为他需要做推挽输出，还要配置USART，所以不能简单的设置为推挽输出\n\nRX串口要设置成浮空输入模式，因为不能上升沿或者下降沿，因为会产生错误信号，导致数据错乱\n\n```\n\tGPIO_InitTypeDef GPIO_InitStructure;  //初始化GPIO结构体\n\tUSART_InitTypeDef USART_InitStructure;  //初始化USART结构体\n\t\n\t//打开GPIOA的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n\t//打开USART的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\t\n\t//初始化TX的GPIO口\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  //定义TX引脚\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //设置输出模式为复用推挽输出\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //设置速度为50MHz\n\tGPIO_Init(GPIOA,&GPIO_InitStructure);  //将结构体进行定义\n\t\n\t//初始化RX的GPIO口\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;  //定义RX引脚\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //设置输入模式位浮空输入\n\tGPIO_Init(GPIOA,&GPIO_InitStructure);  //将结构体进行定义\n```\n\n#### 配置USART\n\n波特率是码元的个数，而不是位数，其他配置可以随便调，但是要注意串口调试助手需要相对应配置\n\n校验位用于对数据正确进行校验，通常是需要的，但是数据较少就无所谓了\n\n```\n\tUSART_InitStructure.USART_BaudRate = 115200;  //配置串口的波特率\n\tUSART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  //配置硬件流控制\n\tUSART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  //配置为全双工模式，可同时收发\n\tUSART_InitStructure.USART_StopBits = USART_StopBits_1;  //设置停止位为1位\n\tUSART_InitStructure.USART_Parity = USART_Parity_No;  //设置校验位不打开\n\tUSART_InitStructure.USART_WordLength =USART_WordLength_8b;  //设置数据长度为8位\n\tUSART_Init(USART1, &USART_InitStructure);  //将结构体进行定义\n\t\n\t// 使能串口\n\tUSART_Cmd(USART1, ENABLE);\t\n```\n\n### USART串口发送数据\n\n#### 发送8位数据\n\n直接调用固件库函数，然后使用TXE标志位进行判断是否完成发送\n\n```\nvoid Usart_SendByte(USART_TypeDef* pUSARTx, uint8_t data)\n{\n\t//使用发送函数对字节进行发送\n\tUSART_SendData(pUSARTx, data);\n\t\n\t//定义循环函数，不断检测TXE位是否为SET，如果为SET则退出循环，完成单次传输\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET );\n}\n```\n\n#### 发送16位数据\n\n由于USART只能发送8位数据，所以需要把数据拆成两个8位进行发送，然后发送两次，在接收端可以写函数进行拼接，依旧是使用TXE标志位进行判断是否完成发送，TXE标志位只能判断单次发送情况，所以需要发送一次判断一次\n\n```\n//发送16位数据\nvoid Usart_SendDoubleByte(USART_TypeDef* pUSARTx, uint16_t data)\n{\n\t//采用高八位第八位分开发送的方式\n\tuint8_t temp_h,temp_l;\n\t\n\t//使用发送函数对字节进行发送\n\ttemp_h = (data&0xff00) >> 8;//先对数据取值高八位，然后进行偏移\n\ttemp_l = data&(0xff);//直接发送低八位\n\t\n\t//使用发送函数对字节进行发送，并利用TXE标志位进行判断\n\tUSART_SendData(pUSARTx, temp_h);\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET );\n\tUSART_SendData(pUSARTx, temp_l);\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET );\n}\n```\n\n#### 发送字符串\n\n需要有数组和指针的概念，直接用指针依次指向每一字节数据，每一字节数据代表8位，依次发送每一字节的数据\n\n这里需要注意的是要采用TC标志位，因为TXE需要每发送一次判断一次，而TC针对大量数据发送结束后，单次判断即可\n\n```\n//发送字符串\nvoid Usart_SendStr(USART_TypeDef* pUSARTx, uint8_t *str)\n{\n\t//定义初始值\n\tuint8_t i=0;\n\t//对数组指针进行循环判断\n\tdo\n  {\n\t\t//单次发送数组的1字节\n\t\tUsart_SendByte(pUSARTx, *(str+i));\n\t\t//发送完对指向下一字节\n\t\ti++;\n\t}while(*(str+i) != '\\0');//判断如果是空行符则退出循环，代表数组的最后一位结束\n\t\n\t//连续发送多个数据的需要采用TC标志位进行判断\n\twhile( USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET );\n}\n```\n\n","slug":"STM32的USART发送测试","published":1,"updated":"2024-08-01T00:55:39.078Z","comments":1,"layout":"post","photos":[],"_id":"clzl8m0vz0000hsfb4m29cfoz","content":"<h1 id=\"STM32的USART发送测试\"><a href=\"#STM32的USART发送测试\" class=\"headerlink\" title=\"STM32的USART发送测试\"></a>STM32的USART发送测试</h1><h3 id=\"通信的基本知识\"><a href=\"#通信的基本知识\" class=\"headerlink\" title=\"通信的基本知识\"></a>通信的基本知识</h3><p>串行通信：串行是一次性发一个数据过去，所以一般就两根线，一个收一个发，传输距离远，抗干扰能力强，例如UART、IIC、SPI…</p>\n<p>并行通信：并行是一次性发多个数据，多根线同时发，传输速度快，但是抗干扰能力弱，传输距离短，例如SDIO(4根线)、FSMC(8根线)…</p>\n<p>全双工：可以同时收发数据</p>\n<p>半双工：不可以同时收发数据，需要收完再发或者发完再收</p>\n<p>单工：只能进行收或者发数据，无法同时进行</p>\n<p>同步传输：同步是有时钟信号的，只有时钟使能的时候，信号才有用，但是对时钟要求高，时钟的方波不能有尖峰等</p>\n<p>异步传输：有通讯起始位、通讯内容主题、数据校验位、通信停止位</p>\n<p>比特率：每秒钟传输二进制位数，bit&#x2F;s</p>\n<p>波特率：每秒钟传输码元个数</p>\n<p>码元：要传输的信息</p>\n<p>RS232：+15V传输0，-15V传输1，需要DB9接口，使用电平转换芯片，用于工业设备的直接通信，能够利用高电平防止静电干扰</p>\n<h3 id=\"USART串口初始化配置\"><a href=\"#USART串口初始化配置\" class=\"headerlink\" title=\"USART串口初始化配置\"></a>USART串口初始化配置</h3><p>USART_TX：发送数据输出引脚 </p>\n<p>USART_RX：接收数据输入引脚</p>\n<p>USART通常只能收发8位以内数据，最大为9位，第 9 位数据是否有效要取决于 USART控制寄存器 1(USART_CR1) 的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M 位为 1 表示 9位数据字长</p>\n<p>接下来是代码的编写，步骤为打开GPIO、USART1的时钟、GPIO口初始化、GPIO_USART初始化、串口中断优先级配置、中断串口使能、串口使能</p>\n<h4 id=\"初始化GPIO和GPIO-USART\"><a href=\"#初始化GPIO和GPIO-USART\" class=\"headerlink\" title=\"初始化GPIO和GPIO_USART\"></a>初始化GPIO和GPIO_USART</h4><p>这里面基本逻辑跟GPIO的设置几乎一样，要注意的是TX串口的模式要改成复用推挽输出，因为他需要做推挽输出，还要配置USART，所以不能简单的设置为推挽输出</p>\n<p>RX串口要设置成浮空输入模式，因为不能上升沿或者下降沿，因为会产生错误信号，导致数据错乱</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">GPIO_InitTypeDef GPIO_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>USART_InitTypeDef USART_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化USART结构体</span><br><br><span class=\"hljs-comment\">//打开GPIOA的时钟</span><br>RCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_GPIOA<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//打开USART的时钟</span><br>RCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_USART1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//初始化TX的GPIO口</span><br>GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_9<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//定义TX引脚</span><br>GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_PP<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置输出模式为复用推挽输出</span><br>GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置速度为50MHz</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span><span class=\"hljs-meta\">&amp;GPIO_InitStructure);  <span class=\"hljs-comment\">//将结构体进行定义</span></span><br><br><span class=\"hljs-comment\">//初始化RX的GPIO口</span><br>GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_10<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//定义RX引脚</span><br>GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_IN_FLOATING<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置输入模式位浮空输入</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span><span class=\"hljs-meta\">&amp;GPIO_InitStructure);  <span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"配置USART\"><a href=\"#配置USART\" class=\"headerlink\" title=\"配置USART\"></a>配置USART</h4><p>波特率是码元的个数，而不是位数，其他配置可以随便调，但是要注意串口调试助手需要相对应配置</p>\n<p>校验位用于对数据正确进行校验，通常是需要的，但是数据较少就无所谓了</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">USART_InitStructure.USART_BaudRate <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">115200</span><span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//配置串口的波特率</span><br>USART_InitStructure.USART_HardwareFlowControl <span class=\"hljs-punctuation\">=</span> USART_HardwareFlowControl_None<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//配置硬件流控制</span><br>USART_InitStructure.USART_Mode <span class=\"hljs-punctuation\">=</span> USART_Mode_Rx <span class=\"hljs-string\">| USART_Mode_Tx;  //配置为全双工模式，可同时收发</span><br>USART_InitStructure.USART_StopBits <span class=\"hljs-punctuation\">=</span> USART_StopBits_1<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置停止位为1位</span><br>USART_InitStructure.USART_Parity <span class=\"hljs-punctuation\">=</span> USART_Parity_No<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置校验位不打开</span><br>USART_InitStructure.USART_WordLength <span class=\"hljs-punctuation\">=</span>USART_WordLength_8b<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置数据长度为8位</span><br>USART_Init<span class=\"hljs-punctuation\">(</span>USART1<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;USART_InitStructure);  <span class=\"hljs-comment\">//将结构体进行定义</span></span><br><br><span class=\"hljs-comment\">// 使能串口</span><br>USART_Cmd<span class=\"hljs-punctuation\">(</span>USART1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span>\t<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"USART串口发送数据\"><a href=\"#USART串口发送数据\" class=\"headerlink\" title=\"USART串口发送数据\"></a>USART串口发送数据</h3><h4 id=\"发送8位数据\"><a href=\"#发送8位数据\" class=\"headerlink\" title=\"发送8位数据\"></a>发送8位数据</h4><p>直接调用固件库函数，然后使用TXE标志位进行判断是否完成发送</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Usart_SendByte</span><span class=\"hljs-params\">(USART_TypeDef* pUSARTx, <span class=\"hljs-type\">uint8_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//使用发送函数对字节进行发送</span><br>\t<span class=\"hljs-built_in\">USART_SendData</span>(pUSARTx, data);<br>\t<br>\t<span class=\"hljs-comment\">//定义循环函数，不断检测TXE位是否为SET，如果为SET则退出循环，完成单次传输</span><br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TXE) == RESET );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"发送16位数据\"><a href=\"#发送16位数据\" class=\"headerlink\" title=\"发送16位数据\"></a>发送16位数据</h4><p>由于USART只能发送8位数据，所以需要把数据拆成两个8位进行发送，然后发送两次，在接收端可以写函数进行拼接，依旧是使用TXE标志位进行判断是否完成发送，TXE标志位只能判断单次发送情况，所以需要发送一次判断一次</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//发送16位数据</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Usart_SendDoubleByte</span><span class=\"hljs-params\">(USART_TypeDef* pUSARTx, <span class=\"hljs-type\">uint16_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//采用高八位第八位分开发送的方式</span><br>\t<span class=\"hljs-type\">uint8_t</span> temp_h,temp_l;<br>\t<br>\t<span class=\"hljs-comment\">//使用发送函数对字节进行发送</span><br>\ttemp_h = (data&amp;<span class=\"hljs-number\">0xff00</span>) &gt;&gt; <span class=\"hljs-number\">8</span>;<span class=\"hljs-comment\">//先对数据取值高八位，然后进行偏移</span><br>\ttemp_l = data&amp;(<span class=\"hljs-number\">0xff</span>);<span class=\"hljs-comment\">//直接发送低八位</span><br>\t<br>\t<span class=\"hljs-comment\">//使用发送函数对字节进行发送，并利用TXE标志位进行判断</span><br>\t<span class=\"hljs-built_in\">USART_SendData</span>(pUSARTx, temp_h);<br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TXE) == RESET );<br>\t<span class=\"hljs-built_in\">USART_SendData</span>(pUSARTx, temp_l);<br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TXE) == RESET );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"发送字符串\"><a href=\"#发送字符串\" class=\"headerlink\" title=\"发送字符串\"></a>发送字符串</h4><p>需要有数组和指针的概念，直接用指针依次指向每一字节数据，每一字节数据代表8位，依次发送每一字节的数据</p>\n<p>这里需要注意的是要采用TC标志位，因为TXE需要每发送一次判断一次，而TC针对大量数据发送结束后，单次判断即可</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//发送字符串</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Usart_SendStr</span><span class=\"hljs-params\">(USART_TypeDef* pUSARTx, <span class=\"hljs-type\">uint8_t</span> *str)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//定义初始值</span><br>\t<span class=\"hljs-type\">uint8_t</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">//对数组指针进行循环判断</span><br>\t<span class=\"hljs-keyword\">do</span><br>  &#123;<br>\t\t<span class=\"hljs-comment\">//单次发送数组的1字节</span><br>\t\t<span class=\"hljs-built_in\">Usart_SendByte</span>(pUSARTx, *(str+i));<br>\t\t<span class=\"hljs-comment\">//发送完对指向下一字节</span><br>\t\ti++;<br>\t&#125;<span class=\"hljs-keyword\">while</span>(*(str+i) != <span class=\"hljs-string\">&#x27;\\0&#x27;</span>);<span class=\"hljs-comment\">//判断如果是空行符则退出循环，代表数组的最后一位结束</span><br>\t<br>\t<span class=\"hljs-comment\">//连续发送多个数据的需要采用TC标志位进行判断</span><br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TC) == RESET );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"STM32的USART发送测试\"><a href=\"#STM32的USART发送测试\" class=\"headerlink\" title=\"STM32的USART发送测试\"></a>STM32的USART发送测试</h1><h3 id=\"通信的基本知识\"><a href=\"#通信的基本知识\" class=\"headerlink\" title=\"通信的基本知识\"></a>通信的基本知识</h3><p>串行通信：串行是一次性发一个数据过去，所以一般就两根线，一个收一个发，传输距离远，抗干扰能力强，例如UART、IIC、SPI…</p>\n<p>并行通信：并行是一次性发多个数据，多根线同时发，传输速度快，但是抗干扰能力弱，传输距离短，例如SDIO(4根线)、FSMC(8根线)…</p>\n<p>全双工：可以同时收发数据</p>\n<p>半双工：不可以同时收发数据，需要收完再发或者发完再收</p>\n<p>单工：只能进行收或者发数据，无法同时进行</p>\n<p>同步传输：同步是有时钟信号的，只有时钟使能的时候，信号才有用，但是对时钟要求高，时钟的方波不能有尖峰等</p>\n<p>异步传输：有通讯起始位、通讯内容主题、数据校验位、通信停止位</p>\n<p>比特率：每秒钟传输二进制位数，bit&#x2F;s</p>\n<p>波特率：每秒钟传输码元个数</p>\n<p>码元：要传输的信息</p>\n<p>RS232：+15V传输0，-15V传输1，需要DB9接口，使用电平转换芯片，用于工业设备的直接通信，能够利用高电平防止静电干扰</p>\n<h3 id=\"USART串口初始化配置\"><a href=\"#USART串口初始化配置\" class=\"headerlink\" title=\"USART串口初始化配置\"></a>USART串口初始化配置</h3><p>USART_TX：发送数据输出引脚 </p>\n<p>USART_RX：接收数据输入引脚</p>\n<p>USART通常只能收发8位以内数据，最大为9位，第 9 位数据是否有效要取决于 USART控制寄存器 1(USART_CR1) 的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M 位为 1 表示 9位数据字长</p>\n<p>接下来是代码的编写，步骤为打开GPIO、USART1的时钟、GPIO口初始化、GPIO_USART初始化、串口中断优先级配置、中断串口使能、串口使能</p>\n<h4 id=\"初始化GPIO和GPIO-USART\"><a href=\"#初始化GPIO和GPIO-USART\" class=\"headerlink\" title=\"初始化GPIO和GPIO_USART\"></a>初始化GPIO和GPIO_USART</h4><p>这里面基本逻辑跟GPIO的设置几乎一样，要注意的是TX串口的模式要改成复用推挽输出，因为他需要做推挽输出，还要配置USART，所以不能简单的设置为推挽输出</p>\n<p>RX串口要设置成浮空输入模式，因为不能上升沿或者下降沿，因为会产生错误信号，导致数据错乱</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">GPIO_InitTypeDef GPIO_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>USART_InitTypeDef USART_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化USART结构体</span><br><br><span class=\"hljs-comment\">//打开GPIOA的时钟</span><br>RCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_GPIOA<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//打开USART的时钟</span><br>RCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_USART1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//初始化TX的GPIO口</span><br>GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_9<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//定义TX引脚</span><br>GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_PP<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置输出模式为复用推挽输出</span><br>GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置速度为50MHz</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span><span class=\"hljs-meta\">&amp;GPIO_InitStructure);  <span class=\"hljs-comment\">//将结构体进行定义</span></span><br><br><span class=\"hljs-comment\">//初始化RX的GPIO口</span><br>GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_10<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//定义RX引脚</span><br>GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_IN_FLOATING<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置输入模式位浮空输入</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span><span class=\"hljs-meta\">&amp;GPIO_InitStructure);  <span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"配置USART\"><a href=\"#配置USART\" class=\"headerlink\" title=\"配置USART\"></a>配置USART</h4><p>波特率是码元的个数，而不是位数，其他配置可以随便调，但是要注意串口调试助手需要相对应配置</p>\n<p>校验位用于对数据正确进行校验，通常是需要的，但是数据较少就无所谓了</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">USART_InitStructure.USART_BaudRate <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">115200</span><span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//配置串口的波特率</span><br>USART_InitStructure.USART_HardwareFlowControl <span class=\"hljs-punctuation\">=</span> USART_HardwareFlowControl_None<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//配置硬件流控制</span><br>USART_InitStructure.USART_Mode <span class=\"hljs-punctuation\">=</span> USART_Mode_Rx <span class=\"hljs-string\">| USART_Mode_Tx;  //配置为全双工模式，可同时收发</span><br>USART_InitStructure.USART_StopBits <span class=\"hljs-punctuation\">=</span> USART_StopBits_1<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置停止位为1位</span><br>USART_InitStructure.USART_Parity <span class=\"hljs-punctuation\">=</span> USART_Parity_No<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置校验位不打开</span><br>USART_InitStructure.USART_WordLength <span class=\"hljs-punctuation\">=</span>USART_WordLength_8b<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//设置数据长度为8位</span><br>USART_Init<span class=\"hljs-punctuation\">(</span>USART1<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;USART_InitStructure);  <span class=\"hljs-comment\">//将结构体进行定义</span></span><br><br><span class=\"hljs-comment\">// 使能串口</span><br>USART_Cmd<span class=\"hljs-punctuation\">(</span>USART1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span>\t<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"USART串口发送数据\"><a href=\"#USART串口发送数据\" class=\"headerlink\" title=\"USART串口发送数据\"></a>USART串口发送数据</h3><h4 id=\"发送8位数据\"><a href=\"#发送8位数据\" class=\"headerlink\" title=\"发送8位数据\"></a>发送8位数据</h4><p>直接调用固件库函数，然后使用TXE标志位进行判断是否完成发送</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Usart_SendByte</span><span class=\"hljs-params\">(USART_TypeDef* pUSARTx, <span class=\"hljs-type\">uint8_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//使用发送函数对字节进行发送</span><br>\t<span class=\"hljs-built_in\">USART_SendData</span>(pUSARTx, data);<br>\t<br>\t<span class=\"hljs-comment\">//定义循环函数，不断检测TXE位是否为SET，如果为SET则退出循环，完成单次传输</span><br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TXE) == RESET );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"发送16位数据\"><a href=\"#发送16位数据\" class=\"headerlink\" title=\"发送16位数据\"></a>发送16位数据</h4><p>由于USART只能发送8位数据，所以需要把数据拆成两个8位进行发送，然后发送两次，在接收端可以写函数进行拼接，依旧是使用TXE标志位进行判断是否完成发送，TXE标志位只能判断单次发送情况，所以需要发送一次判断一次</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//发送16位数据</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Usart_SendDoubleByte</span><span class=\"hljs-params\">(USART_TypeDef* pUSARTx, <span class=\"hljs-type\">uint16_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//采用高八位第八位分开发送的方式</span><br>\t<span class=\"hljs-type\">uint8_t</span> temp_h,temp_l;<br>\t<br>\t<span class=\"hljs-comment\">//使用发送函数对字节进行发送</span><br>\ttemp_h = (data&amp;<span class=\"hljs-number\">0xff00</span>) &gt;&gt; <span class=\"hljs-number\">8</span>;<span class=\"hljs-comment\">//先对数据取值高八位，然后进行偏移</span><br>\ttemp_l = data&amp;(<span class=\"hljs-number\">0xff</span>);<span class=\"hljs-comment\">//直接发送低八位</span><br>\t<br>\t<span class=\"hljs-comment\">//使用发送函数对字节进行发送，并利用TXE标志位进行判断</span><br>\t<span class=\"hljs-built_in\">USART_SendData</span>(pUSARTx, temp_h);<br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TXE) == RESET );<br>\t<span class=\"hljs-built_in\">USART_SendData</span>(pUSARTx, temp_l);<br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TXE) == RESET );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"发送字符串\"><a href=\"#发送字符串\" class=\"headerlink\" title=\"发送字符串\"></a>发送字符串</h4><p>需要有数组和指针的概念，直接用指针依次指向每一字节数据，每一字节数据代表8位，依次发送每一字节的数据</p>\n<p>这里需要注意的是要采用TC标志位，因为TXE需要每发送一次判断一次，而TC针对大量数据发送结束后，单次判断即可</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//发送字符串</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Usart_SendStr</span><span class=\"hljs-params\">(USART_TypeDef* pUSARTx, <span class=\"hljs-type\">uint8_t</span> *str)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//定义初始值</span><br>\t<span class=\"hljs-type\">uint8_t</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">//对数组指针进行循环判断</span><br>\t<span class=\"hljs-keyword\">do</span><br>  &#123;<br>\t\t<span class=\"hljs-comment\">//单次发送数组的1字节</span><br>\t\t<span class=\"hljs-built_in\">Usart_SendByte</span>(pUSARTx, *(str+i));<br>\t\t<span class=\"hljs-comment\">//发送完对指向下一字节</span><br>\t\ti++;<br>\t&#125;<span class=\"hljs-keyword\">while</span>(*(str+i) != <span class=\"hljs-string\">&#x27;\\0&#x27;</span>);<span class=\"hljs-comment\">//判断如果是空行符则退出循环，代表数组的最后一位结束</span><br>\t<br>\t<span class=\"hljs-comment\">//连续发送多个数据的需要采用TC标志位进行判断</span><br>\t<span class=\"hljs-keyword\">while</span>( <span class=\"hljs-built_in\">USART_GetFlagStatus</span>(pUSARTx, USART_FLAG_TC) == RESET );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"STM32的USART接收测试","date":"2024-07-30T16:00:00.000Z","index_img":"https://s2.loli.net/2024/07/31/CsbJKkLaQt9OgVu.jpg","_content":"\n# STM32的USART接收测试\n\n## printf()和getchar()的重定义\n\n这两个函数在STM32里面并没有进行强定义，因为他的意思是输出和输入，但是输出输入的位置并没有确定，所以无法定义，因此我们要使用的时候，需要对这两个函数进行指定定义，比如定义到USART1，通过电脑或者其他上位机进行读取或者发送数据\n\n```\n//重定向c库函数printf到串口，重定向后可使用printf函数\nint fputc(int ch, FILE *f)\n{\n\t\t/* 发送一个字节数据到串口 */\n\t\tUSART_SendData(USART1, (uint8_t) ch);\n\t\t\n\t\t/* 等待发送完毕 */\n\t\twhile (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);\t\t\n\t\n\t\treturn (ch);\n}\n\n//重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数\nint fgetc(FILE *f)\n{\n\t\t/* 等待串口输入数据 */\n\t\twhile (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);\n\n\t\treturn (int)USART_ReceiveData(USART1);\n}\n```\n\n## 中断直接接收数据\n\nUSART接收一共有两种方法，第一种是利用中断直接接收数据，这种方式的优先级可以自定义，如果有特殊需要时可以采用这种方式，还有一种方法是正常接收，按照程序流程进行接收\n\n接收数据需要随时进行触发，在函数运行时也有可能收到数据，所以需要对USART进行中断配置，当然如果不需要使用中断接收数据，可以不进行中断配置，直接读取USART_RX串口的数据即可，但是需要把所有中断注释\n\n中断接收数据需要对中断函数进行配置\n\n#### 中断优先级配置\n\n这个跟中断配置代码的一样，可以参照中断配置，这个主要为内部中断配置，而不是外部中断配置，因为外部中断是真的中断，USART有属于自己的额外的中断线，所以配置USART约等于配置了外部中断，所以只需要内部中断即可\n\n```\n\t//定义结构体\n\tNVIC_InitTypeDef  NVIC_InitStruct;\n\t\n\t//NVIC初始化\n\tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//配置组优先级（0，1，2，3，4，5）\n\tNVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;//配置内部中断线\n\tNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;//配置抢占优先级\n\tNVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;//配置子优先级\n\tNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//使能中断通道\n\tNVIC_Init(&NVIC_InitStruct);//将结构体进行定义\n```\n\n#### 中断串口和串口使能\n\n```\n\t// 使能串口接收中断\n\tUSART_ITConfig(USART1, USART_IT_RXNE, ENABLE);\t\n\t// 使能串口空闲中断\n\tUSART_ITConfig(USART1, USART_IT_IDLE, ENABLE);\n```\n\n#### USART中断服务函数\n\n这个是需要在stm32f10x_it.c文件里面进行设置，跟按键中断一致，所有的中断函数的触发都是需要在这个文件里面进行定义，中断函数的函数名需要查询中断表格，不能自定义\n\nUSART_IT_IDLE标志位会在RX总线从busy状态转换到free状态时被触发，也就是只有接收到数据后连续一个数据帧时间内不再有数据发送过来的时候触发，常用于判断单次数据接收完成。\n\nUSART_IT_IDLE标志位只能在中断中进行使用\n\n中断标志位由硬件触发（代表USART_RX端口接收数据检测），软件清零（需要使用USART_IT_IDLE函数判断是否完成传输，是否有空闲线路，再使用USART_ReceiveData(USART1)进行软件标志位清零），清零方法时读取一遍USART_SR寄存器然后读取一遍USART_DR寄存器，也就是不能简单的用USART_ClearITPendingBit()来清除就完事。\n\n如果想实现长数据的接收，可以定义直接在中断里面定义一个字节长度的数组，然后不断的往里面塞数据，用中断空闲标志位来判断什么时候停止接收退出循环（判断最后一位是否为“\\0”，如果是的话，则中断停止回到原有程序中）\n\n```\n#include \"bsp_usart.h\"//必须在stm32f10x_it.c文件里面包含头文件，否则会报错\n\n// USART1中断服务函数\nvoid USART1_IRQHandler (void)\n{\n\t//定义接收缓存区\n\tuint8_t ucTemp;\n\t//判断中断接收标志位，进入该函数，说明有数据进入\n\tif(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)\n\t{\n\t\t//读取数据并储存\n\t\tucTemp = USART_ReceiveData(USART1);\n\t\t//将数据发送到USART1进行查看\n    \tUSART_SendData(USART1,ucTemp);\n    \t\n    \t//做各种函数接收数据处理\n    \t/*.................*/\n    \t\n\t} \n\t//判断中断是否接收完毕\n\tif(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET)\n\t{\t\n    \tUSART_ReceiveData(USART1);//软件序列清除标志位流程\n\n\t\t//做各种函数接收数据结束标志位处理\n    \t/*.................*/\n\t}\n}\n```\n\n## 不通过中断直接接收发数据\n\n不通过中断的话就不需要定义中断，直接再函数里面调用getchar()函数进行读取数据即可\n\n但是这种方式有比较大的缺陷，就是只能读取1字节的数据，因为缺少了判断的标志位，无法获取是否完成读取，但是很多时候一个字符就已经足够判断\n\n```\n\tuint8_t str;\n\tstr = getchar();\n\tprintf(\"str:%c\\n\", str);\n```\n\n","source":"_posts/STM32的USART接收测试.md","raw":"---\ntitle: STM32的USART接收测试\ntag: USART\ndate: 2024-07-31\ncategories: STM32\nindex_img: https://s2.loli.net/2024/07/31/CsbJKkLaQt9OgVu.jpg\n---\n\n# STM32的USART接收测试\n\n## printf()和getchar()的重定义\n\n这两个函数在STM32里面并没有进行强定义，因为他的意思是输出和输入，但是输出输入的位置并没有确定，所以无法定义，因此我们要使用的时候，需要对这两个函数进行指定定义，比如定义到USART1，通过电脑或者其他上位机进行读取或者发送数据\n\n```\n//重定向c库函数printf到串口，重定向后可使用printf函数\nint fputc(int ch, FILE *f)\n{\n\t\t/* 发送一个字节数据到串口 */\n\t\tUSART_SendData(USART1, (uint8_t) ch);\n\t\t\n\t\t/* 等待发送完毕 */\n\t\twhile (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);\t\t\n\t\n\t\treturn (ch);\n}\n\n//重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数\nint fgetc(FILE *f)\n{\n\t\t/* 等待串口输入数据 */\n\t\twhile (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);\n\n\t\treturn (int)USART_ReceiveData(USART1);\n}\n```\n\n## 中断直接接收数据\n\nUSART接收一共有两种方法，第一种是利用中断直接接收数据，这种方式的优先级可以自定义，如果有特殊需要时可以采用这种方式，还有一种方法是正常接收，按照程序流程进行接收\n\n接收数据需要随时进行触发，在函数运行时也有可能收到数据，所以需要对USART进行中断配置，当然如果不需要使用中断接收数据，可以不进行中断配置，直接读取USART_RX串口的数据即可，但是需要把所有中断注释\n\n中断接收数据需要对中断函数进行配置\n\n#### 中断优先级配置\n\n这个跟中断配置代码的一样，可以参照中断配置，这个主要为内部中断配置，而不是外部中断配置，因为外部中断是真的中断，USART有属于自己的额外的中断线，所以配置USART约等于配置了外部中断，所以只需要内部中断即可\n\n```\n\t//定义结构体\n\tNVIC_InitTypeDef  NVIC_InitStruct;\n\t\n\t//NVIC初始化\n\tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//配置组优先级（0，1，2，3，4，5）\n\tNVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;//配置内部中断线\n\tNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;//配置抢占优先级\n\tNVIC_InitStruct.NVIC_IRQChannelSubPriority = 1;//配置子优先级\n\tNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;//使能中断通道\n\tNVIC_Init(&NVIC_InitStruct);//将结构体进行定义\n```\n\n#### 中断串口和串口使能\n\n```\n\t// 使能串口接收中断\n\tUSART_ITConfig(USART1, USART_IT_RXNE, ENABLE);\t\n\t// 使能串口空闲中断\n\tUSART_ITConfig(USART1, USART_IT_IDLE, ENABLE);\n```\n\n#### USART中断服务函数\n\n这个是需要在stm32f10x_it.c文件里面进行设置，跟按键中断一致，所有的中断函数的触发都是需要在这个文件里面进行定义，中断函数的函数名需要查询中断表格，不能自定义\n\nUSART_IT_IDLE标志位会在RX总线从busy状态转换到free状态时被触发，也就是只有接收到数据后连续一个数据帧时间内不再有数据发送过来的时候触发，常用于判断单次数据接收完成。\n\nUSART_IT_IDLE标志位只能在中断中进行使用\n\n中断标志位由硬件触发（代表USART_RX端口接收数据检测），软件清零（需要使用USART_IT_IDLE函数判断是否完成传输，是否有空闲线路，再使用USART_ReceiveData(USART1)进行软件标志位清零），清零方法时读取一遍USART_SR寄存器然后读取一遍USART_DR寄存器，也就是不能简单的用USART_ClearITPendingBit()来清除就完事。\n\n如果想实现长数据的接收，可以定义直接在中断里面定义一个字节长度的数组，然后不断的往里面塞数据，用中断空闲标志位来判断什么时候停止接收退出循环（判断最后一位是否为“\\0”，如果是的话，则中断停止回到原有程序中）\n\n```\n#include \"bsp_usart.h\"//必须在stm32f10x_it.c文件里面包含头文件，否则会报错\n\n// USART1中断服务函数\nvoid USART1_IRQHandler (void)\n{\n\t//定义接收缓存区\n\tuint8_t ucTemp;\n\t//判断中断接收标志位，进入该函数，说明有数据进入\n\tif(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)\n\t{\n\t\t//读取数据并储存\n\t\tucTemp = USART_ReceiveData(USART1);\n\t\t//将数据发送到USART1进行查看\n    \tUSART_SendData(USART1,ucTemp);\n    \t\n    \t//做各种函数接收数据处理\n    \t/*.................*/\n    \t\n\t} \n\t//判断中断是否接收完毕\n\tif(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET)\n\t{\t\n    \tUSART_ReceiveData(USART1);//软件序列清除标志位流程\n\n\t\t//做各种函数接收数据结束标志位处理\n    \t/*.................*/\n\t}\n}\n```\n\n## 不通过中断直接接收发数据\n\n不通过中断的话就不需要定义中断，直接再函数里面调用getchar()函数进行读取数据即可\n\n但是这种方式有比较大的缺陷，就是只能读取1字节的数据，因为缺少了判断的标志位，无法获取是否完成读取，但是很多时候一个字符就已经足够判断\n\n```\n\tuint8_t str;\n\tstr = getchar();\n\tprintf(\"str:%c\\n\", str);\n```\n\n","slug":"STM32的USART接收测试","published":1,"updated":"2024-08-01T00:54:52.489Z","comments":1,"layout":"post","photos":[],"_id":"clzl8m0w10001hsfbfkc59sky","content":"<h1 id=\"STM32的USART接收测试\"><a href=\"#STM32的USART接收测试\" class=\"headerlink\" title=\"STM32的USART接收测试\"></a>STM32的USART接收测试</h1><h2 id=\"printf-和getchar-的重定义\"><a href=\"#printf-和getchar-的重定义\" class=\"headerlink\" title=\"printf()和getchar()的重定义\"></a>printf()和getchar()的重定义</h2><p>这两个函数在STM32里面并没有进行强定义，因为他的意思是输出和输入，但是输出输入的位置并没有确定，所以无法定义，因此我们要使用的时候，需要对这两个函数进行指定定义，比如定义到USART1，通过电脑或者其他上位机进行读取或者发送数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//重定向c库函数printf到串口，重定向后可使用printf函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">fputc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> ch, FILE *f)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t\t<span class=\"hljs-comment\">/* 发送一个字节数据到串口 */</span><br>\t\t<span class=\"hljs-built_in\">USART_SendData</span>(USART1, (<span class=\"hljs-type\">uint8_t</span>) ch);<br>\t\t<br>\t\t<span class=\"hljs-comment\">/* 等待发送完毕 */</span><br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">USART_GetFlagStatus</span>(USART1, USART_FLAG_TXE) == RESET);\t\t<br>\t<br>\t\t<span class=\"hljs-keyword\">return</span> (ch);<br>&#125;<br><br><span class=\"hljs-comment\">//重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">fgetc</span><span class=\"hljs-params\">(FILE *f)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t\t<span class=\"hljs-comment\">/* 等待串口输入数据 */</span><br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">USART_GetFlagStatus</span>(USART1, USART_FLAG_RXNE) == RESET);<br><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">int</span>)<span class=\"hljs-built_in\">USART_ReceiveData</span>(USART1);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"中断直接接收数据\"><a href=\"#中断直接接收数据\" class=\"headerlink\" title=\"中断直接接收数据\"></a>中断直接接收数据</h2><p>USART接收一共有两种方法，第一种是利用中断直接接收数据，这种方式的优先级可以自定义，如果有特殊需要时可以采用这种方式，还有一种方法是正常接收，按照程序流程进行接收</p>\n<p>接收数据需要随时进行触发，在函数运行时也有可能收到数据，所以需要对USART进行中断配置，当然如果不需要使用中断接收数据，可以不进行中断配置，直接读取USART_RX串口的数据即可，但是需要把所有中断注释</p>\n<p>中断接收数据需要对中断函数进行配置</p>\n<h4 id=\"中断优先级配置\"><a href=\"#中断优先级配置\" class=\"headerlink\" title=\"中断优先级配置\"></a>中断优先级配置</h4><p>这个跟中断配置代码的一样，可以参照中断配置，这个主要为内部中断配置，而不是外部中断配置，因为外部中断是真的中断，USART有属于自己的额外的中断线，所以配置USART约等于配置了外部中断，所以只需要内部中断即可</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//定义结构体</span><br>NVIC_InitTypeDef  NVIC_InitStruct<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//NVIC初始化</span><br>NVIC_PriorityGroupConfig<span class=\"hljs-punctuation\">(</span>NVIC_PriorityGroup_2<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置组优先级（0，1，2，3，4，5）</span><br>NVIC_InitStruct.NVIC_IRQChannel <span class=\"hljs-punctuation\">=</span> USART1_IRQn<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置内部中断线</span><br>NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置抢占优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelSubPriority <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置子优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelCmd <span class=\"hljs-punctuation\">=</span> ENABLE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//使能中断通道</span><br>NVIC_Init<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;NVIC_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"中断串口和串口使能\"><a href=\"#中断串口和串口使能\" class=\"headerlink\" title=\"中断串口和串口使能\"></a>中断串口和串口使能</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 使能串口接收中断</span><br><span class=\"hljs-built_in\">USART_ITConfig</span>(USART1, USART_IT_RXNE, ENABLE);\t<br><span class=\"hljs-comment\">// 使能串口空闲中断</span><br><span class=\"hljs-built_in\">USART_ITConfig</span>(USART1, USART_IT_IDLE, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"USART中断服务函数\"><a href=\"#USART中断服务函数\" class=\"headerlink\" title=\"USART中断服务函数\"></a>USART中断服务函数</h4><p>这个是需要在stm32f10x_it.c文件里面进行设置，跟按键中断一致，所有的中断函数的触发都是需要在这个文件里面进行定义，中断函数的函数名需要查询中断表格，不能自定义</p>\n<p>USART_IT_IDLE标志位会在RX总线从busy状态转换到free状态时被触发，也就是只有接收到数据后连续一个数据帧时间内不再有数据发送过来的时候触发，常用于判断单次数据接收完成。</p>\n<p>USART_IT_IDLE标志位只能在中断中进行使用</p>\n<p>中断标志位由硬件触发（代表USART_RX端口接收数据检测），软件清零（需要使用USART_IT_IDLE函数判断是否完成传输，是否有空闲线路，再使用USART_ReceiveData(USART1)进行软件标志位清零），清零方法时读取一遍USART_SR寄存器然后读取一遍USART_DR寄存器，也就是不能简单的用USART_ClearITPendingBit()来清除就完事。</p>\n<p>如果想实现长数据的接收，可以定义直接在中断里面定义一个字节长度的数组，然后不断的往里面塞数据，用中断空闲标志位来判断什么时候停止接收退出循环（判断最后一位是否为“\\0”，如果是的话，则中断停止回到原有程序中）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span><span class=\"hljs-comment\">//必须在stm32f10x_it.c文件里面包含头文件，否则会报错</span></span><br><br><span class=\"hljs-comment\">// USART1中断服务函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">USART1_IRQHandler</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//定义接收缓存区</span><br>\t<span class=\"hljs-type\">uint8_t</span> ucTemp;<br>\t<span class=\"hljs-comment\">//判断中断接收标志位，进入该函数，说明有数据进入</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">USART_GetITStatus</span>(USART1, USART_IT_RXNE) != RESET)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//读取数据并储存</span><br>\t\tucTemp = <span class=\"hljs-built_in\">USART_ReceiveData</span>(USART1);<br>\t\t<span class=\"hljs-comment\">//将数据发送到USART1进行查看</span><br>    \t<span class=\"hljs-built_in\">USART_SendData</span>(USART1,ucTemp);<br>    \t<br>    \t<span class=\"hljs-comment\">//做各种函数接收数据处理</span><br>    \t<span class=\"hljs-comment\">/*.................*/</span><br>    \t<br>\t&#125; <br>\t<span class=\"hljs-comment\">//判断中断是否接收完毕</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">USART_GetITStatus</span>(USART1, USART_IT_IDLE) != RESET)<br>\t&#123;\t<br>    \t<span class=\"hljs-built_in\">USART_ReceiveData</span>(USART1);<span class=\"hljs-comment\">//软件序列清除标志位流程</span><br><br>\t\t<span class=\"hljs-comment\">//做各种函数接收数据结束标志位处理</span><br>    \t<span class=\"hljs-comment\">/*.................*/</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"不通过中断直接接收发数据\"><a href=\"#不通过中断直接接收发数据\" class=\"headerlink\" title=\"不通过中断直接接收发数据\"></a>不通过中断直接接收发数据</h2><p>不通过中断的话就不需要定义中断，直接再函数里面调用getchar()函数进行读取数据即可</p>\n<p>但是这种方式有比较大的缺陷，就是只能读取1字节的数据，因为缺少了判断的标志位，无法获取是否完成读取，但是很多时候一个字符就已经足够判断</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\">uint8_t <span class=\"hljs-built_in\">str</span>;<br><span class=\"hljs-built_in\">str</span> = getchar();<br>printf(<span class=\"hljs-string\">&quot;str:%c\\n&quot;</span>, <span class=\"hljs-built_in\">str</span>);<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"STM32的USART接收测试\"><a href=\"#STM32的USART接收测试\" class=\"headerlink\" title=\"STM32的USART接收测试\"></a>STM32的USART接收测试</h1><h2 id=\"printf-和getchar-的重定义\"><a href=\"#printf-和getchar-的重定义\" class=\"headerlink\" title=\"printf()和getchar()的重定义\"></a>printf()和getchar()的重定义</h2><p>这两个函数在STM32里面并没有进行强定义，因为他的意思是输出和输入，但是输出输入的位置并没有确定，所以无法定义，因此我们要使用的时候，需要对这两个函数进行指定定义，比如定义到USART1，通过电脑或者其他上位机进行读取或者发送数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//重定向c库函数printf到串口，重定向后可使用printf函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">fputc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> ch, FILE *f)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t\t<span class=\"hljs-comment\">/* 发送一个字节数据到串口 */</span><br>\t\t<span class=\"hljs-built_in\">USART_SendData</span>(USART1, (<span class=\"hljs-type\">uint8_t</span>) ch);<br>\t\t<br>\t\t<span class=\"hljs-comment\">/* 等待发送完毕 */</span><br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">USART_GetFlagStatus</span>(USART1, USART_FLAG_TXE) == RESET);\t\t<br>\t<br>\t\t<span class=\"hljs-keyword\">return</span> (ch);<br>&#125;<br><br><span class=\"hljs-comment\">//重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">fgetc</span><span class=\"hljs-params\">(FILE *f)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t\t<span class=\"hljs-comment\">/* 等待串口输入数据 */</span><br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">USART_GetFlagStatus</span>(USART1, USART_FLAG_RXNE) == RESET);<br><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">int</span>)<span class=\"hljs-built_in\">USART_ReceiveData</span>(USART1);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"中断直接接收数据\"><a href=\"#中断直接接收数据\" class=\"headerlink\" title=\"中断直接接收数据\"></a>中断直接接收数据</h2><p>USART接收一共有两种方法，第一种是利用中断直接接收数据，这种方式的优先级可以自定义，如果有特殊需要时可以采用这种方式，还有一种方法是正常接收，按照程序流程进行接收</p>\n<p>接收数据需要随时进行触发，在函数运行时也有可能收到数据，所以需要对USART进行中断配置，当然如果不需要使用中断接收数据，可以不进行中断配置，直接读取USART_RX串口的数据即可，但是需要把所有中断注释</p>\n<p>中断接收数据需要对中断函数进行配置</p>\n<h4 id=\"中断优先级配置\"><a href=\"#中断优先级配置\" class=\"headerlink\" title=\"中断优先级配置\"></a>中断优先级配置</h4><p>这个跟中断配置代码的一样，可以参照中断配置，这个主要为内部中断配置，而不是外部中断配置，因为外部中断是真的中断，USART有属于自己的额外的中断线，所以配置USART约等于配置了外部中断，所以只需要内部中断即可</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//定义结构体</span><br>NVIC_InitTypeDef  NVIC_InitStruct<span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//NVIC初始化</span><br>NVIC_PriorityGroupConfig<span class=\"hljs-punctuation\">(</span>NVIC_PriorityGroup_2<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置组优先级（0，1，2，3，4，5）</span><br>NVIC_InitStruct.NVIC_IRQChannel <span class=\"hljs-punctuation\">=</span> USART1_IRQn<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置内部中断线</span><br>NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置抢占优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelSubPriority <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//配置子优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelCmd <span class=\"hljs-punctuation\">=</span> ENABLE<span class=\"hljs-punctuation\">;</span><span class=\"hljs-comment\">//使能中断通道</span><br>NVIC_Init<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;NVIC_InitStruct);<span class=\"hljs-comment\">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"中断串口和串口使能\"><a href=\"#中断串口和串口使能\" class=\"headerlink\" title=\"中断串口和串口使能\"></a>中断串口和串口使能</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 使能串口接收中断</span><br><span class=\"hljs-built_in\">USART_ITConfig</span>(USART1, USART_IT_RXNE, ENABLE);\t<br><span class=\"hljs-comment\">// 使能串口空闲中断</span><br><span class=\"hljs-built_in\">USART_ITConfig</span>(USART1, USART_IT_IDLE, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"USART中断服务函数\"><a href=\"#USART中断服务函数\" class=\"headerlink\" title=\"USART中断服务函数\"></a>USART中断服务函数</h4><p>这个是需要在stm32f10x_it.c文件里面进行设置，跟按键中断一致，所有的中断函数的触发都是需要在这个文件里面进行定义，中断函数的函数名需要查询中断表格，不能自定义</p>\n<p>USART_IT_IDLE标志位会在RX总线从busy状态转换到free状态时被触发，也就是只有接收到数据后连续一个数据帧时间内不再有数据发送过来的时候触发，常用于判断单次数据接收完成。</p>\n<p>USART_IT_IDLE标志位只能在中断中进行使用</p>\n<p>中断标志位由硬件触发（代表USART_RX端口接收数据检测），软件清零（需要使用USART_IT_IDLE函数判断是否完成传输，是否有空闲线路，再使用USART_ReceiveData(USART1)进行软件标志位清零），清零方法时读取一遍USART_SR寄存器然后读取一遍USART_DR寄存器，也就是不能简单的用USART_ClearITPendingBit()来清除就完事。</p>\n<p>如果想实现长数据的接收，可以定义直接在中断里面定义一个字节长度的数组，然后不断的往里面塞数据，用中断空闲标志位来判断什么时候停止接收退出循环（判断最后一位是否为“\\0”，如果是的话，则中断停止回到原有程序中）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span><span class=\"hljs-comment\">//必须在stm32f10x_it.c文件里面包含头文件，否则会报错</span></span><br><br><span class=\"hljs-comment\">// USART1中断服务函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">USART1_IRQHandler</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//定义接收缓存区</span><br>\t<span class=\"hljs-type\">uint8_t</span> ucTemp;<br>\t<span class=\"hljs-comment\">//判断中断接收标志位，进入该函数，说明有数据进入</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">USART_GetITStatus</span>(USART1, USART_IT_RXNE) != RESET)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//读取数据并储存</span><br>\t\tucTemp = <span class=\"hljs-built_in\">USART_ReceiveData</span>(USART1);<br>\t\t<span class=\"hljs-comment\">//将数据发送到USART1进行查看</span><br>    \t<span class=\"hljs-built_in\">USART_SendData</span>(USART1,ucTemp);<br>    \t<br>    \t<span class=\"hljs-comment\">//做各种函数接收数据处理</span><br>    \t<span class=\"hljs-comment\">/*.................*/</span><br>    \t<br>\t&#125; <br>\t<span class=\"hljs-comment\">//判断中断是否接收完毕</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">USART_GetITStatus</span>(USART1, USART_IT_IDLE) != RESET)<br>\t&#123;\t<br>    \t<span class=\"hljs-built_in\">USART_ReceiveData</span>(USART1);<span class=\"hljs-comment\">//软件序列清除标志位流程</span><br><br>\t\t<span class=\"hljs-comment\">//做各种函数接收数据结束标志位处理</span><br>    \t<span class=\"hljs-comment\">/*.................*/</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"不通过中断直接接收发数据\"><a href=\"#不通过中断直接接收发数据\" class=\"headerlink\" title=\"不通过中断直接接收发数据\"></a>不通过中断直接接收发数据</h2><p>不通过中断的话就不需要定义中断，直接再函数里面调用getchar()函数进行读取数据即可</p>\n<p>但是这种方式有比较大的缺陷，就是只能读取1字节的数据，因为缺少了判断的标志位，无法获取是否完成读取，但是很多时候一个字符就已经足够判断</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\">uint8_t <span class=\"hljs-built_in\">str</span>;<br><span class=\"hljs-built_in\">str</span> = getchar();<br>printf(<span class=\"hljs-string\">&quot;str:%c\\n&quot;</span>, <span class=\"hljs-built_in\">str</span>);<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Linux系统进程线程学习","date":"2024-08-08T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/1PqnXLKIcmsuZzO.png","_content":"\n# Linux系统进程线程学习\n\n## 感谢博主\n\n[Linux之进程与线程详解(一文足矣)_linux下进程和线程-CSDN博客](https://blog.csdn.net/weixin_53447537/article/details/129372775)\n\n[进程和线程的区别(超详细)-CSDN博客](https://blog.csdn.net/ThinkWon/article/details/102021274)\n\n[进程、子进程、线程-CSDN博客](https://blog.csdn.net/msg1122/article/details/82911644)\n\n## 进程与线程的基本知识\n\n一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。\n\n进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。\n\n同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n\n进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位\n\nLinux 进程之间的通信和同步需要使用进程间通信机制（如**管道、信号、共享内存**等），因为它们之间是相互独立的。而线程之间可以直接共享进程的地址空间，因此它们之间的通信和同步要比进程更加高效。\n\n**在调试时，进程比线程更容易处理**。由于进程是相互独立的，因此可以分别调试每个进程，而线程共享进程的地址空间和资源，因此在调试线程时，需要特别注意线程之间的交互和影响，这使得调试线程变得更加困难。\n\n## 进程与线程的区别总结\n\n线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。\n\n**根本区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位\n\n**资源开销：**每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。\n\n**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。\n\n**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的\n\n**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。\n\n**执行过程：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行\n\n### 父进程、子进程、线程的区别\n\n在Windows下开一个IE浏览器，这个IE浏览器是一个进程。你用浏览器去打开一个pdf，IE就去调用Acrobat去打开，这时Acrobat是一个独立的进程，就是IE的子进程。而IE自己本身同时用同一个进程开了2个网页，并且同时在跑两个网页上的脚本，这两个网页的执行就是IE自己通过两个线程实现的。\n\n一个独立程序的运行称为一个进程， 在进程里并发执行的不同部分称为线程。 由这个进程引发的另外的独立程序运行为这个进程的子进程\n\n父进程还是可以通过和子进程通信来获得一些信息的。 拿上面的例子来说，IE可以通过一些进程间通信的接口来知道Acrobat是否顺利的把pdf打开了之类的信息。但有一点我觉得你的理解基本正确，就是父进程和子进程是独立的。假如IE开了一个病毒子进程，子进程不听话，父进程也没什么特别的办法，除了向系统申请去关闭它之外。\n\n## 进程创建和使用\n\n### 进程的创建函数\n\n```\n#include <sys/types.h>\n#include <unistd.h>\n\n//创建一个进程\npid_t fork(void);\n//在父进程中，fork返回新创建子进程的进程ID；\n//在子进程中，fork返回0；\n//如果出现错误，fork返回一个负值;\n\n//得到一个进程的父进程的PID;\ngetppid();\n//得到当前进程的PID;\ngetpid();\n```\n\nfork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。\n\n### 进程退出\n\n在main函数中使用 `return关键字` ，使用 `return` 后系统会调用 `exit()`函数来终止进程。或者调用 `_exit()` 来终止进程。\n\n_exit会立刻结束进程将缓存释放掉，而exit先查看当前进程有没有文件缓存区，如果有，会先处理缓存区的数据，然后释放内存\n\n```\nvoid _exit(int status);\n\nvoid exit(int status);\n//exit(0):表示运行正常结束进程；exit(1):表示异常退出，返回值1是给操作系统的\n```\n\nreturn 是关键字，是语言级别，表示调用堆栈的返回，并将控制权移交给控制的前一级；exit是函数，表示系统级别，表示进程的结束。\n\n### 子进程等待和销毁处理\n\n父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。\n\n```\n#include <sys/types.h>\n#include <sys/wait.h>\n\npid_t wait(int *wstatus);\n//正常情况下，wait的返回值为子进程的PID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD\n```\n\n当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.\n\n如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.\n\n参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，\n\n```\npid = wait(NULL);\n//如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。\n```\n\n如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中， 这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息 被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作\n\nWIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数\n\nWEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。\n\n```\n/*\n下面的程序没有调用wait函数，那么子进程会成为无父进程状态，也就是僵尸进程，可以根据程序运行后\n所打印的PID，然后命令行输 ps -aux 查看进程状态，\n发现这个子进程依然存在，所以要调用wait来进行所谓的收尸\n*/\n\nint main(){\n\tpid_t pid;//定义fork的返回值,存储在相同类型的变量pid中\n//如果创建成功，在父进程中fork返回新创建的子进程的进程号，在子进程中返回0\n\tprintf(\"hello world\\n\");\n\tpid=fork();//fork创建子进程，将返回值给pid\n\tif(pid<0)//如果出错，fork返回一个负值并设置错误码\n\t\tperror(\"fork error\");\n\telse if(pid==0)//判断pid==0就是子进程\n\t\tprintf(\"I am child,my pid:%d\\n\",getpid());//getpid得到当前进程的进程号,getppid()是得到父进程的进程ID\n\telse if(pid>0)//如果pid>0是父进程\n\t\tprintf(\"I am father,my pid:%d\\n\",pid);//\n \n\tputs(\"hi \");//这里是父子进程都执行的部分,运行结果可以看到两个hi,\n\texit(0);\n}\n```\n\n```\n/*\n下面的程序调用了wait来为孩子收尸，这样再ps -aux会发现进程结束，没有尸体残留\n*/\n\nint main(){\n\tpid_t pid;//定义fork的返回值,存储在相同类型的变量pid中\n\tprintf(\"hello world\\n\");\n\tpid=fork();//fork创建子进程，将返回值给pid\n\tif(pid<0)//如果出错，fork返回一个负值并设置错误码\n\t\tperror(\"fork error\");\n\telse if(pid==0){//如果创建成功,在子进程中，返回的pid==0  是子进程\n\t\tprintf(\"I am child,my pid:%d\\n\",getpid());//getpid得到当前进程的进程号,getppid()得到父进程的进程号\n\t\tprintf(\"my father's pid:%d\\n\",getppid());\n\t}\n\telse if(pid>0){//如果pid>0是父进程，返回的pid 为创建的子进程的ID\n\t\tprintf(\"I am father,my son's pid:%d\\n\",pid);\n\t\tprintf(\"my pid:%d\\n\",getpid());\n\t\tint status;\n\t\tpid_t sonpid=wait(NULL);\n\t\tif(sonpid<0)puts(\"调用进程没有子进程\");\n\t\telse printf(\"等到了孩子的尸体，孩子进程号为:%d\\n\",sonpid);\n \n\t}\n\tputs(\"hi \");//这里是父子进程都执行的部分,运行结果可以看到两个hi,\n\texit(0);\n}\n\n//output\nhello world\nI am father,my son's pid:12345\nmy pid:6789\nhi \nI am child,my pid:12345\nmy father's pid:6789\nhi \n等到了孩子的尸体，孩子进程号为:12345\n```\n\n这个程序在子进程创建的时候，等于开了另一个main函数，用于执行这个函数指令，但是子进程不会重新创建子进程，只会执行子进程创建后的命令，比如进行函数判断和输出puts，而父进程也是会执行该操作，因此会输出两个hi\n\n### exec函数族\n\nexec函数族提供一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。\n`fork()` 创建一个子进程后，父进程和子进程共享同一个代码段（程序），但在有些情况下，我们希望子进程运行一个完全不同的程序，而不是继续执行父进程的代码。**子进程执行完新的程序后，它依然需要父进程wait收尸!!!**\n\nexec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。\n\n```\nexec函数族：execl 、execlp、execvp\nexec族函数参数极难记忆和分辨，函数名中的字符会给我们一些帮助： \nl : 使用参数列表 \np：使用文件名，并从PATH环境进行寻找可执行文件 ,自动搜索环境变量PATH\nv：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。 \ne：多了envp[]数组，使用新的环境变量代替调用进程的环境变量,表示自己维护环境变量\n```\n\n### 示例\n\n```\n//exec_test.c  中的代码，这个程序会在主函数中进程的子进程里面进行替换执行\n#include<stdio.h>\n#include <unistd.h>\nint main(){\n\tint i=0;\n\twhile(i<6){\n\t\tprintf(\"正在执行exec_test.out,此时i:%d\\n\",i++);\n\t\tsleep(1);\n\t}\n\treturn 0;\n}\n```\n\n```\n//exec.c  文件\n#include<stdio.h>\n#include<stdlib.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/wait.h>\n #include <unistd.h>\nint main(){\n\tprintf(\"这是刚开始的父进程,进程号:%d\\n\",getpid());\n\tpid_t pid=fork();//创建子进程\n\tif(pid<0){//判断是否成功\n\t\tperror(\"fork error\");\n\t}\n\telse if(pid==0){\n\t\tputs(\"接下来执行子进程\");\n\t\t//执行该语句的话，后续父进程的puts就不再执行\n\t\tint ret=execl(\"./exec_test.out\",\"exec_test.out\",NULL,NULL);//将子进程即将执行的程序进行替换\n\t\tif(ret<0)perror(\"exec error\");//判断是否失败，成功的话都无法来到这个指令\n\t\tputs(\"子进程执行结束\");//如果执行失败，则会输出该log\n\t}\n\telse if(pid>0){\n\t\tprintf(\"这是父进程,父进程pid:%d\\n\",getpid());\n\t\tprintf(\"我创建的子进程的pid:%d\\n\",pid);\n\t\tputs(\"接下来调用wait\");\n\t\t  pid_t sonpid=wait(NULL); \n        if(sonpid<0)puts(\"调用进程没有子进程\"); \n        else printf(\"等到了孩子的尸体，孩子进程号为:%d\\n\",sonpid);\n\t}\nputs(\"准备结束父进程\");\nreturn 0;\n}\n\n//output\n这是刚开始的父进程,进程号:4588\n这是父进程,父进程pid:4588\n创建的子进程的pid:4589\n接下来调用wait\n接下来执行子进程\n\n正在执行exec_test.out,此时i\n...\n...\n...\n\n等到了孩子的尸体，孩子进程号为:\n准备结束父进程\n```\n\n**有了exec函数族我们就可以用它来调用任何程序，也就是说，你还可以在C/C++，可以调用其他任何语言，比如python，Java等程序；**\n\n## 线程的创建和使用\n\n当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。\n\n### 线程创建函数\n\n```\n//创建一个线程\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void *), void *arg);\n//函数返回值：成功返回0；失败返回错误码\n\n参数解释：\n第一个参数：pthread_t *thread\n    pthread_t是类型，在linux下被定义为“unsigned long int”，是一种用于表示线程的数据类型；\n    phtread_t *thread:传递一个pthread_t类型的指针变量，也可以传递这个类型变量的地址\n第二个参数： const pthread_attr_t *attr\n    const pthread_attr_t：该类型以结构体的形式定义在<pthread.h>头文件中，专门表示线程的属性\n    const pthread_attr_t *attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\n \n第三个参数：void *(*start_routine)(void *)\n    以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void 类型。void 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\n    如果该函数有返回值，则线程执行完函数后，函数的返回值可以由 pthread_join() 函数接收\n第四个参数：void *arg\n    void *arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\n```\n\n### 线程退出函数\n\n```\n//线程退出函数\nvoid pthread_exit(void *retval);\n \n功能说明：主动结束当前线程（终止调用它的线程并返回一个指向某个对象的指针）\n \n参数：\n void *retval：函数的返回指针，只要pthread_join中的第二个参数retval不是NULL，这个值将被传递给retval\n```\n\n### 线程等待函数\n\n```\n//线程等待也叫阻塞\nint pthread_join(pthread_t thread, void **retval);\n\n功能说明：\n    这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回，可以理解为进程当中的wait收尸\n \n参数：\n    pthread_t thread  被等待的线程标识符\n    void **retval     一个用户定义的指针，它可以用来存储被等待线程的返回值\n返回值：\nOn success, pthread_join() returns 0; on error,  it  returns  an  error number.\n```\n\n### 示例\n\n```\n//以下是这三个函数的程序实例：\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<pthread.h>\nvoid *thread1fun(){\n\tputs(\"进入线程1\");\n\tputs(\"执行线程1\");\n\tputs(\"hello i am thread1\");\n\tchar *p=\"线程1已经退出，返回指针char *p\";\n\tpthread_exit(p);\n}\nvoid *thread2fun(){\n\tputs(\"进入线程2\");\n\tputs(\"执行线程2\");\n\tputs(\"hello i am thread2\");\n\tchar *p=\"线程2已经退出，返回指针char *p\";\n\tpthread_exit(p);\n}\nint main(){\n\tpthread_t thread1;\n\tpthread_t thread2;//定义两个线程类型变量\n\t//创建线程，开始执行其他线程函数thread1fun\n\tif(pthread_create(&thread1,NULL,thread1fun,NULL)!=0){//判断是否错误\n\t\tperror(\"thread1_create error\");\n\t\texit(1);\n\t}\n\telse {\n\t\tputs(\"线程1创建成功\");\n\t\tprintf(\"线程1线程号：%lu\\n\",thread1);\n\t}\n \t//创建线程，开始执行其他线程函数thread2fun\n\tif(pthread_create(&thread2,NULL,thread2fun,NULL)!=0){//判断是否错误\n\t\tperror(\"thread1_create error\");\n       exit(1);\n\t}\n\telse {\n\t\tputs(\"线程2创建成功\");\n\t\tprintf(\"线程2线程号：%lu\\n\",thread2);\n\t}\n\t\n    puts(\"阻塞等待回收线程\");\n    if(pthread_join(thread1,(void**)&thread1)==0){\n        puts(\"等到了，打印返回指针\");\n    \tputs((char*) *(&thread1));\n    }\n    if(pthread_join(thread2,(void **)&thread2)==0){\n        puts(\"等到了，打印返回指针\");\n    \tputs((char*) *(&thread2));\n    }\n    return 0;\n}\n\n//output\n线程1创建成功\n线程1线程号：<thread1的线程ID>\n线程2创建成功\n线程2线程号：<thread2的线程ID>\n进入线程1\n执行线程1\nhello i am thread1\n进入线程2\n执行线程2\nhello i am thread2\n阻塞等待回收线程\n等到了，打印返回指针\n线程1已经退出，返回指针char *p\n等到了，打印返回指针\n线程2已经退出，返回指针char *p\n```\n\n在执行线程1的时候，主函数和线程2仍然在执行。\n\n### 线程取消函数\n\n```\n//取消某个线程的执行\nint pthread_cancel(pthread_t thread);\n\n//返回值：成功返回0，否则返回perror\n//参数：要取消线程的标识符ID\n```\n\n### 获取线程当前ID\n\n```\n//获取当前调用线程的ID\npthread_t pthread_self(void);\n\n//返回值：当前线程的线程ID标识\n```\n\n## 线程互斥锁\n\n互斥锁的初始化和销毁：在使用互斥锁之前，需要先对其进行初始化，使用完毕后需要将其销毁。初始化可以使用 `pthread_mutex_init`() 函数，销毁可以使用 `pthread_mutex_destroy`() 函数。\n\n加锁和解锁的配对：在使用 `pthread_mutex_lock`() 和 `pthread_mutex_unlock`() 函数时，需要保证加锁和解锁的配对性，即每次加锁后都必须要对应的解锁。\n\n避免死锁：死锁是指两个或多个线程互相等待对方释放锁，导致程序无法继续执行。为了避免死锁，需要确保**加锁的顺序一致**，并且**不要在加锁的状态下等待其他锁。**\n\n不要重复加锁：重复加锁会导致线程阻塞，无法进行下去，需要注意避免。\n\n对共享资源的访问必须要在加锁状态下进行：为了确保多个线程访问共享资源的互斥性，需要在对共享资源进行访问之前，先获取对应的互斥锁，以避免多个线程同时访问共享资源。\n\n```\npthread_mutex_init()：用于初始化一个互斥锁。可以使用默认属性或者自定义属性进行初始化。\npthread_mutex_destroy()：用于销毁一个互斥锁，释放相关资源。\npthread_mutex_lock()：用于获取一个互斥锁，如果该锁已经被其他线程获取，则当前线程将阻塞，直到该锁被释放为止。\npthread_mutex_unlock()：用于释放一个互斥锁，如果该锁当前没有被任何线程获取，则此函数将返回一个错误。\n```\n\n## 线程锁（读写锁）\n\n上面是互斥锁，但是线程并不只有互斥锁，在实际的多线程编程中，我们应该选择合适的线程锁。\n\n互斥锁（Mutex）：互斥锁是一种二元锁，只有两个状态：锁定和未锁定。当一个线程持有互斥锁时，其他线程必须等待该线程释放锁之后才能继续执行。如果多个线程同时竞争锁，只有一个线程可以获得锁，其他线程将被阻塞，直到获得锁的线程释放锁。互斥锁提供了一种简单而有效的方法，用于确保多个线程之间对共享资源的互斥访问。\n\n读写锁（Reader-Writer Lock）：读写锁是一种更高效的锁，适用于读多写少的场景。读写锁允许多个线程同时读取共享资源，但是只有一个线程可以写入共享资源。当一个线程持有读锁时，其他线程也可以持有读锁，但是当一个线程持有写锁时，其他线程必须等待该线程释放写锁之后才能继续执行。读写锁的优点是在读取共享资源时可以允许多个线程同时进行，从而提高了程序的并发性和性能。\n\n自旋锁（Spin Lock）：自旋锁是一种非阻塞锁，线程在尝试获取锁时不会被挂起，而是一直循环尝试获取锁。当锁被其他线程持有时，线程会一直尝试获取锁，直到锁被释放。自旋锁适用于锁被持有时间很短的场景，因为在等待锁的过程中，线程会消耗大量的CPU资源。\n\n条件变量（Condition Variable）：条件变量用于在某个条件满足时通知等待线程。线程可以在条件变量上等待，直到满足条件后才被唤醒。条件变量通常与互斥锁一起使用，以确保在修改共享资源时不会出现竞态条件。\n\n信号量（Semaphore）：信号量是一种计数器，用于控制多个线程对共享资源的访问。当计数器大于零时，线程可以访问资源，并将计数器减一；当计数器等于零时，线程就必须等待。信号量可以用来实现读写锁和生产者-消费者模型等并发编程模型。\n\n```\n//此函数用于初始化读写锁对象。读写锁对象在使用前必须被初始化，可以使用静态初始化或者动态初始化。\npthread_rwlock_init()\nint pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);\n\n    rwlock：读写锁对象的指针。\n    attr：读写锁属性对象的指针，可以为NULL。\n    返回值：成功返回0，失败返回错误码。\n\n\n//获取读取锁，如果写入锁已经被占用，则函数会阻塞等待，直到写入锁被释放。多个线程可以同时获取读取锁。\npthread_rwlock_rdlock()\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数用于获取写入锁，如果读取锁或者写入锁已经被占用，则函数会阻塞等待，直到锁被释放。写入锁是独占的，只有一个线程可以获取写入锁。\npthread_rwlock_wrlock()\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数用于释放读取锁或者写入锁。如果锁没有被获取，释放锁会导致未定义的行为。\npthread_rwlock_unlock()\nint pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数尝试获取读取锁，如果读取锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行读取操作。\npthread_rwlock_tryrdlock()\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数尝试获取写入锁，如果读取锁或者写入锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行写入操作。\npthread_rwlock_trywrlock()\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数用于销毁读写锁\npthread_rwlock_destroy()\nint pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n```\n\n## 进程通信方式\n\n**管道（Pipe）：管道是一种半双工的通信方式，它只能用于父子进程或者兄弟进程之间的通信**。管道有两种类型：无名管道和命名管道。无名管道只存在于相关进程的内存中，而命名管道则存在于文件系统中，允许不相关的进程进行通信。\n\n**命名管道（Named Pipe）：命名管道允许不相关的进程进行通信。**它在文件系统中创建一个特殊文件，任何知道文件名的进程都可以通过文件访问方式进行通信。\n\n**信号（Signal）：信号是一种异步通信机制，用于通知进程发生了某些事件。**一个进程可以向另一个进程发送信号，另一个进程可以选择接受或忽略信号。\n\n**消息队列（Message Queue）：消息队列是一种存放在内核中的消息链表，用于不相关的进程间的通信。**进程可以向队列中发送消息，其他进程可以从队列中接收消息。\n\n**共享内存（Shared Memory）：共享内存允许多个进程访问同一块物理内存。**进程可以将数据写入共享内存区域，其他进程可以直接从该内存区域读取数据。\n\n**套接字（Socket）：套接字是一种通用的进程间通信方式，可用于不同主机之间的通信。**套接字提供了一组接口，进程可以使用这些接口来建立网络连接并进行通信。\n","source":"_posts/Work No.17.md","raw":"---\ntitle: Linux系统进程线程学习\ntag: 进程和线程\ndate: 2024-08-09\ncategories: Linux\nindex_img: https://s2.loli.net/2024/08/02/1PqnXLKIcmsuZzO.png\n---\n\n# Linux系统进程线程学习\n\n## 感谢博主\n\n[Linux之进程与线程详解(一文足矣)_linux下进程和线程-CSDN博客](https://blog.csdn.net/weixin_53447537/article/details/129372775)\n\n[进程和线程的区别(超详细)-CSDN博客](https://blog.csdn.net/ThinkWon/article/details/102021274)\n\n[进程、子进程、线程-CSDN博客](https://blog.csdn.net/msg1122/article/details/82911644)\n\n## 进程与线程的基本知识\n\n一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。\n\n进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。\n\n同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n\n进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位\n\nLinux 进程之间的通信和同步需要使用进程间通信机制（如**管道、信号、共享内存**等），因为它们之间是相互独立的。而线程之间可以直接共享进程的地址空间，因此它们之间的通信和同步要比进程更加高效。\n\n**在调试时，进程比线程更容易处理**。由于进程是相互独立的，因此可以分别调试每个进程，而线程共享进程的地址空间和资源，因此在调试线程时，需要特别注意线程之间的交互和影响，这使得调试线程变得更加困难。\n\n## 进程与线程的区别总结\n\n线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。\n\n**根本区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位\n\n**资源开销：**每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。\n\n**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。\n\n**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的\n\n**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。\n\n**执行过程：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行\n\n### 父进程、子进程、线程的区别\n\n在Windows下开一个IE浏览器，这个IE浏览器是一个进程。你用浏览器去打开一个pdf，IE就去调用Acrobat去打开，这时Acrobat是一个独立的进程，就是IE的子进程。而IE自己本身同时用同一个进程开了2个网页，并且同时在跑两个网页上的脚本，这两个网页的执行就是IE自己通过两个线程实现的。\n\n一个独立程序的运行称为一个进程， 在进程里并发执行的不同部分称为线程。 由这个进程引发的另外的独立程序运行为这个进程的子进程\n\n父进程还是可以通过和子进程通信来获得一些信息的。 拿上面的例子来说，IE可以通过一些进程间通信的接口来知道Acrobat是否顺利的把pdf打开了之类的信息。但有一点我觉得你的理解基本正确，就是父进程和子进程是独立的。假如IE开了一个病毒子进程，子进程不听话，父进程也没什么特别的办法，除了向系统申请去关闭它之外。\n\n## 进程创建和使用\n\n### 进程的创建函数\n\n```\n#include <sys/types.h>\n#include <unistd.h>\n\n//创建一个进程\npid_t fork(void);\n//在父进程中，fork返回新创建子进程的进程ID；\n//在子进程中，fork返回0；\n//如果出现错误，fork返回一个负值;\n\n//得到一个进程的父进程的PID;\ngetppid();\n//得到当前进程的PID;\ngetpid();\n```\n\nfork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。\n\n### 进程退出\n\n在main函数中使用 `return关键字` ，使用 `return` 后系统会调用 `exit()`函数来终止进程。或者调用 `_exit()` 来终止进程。\n\n_exit会立刻结束进程将缓存释放掉，而exit先查看当前进程有没有文件缓存区，如果有，会先处理缓存区的数据，然后释放内存\n\n```\nvoid _exit(int status);\n\nvoid exit(int status);\n//exit(0):表示运行正常结束进程；exit(1):表示异常退出，返回值1是给操作系统的\n```\n\nreturn 是关键字，是语言级别，表示调用堆栈的返回，并将控制权移交给控制的前一级；exit是函数，表示系统级别，表示进程的结束。\n\n### 子进程等待和销毁处理\n\n父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。\n\n```\n#include <sys/types.h>\n#include <sys/wait.h>\n\npid_t wait(int *wstatus);\n//正常情况下，wait的返回值为子进程的PID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD\n```\n\n当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.\n\n如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.\n\n参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，\n\n```\npid = wait(NULL);\n//如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。\n```\n\n如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中， 这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息 被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作\n\nWIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数\n\nWEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。\n\n```\n/*\n下面的程序没有调用wait函数，那么子进程会成为无父进程状态，也就是僵尸进程，可以根据程序运行后\n所打印的PID，然后命令行输 ps -aux 查看进程状态，\n发现这个子进程依然存在，所以要调用wait来进行所谓的收尸\n*/\n\nint main(){\n\tpid_t pid;//定义fork的返回值,存储在相同类型的变量pid中\n//如果创建成功，在父进程中fork返回新创建的子进程的进程号，在子进程中返回0\n\tprintf(\"hello world\\n\");\n\tpid=fork();//fork创建子进程，将返回值给pid\n\tif(pid<0)//如果出错，fork返回一个负值并设置错误码\n\t\tperror(\"fork error\");\n\telse if(pid==0)//判断pid==0就是子进程\n\t\tprintf(\"I am child,my pid:%d\\n\",getpid());//getpid得到当前进程的进程号,getppid()是得到父进程的进程ID\n\telse if(pid>0)//如果pid>0是父进程\n\t\tprintf(\"I am father,my pid:%d\\n\",pid);//\n \n\tputs(\"hi \");//这里是父子进程都执行的部分,运行结果可以看到两个hi,\n\texit(0);\n}\n```\n\n```\n/*\n下面的程序调用了wait来为孩子收尸，这样再ps -aux会发现进程结束，没有尸体残留\n*/\n\nint main(){\n\tpid_t pid;//定义fork的返回值,存储在相同类型的变量pid中\n\tprintf(\"hello world\\n\");\n\tpid=fork();//fork创建子进程，将返回值给pid\n\tif(pid<0)//如果出错，fork返回一个负值并设置错误码\n\t\tperror(\"fork error\");\n\telse if(pid==0){//如果创建成功,在子进程中，返回的pid==0  是子进程\n\t\tprintf(\"I am child,my pid:%d\\n\",getpid());//getpid得到当前进程的进程号,getppid()得到父进程的进程号\n\t\tprintf(\"my father's pid:%d\\n\",getppid());\n\t}\n\telse if(pid>0){//如果pid>0是父进程，返回的pid 为创建的子进程的ID\n\t\tprintf(\"I am father,my son's pid:%d\\n\",pid);\n\t\tprintf(\"my pid:%d\\n\",getpid());\n\t\tint status;\n\t\tpid_t sonpid=wait(NULL);\n\t\tif(sonpid<0)puts(\"调用进程没有子进程\");\n\t\telse printf(\"等到了孩子的尸体，孩子进程号为:%d\\n\",sonpid);\n \n\t}\n\tputs(\"hi \");//这里是父子进程都执行的部分,运行结果可以看到两个hi,\n\texit(0);\n}\n\n//output\nhello world\nI am father,my son's pid:12345\nmy pid:6789\nhi \nI am child,my pid:12345\nmy father's pid:6789\nhi \n等到了孩子的尸体，孩子进程号为:12345\n```\n\n这个程序在子进程创建的时候，等于开了另一个main函数，用于执行这个函数指令，但是子进程不会重新创建子进程，只会执行子进程创建后的命令，比如进行函数判断和输出puts，而父进程也是会执行该操作，因此会输出两个hi\n\n### exec函数族\n\nexec函数族提供一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。\n`fork()` 创建一个子进程后，父进程和子进程共享同一个代码段（程序），但在有些情况下，我们希望子进程运行一个完全不同的程序，而不是继续执行父进程的代码。**子进程执行完新的程序后，它依然需要父进程wait收尸!!!**\n\nexec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。\n\n```\nexec函数族：execl 、execlp、execvp\nexec族函数参数极难记忆和分辨，函数名中的字符会给我们一些帮助： \nl : 使用参数列表 \np：使用文件名，并从PATH环境进行寻找可执行文件 ,自动搜索环境变量PATH\nv：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。 \ne：多了envp[]数组，使用新的环境变量代替调用进程的环境变量,表示自己维护环境变量\n```\n\n### 示例\n\n```\n//exec_test.c  中的代码，这个程序会在主函数中进程的子进程里面进行替换执行\n#include<stdio.h>\n#include <unistd.h>\nint main(){\n\tint i=0;\n\twhile(i<6){\n\t\tprintf(\"正在执行exec_test.out,此时i:%d\\n\",i++);\n\t\tsleep(1);\n\t}\n\treturn 0;\n}\n```\n\n```\n//exec.c  文件\n#include<stdio.h>\n#include<stdlib.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/wait.h>\n #include <unistd.h>\nint main(){\n\tprintf(\"这是刚开始的父进程,进程号:%d\\n\",getpid());\n\tpid_t pid=fork();//创建子进程\n\tif(pid<0){//判断是否成功\n\t\tperror(\"fork error\");\n\t}\n\telse if(pid==0){\n\t\tputs(\"接下来执行子进程\");\n\t\t//执行该语句的话，后续父进程的puts就不再执行\n\t\tint ret=execl(\"./exec_test.out\",\"exec_test.out\",NULL,NULL);//将子进程即将执行的程序进行替换\n\t\tif(ret<0)perror(\"exec error\");//判断是否失败，成功的话都无法来到这个指令\n\t\tputs(\"子进程执行结束\");//如果执行失败，则会输出该log\n\t}\n\telse if(pid>0){\n\t\tprintf(\"这是父进程,父进程pid:%d\\n\",getpid());\n\t\tprintf(\"我创建的子进程的pid:%d\\n\",pid);\n\t\tputs(\"接下来调用wait\");\n\t\t  pid_t sonpid=wait(NULL); \n        if(sonpid<0)puts(\"调用进程没有子进程\"); \n        else printf(\"等到了孩子的尸体，孩子进程号为:%d\\n\",sonpid);\n\t}\nputs(\"准备结束父进程\");\nreturn 0;\n}\n\n//output\n这是刚开始的父进程,进程号:4588\n这是父进程,父进程pid:4588\n创建的子进程的pid:4589\n接下来调用wait\n接下来执行子进程\n\n正在执行exec_test.out,此时i\n...\n...\n...\n\n等到了孩子的尸体，孩子进程号为:\n准备结束父进程\n```\n\n**有了exec函数族我们就可以用它来调用任何程序，也就是说，你还可以在C/C++，可以调用其他任何语言，比如python，Java等程序；**\n\n## 线程的创建和使用\n\n当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。\n\n### 线程创建函数\n\n```\n//创建一个线程\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void *), void *arg);\n//函数返回值：成功返回0；失败返回错误码\n\n参数解释：\n第一个参数：pthread_t *thread\n    pthread_t是类型，在linux下被定义为“unsigned long int”，是一种用于表示线程的数据类型；\n    phtread_t *thread:传递一个pthread_t类型的指针变量，也可以传递这个类型变量的地址\n第二个参数： const pthread_attr_t *attr\n    const pthread_attr_t：该类型以结构体的形式定义在<pthread.h>头文件中，专门表示线程的属性\n    const pthread_attr_t *attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\n \n第三个参数：void *(*start_routine)(void *)\n    以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void 类型。void 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。\n    如果该函数有返回值，则线程执行完函数后，函数的返回值可以由 pthread_join() 函数接收\n第四个参数：void *arg\n    void *arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\n```\n\n### 线程退出函数\n\n```\n//线程退出函数\nvoid pthread_exit(void *retval);\n \n功能说明：主动结束当前线程（终止调用它的线程并返回一个指向某个对象的指针）\n \n参数：\n void *retval：函数的返回指针，只要pthread_join中的第二个参数retval不是NULL，这个值将被传递给retval\n```\n\n### 线程等待函数\n\n```\n//线程等待也叫阻塞\nint pthread_join(pthread_t thread, void **retval);\n\n功能说明：\n    这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回，可以理解为进程当中的wait收尸\n \n参数：\n    pthread_t thread  被等待的线程标识符\n    void **retval     一个用户定义的指针，它可以用来存储被等待线程的返回值\n返回值：\nOn success, pthread_join() returns 0; on error,  it  returns  an  error number.\n```\n\n### 示例\n\n```\n//以下是这三个函数的程序实例：\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<pthread.h>\nvoid *thread1fun(){\n\tputs(\"进入线程1\");\n\tputs(\"执行线程1\");\n\tputs(\"hello i am thread1\");\n\tchar *p=\"线程1已经退出，返回指针char *p\";\n\tpthread_exit(p);\n}\nvoid *thread2fun(){\n\tputs(\"进入线程2\");\n\tputs(\"执行线程2\");\n\tputs(\"hello i am thread2\");\n\tchar *p=\"线程2已经退出，返回指针char *p\";\n\tpthread_exit(p);\n}\nint main(){\n\tpthread_t thread1;\n\tpthread_t thread2;//定义两个线程类型变量\n\t//创建线程，开始执行其他线程函数thread1fun\n\tif(pthread_create(&thread1,NULL,thread1fun,NULL)!=0){//判断是否错误\n\t\tperror(\"thread1_create error\");\n\t\texit(1);\n\t}\n\telse {\n\t\tputs(\"线程1创建成功\");\n\t\tprintf(\"线程1线程号：%lu\\n\",thread1);\n\t}\n \t//创建线程，开始执行其他线程函数thread2fun\n\tif(pthread_create(&thread2,NULL,thread2fun,NULL)!=0){//判断是否错误\n\t\tperror(\"thread1_create error\");\n       exit(1);\n\t}\n\telse {\n\t\tputs(\"线程2创建成功\");\n\t\tprintf(\"线程2线程号：%lu\\n\",thread2);\n\t}\n\t\n    puts(\"阻塞等待回收线程\");\n    if(pthread_join(thread1,(void**)&thread1)==0){\n        puts(\"等到了，打印返回指针\");\n    \tputs((char*) *(&thread1));\n    }\n    if(pthread_join(thread2,(void **)&thread2)==0){\n        puts(\"等到了，打印返回指针\");\n    \tputs((char*) *(&thread2));\n    }\n    return 0;\n}\n\n//output\n线程1创建成功\n线程1线程号：<thread1的线程ID>\n线程2创建成功\n线程2线程号：<thread2的线程ID>\n进入线程1\n执行线程1\nhello i am thread1\n进入线程2\n执行线程2\nhello i am thread2\n阻塞等待回收线程\n等到了，打印返回指针\n线程1已经退出，返回指针char *p\n等到了，打印返回指针\n线程2已经退出，返回指针char *p\n```\n\n在执行线程1的时候，主函数和线程2仍然在执行。\n\n### 线程取消函数\n\n```\n//取消某个线程的执行\nint pthread_cancel(pthread_t thread);\n\n//返回值：成功返回0，否则返回perror\n//参数：要取消线程的标识符ID\n```\n\n### 获取线程当前ID\n\n```\n//获取当前调用线程的ID\npthread_t pthread_self(void);\n\n//返回值：当前线程的线程ID标识\n```\n\n## 线程互斥锁\n\n互斥锁的初始化和销毁：在使用互斥锁之前，需要先对其进行初始化，使用完毕后需要将其销毁。初始化可以使用 `pthread_mutex_init`() 函数，销毁可以使用 `pthread_mutex_destroy`() 函数。\n\n加锁和解锁的配对：在使用 `pthread_mutex_lock`() 和 `pthread_mutex_unlock`() 函数时，需要保证加锁和解锁的配对性，即每次加锁后都必须要对应的解锁。\n\n避免死锁：死锁是指两个或多个线程互相等待对方释放锁，导致程序无法继续执行。为了避免死锁，需要确保**加锁的顺序一致**，并且**不要在加锁的状态下等待其他锁。**\n\n不要重复加锁：重复加锁会导致线程阻塞，无法进行下去，需要注意避免。\n\n对共享资源的访问必须要在加锁状态下进行：为了确保多个线程访问共享资源的互斥性，需要在对共享资源进行访问之前，先获取对应的互斥锁，以避免多个线程同时访问共享资源。\n\n```\npthread_mutex_init()：用于初始化一个互斥锁。可以使用默认属性或者自定义属性进行初始化。\npthread_mutex_destroy()：用于销毁一个互斥锁，释放相关资源。\npthread_mutex_lock()：用于获取一个互斥锁，如果该锁已经被其他线程获取，则当前线程将阻塞，直到该锁被释放为止。\npthread_mutex_unlock()：用于释放一个互斥锁，如果该锁当前没有被任何线程获取，则此函数将返回一个错误。\n```\n\n## 线程锁（读写锁）\n\n上面是互斥锁，但是线程并不只有互斥锁，在实际的多线程编程中，我们应该选择合适的线程锁。\n\n互斥锁（Mutex）：互斥锁是一种二元锁，只有两个状态：锁定和未锁定。当一个线程持有互斥锁时，其他线程必须等待该线程释放锁之后才能继续执行。如果多个线程同时竞争锁，只有一个线程可以获得锁，其他线程将被阻塞，直到获得锁的线程释放锁。互斥锁提供了一种简单而有效的方法，用于确保多个线程之间对共享资源的互斥访问。\n\n读写锁（Reader-Writer Lock）：读写锁是一种更高效的锁，适用于读多写少的场景。读写锁允许多个线程同时读取共享资源，但是只有一个线程可以写入共享资源。当一个线程持有读锁时，其他线程也可以持有读锁，但是当一个线程持有写锁时，其他线程必须等待该线程释放写锁之后才能继续执行。读写锁的优点是在读取共享资源时可以允许多个线程同时进行，从而提高了程序的并发性和性能。\n\n自旋锁（Spin Lock）：自旋锁是一种非阻塞锁，线程在尝试获取锁时不会被挂起，而是一直循环尝试获取锁。当锁被其他线程持有时，线程会一直尝试获取锁，直到锁被释放。自旋锁适用于锁被持有时间很短的场景，因为在等待锁的过程中，线程会消耗大量的CPU资源。\n\n条件变量（Condition Variable）：条件变量用于在某个条件满足时通知等待线程。线程可以在条件变量上等待，直到满足条件后才被唤醒。条件变量通常与互斥锁一起使用，以确保在修改共享资源时不会出现竞态条件。\n\n信号量（Semaphore）：信号量是一种计数器，用于控制多个线程对共享资源的访问。当计数器大于零时，线程可以访问资源，并将计数器减一；当计数器等于零时，线程就必须等待。信号量可以用来实现读写锁和生产者-消费者模型等并发编程模型。\n\n```\n//此函数用于初始化读写锁对象。读写锁对象在使用前必须被初始化，可以使用静态初始化或者动态初始化。\npthread_rwlock_init()\nint pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);\n\n    rwlock：读写锁对象的指针。\n    attr：读写锁属性对象的指针，可以为NULL。\n    返回值：成功返回0，失败返回错误码。\n\n\n//获取读取锁，如果写入锁已经被占用，则函数会阻塞等待，直到写入锁被释放。多个线程可以同时获取读取锁。\npthread_rwlock_rdlock()\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数用于获取写入锁，如果读取锁或者写入锁已经被占用，则函数会阻塞等待，直到锁被释放。写入锁是独占的，只有一个线程可以获取写入锁。\npthread_rwlock_wrlock()\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数用于释放读取锁或者写入锁。如果锁没有被获取，释放锁会导致未定义的行为。\npthread_rwlock_unlock()\nint pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数尝试获取读取锁，如果读取锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行读取操作。\npthread_rwlock_tryrdlock()\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数尝试获取写入锁，如果读取锁或者写入锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行写入操作。\npthread_rwlock_trywrlock()\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n\n//此函数用于销毁读写锁\npthread_rwlock_destroy()\nint pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n\n    rwlock：读写锁对象的指针。\n    返回值：成功返回0，失败返回错误码。\n```\n\n## 进程通信方式\n\n**管道（Pipe）：管道是一种半双工的通信方式，它只能用于父子进程或者兄弟进程之间的通信**。管道有两种类型：无名管道和命名管道。无名管道只存在于相关进程的内存中，而命名管道则存在于文件系统中，允许不相关的进程进行通信。\n\n**命名管道（Named Pipe）：命名管道允许不相关的进程进行通信。**它在文件系统中创建一个特殊文件，任何知道文件名的进程都可以通过文件访问方式进行通信。\n\n**信号（Signal）：信号是一种异步通信机制，用于通知进程发生了某些事件。**一个进程可以向另一个进程发送信号，另一个进程可以选择接受或忽略信号。\n\n**消息队列（Message Queue）：消息队列是一种存放在内核中的消息链表，用于不相关的进程间的通信。**进程可以向队列中发送消息，其他进程可以从队列中接收消息。\n\n**共享内存（Shared Memory）：共享内存允许多个进程访问同一块物理内存。**进程可以将数据写入共享内存区域，其他进程可以直接从该内存区域读取数据。\n\n**套接字（Socket）：套接字是一种通用的进程间通信方式，可用于不同主机之间的通信。**套接字提供了一组接口，进程可以使用这些接口来建立网络连接并进行通信。\n","slug":"Work No.17","published":1,"updated":"2024-08-09T09:03:20.220Z","_id":"clzmh9t9t0000gsfbgtxabhdk","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Linux系统进程线程学习\"><a href=\"#Linux系统进程线程学习\" class=\"headerlink\" title=\"Linux系统进程线程学习\"></a>Linux系统进程线程学习</h1><h2 id=\"感谢博主\"><a href=\"#感谢博主\" class=\"headerlink\" title=\"感谢博主\"></a>感谢博主</h2><p><a href=\"https://blog.csdn.net/weixin_53447537/article/details/129372775\">Linux之进程与线程详解(一文足矣)_linux下进程和线程-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/ThinkWon/article/details/102021274\">进程和线程的区别(超详细)-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/msg1122/article/details/82911644\">进程、子进程、线程-CSDN博客</a></p>\n<h2 id=\"进程与线程的基本知识\"><a href=\"#进程与线程的基本知识\" class=\"headerlink\" title=\"进程与线程的基本知识\"></a>进程与线程的基本知识</h2><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p>\n<p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p>\n<p>同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>\n<p>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>\n<p>Linux 进程之间的通信和同步需要使用进程间通信机制（如<strong>管道、信号、共享内存</strong>等），因为它们之间是相互独立的。而线程之间可以直接共享进程的地址空间，因此它们之间的通信和同步要比进程更加高效。</p>\n<p><strong>在调试时，进程比线程更容易处理</strong>。由于进程是相互独立的，因此可以分别调试每个进程，而线程共享进程的地址空间和资源，因此在调试线程时，需要特别注意线程之间的交互和影响，这使得调试线程变得更加困难。</p>\n<h2 id=\"进程与线程的区别总结\"><a href=\"#进程与线程的区别总结\" class=\"headerlink\" title=\"进程与线程的区别总结\"></a>进程与线程的区别总结</h2><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>\n<p><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>\n<p><strong>资源开销：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>\n<p><strong>包含关系：</strong>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>\n<p><strong>内存分配：</strong>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p>\n<p><strong>影响关系：</strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>\n<p><strong>执行过程：</strong>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>\n<h3 id=\"父进程、子进程、线程的区别\"><a href=\"#父进程、子进程、线程的区别\" class=\"headerlink\" title=\"父进程、子进程、线程的区别\"></a>父进程、子进程、线程的区别</h3><p>在Windows下开一个IE浏览器，这个IE浏览器是一个进程。你用浏览器去打开一个pdf，IE就去调用Acrobat去打开，这时Acrobat是一个独立的进程，就是IE的子进程。而IE自己本身同时用同一个进程开了2个网页，并且同时在跑两个网页上的脚本，这两个网页的执行就是IE自己通过两个线程实现的。</p>\n<p>一个独立程序的运行称为一个进程， 在进程里并发执行的不同部分称为线程。 由这个进程引发的另外的独立程序运行为这个进程的子进程</p>\n<p>父进程还是可以通过和子进程通信来获得一些信息的。 拿上面的例子来说，IE可以通过一些进程间通信的接口来知道Acrobat是否顺利的把pdf打开了之类的信息。但有一点我觉得你的理解基本正确，就是父进程和子进程是独立的。假如IE开了一个病毒子进程，子进程不听话，父进程也没什么特别的办法，除了向系统申请去关闭它之外。</p>\n<h2 id=\"进程创建和使用\"><a href=\"#进程创建和使用\" class=\"headerlink\" title=\"进程创建和使用\"></a>进程创建和使用</h2><h3 id=\"进程的创建函数\"><a href=\"#进程的创建函数\" class=\"headerlink\" title=\"进程的创建函数\"></a>进程的创建函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/types.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><br><span class=\"hljs-comment\">//创建一个进程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">pid_t</span> <span class=\"hljs-title\">fork</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-comment\">//在父进程中，fork返回新创建子进程的进程ID；</span><br><span class=\"hljs-comment\">//在子进程中，fork返回0；</span><br><span class=\"hljs-comment\">//如果出现错误，fork返回一个负值;</span><br><br><span class=\"hljs-comment\">//得到一个进程的父进程的PID;</span><br><span class=\"hljs-built_in\">getppid</span>();<br><span class=\"hljs-comment\">//得到当前进程的PID;</span><br><span class=\"hljs-built_in\">getpid</span>();<br></code></pre></td></tr></table></figure>\n\n<p>fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>\n<h3 id=\"进程退出\"><a href=\"#进程退出\" class=\"headerlink\" title=\"进程退出\"></a>进程退出</h3><p>在main函数中使用 <code>return关键字</code> ，使用 <code>return</code> 后系统会调用 <code>exit()</code>函数来终止进程。或者调用 <code>_exit()</code> 来终止进程。</p>\n<p>_exit会立刻结束进程将缓存释放掉，而exit先查看当前进程有没有文件缓存区，如果有，会先处理缓存区的数据，然后释放内存</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">void _exit(int status);<br><br>void <span class=\"hljs-keyword\">exit</span>(int status);<br><span class=\"hljs-regexp\">//</span><span class=\"hljs-keyword\">exit</span>(<span class=\"hljs-number\">0</span>):表示运行正常结束进程；<span class=\"hljs-keyword\">exit</span>(<span class=\"hljs-number\">1</span>):表示异常退出，返回值<span class=\"hljs-number\">1</span>是给操作系统的<br></code></pre></td></tr></table></figure>\n\n<p>return 是关键字，是语言级别，表示调用堆栈的返回，并将控制权移交给控制的前一级；exit是函数，表示系统级别，表示进程的结束。</p>\n<h3 id=\"子进程等待和销毁处理\"><a href=\"#子进程等待和销毁处理\" class=\"headerlink\" title=\"子进程等待和销毁处理\"></a>子进程等待和销毁处理</h3><p>父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/types.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/wait.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">pid_t</span> <span class=\"hljs-title\">wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *wstatus)</span></span>;<br><span class=\"hljs-comment\">//正常情况下，wait的返回值为子进程的PID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD</span><br></code></pre></td></tr></table></figure>\n\n<p>当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.</p>\n<p>如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.</p>\n<p>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">pid = <span class=\"hljs-keyword\">wait</span>(NULL);<br><span class=\"hljs-regexp\">//</span>如果成功，<span class=\"hljs-keyword\">wait</span>会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时<span class=\"hljs-keyword\">wait</span>返回-<span class=\"hljs-number\">1</span>，同时errno被置为ECHILD。<br></code></pre></td></tr></table></figure>\n\n<p>如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中， 这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息 被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作</p>\n<p>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数</p>\n<p>WEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">/*<br>下面的程序没有调用wait函数，那么子进程会成为无父进程状态，也就是僵尸进程，可以根据程序运行后<br>所打印的PID，然后命令行输 ps -aux 查看进程状态，<br>发现这个子进程依然存在，所以要调用wait来进行所谓的收尸<br>*/<br><br>int main()&#123;<br>\tpid_t pid;<span class=\"hljs-regexp\">//</span>定义fork的返回值,存储在相同类型的变量pid中<br><span class=\"hljs-regexp\">//</span>如果创建成功，在父进程中fork返回新创建的子进程的进程号，在子进程中返回<span class=\"hljs-number\">0</span><br>\tprintf(<span class=\"hljs-string\">&quot;hello world\\n&quot;</span>);<br>\tpid=fork();<span class=\"hljs-regexp\">//</span>fork创建子进程，将返回值给pid<br>\t<span class=\"hljs-keyword\">if</span>(pid&lt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-regexp\">//</span>如果出错，fork返回一个负值并设置错误码<br>\t\tperror(<span class=\"hljs-string\">&quot;fork error&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid==<span class=\"hljs-number\">0</span>)<span class=\"hljs-regexp\">//</span>判断pid==<span class=\"hljs-number\">0</span>就是子进程<br>\t\tprintf(<span class=\"hljs-string\">&quot;I am child,my pid:%d\\n&quot;</span>,getpid());<span class=\"hljs-regexp\">//g</span>etpid得到当前进程的进程号,getppid()是得到父进程的进程ID<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid&gt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-regexp\">//</span>如果pid&gt;<span class=\"hljs-number\">0</span>是父进程<br>\t\tprintf(<span class=\"hljs-string\">&quot;I am father,my pid:%d\\n&quot;</span>,pid);<span class=\"hljs-regexp\">//</span><br> <br>\tputs(<span class=\"hljs-string\">&quot;hi &quot;</span>);<span class=\"hljs-regexp\">//</span>这里是父子进程都执行的部分,运行结果可以看到两个hi,<br>\t<span class=\"hljs-keyword\">exit</span>(<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">下面的程序调用了wait来为孩子收尸，这样再ps -aux会发现进程结束，没有尸体残留</span><br><span class=\"hljs-comment\">*/</span><br><br>int main()&#123;<br>\tpid_t pid;<span class=\"hljs-comment\">//定义fork的返回值,存储在相同类型的变量pid中</span><br>\tprintf(<span class=\"hljs-string\">&quot;hello world<span class=\"hljs-subst\">\\n</span>&quot;</span>);<br>\tpid<span class=\"hljs-operator\">=</span>fork();<span class=\"hljs-comment\">//fork创建子进程，将返回值给pid</span><br>\t<span class=\"hljs-keyword\">if</span>(pid<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-number\">0</span>)<span class=\"hljs-comment\">//如果出错，fork返回一个负值并设置错误码</span><br>\t\tperror(<span class=\"hljs-string\">&quot;fork error&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid<span class=\"hljs-operator\">==</span><span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//如果创建成功,在子进程中，返回的pid==0  是子进程</span><br>\t\tprintf(<span class=\"hljs-string\">&quot;I am child,my pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,getpid());<span class=\"hljs-comment\">//getpid得到当前进程的进程号,getppid()得到父进程的进程号</span><br>\t\tprintf(<span class=\"hljs-string\">&quot;my father&#x27;s pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,getppid());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid<span class=\"hljs-operator\">&gt;</span><span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//如果pid&gt;0是父进程，返回的pid 为创建的子进程的ID</span><br>\t\tprintf(<span class=\"hljs-string\">&quot;I am father,my son&#x27;s pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,pid);<br>\t\tprintf(<span class=\"hljs-string\">&quot;my pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,getpid());<br>\t\tint status;<br>\t\tpid_t sonpid<span class=\"hljs-operator\">=</span>wait(<span class=\"hljs-type\">NULL</span>);<br>\t\t<span class=\"hljs-keyword\">if</span>(sonpid<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-number\">0</span>)puts(<span class=\"hljs-string\">&quot;调用进程没有子进程&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span> printf(<span class=\"hljs-string\">&quot;等到了孩子的尸体，孩子进程号为:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,sonpid);<br> <br>\t&#125;<br>\tputs(<span class=\"hljs-string\">&quot;hi &quot;</span>);<span class=\"hljs-comment\">//这里是父子进程都执行的部分,运行结果可以看到两个hi,</span><br>\texit(<span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//output</span><br>hello world<br><span class=\"hljs-type\">I</span> am father,my son&#x27;s pid:<span class=\"hljs-number\">12345</span><br>my pid:<span class=\"hljs-number\">6789</span><br>hi <br><span class=\"hljs-type\">I</span> am child,my pid:<span class=\"hljs-number\">12345</span><br>my father&#x27;s pid:<span class=\"hljs-number\">6789</span><br>hi <br>等到了孩子的尸体，孩子进程号为:<span class=\"hljs-number\">12345</span><br></code></pre></td></tr></table></figure>\n\n<p>这个程序在子进程创建的时候，等于开了另一个main函数，用于执行这个函数指令，但是子进程不会重新创建子进程，只会执行子进程创建后的命令，比如进行函数判断和输出puts，而父进程也是会执行该操作，因此会输出两个hi</p>\n<h3 id=\"exec函数族\"><a href=\"#exec函数族\" class=\"headerlink\" title=\"exec函数族\"></a>exec函数族</h3><p>exec函数族提供一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。<br><code>fork()</code> 创建一个子进程后，父进程和子进程共享同一个代码段（程序），但在有些情况下，我们希望子进程运行一个完全不同的程序，而不是继续执行父进程的代码。<strong>子进程执行完新的程序后，它依然需要父进程wait收尸!!!</strong></p>\n<p>exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">exec</span>函数族：<span class=\"hljs-selector-tag\">execl</span> 、<span class=\"hljs-selector-tag\">execlp</span>、<span class=\"hljs-selector-tag\">execvp</span><br><span class=\"hljs-selector-tag\">exec</span>族函数参数极难记忆和分辨，函数名中的字符会给我们一些帮助： <br><span class=\"hljs-selector-tag\">l</span> : 使用参数列表 <br><span class=\"hljs-selector-tag\">p</span>：使用文件名，并从<span class=\"hljs-selector-tag\">PATH</span>环境进行寻找可执行文件 ,自动搜索环境变量<span class=\"hljs-selector-tag\">PATH</span><br><span class=\"hljs-selector-tag\">v</span>：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。 <br><span class=\"hljs-selector-tag\">e</span>：多了<span class=\"hljs-selector-tag\">envp</span><span class=\"hljs-selector-attr\">[]</span>数组，使用新的环境变量代替调用进程的环境变量,表示自己维护环境变量<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//exec_test.c  中的代码，这个程序会在主函数中进程的子进程里面进行替换执行</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span>(i&lt;<span class=\"hljs-number\">6</span>)&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;正在执行exec_test.out,此时i:%d\\n&quot;</span>,i++);<br>\t\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//exec.c  文件</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/types.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/wait.h&gt;</span></span><br> <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;这是刚开始的父进程,进程号:%d\\n&quot;</span>,<span class=\"hljs-built_in\">getpid</span>());<br>\t<span class=\"hljs-type\">pid_t</span> pid=fork();<span class=\"hljs-comment\">//创建子进程</span><br>\t<span class=\"hljs-keyword\">if</span>(pid&lt;<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//判断是否成功</span><br>\t\t<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;fork error&quot;</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid==<span class=\"hljs-number\">0</span>)&#123;<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;接下来执行子进程&quot;</span>);<br>\t\t<span class=\"hljs-comment\">//执行该语句的话，后续父进程的puts就不再执行</span><br>\t\t<span class=\"hljs-type\">int</span> ret=<span class=\"hljs-built_in\">execl</span>(<span class=\"hljs-string\">&quot;./exec_test.out&quot;</span>,<span class=\"hljs-string\">&quot;exec_test.out&quot;</span>,<span class=\"hljs-literal\">NULL</span>,<span class=\"hljs-literal\">NULL</span>);<span class=\"hljs-comment\">//将子进程即将执行的程序进行替换</span><br>\t\t<span class=\"hljs-keyword\">if</span>(ret&lt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;exec error&quot;</span>);<span class=\"hljs-comment\">//判断是否失败，成功的话都无法来到这个指令</span><br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;子进程执行结束&quot;</span>);<span class=\"hljs-comment\">//如果执行失败，则会输出该log</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid&gt;<span class=\"hljs-number\">0</span>)&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;这是父进程,父进程pid:%d\\n&quot;</span>,<span class=\"hljs-built_in\">getpid</span>());<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;我创建的子进程的pid:%d\\n&quot;</span>,pid);<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;接下来调用wait&quot;</span>);<br>\t\t  <span class=\"hljs-type\">pid_t</span> sonpid=<span class=\"hljs-built_in\">wait</span>(<span class=\"hljs-literal\">NULL</span>); <br>        <span class=\"hljs-keyword\">if</span>(sonpid&lt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;调用进程没有子进程&quot;</span>); <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;等到了孩子的尸体，孩子进程号为:%d\\n&quot;</span>,sonpid);<br>\t&#125;<br><span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;准备结束父进程&quot;</span>);<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//output</span><br>这是刚开始的父进程,进程号:<span class=\"hljs-number\">4588</span><br>这是父进程,父进程pid:<span class=\"hljs-number\">4588</span><br>创建的子进程的pid:<span class=\"hljs-number\">4589</span><br>接下来调用wait<br>接下来执行子进程<br><br>正在执行exec_test.out,此时i<br>...<br>...<br>...<br><br>等到了孩子的尸体，孩子进程号为:<br>准备结束父进程<br></code></pre></td></tr></table></figure>\n\n<p><strong>有了exec函数族我们就可以用它来调用任何程序，也就是说，你还可以在C&#x2F;C++，可以调用其他任何语言，比如python，Java等程序；</strong></p>\n<h2 id=\"线程的创建和使用\"><a href=\"#线程的创建和使用\" class=\"headerlink\" title=\"线程的创建和使用\"></a>线程的创建和使用</h2><p>当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p>\n<h3 id=\"线程创建函数\"><a href=\"#线程创建函数\" class=\"headerlink\" title=\"线程创建函数\"></a>线程创建函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//创建一个线程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pthread_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">pthread_t</span> *thread, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span> *attr,<span class=\"hljs-type\">void</span> *(*start_routine)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *arg)</span></span>;<br><span class=\"hljs-comment\">//函数返回值：成功返回0；失败返回错误码</span><br><br>参数解释：<br>第一个参数：<span class=\"hljs-type\">pthread_t</span> *thread<br>    <span class=\"hljs-type\">pthread_t</span>是类型，在linux下被定义为“<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span>”，是一种用于表示线程的数据类型；<br>    <span class=\"hljs-type\">phtread_t</span> *thread:传递一个<span class=\"hljs-type\">pthread_t</span>类型的指针变量，也可以传递这个类型变量的地址<br>第二个参数： <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span> *attr<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span>：该类型以结构体的形式定义在&lt;pthread.h&gt;头文件中，专门表示线程的属性<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span> *attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 <span class=\"hljs-literal\">NULL</span>，<span class=\"hljs-built_in\">pthread_create</span>() 函数会采用系统默认的属性值创建线程。<br> <br>第三个参数：<span class=\"hljs-type\">void</span> *(*start_routine)(<span class=\"hljs-type\">void</span> *)<br>    以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 <span class=\"hljs-number\">1</span> 个（可以省略不写），形参和返回值的类型都必须为 <span class=\"hljs-type\">void</span> 类型。<span class=\"hljs-type\">void</span> 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。<br>    如果该函数有返回值，则线程执行完函数后，函数的返回值可以由 <span class=\"hljs-built_in\">pthread_join</span>() 函数接收<br>第四个参数：<span class=\"hljs-type\">void</span> *arg<br>    <span class=\"hljs-type\">void</span> *arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 <span class=\"hljs-literal\">NULL</span> 即可。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"线程退出函数\"><a href=\"#线程退出函数\" class=\"headerlink\" title=\"线程退出函数\"></a>线程退出函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//线程退出函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pthread_exit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *retval)</span></span>;<br> <br>功能说明：主动结束当前线程（终止调用它的线程并返回一个指向某个对象的指针）<br> <br>参数：<br> <span class=\"hljs-type\">void</span> *retval：函数的返回指针，只要pthread_join中的第二个参数retval不是<span class=\"hljs-literal\">NULL</span>，这个值将被传递给retval<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"线程等待函数\"><a href=\"#线程等待函数\" class=\"headerlink\" title=\"线程等待函数\"></a>线程等待函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//线程等待也叫阻塞</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pthread_join</span><span class=\"hljs-params\">(<span class=\"hljs-type\">pthread_t</span> thread, <span class=\"hljs-type\">void</span> **retval)</span></span>;<br><br>功能说明：<br>    这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回，可以理解为进程当中的wait收尸<br> <br>参数：<br>    <span class=\"hljs-type\">pthread_t</span> thread  被等待的线程标识符<br>    <span class=\"hljs-type\">void</span> **retval     一个用户定义的指针，它可以用来存储被等待线程的返回值<br>返回值：<br>On success, <span class=\"hljs-built_in\">pthread_join</span>() returns <span class=\"hljs-number\">0</span>; on error,  it  returns  an  error number.<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//以下是这三个函数的程序实例：</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;pthread.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title\">thread1fun</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;进入线程1&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;执行线程1&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;hello i am thread1&quot;</span>);<br>\t<span class=\"hljs-type\">char</span> *p=<span class=\"hljs-string\">&quot;线程1已经退出，返回指针char *p&quot;</span>;<br>\t<span class=\"hljs-built_in\">pthread_exit</span>(p);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title\">thread2fun</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;进入线程2&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;执行线程2&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;hello i am thread2&quot;</span>);<br>\t<span class=\"hljs-type\">char</span> *p=<span class=\"hljs-string\">&quot;线程2已经退出，返回指针char *p&quot;</span>;<br>\t<span class=\"hljs-built_in\">pthread_exit</span>(p);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">pthread_t</span> thread1;<br>\t<span class=\"hljs-type\">pthread_t</span> thread2;<span class=\"hljs-comment\">//定义两个线程类型变量</span><br>\t<span class=\"hljs-comment\">//创建线程，开始执行其他线程函数thread1fun</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_create</span>(&amp;thread1,<span class=\"hljs-literal\">NULL</span>,thread1fun,<span class=\"hljs-literal\">NULL</span>)!=<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//判断是否错误</span><br>\t\t<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;thread1_create error&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;线程1创建成功&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;线程1线程号：%lu\\n&quot;</span>,thread1);<br>\t&#125;<br> \t<span class=\"hljs-comment\">//创建线程，开始执行其他线程函数thread2fun</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_create</span>(&amp;thread2,<span class=\"hljs-literal\">NULL</span>,thread2fun,<span class=\"hljs-literal\">NULL</span>)!=<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//判断是否错误</span><br>\t\t<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;thread1_create error&quot;</span>);<br>       <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;线程2创建成功&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;线程2线程号：%lu\\n&quot;</span>,thread2);<br>\t&#125;<br>\t<br>    <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;阻塞等待回收线程&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_join</span>(thread1,(<span class=\"hljs-type\">void</span>**)&amp;thread1)==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;等到了，打印返回指针&quot;</span>);<br>    \t<span class=\"hljs-built_in\">puts</span>((<span class=\"hljs-type\">char</span>*) *(&amp;thread1));<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_join</span>(thread2,(<span class=\"hljs-type\">void</span> **)&amp;thread2)==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;等到了，打印返回指针&quot;</span>);<br>    \t<span class=\"hljs-built_in\">puts</span>((<span class=\"hljs-type\">char</span>*) *(&amp;thread2));<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//output</span><br>线程<span class=\"hljs-number\">1</span>创建成功<br>线程<span class=\"hljs-number\">1</span>线程号：&lt;thread1的线程ID&gt;<br>线程<span class=\"hljs-number\">2</span>创建成功<br>线程<span class=\"hljs-number\">2</span>线程号：&lt;thread2的线程ID&gt;<br>进入线程<span class=\"hljs-number\">1</span><br>执行线程<span class=\"hljs-number\">1</span><br>hello i am thread1<br>进入线程<span class=\"hljs-number\">2</span><br>执行线程<span class=\"hljs-number\">2</span><br>hello i am thread2<br>阻塞等待回收线程<br>等到了，打印返回指针<br>线程<span class=\"hljs-number\">1</span>已经退出，返回指针<span class=\"hljs-type\">char</span> *p<br>等到了，打印返回指针<br>线程<span class=\"hljs-number\">2</span>已经退出，返回指针<span class=\"hljs-type\">char</span> *p<br></code></pre></td></tr></table></figure>\n\n<p>在执行线程1的时候，主函数和线程2仍然在执行。</p>\n<h3 id=\"线程取消函数\"><a href=\"#线程取消函数\" class=\"headerlink\" title=\"线程取消函数\"></a>线程取消函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//取消某个线程的执行</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pthread_cancel</span><span class=\"hljs-params\">(<span class=\"hljs-type\">pthread_t</span> thread)</span></span>;<br><br><span class=\"hljs-comment\">//返回值：成功返回0，否则返回perror</span><br><span class=\"hljs-comment\">//参数：要取消线程的标识符ID</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"获取线程当前ID\"><a href=\"#获取线程当前ID\" class=\"headerlink\" title=\"获取线程当前ID\"></a>获取线程当前ID</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//获取当前调用线程的ID</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">pthread_t</span> <span class=\"hljs-title\">pthread_self</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">//返回值：当前线程的线程ID标识</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"线程互斥锁\"><a href=\"#线程互斥锁\" class=\"headerlink\" title=\"线程互斥锁\"></a>线程互斥锁</h2><p>互斥锁的初始化和销毁：在使用互斥锁之前，需要先对其进行初始化，使用完毕后需要将其销毁。初始化可以使用 <code>pthread_mutex_init</code>() 函数，销毁可以使用 <code>pthread_mutex_destroy</code>() 函数。</p>\n<p>加锁和解锁的配对：在使用 <code>pthread_mutex_lock</code>() 和 <code>pthread_mutex_unlock</code>() 函数时，需要保证加锁和解锁的配对性，即每次加锁后都必须要对应的解锁。</p>\n<p>避免死锁：死锁是指两个或多个线程互相等待对方释放锁，导致程序无法继续执行。为了避免死锁，需要确保<strong>加锁的顺序一致</strong>，并且<strong>不要在加锁的状态下等待其他锁。</strong></p>\n<p>不要重复加锁：重复加锁会导致线程阻塞，无法进行下去，需要注意避免。</p>\n<p>对共享资源的访问必须要在加锁状态下进行：为了确保多个线程访问共享资源的互斥性，需要在对共享资源进行访问之前，先获取对应的互斥锁，以避免多个线程同时访问共享资源。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_init</span><span class=\"hljs-params\">()</span></span>：用于初始化一个互斥锁。可以使用默认属性或者自定义属性进行初始化。<br><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_destroy</span><span class=\"hljs-params\">()</span></span>：用于销毁一个互斥锁，释放相关资源。<br><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_lock</span><span class=\"hljs-params\">()</span></span>：用于获取一个互斥锁，如果该锁已经被其他线程获取，则当前线程将阻塞，直到该锁被释放为止。<br><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_unlock</span><span class=\"hljs-params\">()</span></span>：用于释放一个互斥锁，如果该锁当前没有被任何线程获取，则此函数将返回一个错误。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"线程锁（读写锁）\"><a href=\"#线程锁（读写锁）\" class=\"headerlink\" title=\"线程锁（读写锁）\"></a>线程锁（读写锁）</h2><p>上面是互斥锁，但是线程并不只有互斥锁，在实际的多线程编程中，我们应该选择合适的线程锁。</p>\n<p>互斥锁（Mutex）：互斥锁是一种二元锁，只有两个状态：锁定和未锁定。当一个线程持有互斥锁时，其他线程必须等待该线程释放锁之后才能继续执行。如果多个线程同时竞争锁，只有一个线程可以获得锁，其他线程将被阻塞，直到获得锁的线程释放锁。互斥锁提供了一种简单而有效的方法，用于确保多个线程之间对共享资源的互斥访问。</p>\n<p>读写锁（Reader-Writer Lock）：读写锁是一种更高效的锁，适用于读多写少的场景。读写锁允许多个线程同时读取共享资源，但是只有一个线程可以写入共享资源。当一个线程持有读锁时，其他线程也可以持有读锁，但是当一个线程持有写锁时，其他线程必须等待该线程释放写锁之后才能继续执行。读写锁的优点是在读取共享资源时可以允许多个线程同时进行，从而提高了程序的并发性和性能。</p>\n<p>自旋锁（Spin Lock）：自旋锁是一种非阻塞锁，线程在尝试获取锁时不会被挂起，而是一直循环尝试获取锁。当锁被其他线程持有时，线程会一直尝试获取锁，直到锁被释放。自旋锁适用于锁被持有时间很短的场景，因为在等待锁的过程中，线程会消耗大量的CPU资源。</p>\n<p>条件变量（Condition Variable）：条件变量用于在某个条件满足时通知等待线程。线程可以在条件变量上等待，直到满足条件后才被唤醒。条件变量通常与互斥锁一起使用，以确保在修改共享资源时不会出现竞态条件。</p>\n<p>信号量（Semaphore）：信号量是一种计数器，用于控制多个线程对共享资源的访问。当计数器大于零时，线程可以访问资源，并将计数器减一；当计数器等于零时，线程就必须等待。信号量可以用来实现读写锁和生产者-消费者模型等并发编程模型。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//此函数用于初始化读写锁对象。读写锁对象在使用前必须被初始化，可以使用静态初始化或者动态初始化。</span><br><span class=\"hljs-built_in\">pthread_rwlock_init</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_init</span>(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);<br><br>    rwlock：读写锁对象的指针。<br>    attr：读写锁属性对象的指针，可以为NULL。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><br><span class=\"hljs-comment\">//获取读取锁，如果写入锁已经被占用，则函数会阻塞等待，直到写入锁被释放。多个线程可以同时获取读取锁。</span><br><span class=\"hljs-built_in\">pthread_rwlock_rdlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_rdlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数用于获取写入锁，如果读取锁或者写入锁已经被占用，则函数会阻塞等待，直到锁被释放。写入锁是独占的，只有一个线程可以获取写入锁。</span><br><span class=\"hljs-built_in\">pthread_rwlock_wrlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_wrlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数用于释放读取锁或者写入锁。如果锁没有被获取，释放锁会导致未定义的行为。</span><br><span class=\"hljs-built_in\">pthread_rwlock_unlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_unlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数尝试获取读取锁，如果读取锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行读取操作。</span><br><span class=\"hljs-built_in\">pthread_rwlock_tryrdlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_tryrdlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数尝试获取写入锁，如果读取锁或者写入锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行写入操作。</span><br><span class=\"hljs-built_in\">pthread_rwlock_trywrlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_trywrlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数用于销毁读写锁</span><br><span class=\"hljs-built_in\">pthread_rwlock_destroy</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_destroy</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"进程通信方式\"><a href=\"#进程通信方式\" class=\"headerlink\" title=\"进程通信方式\"></a>进程通信方式</h2><p><strong>管道（Pipe）：管道是一种半双工的通信方式，它只能用于父子进程或者兄弟进程之间的通信</strong>。管道有两种类型：无名管道和命名管道。无名管道只存在于相关进程的内存中，而命名管道则存在于文件系统中，允许不相关的进程进行通信。</p>\n<p><strong>命名管道（Named Pipe）：命名管道允许不相关的进程进行通信。</strong>它在文件系统中创建一个特殊文件，任何知道文件名的进程都可以通过文件访问方式进行通信。</p>\n<p><strong>信号（Signal）：信号是一种异步通信机制，用于通知进程发生了某些事件。</strong>一个进程可以向另一个进程发送信号，另一个进程可以选择接受或忽略信号。</p>\n<p><strong>消息队列（Message Queue）：消息队列是一种存放在内核中的消息链表，用于不相关的进程间的通信。</strong>进程可以向队列中发送消息，其他进程可以从队列中接收消息。</p>\n<p><strong>共享内存（Shared Memory）：共享内存允许多个进程访问同一块物理内存。</strong>进程可以将数据写入共享内存区域，其他进程可以直接从该内存区域读取数据。</p>\n<p><strong>套接字（Socket）：套接字是一种通用的进程间通信方式，可用于不同主机之间的通信。</strong>套接字提供了一组接口，进程可以使用这些接口来建立网络连接并进行通信。</p>\n","excerpt":"","more":"<h1 id=\"Linux系统进程线程学习\"><a href=\"#Linux系统进程线程学习\" class=\"headerlink\" title=\"Linux系统进程线程学习\"></a>Linux系统进程线程学习</h1><h2 id=\"感谢博主\"><a href=\"#感谢博主\" class=\"headerlink\" title=\"感谢博主\"></a>感谢博主</h2><p><a href=\"https://blog.csdn.net/weixin_53447537/article/details/129372775\">Linux之进程与线程详解(一文足矣)_linux下进程和线程-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/ThinkWon/article/details/102021274\">进程和线程的区别(超详细)-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/msg1122/article/details/82911644\">进程、子进程、线程-CSDN博客</a></p>\n<h2 id=\"进程与线程的基本知识\"><a href=\"#进程与线程的基本知识\" class=\"headerlink\" title=\"进程与线程的基本知识\"></a>进程与线程的基本知识</h2><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p>\n<p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p>\n<p>同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>\n<p>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>\n<p>Linux 进程之间的通信和同步需要使用进程间通信机制（如<strong>管道、信号、共享内存</strong>等），因为它们之间是相互独立的。而线程之间可以直接共享进程的地址空间，因此它们之间的通信和同步要比进程更加高效。</p>\n<p><strong>在调试时，进程比线程更容易处理</strong>。由于进程是相互独立的，因此可以分别调试每个进程，而线程共享进程的地址空间和资源，因此在调试线程时，需要特别注意线程之间的交互和影响，这使得调试线程变得更加困难。</p>\n<h2 id=\"进程与线程的区别总结\"><a href=\"#进程与线程的区别总结\" class=\"headerlink\" title=\"进程与线程的区别总结\"></a>进程与线程的区别总结</h2><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>\n<p><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>\n<p><strong>资源开销：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>\n<p><strong>包含关系：</strong>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>\n<p><strong>内存分配：</strong>同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p>\n<p><strong>影响关系：</strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>\n<p><strong>执行过程：</strong>每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>\n<h3 id=\"父进程、子进程、线程的区别\"><a href=\"#父进程、子进程、线程的区别\" class=\"headerlink\" title=\"父进程、子进程、线程的区别\"></a>父进程、子进程、线程的区别</h3><p>在Windows下开一个IE浏览器，这个IE浏览器是一个进程。你用浏览器去打开一个pdf，IE就去调用Acrobat去打开，这时Acrobat是一个独立的进程，就是IE的子进程。而IE自己本身同时用同一个进程开了2个网页，并且同时在跑两个网页上的脚本，这两个网页的执行就是IE自己通过两个线程实现的。</p>\n<p>一个独立程序的运行称为一个进程， 在进程里并发执行的不同部分称为线程。 由这个进程引发的另外的独立程序运行为这个进程的子进程</p>\n<p>父进程还是可以通过和子进程通信来获得一些信息的。 拿上面的例子来说，IE可以通过一些进程间通信的接口来知道Acrobat是否顺利的把pdf打开了之类的信息。但有一点我觉得你的理解基本正确，就是父进程和子进程是独立的。假如IE开了一个病毒子进程，子进程不听话，父进程也没什么特别的办法，除了向系统申请去关闭它之外。</p>\n<h2 id=\"进程创建和使用\"><a href=\"#进程创建和使用\" class=\"headerlink\" title=\"进程创建和使用\"></a>进程创建和使用</h2><h3 id=\"进程的创建函数\"><a href=\"#进程的创建函数\" class=\"headerlink\" title=\"进程的创建函数\"></a>进程的创建函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/types.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><br><span class=\"hljs-comment\">//创建一个进程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">pid_t</span> <span class=\"hljs-title\">fork</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-comment\">//在父进程中，fork返回新创建子进程的进程ID；</span><br><span class=\"hljs-comment\">//在子进程中，fork返回0；</span><br><span class=\"hljs-comment\">//如果出现错误，fork返回一个负值;</span><br><br><span class=\"hljs-comment\">//得到一个进程的父进程的PID;</span><br><span class=\"hljs-built_in\">getppid</span>();<br><span class=\"hljs-comment\">//得到当前进程的PID;</span><br><span class=\"hljs-built_in\">getpid</span>();<br></code></pre></td></tr></table></figure>\n\n<p>fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>\n<h3 id=\"进程退出\"><a href=\"#进程退出\" class=\"headerlink\" title=\"进程退出\"></a>进程退出</h3><p>在main函数中使用 <code>return关键字</code> ，使用 <code>return</code> 后系统会调用 <code>exit()</code>函数来终止进程。或者调用 <code>_exit()</code> 来终止进程。</p>\n<p>_exit会立刻结束进程将缓存释放掉，而exit先查看当前进程有没有文件缓存区，如果有，会先处理缓存区的数据，然后释放内存</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">void _exit(int status);<br><br>void <span class=\"hljs-keyword\">exit</span>(int status);<br><span class=\"hljs-regexp\">//</span><span class=\"hljs-keyword\">exit</span>(<span class=\"hljs-number\">0</span>):表示运行正常结束进程；<span class=\"hljs-keyword\">exit</span>(<span class=\"hljs-number\">1</span>):表示异常退出，返回值<span class=\"hljs-number\">1</span>是给操作系统的<br></code></pre></td></tr></table></figure>\n\n<p>return 是关键字，是语言级别，表示调用堆栈的返回，并将控制权移交给控制的前一级；exit是函数，表示系统级别，表示进程的结束。</p>\n<h3 id=\"子进程等待和销毁处理\"><a href=\"#子进程等待和销毁处理\" class=\"headerlink\" title=\"子进程等待和销毁处理\"></a>子进程等待和销毁处理</h3><p>父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/types.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/wait.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">pid_t</span> <span class=\"hljs-title\">wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *wstatus)</span></span>;<br><span class=\"hljs-comment\">//正常情况下，wait的返回值为子进程的PID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD</span><br></code></pre></td></tr></table></figure>\n\n<p>当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.</p>\n<p>如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.</p>\n<p>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">pid = <span class=\"hljs-keyword\">wait</span>(NULL);<br><span class=\"hljs-regexp\">//</span>如果成功，<span class=\"hljs-keyword\">wait</span>会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时<span class=\"hljs-keyword\">wait</span>返回-<span class=\"hljs-number\">1</span>，同时errno被置为ECHILD。<br></code></pre></td></tr></table></figure>\n\n<p>如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中， 这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息 被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作</p>\n<p>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数</p>\n<p>WEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">/*<br>下面的程序没有调用wait函数，那么子进程会成为无父进程状态，也就是僵尸进程，可以根据程序运行后<br>所打印的PID，然后命令行输 ps -aux 查看进程状态，<br>发现这个子进程依然存在，所以要调用wait来进行所谓的收尸<br>*/<br><br>int main()&#123;<br>\tpid_t pid;<span class=\"hljs-regexp\">//</span>定义fork的返回值,存储在相同类型的变量pid中<br><span class=\"hljs-regexp\">//</span>如果创建成功，在父进程中fork返回新创建的子进程的进程号，在子进程中返回<span class=\"hljs-number\">0</span><br>\tprintf(<span class=\"hljs-string\">&quot;hello world\\n&quot;</span>);<br>\tpid=fork();<span class=\"hljs-regexp\">//</span>fork创建子进程，将返回值给pid<br>\t<span class=\"hljs-keyword\">if</span>(pid&lt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-regexp\">//</span>如果出错，fork返回一个负值并设置错误码<br>\t\tperror(<span class=\"hljs-string\">&quot;fork error&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid==<span class=\"hljs-number\">0</span>)<span class=\"hljs-regexp\">//</span>判断pid==<span class=\"hljs-number\">0</span>就是子进程<br>\t\tprintf(<span class=\"hljs-string\">&quot;I am child,my pid:%d\\n&quot;</span>,getpid());<span class=\"hljs-regexp\">//g</span>etpid得到当前进程的进程号,getppid()是得到父进程的进程ID<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid&gt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-regexp\">//</span>如果pid&gt;<span class=\"hljs-number\">0</span>是父进程<br>\t\tprintf(<span class=\"hljs-string\">&quot;I am father,my pid:%d\\n&quot;</span>,pid);<span class=\"hljs-regexp\">//</span><br> <br>\tputs(<span class=\"hljs-string\">&quot;hi &quot;</span>);<span class=\"hljs-regexp\">//</span>这里是父子进程都执行的部分,运行结果可以看到两个hi,<br>\t<span class=\"hljs-keyword\">exit</span>(<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">下面的程序调用了wait来为孩子收尸，这样再ps -aux会发现进程结束，没有尸体残留</span><br><span class=\"hljs-comment\">*/</span><br><br>int main()&#123;<br>\tpid_t pid;<span class=\"hljs-comment\">//定义fork的返回值,存储在相同类型的变量pid中</span><br>\tprintf(<span class=\"hljs-string\">&quot;hello world<span class=\"hljs-subst\">\\n</span>&quot;</span>);<br>\tpid<span class=\"hljs-operator\">=</span>fork();<span class=\"hljs-comment\">//fork创建子进程，将返回值给pid</span><br>\t<span class=\"hljs-keyword\">if</span>(pid<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-number\">0</span>)<span class=\"hljs-comment\">//如果出错，fork返回一个负值并设置错误码</span><br>\t\tperror(<span class=\"hljs-string\">&quot;fork error&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid<span class=\"hljs-operator\">==</span><span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//如果创建成功,在子进程中，返回的pid==0  是子进程</span><br>\t\tprintf(<span class=\"hljs-string\">&quot;I am child,my pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,getpid());<span class=\"hljs-comment\">//getpid得到当前进程的进程号,getppid()得到父进程的进程号</span><br>\t\tprintf(<span class=\"hljs-string\">&quot;my father&#x27;s pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,getppid());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid<span class=\"hljs-operator\">&gt;</span><span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//如果pid&gt;0是父进程，返回的pid 为创建的子进程的ID</span><br>\t\tprintf(<span class=\"hljs-string\">&quot;I am father,my son&#x27;s pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,pid);<br>\t\tprintf(<span class=\"hljs-string\">&quot;my pid:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,getpid());<br>\t\tint status;<br>\t\tpid_t sonpid<span class=\"hljs-operator\">=</span>wait(<span class=\"hljs-type\">NULL</span>);<br>\t\t<span class=\"hljs-keyword\">if</span>(sonpid<span class=\"hljs-operator\">&lt;</span><span class=\"hljs-number\">0</span>)puts(<span class=\"hljs-string\">&quot;调用进程没有子进程&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span> printf(<span class=\"hljs-string\">&quot;等到了孩子的尸体，孩子进程号为:%d<span class=\"hljs-subst\">\\n</span>&quot;</span>,sonpid);<br> <br>\t&#125;<br>\tputs(<span class=\"hljs-string\">&quot;hi &quot;</span>);<span class=\"hljs-comment\">//这里是父子进程都执行的部分,运行结果可以看到两个hi,</span><br>\texit(<span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//output</span><br>hello world<br><span class=\"hljs-type\">I</span> am father,my son&#x27;s pid:<span class=\"hljs-number\">12345</span><br>my pid:<span class=\"hljs-number\">6789</span><br>hi <br><span class=\"hljs-type\">I</span> am child,my pid:<span class=\"hljs-number\">12345</span><br>my father&#x27;s pid:<span class=\"hljs-number\">6789</span><br>hi <br>等到了孩子的尸体，孩子进程号为:<span class=\"hljs-number\">12345</span><br></code></pre></td></tr></table></figure>\n\n<p>这个程序在子进程创建的时候，等于开了另一个main函数，用于执行这个函数指令，但是子进程不会重新创建子进程，只会执行子进程创建后的命令，比如进行函数判断和输出puts，而父进程也是会执行该操作，因此会输出两个hi</p>\n<h3 id=\"exec函数族\"><a href=\"#exec函数族\" class=\"headerlink\" title=\"exec函数族\"></a>exec函数族</h3><p>exec函数族提供一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。<br><code>fork()</code> 创建一个子进程后，父进程和子进程共享同一个代码段（程序），但在有些情况下，我们希望子进程运行一个完全不同的程序，而不是继续执行父进程的代码。<strong>子进程执行完新的程序后，它依然需要父进程wait收尸!!!</strong></p>\n<p>exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">exec</span>函数族：<span class=\"hljs-selector-tag\">execl</span> 、<span class=\"hljs-selector-tag\">execlp</span>、<span class=\"hljs-selector-tag\">execvp</span><br><span class=\"hljs-selector-tag\">exec</span>族函数参数极难记忆和分辨，函数名中的字符会给我们一些帮助： <br><span class=\"hljs-selector-tag\">l</span> : 使用参数列表 <br><span class=\"hljs-selector-tag\">p</span>：使用文件名，并从<span class=\"hljs-selector-tag\">PATH</span>环境进行寻找可执行文件 ,自动搜索环境变量<span class=\"hljs-selector-tag\">PATH</span><br><span class=\"hljs-selector-tag\">v</span>：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。 <br><span class=\"hljs-selector-tag\">e</span>：多了<span class=\"hljs-selector-tag\">envp</span><span class=\"hljs-selector-attr\">[]</span>数组，使用新的环境变量代替调用进程的环境变量,表示自己维护环境变量<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//exec_test.c  中的代码，这个程序会在主函数中进程的子进程里面进行替换执行</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span>(i&lt;<span class=\"hljs-number\">6</span>)&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;正在执行exec_test.out,此时i:%d\\n&quot;</span>,i++);<br>\t\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//exec.c  文件</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/types.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/wait.h&gt;</span></span><br> <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;这是刚开始的父进程,进程号:%d\\n&quot;</span>,<span class=\"hljs-built_in\">getpid</span>());<br>\t<span class=\"hljs-type\">pid_t</span> pid=fork();<span class=\"hljs-comment\">//创建子进程</span><br>\t<span class=\"hljs-keyword\">if</span>(pid&lt;<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//判断是否成功</span><br>\t\t<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;fork error&quot;</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid==<span class=\"hljs-number\">0</span>)&#123;<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;接下来执行子进程&quot;</span>);<br>\t\t<span class=\"hljs-comment\">//执行该语句的话，后续父进程的puts就不再执行</span><br>\t\t<span class=\"hljs-type\">int</span> ret=<span class=\"hljs-built_in\">execl</span>(<span class=\"hljs-string\">&quot;./exec_test.out&quot;</span>,<span class=\"hljs-string\">&quot;exec_test.out&quot;</span>,<span class=\"hljs-literal\">NULL</span>,<span class=\"hljs-literal\">NULL</span>);<span class=\"hljs-comment\">//将子进程即将执行的程序进行替换</span><br>\t\t<span class=\"hljs-keyword\">if</span>(ret&lt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;exec error&quot;</span>);<span class=\"hljs-comment\">//判断是否失败，成功的话都无法来到这个指令</span><br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;子进程执行结束&quot;</span>);<span class=\"hljs-comment\">//如果执行失败，则会输出该log</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(pid&gt;<span class=\"hljs-number\">0</span>)&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;这是父进程,父进程pid:%d\\n&quot;</span>,<span class=\"hljs-built_in\">getpid</span>());<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;我创建的子进程的pid:%d\\n&quot;</span>,pid);<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;接下来调用wait&quot;</span>);<br>\t\t  <span class=\"hljs-type\">pid_t</span> sonpid=<span class=\"hljs-built_in\">wait</span>(<span class=\"hljs-literal\">NULL</span>); <br>        <span class=\"hljs-keyword\">if</span>(sonpid&lt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;调用进程没有子进程&quot;</span>); <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;等到了孩子的尸体，孩子进程号为:%d\\n&quot;</span>,sonpid);<br>\t&#125;<br><span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;准备结束父进程&quot;</span>);<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//output</span><br>这是刚开始的父进程,进程号:<span class=\"hljs-number\">4588</span><br>这是父进程,父进程pid:<span class=\"hljs-number\">4588</span><br>创建的子进程的pid:<span class=\"hljs-number\">4589</span><br>接下来调用wait<br>接下来执行子进程<br><br>正在执行exec_test.out,此时i<br>...<br>...<br>...<br><br>等到了孩子的尸体，孩子进程号为:<br>准备结束父进程<br></code></pre></td></tr></table></figure>\n\n<p><strong>有了exec函数族我们就可以用它来调用任何程序，也就是说，你还可以在C&#x2F;C++，可以调用其他任何语言，比如python，Java等程序；</strong></p>\n<h2 id=\"线程的创建和使用\"><a href=\"#线程的创建和使用\" class=\"headerlink\" title=\"线程的创建和使用\"></a>线程的创建和使用</h2><p>当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p>\n<h3 id=\"线程创建函数\"><a href=\"#线程创建函数\" class=\"headerlink\" title=\"线程创建函数\"></a>线程创建函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//创建一个线程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pthread_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">pthread_t</span> *thread, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span> *attr,<span class=\"hljs-type\">void</span> *(*start_routine)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *arg)</span></span>;<br><span class=\"hljs-comment\">//函数返回值：成功返回0；失败返回错误码</span><br><br>参数解释：<br>第一个参数：<span class=\"hljs-type\">pthread_t</span> *thread<br>    <span class=\"hljs-type\">pthread_t</span>是类型，在linux下被定义为“<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span>”，是一种用于表示线程的数据类型；<br>    <span class=\"hljs-type\">phtread_t</span> *thread:传递一个<span class=\"hljs-type\">pthread_t</span>类型的指针变量，也可以传递这个类型变量的地址<br>第二个参数： <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span> *attr<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span>：该类型以结构体的形式定义在&lt;pthread.h&gt;头文件中，专门表示线程的属性<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">pthread_attr_t</span> *attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 <span class=\"hljs-literal\">NULL</span>，<span class=\"hljs-built_in\">pthread_create</span>() 函数会采用系统默认的属性值创建线程。<br> <br>第三个参数：<span class=\"hljs-type\">void</span> *(*start_routine)(<span class=\"hljs-type\">void</span> *)<br>    以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 <span class=\"hljs-number\">1</span> 个（可以省略不写），形参和返回值的类型都必须为 <span class=\"hljs-type\">void</span> 类型。<span class=\"hljs-type\">void</span> 类型又称空指针类型，表明指针所指数据的类型是未知的。使用此类型指针时，我们通常需要先对其进行强制类型转换，然后才能正常访问指针指向的数据。<br>    如果该函数有返回值，则线程执行完函数后，函数的返回值可以由 <span class=\"hljs-built_in\">pthread_join</span>() 函数接收<br>第四个参数：<span class=\"hljs-type\">void</span> *arg<br>    <span class=\"hljs-type\">void</span> *arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 <span class=\"hljs-literal\">NULL</span> 即可。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"线程退出函数\"><a href=\"#线程退出函数\" class=\"headerlink\" title=\"线程退出函数\"></a>线程退出函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//线程退出函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pthread_exit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *retval)</span></span>;<br> <br>功能说明：主动结束当前线程（终止调用它的线程并返回一个指向某个对象的指针）<br> <br>参数：<br> <span class=\"hljs-type\">void</span> *retval：函数的返回指针，只要pthread_join中的第二个参数retval不是<span class=\"hljs-literal\">NULL</span>，这个值将被传递给retval<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"线程等待函数\"><a href=\"#线程等待函数\" class=\"headerlink\" title=\"线程等待函数\"></a>线程等待函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//线程等待也叫阻塞</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pthread_join</span><span class=\"hljs-params\">(<span class=\"hljs-type\">pthread_t</span> thread, <span class=\"hljs-type\">void</span> **retval)</span></span>;<br><br>功能说明：<br>    这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回，可以理解为进程当中的wait收尸<br> <br>参数：<br>    <span class=\"hljs-type\">pthread_t</span> thread  被等待的线程标识符<br>    <span class=\"hljs-type\">void</span> **retval     一个用户定义的指针，它可以用来存储被等待线程的返回值<br>返回值：<br>On success, <span class=\"hljs-built_in\">pthread_join</span>() returns <span class=\"hljs-number\">0</span>; on error,  it  returns  an  error number.<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//以下是这三个函数的程序实例：</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;pthread.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title\">thread1fun</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;进入线程1&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;执行线程1&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;hello i am thread1&quot;</span>);<br>\t<span class=\"hljs-type\">char</span> *p=<span class=\"hljs-string\">&quot;线程1已经退出，返回指针char *p&quot;</span>;<br>\t<span class=\"hljs-built_in\">pthread_exit</span>(p);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> *<span class=\"hljs-title\">thread2fun</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;进入线程2&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;执行线程2&quot;</span>);<br>\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;hello i am thread2&quot;</span>);<br>\t<span class=\"hljs-type\">char</span> *p=<span class=\"hljs-string\">&quot;线程2已经退出，返回指针char *p&quot;</span>;<br>\t<span class=\"hljs-built_in\">pthread_exit</span>(p);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">pthread_t</span> thread1;<br>\t<span class=\"hljs-type\">pthread_t</span> thread2;<span class=\"hljs-comment\">//定义两个线程类型变量</span><br>\t<span class=\"hljs-comment\">//创建线程，开始执行其他线程函数thread1fun</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_create</span>(&amp;thread1,<span class=\"hljs-literal\">NULL</span>,thread1fun,<span class=\"hljs-literal\">NULL</span>)!=<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//判断是否错误</span><br>\t\t<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;thread1_create error&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;线程1创建成功&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;线程1线程号：%lu\\n&quot;</span>,thread1);<br>\t&#125;<br> \t<span class=\"hljs-comment\">//创建线程，开始执行其他线程函数thread2fun</span><br>\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_create</span>(&amp;thread2,<span class=\"hljs-literal\">NULL</span>,thread2fun,<span class=\"hljs-literal\">NULL</span>)!=<span class=\"hljs-number\">0</span>)&#123;<span class=\"hljs-comment\">//判断是否错误</span><br>\t\t<span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;thread1_create error&quot;</span>);<br>       <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;线程2创建成功&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;线程2线程号：%lu\\n&quot;</span>,thread2);<br>\t&#125;<br>\t<br>    <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;阻塞等待回收线程&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_join</span>(thread1,(<span class=\"hljs-type\">void</span>**)&amp;thread1)==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;等到了，打印返回指针&quot;</span>);<br>    \t<span class=\"hljs-built_in\">puts</span>((<span class=\"hljs-type\">char</span>*) *(&amp;thread1));<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">pthread_join</span>(thread2,(<span class=\"hljs-type\">void</span> **)&amp;thread2)==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;等到了，打印返回指针&quot;</span>);<br>    \t<span class=\"hljs-built_in\">puts</span>((<span class=\"hljs-type\">char</span>*) *(&amp;thread2));<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//output</span><br>线程<span class=\"hljs-number\">1</span>创建成功<br>线程<span class=\"hljs-number\">1</span>线程号：&lt;thread1的线程ID&gt;<br>线程<span class=\"hljs-number\">2</span>创建成功<br>线程<span class=\"hljs-number\">2</span>线程号：&lt;thread2的线程ID&gt;<br>进入线程<span class=\"hljs-number\">1</span><br>执行线程<span class=\"hljs-number\">1</span><br>hello i am thread1<br>进入线程<span class=\"hljs-number\">2</span><br>执行线程<span class=\"hljs-number\">2</span><br>hello i am thread2<br>阻塞等待回收线程<br>等到了，打印返回指针<br>线程<span class=\"hljs-number\">1</span>已经退出，返回指针<span class=\"hljs-type\">char</span> *p<br>等到了，打印返回指针<br>线程<span class=\"hljs-number\">2</span>已经退出，返回指针<span class=\"hljs-type\">char</span> *p<br></code></pre></td></tr></table></figure>\n\n<p>在执行线程1的时候，主函数和线程2仍然在执行。</p>\n<h3 id=\"线程取消函数\"><a href=\"#线程取消函数\" class=\"headerlink\" title=\"线程取消函数\"></a>线程取消函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//取消某个线程的执行</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pthread_cancel</span><span class=\"hljs-params\">(<span class=\"hljs-type\">pthread_t</span> thread)</span></span>;<br><br><span class=\"hljs-comment\">//返回值：成功返回0，否则返回perror</span><br><span class=\"hljs-comment\">//参数：要取消线程的标识符ID</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"获取线程当前ID\"><a href=\"#获取线程当前ID\" class=\"headerlink\" title=\"获取线程当前ID\"></a>获取线程当前ID</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//获取当前调用线程的ID</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">pthread_t</span> <span class=\"hljs-title\">pthread_self</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">//返回值：当前线程的线程ID标识</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"线程互斥锁\"><a href=\"#线程互斥锁\" class=\"headerlink\" title=\"线程互斥锁\"></a>线程互斥锁</h2><p>互斥锁的初始化和销毁：在使用互斥锁之前，需要先对其进行初始化，使用完毕后需要将其销毁。初始化可以使用 <code>pthread_mutex_init</code>() 函数，销毁可以使用 <code>pthread_mutex_destroy</code>() 函数。</p>\n<p>加锁和解锁的配对：在使用 <code>pthread_mutex_lock</code>() 和 <code>pthread_mutex_unlock</code>() 函数时，需要保证加锁和解锁的配对性，即每次加锁后都必须要对应的解锁。</p>\n<p>避免死锁：死锁是指两个或多个线程互相等待对方释放锁，导致程序无法继续执行。为了避免死锁，需要确保<strong>加锁的顺序一致</strong>，并且<strong>不要在加锁的状态下等待其他锁。</strong></p>\n<p>不要重复加锁：重复加锁会导致线程阻塞，无法进行下去，需要注意避免。</p>\n<p>对共享资源的访问必须要在加锁状态下进行：为了确保多个线程访问共享资源的互斥性，需要在对共享资源进行访问之前，先获取对应的互斥锁，以避免多个线程同时访问共享资源。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_init</span><span class=\"hljs-params\">()</span></span>：用于初始化一个互斥锁。可以使用默认属性或者自定义属性进行初始化。<br><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_destroy</span><span class=\"hljs-params\">()</span></span>：用于销毁一个互斥锁，释放相关资源。<br><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_lock</span><span class=\"hljs-params\">()</span></span>：用于获取一个互斥锁，如果该锁已经被其他线程获取，则当前线程将阻塞，直到该锁被释放为止。<br><span class=\"hljs-function\"><span class=\"hljs-title\">pthread_mutex_unlock</span><span class=\"hljs-params\">()</span></span>：用于释放一个互斥锁，如果该锁当前没有被任何线程获取，则此函数将返回一个错误。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"线程锁（读写锁）\"><a href=\"#线程锁（读写锁）\" class=\"headerlink\" title=\"线程锁（读写锁）\"></a>线程锁（读写锁）</h2><p>上面是互斥锁，但是线程并不只有互斥锁，在实际的多线程编程中，我们应该选择合适的线程锁。</p>\n<p>互斥锁（Mutex）：互斥锁是一种二元锁，只有两个状态：锁定和未锁定。当一个线程持有互斥锁时，其他线程必须等待该线程释放锁之后才能继续执行。如果多个线程同时竞争锁，只有一个线程可以获得锁，其他线程将被阻塞，直到获得锁的线程释放锁。互斥锁提供了一种简单而有效的方法，用于确保多个线程之间对共享资源的互斥访问。</p>\n<p>读写锁（Reader-Writer Lock）：读写锁是一种更高效的锁，适用于读多写少的场景。读写锁允许多个线程同时读取共享资源，但是只有一个线程可以写入共享资源。当一个线程持有读锁时，其他线程也可以持有读锁，但是当一个线程持有写锁时，其他线程必须等待该线程释放写锁之后才能继续执行。读写锁的优点是在读取共享资源时可以允许多个线程同时进行，从而提高了程序的并发性和性能。</p>\n<p>自旋锁（Spin Lock）：自旋锁是一种非阻塞锁，线程在尝试获取锁时不会被挂起，而是一直循环尝试获取锁。当锁被其他线程持有时，线程会一直尝试获取锁，直到锁被释放。自旋锁适用于锁被持有时间很短的场景，因为在等待锁的过程中，线程会消耗大量的CPU资源。</p>\n<p>条件变量（Condition Variable）：条件变量用于在某个条件满足时通知等待线程。线程可以在条件变量上等待，直到满足条件后才被唤醒。条件变量通常与互斥锁一起使用，以确保在修改共享资源时不会出现竞态条件。</p>\n<p>信号量（Semaphore）：信号量是一种计数器，用于控制多个线程对共享资源的访问。当计数器大于零时，线程可以访问资源，并将计数器减一；当计数器等于零时，线程就必须等待。信号量可以用来实现读写锁和生产者-消费者模型等并发编程模型。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//此函数用于初始化读写锁对象。读写锁对象在使用前必须被初始化，可以使用静态初始化或者动态初始化。</span><br><span class=\"hljs-built_in\">pthread_rwlock_init</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_init</span>(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);<br><br>    rwlock：读写锁对象的指针。<br>    attr：读写锁属性对象的指针，可以为NULL。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><br><span class=\"hljs-comment\">//获取读取锁，如果写入锁已经被占用，则函数会阻塞等待，直到写入锁被释放。多个线程可以同时获取读取锁。</span><br><span class=\"hljs-built_in\">pthread_rwlock_rdlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_rdlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数用于获取写入锁，如果读取锁或者写入锁已经被占用，则函数会阻塞等待，直到锁被释放。写入锁是独占的，只有一个线程可以获取写入锁。</span><br><span class=\"hljs-built_in\">pthread_rwlock_wrlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_wrlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数用于释放读取锁或者写入锁。如果锁没有被获取，释放锁会导致未定义的行为。</span><br><span class=\"hljs-built_in\">pthread_rwlock_unlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_unlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数尝试获取读取锁，如果读取锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行读取操作。</span><br><span class=\"hljs-built_in\">pthread_rwlock_tryrdlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_tryrdlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数尝试获取写入锁，如果读取锁或者写入锁已经被占用，则函数会立即返回，不会阻塞等待。如果获取成功，则进行写入操作。</span><br><span class=\"hljs-built_in\">pthread_rwlock_trywrlock</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_trywrlock</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br><br><span class=\"hljs-comment\">//此函数用于销毁读写锁</span><br><span class=\"hljs-built_in\">pthread_rwlock_destroy</span>()<br>int <span class=\"hljs-built_in\">pthread_rwlock_destroy</span>(pthread_rwlock_t *rwlock);<br><br>    rwlock：读写锁对象的指针。<br>    返回值：成功返回<span class=\"hljs-number\">0</span>，失败返回错误码。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"进程通信方式\"><a href=\"#进程通信方式\" class=\"headerlink\" title=\"进程通信方式\"></a>进程通信方式</h2><p><strong>管道（Pipe）：管道是一种半双工的通信方式，它只能用于父子进程或者兄弟进程之间的通信</strong>。管道有两种类型：无名管道和命名管道。无名管道只存在于相关进程的内存中，而命名管道则存在于文件系统中，允许不相关的进程进行通信。</p>\n<p><strong>命名管道（Named Pipe）：命名管道允许不相关的进程进行通信。</strong>它在文件系统中创建一个特殊文件，任何知道文件名的进程都可以通过文件访问方式进行通信。</p>\n<p><strong>信号（Signal）：信号是一种异步通信机制，用于通知进程发生了某些事件。</strong>一个进程可以向另一个进程发送信号，另一个进程可以选择接受或忽略信号。</p>\n<p><strong>消息队列（Message Queue）：消息队列是一种存放在内核中的消息链表，用于不相关的进程间的通信。</strong>进程可以向队列中发送消息，其他进程可以从队列中接收消息。</p>\n<p><strong>共享内存（Shared Memory）：共享内存允许多个进程访问同一块物理内存。</strong>进程可以将数据写入共享内存区域，其他进程可以直接从该内存区域读取数据。</p>\n<p><strong>套接字（Socket）：套接字是一种通用的进程间通信方式，可用于不同主机之间的通信。</strong>套接字提供了一组接口，进程可以使用这些接口来建立网络连接并进行通信。</p>\n"},{"title":"C语言内存分配学习","date":"2024-08-06T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/BsDplXmnL3YjeQ7.jpg","_content":"\n# C语言内存分配学习\n\n## 感谢博主：\n\n[C语言：内存分配---栈区、堆区、全局区、常量区和代码区_c 内存布局-CSDN博客](https://blog.csdn.net/MQ0522/article/details/114823770)\n\n[7-代码区 | 常量区 | 静态区(全局区) | 堆区 | 栈区 - Darren_pty - 博客园 (cnblogs.com)](https://www.cnblogs.com/darren-pty/p/14241169.html)\n\n## 内存基础知识\n\nC语言中，内存主要分为5个区，分别为栈区、堆区、全局/静态存储区、常量存储区、代码区。\n\n栈区存放局部变量和函数，动态分配在堆上，由程序员负责释放。全局变量和静态变量存储在静态存储区，常量存储在常量区，代码区存放二进制代码。\n\n<img src=\"https://s2.loli.net/2024/08/07/BYJIcUkN4OLtf76.png\" alt=\"image.png\" style=\"zoom:50%;\" /><img src=\"https://s2.loli.net/2024/08/07/DS3xisJWTjr86lN.png\" alt=\"image.png\" style=\"zoom:45%;\" />\n\n## 栈区\n\n栈区由编译器自动分配释放，由操作系统自动管理，**无须手动管理**。\n\n栈区上的内容只在函数范围内存在，**当函数运行结束，这些内容也会自动被销毁**。\n\n栈区按内存地址由高到低方向生长，其最大大小由编译时确定，**速度快，但自由性差，最大空间不大**。\n\n但是对于栈来讲，一般都是有一定的空间大小的，默认的栈空间大小是1M（听博主诌了一个，反正就是很小）\n\n栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出\n\n栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。\n\n**栈区是先进后出原则**，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。先进后出的定义是比较有趣的，因为栈区主要为函数的和函数范围的调用，函数套函数套函数套n个函数之后，要释放内存，就可以从最后面的函数开始一个一个往外出，所以就形成先进后出\n\n**临时创建的局部变量和const定义的局部变量存放在栈区。**\n\n函数调用和返回时，其**入口参数和返回值存放在栈区。**\n\n**局部变量不要定义的太大，**不然占用非常大的栈区空间，会导致栈溢出；\n\n栈用于函数嵌套调用、中断切换时保存和恢复现场数据。调用函数不要有深层次的调用，调用函数的过程中栈区会不停的存储函数的一些相关的变量、地址之类的，如果有深层次函数递归的需要，尽量采用别的方式去替代它；\n\n## 堆区\n\n堆区由**程序员分配内存和释放**，系统不自动回收，所以一定要记得**申请了就要释放，以免溢出**。\n\n堆区按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。\n\n C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。\n\n一般来讲在 32 位系统下，**堆内存可以达到4G的空间**，从这个角度来看堆内存几乎是没有什么限制的。\n\n对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。\n\n释放的时候只能释放一次，不要重复释放，因为释放后的内存可能会去做别的事情，重复释放会出现问题，释放完后让这个指针最好指向空地址，避免下次用这个指针的时候出现地址错误。\n\n系统提供了四个库函数来实现内存的动态分配：\n\n（1）malloc(size) 在内存的动态存储区中分配一个长度为size的连续空间。\n\n（2）calloc(n,size) 在内存的动态存储区中分配n个长度为size的连续空间。\n\n（3）free(p) 释放指针变量p做指向的动态空间。\n\n（4）realloc(p,size) 将指针变量p指向的动态空间大小改变为size。\n\n## 全局静态区（static）\n\n通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。\n\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。\n\n## 常量区\n\n**字符串**、**数字**等常量存放在常量区。\n\n**const修饰的全局变量**存放在常量区。\n\n程序运行期间，**常量**区的内容不可以被修改，程序结束后由系统释放。\n\n## 代码区\n\n程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。\n\n字符串常量和define定义的常量也有可能存放在代码区。\n\n表示程序所占用 FLASH 的大小，即代码区（FLASH）；\n\n## 定义演示\n\n```\nint  a=0;   全局初始化区    \n\nchar *p1;   全局未初始化区    \nint  main()    \n{    \n  int  b; //栈    \n  char  s[]=\"abc\"; //栈    \n  char  *p2; //栈    \n  char  *p3=\"123456\"; //123456/0在常量区，p3在栈上。    \n\n  static int c =0；//全局（静态）初始化区    \n  p1 =  (char  *)malloc(10);  //分配得来得10和20字节的区域就在堆区\n  p2  = (char  *)malloc(20);       \n  strcpy(p3,\"123456\"); //123456/0放在常量区，编译器可能会将它与p3所指向的\"123456\"  优化成一个地方。    \n} \n```\n\n## RAM和ROM\n\n#### RAM是“Random Access Memory”的缩写，被译为随机存储器。\n\n根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种。\n\n动态随机存储器DRAM的存储单元以电容的电荷来表示数据，有电荷代表1，无电荷代表0， 但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，因此它需要定期刷新操作，这就是“动态(Dynamic)”一词所形容的特性。 刷新操作会对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，藉此来保证数据的正确性。\n\n静态随机存储器SRAM的存储单元以锁存器来存储数据，这种电路结构不需要定时刷新充电，就能保持状态(当然，如果断电了，数据还是会丢失的)，所以这种存储器被称为“静态(Static)”RAM。\n\n#### ROM是“Read Only Memory”的缩写，意为只能读的存储器。\n\nEEPROM(Electrically Erasable Programmable ROM)是电可擦除存储器。 EEPROM可以重复擦写，它的擦除和写入都是直接使用电路控制， 不需要再使用外部设备来擦写。而且可以按字节为单位修改数据，无需整个芯片擦除。现在主要使用的ROM芯片都是EEPROM。\n\nFLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多， 且在擦除时，一般以多个字节为单位。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Work No.18.md","raw":"---\ntitle: C语言内存分配学习\ntag: C/C++\ndate: 2024-08-07\ncategories: C/C++\nindex_img: https://s2.loli.net/2024/08/02/BsDplXmnL3YjeQ7.jpg\n---\n\n# C语言内存分配学习\n\n## 感谢博主：\n\n[C语言：内存分配---栈区、堆区、全局区、常量区和代码区_c 内存布局-CSDN博客](https://blog.csdn.net/MQ0522/article/details/114823770)\n\n[7-代码区 | 常量区 | 静态区(全局区) | 堆区 | 栈区 - Darren_pty - 博客园 (cnblogs.com)](https://www.cnblogs.com/darren-pty/p/14241169.html)\n\n## 内存基础知识\n\nC语言中，内存主要分为5个区，分别为栈区、堆区、全局/静态存储区、常量存储区、代码区。\n\n栈区存放局部变量和函数，动态分配在堆上，由程序员负责释放。全局变量和静态变量存储在静态存储区，常量存储在常量区，代码区存放二进制代码。\n\n<img src=\"https://s2.loli.net/2024/08/07/BYJIcUkN4OLtf76.png\" alt=\"image.png\" style=\"zoom:50%;\" /><img src=\"https://s2.loli.net/2024/08/07/DS3xisJWTjr86lN.png\" alt=\"image.png\" style=\"zoom:45%;\" />\n\n## 栈区\n\n栈区由编译器自动分配释放，由操作系统自动管理，**无须手动管理**。\n\n栈区上的内容只在函数范围内存在，**当函数运行结束，这些内容也会自动被销毁**。\n\n栈区按内存地址由高到低方向生长，其最大大小由编译时确定，**速度快，但自由性差，最大空间不大**。\n\n但是对于栈来讲，一般都是有一定的空间大小的，默认的栈空间大小是1M（听博主诌了一个，反正就是很小）\n\n栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出\n\n栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。\n\n**栈区是先进后出原则**，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。先进后出的定义是比较有趣的，因为栈区主要为函数的和函数范围的调用，函数套函数套函数套n个函数之后，要释放内存，就可以从最后面的函数开始一个一个往外出，所以就形成先进后出\n\n**临时创建的局部变量和const定义的局部变量存放在栈区。**\n\n函数调用和返回时，其**入口参数和返回值存放在栈区。**\n\n**局部变量不要定义的太大，**不然占用非常大的栈区空间，会导致栈溢出；\n\n栈用于函数嵌套调用、中断切换时保存和恢复现场数据。调用函数不要有深层次的调用，调用函数的过程中栈区会不停的存储函数的一些相关的变量、地址之类的，如果有深层次函数递归的需要，尽量采用别的方式去替代它；\n\n## 堆区\n\n堆区由**程序员分配内存和释放**，系统不自动回收，所以一定要记得**申请了就要释放，以免溢出**。\n\n堆区按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。\n\n C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。\n\n一般来讲在 32 位系统下，**堆内存可以达到4G的空间**，从这个角度来看堆内存几乎是没有什么限制的。\n\n对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。\n\n释放的时候只能释放一次，不要重复释放，因为释放后的内存可能会去做别的事情，重复释放会出现问题，释放完后让这个指针最好指向空地址，避免下次用这个指针的时候出现地址错误。\n\n系统提供了四个库函数来实现内存的动态分配：\n\n（1）malloc(size) 在内存的动态存储区中分配一个长度为size的连续空间。\n\n（2）calloc(n,size) 在内存的动态存储区中分配n个长度为size的连续空间。\n\n（3）free(p) 释放指针变量p做指向的动态空间。\n\n（4）realloc(p,size) 将指针变量p指向的动态空间大小改变为size。\n\n## 全局静态区（static）\n\n通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。\n\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。\n\n## 常量区\n\n**字符串**、**数字**等常量存放在常量区。\n\n**const修饰的全局变量**存放在常量区。\n\n程序运行期间，**常量**区的内容不可以被修改，程序结束后由系统释放。\n\n## 代码区\n\n程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。\n\n字符串常量和define定义的常量也有可能存放在代码区。\n\n表示程序所占用 FLASH 的大小，即代码区（FLASH）；\n\n## 定义演示\n\n```\nint  a=0;   全局初始化区    \n\nchar *p1;   全局未初始化区    \nint  main()    \n{    \n  int  b; //栈    \n  char  s[]=\"abc\"; //栈    \n  char  *p2; //栈    \n  char  *p3=\"123456\"; //123456/0在常量区，p3在栈上。    \n\n  static int c =0；//全局（静态）初始化区    \n  p1 =  (char  *)malloc(10);  //分配得来得10和20字节的区域就在堆区\n  p2  = (char  *)malloc(20);       \n  strcpy(p3,\"123456\"); //123456/0放在常量区，编译器可能会将它与p3所指向的\"123456\"  优化成一个地方。    \n} \n```\n\n## RAM和ROM\n\n#### RAM是“Random Access Memory”的缩写，被译为随机存储器。\n\n根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种。\n\n动态随机存储器DRAM的存储单元以电容的电荷来表示数据，有电荷代表1，无电荷代表0， 但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，因此它需要定期刷新操作，这就是“动态(Dynamic)”一词所形容的特性。 刷新操作会对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，藉此来保证数据的正确性。\n\n静态随机存储器SRAM的存储单元以锁存器来存储数据，这种电路结构不需要定时刷新充电，就能保持状态(当然，如果断电了，数据还是会丢失的)，所以这种存储器被称为“静态(Static)”RAM。\n\n#### ROM是“Read Only Memory”的缩写，意为只能读的存储器。\n\nEEPROM(Electrically Erasable Programmable ROM)是电可擦除存储器。 EEPROM可以重复擦写，它的擦除和写入都是直接使用电路控制， 不需要再使用外部设备来擦写。而且可以按字节为单位修改数据，无需整个芯片擦除。现在主要使用的ROM芯片都是EEPROM。\n\nFLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多， 且在擦除时，一般以多个字节为单位。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Work No.18","published":1,"updated":"2024-08-09T04:03:57.175Z","comments":1,"layout":"post","photos":[],"_id":"clzmh9t9w0002gsfb26xydqdu","content":"<h1 id=\"C语言内存分配学习\"><a href=\"#C语言内存分配学习\" class=\"headerlink\" title=\"C语言内存分配学习\"></a>C语言内存分配学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/MQ0522/article/details/114823770\">C语言：内存分配—栈区、堆区、全局区、常量区和代码区_c 内存布局-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/darren-pty/p/14241169.html\">7-代码区 | 常量区 | 静态区(全局区) | 堆区 | 栈区 - Darren_pty - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"内存基础知识\"><a href=\"#内存基础知识\" class=\"headerlink\" title=\"内存基础知识\"></a>内存基础知识</h2><p>C语言中，内存主要分为5个区，分别为栈区、堆区、全局&#x2F;静态存储区、常量存储区、代码区。</p>\n<p>栈区存放局部变量和函数，动态分配在堆上，由程序员负责释放。全局变量和静态变量存储在静态存储区，常量存储在常量区，代码区存放二进制代码。</p>\n<p><img src=\"https://s2.loli.net/2024/08/07/BYJIcUkN4OLtf76.png\" alt=\"image.png\" style=\"zoom:50%;\" /><img src=\"https://s2.loli.net/2024/08/07/DS3xisJWTjr86lN.png\" alt=\"image.png\" style=\"zoom:45%;\" /></p>\n<h2 id=\"栈区\"><a href=\"#栈区\" class=\"headerlink\" title=\"栈区\"></a>栈区</h2><p>栈区由编译器自动分配释放，由操作系统自动管理，<strong>无须手动管理</strong>。</p>\n<p>栈区上的内容只在函数范围内存在，<strong>当函数运行结束，这些内容也会自动被销毁</strong>。</p>\n<p>栈区按内存地址由高到低方向生长，其最大大小由编译时确定，<strong>速度快，但自由性差，最大空间不大</strong>。</p>\n<p>但是对于栈来讲，一般都是有一定的空间大小的，默认的栈空间大小是1M（听博主诌了一个，反正就是很小）</p>\n<p>栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出</p>\n<p>栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>\n<p><strong>栈区是先进后出原则</strong>，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。先进后出的定义是比较有趣的，因为栈区主要为函数的和函数范围的调用，函数套函数套函数套n个函数之后，要释放内存，就可以从最后面的函数开始一个一个往外出，所以就形成先进后出</p>\n<p><strong>临时创建的局部变量和const定义的局部变量存放在栈区。</strong></p>\n<p>函数调用和返回时，其<strong>入口参数和返回值存放在栈区。</strong></p>\n<p><strong>局部变量不要定义的太大，</strong>不然占用非常大的栈区空间，会导致栈溢出；</p>\n<p>栈用于函数嵌套调用、中断切换时保存和恢复现场数据。调用函数不要有深层次的调用，调用函数的过程中栈区会不停的存储函数的一些相关的变量、地址之类的，如果有深层次函数递归的需要，尽量采用别的方式去替代它；</p>\n<h2 id=\"堆区\"><a href=\"#堆区\" class=\"headerlink\" title=\"堆区\"></a>堆区</h2><p>堆区由<strong>程序员分配内存和释放</strong>，系统不自动回收，所以一定要记得<strong>申请了就要释放，以免溢出</strong>。</p>\n<p>堆区按内存地址由低到高方向生长，其大小由系统内存&#x2F;虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</p>\n<p> C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。</p>\n<p>一般来讲在 32 位系统下，<strong>堆内存可以达到4G的空间</strong>，从这个角度来看堆内存几乎是没有什么限制的。</p>\n<p>对于堆来讲，频繁的 new&#x2F;delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。</p>\n<p>释放的时候只能释放一次，不要重复释放，因为释放后的内存可能会去做别的事情，重复释放会出现问题，释放完后让这个指针最好指向空地址，避免下次用这个指针的时候出现地址错误。</p>\n<p>系统提供了四个库函数来实现内存的动态分配：</p>\n<p>（1）malloc(size) 在内存的动态存储区中分配一个长度为size的连续空间。</p>\n<p>（2）calloc(n,size) 在内存的动态存储区中分配n个长度为size的连续空间。</p>\n<p>（3）free(p) 释放指针变量p做指向的动态空间。</p>\n<p>（4）realloc(p,size) 将指针变量p指向的动态空间大小改变为size。</p>\n<h2 id=\"全局静态区（static）\"><a href=\"#全局静态区（static）\" class=\"headerlink\" title=\"全局静态区（static）\"></a>全局静态区（static）</h2><p>通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。</p>\n<p>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p>\n<h2 id=\"常量区\"><a href=\"#常量区\" class=\"headerlink\" title=\"常量区\"></a>常量区</h2><p><strong>字符串</strong>、<strong>数字</strong>等常量存放在常量区。</p>\n<p><strong>const修饰的全局变量</strong>存放在常量区。</p>\n<p>程序运行期间，<strong>常量</strong>区的内容不可以被修改，程序结束后由系统释放。</p>\n<h2 id=\"代码区\"><a href=\"#代码区\" class=\"headerlink\" title=\"代码区\"></a>代码区</h2><p>程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。</p>\n<p>字符串常量和define定义的常量也有可能存放在代码区。</p>\n<p>表示程序所占用 FLASH 的大小，即代码区（FLASH）；</p>\n<h2 id=\"定义演示\"><a href=\"#定义演示\" class=\"headerlink\" title=\"定义演示\"></a>定义演示</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span>  a=<span class=\"hljs-number\">0</span>;   全局初始化区    <br><br><span class=\"hljs-type\">char</span> *p1;   全局未初始化区    <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>  <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>    </span><br><span class=\"hljs-function\"></span>&#123;    <br>  <span class=\"hljs-type\">int</span>  b; <span class=\"hljs-comment\">//栈    </span><br>  <span class=\"hljs-type\">char</span>  s[]=<span class=\"hljs-string\">&quot;abc&quot;</span>; <span class=\"hljs-comment\">//栈    </span><br>  <span class=\"hljs-type\">char</span>  *p2; <span class=\"hljs-comment\">//栈    </span><br>  <span class=\"hljs-type\">char</span>  *p3=<span class=\"hljs-string\">&quot;123456&quot;</span>; <span class=\"hljs-comment\">//123456/0在常量区，p3在栈上。    </span><br><br>  <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> c =<span class=\"hljs-number\">0</span>；<span class=\"hljs-comment\">//全局（静态）初始化区    </span><br>  p1 =  (<span class=\"hljs-type\">char</span>  *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">//分配得来得10和20字节的区域就在堆区</span><br>  p2  = (<span class=\"hljs-type\">char</span>  *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">20</span>);       <br>  <span class=\"hljs-built_in\">strcpy</span>(p3,<span class=\"hljs-string\">&quot;123456&quot;</span>); <span class=\"hljs-comment\">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;  优化成一个地方。    </span><br>&#125; <br></code></pre></td></tr></table></figure>\n\n<h2 id=\"RAM和ROM\"><a href=\"#RAM和ROM\" class=\"headerlink\" title=\"RAM和ROM\"></a>RAM和ROM</h2><h4 id=\"RAM是“Random-Access-Memory”的缩写，被译为随机存储器。\"><a href=\"#RAM是“Random-Access-Memory”的缩写，被译为随机存储器。\" class=\"headerlink\" title=\"RAM是“Random Access Memory”的缩写，被译为随机存储器。\"></a>RAM是“Random Access Memory”的缩写，被译为随机存储器。</h4><p>根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种。</p>\n<p>动态随机存储器DRAM的存储单元以电容的电荷来表示数据，有电荷代表1，无电荷代表0， 但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，因此它需要定期刷新操作，这就是“动态(Dynamic)”一词所形容的特性。 刷新操作会对电容进行检查，若电量大于满电量的1&#x2F;2，则认为其代表1，并把电容充满电；若电量小于1&#x2F;2，则认为其代表0，并把电容放电，藉此来保证数据的正确性。</p>\n<p>静态随机存储器SRAM的存储单元以锁存器来存储数据，这种电路结构不需要定时刷新充电，就能保持状态(当然，如果断电了，数据还是会丢失的)，所以这种存储器被称为“静态(Static)”RAM。</p>\n<h4 id=\"ROM是“Read-Only-Memory”的缩写，意为只能读的存储器。\"><a href=\"#ROM是“Read-Only-Memory”的缩写，意为只能读的存储器。\" class=\"headerlink\" title=\"ROM是“Read Only Memory”的缩写，意为只能读的存储器。\"></a>ROM是“Read Only Memory”的缩写，意为只能读的存储器。</h4><p>EEPROM(Electrically Erasable Programmable ROM)是电可擦除存储器。 EEPROM可以重复擦写，它的擦除和写入都是直接使用电路控制， 不需要再使用外部设备来擦写。而且可以按字节为单位修改数据，无需整个芯片擦除。现在主要使用的ROM芯片都是EEPROM。</p>\n<p>FLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多， 且在擦除时，一般以多个字节为单位。</p>\n","excerpt":"","more":"<h1 id=\"C语言内存分配学习\"><a href=\"#C语言内存分配学习\" class=\"headerlink\" title=\"C语言内存分配学习\"></a>C语言内存分配学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/MQ0522/article/details/114823770\">C语言：内存分配—栈区、堆区、全局区、常量区和代码区_c 内存布局-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/darren-pty/p/14241169.html\">7-代码区 | 常量区 | 静态区(全局区) | 堆区 | 栈区 - Darren_pty - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"内存基础知识\"><a href=\"#内存基础知识\" class=\"headerlink\" title=\"内存基础知识\"></a>内存基础知识</h2><p>C语言中，内存主要分为5个区，分别为栈区、堆区、全局&#x2F;静态存储区、常量存储区、代码区。</p>\n<p>栈区存放局部变量和函数，动态分配在堆上，由程序员负责释放。全局变量和静态变量存储在静态存储区，常量存储在常量区，代码区存放二进制代码。</p>\n<p><img src=\"https://s2.loli.net/2024/08/07/BYJIcUkN4OLtf76.png\" alt=\"image.png\" style=\"zoom:50%;\" /><img src=\"https://s2.loli.net/2024/08/07/DS3xisJWTjr86lN.png\" alt=\"image.png\" style=\"zoom:45%;\" /></p>\n<h2 id=\"栈区\"><a href=\"#栈区\" class=\"headerlink\" title=\"栈区\"></a>栈区</h2><p>栈区由编译器自动分配释放，由操作系统自动管理，<strong>无须手动管理</strong>。</p>\n<p>栈区上的内容只在函数范围内存在，<strong>当函数运行结束，这些内容也会自动被销毁</strong>。</p>\n<p>栈区按内存地址由高到低方向生长，其最大大小由编译时确定，<strong>速度快，但自由性差，最大空间不大</strong>。</p>\n<p>但是对于栈来讲，一般都是有一定的空间大小的，默认的栈空间大小是1M（听博主诌了一个，反正就是很小）</p>\n<p>栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出</p>\n<p>栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>\n<p><strong>栈区是先进后出原则</strong>，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。先进后出的定义是比较有趣的，因为栈区主要为函数的和函数范围的调用，函数套函数套函数套n个函数之后，要释放内存，就可以从最后面的函数开始一个一个往外出，所以就形成先进后出</p>\n<p><strong>临时创建的局部变量和const定义的局部变量存放在栈区。</strong></p>\n<p>函数调用和返回时，其<strong>入口参数和返回值存放在栈区。</strong></p>\n<p><strong>局部变量不要定义的太大，</strong>不然占用非常大的栈区空间，会导致栈溢出；</p>\n<p>栈用于函数嵌套调用、中断切换时保存和恢复现场数据。调用函数不要有深层次的调用，调用函数的过程中栈区会不停的存储函数的一些相关的变量、地址之类的，如果有深层次函数递归的需要，尽量采用别的方式去替代它；</p>\n<h2 id=\"堆区\"><a href=\"#堆区\" class=\"headerlink\" title=\"堆区\"></a>堆区</h2><p>堆区由<strong>程序员分配内存和释放</strong>，系统不自动回收，所以一定要记得<strong>申请了就要释放，以免溢出</strong>。</p>\n<p>堆区按内存地址由低到高方向生长，其大小由系统内存&#x2F;虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</p>\n<p> C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。</p>\n<p>一般来讲在 32 位系统下，<strong>堆内存可以达到4G的空间</strong>，从这个角度来看堆内存几乎是没有什么限制的。</p>\n<p>对于堆来讲，频繁的 new&#x2F;delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。</p>\n<p>释放的时候只能释放一次，不要重复释放，因为释放后的内存可能会去做别的事情，重复释放会出现问题，释放完后让这个指针最好指向空地址，避免下次用这个指针的时候出现地址错误。</p>\n<p>系统提供了四个库函数来实现内存的动态分配：</p>\n<p>（1）malloc(size) 在内存的动态存储区中分配一个长度为size的连续空间。</p>\n<p>（2）calloc(n,size) 在内存的动态存储区中分配n个长度为size的连续空间。</p>\n<p>（3）free(p) 释放指针变量p做指向的动态空间。</p>\n<p>（4）realloc(p,size) 将指针变量p指向的动态空间大小改变为size。</p>\n<h2 id=\"全局静态区（static）\"><a href=\"#全局静态区（static）\" class=\"headerlink\" title=\"全局静态区（static）\"></a>全局静态区（static）</h2><p>通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。</p>\n<p>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p>\n<h2 id=\"常量区\"><a href=\"#常量区\" class=\"headerlink\" title=\"常量区\"></a>常量区</h2><p><strong>字符串</strong>、<strong>数字</strong>等常量存放在常量区。</p>\n<p><strong>const修饰的全局变量</strong>存放在常量区。</p>\n<p>程序运行期间，<strong>常量</strong>区的内容不可以被修改，程序结束后由系统释放。</p>\n<h2 id=\"代码区\"><a href=\"#代码区\" class=\"headerlink\" title=\"代码区\"></a>代码区</h2><p>程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。</p>\n<p>字符串常量和define定义的常量也有可能存放在代码区。</p>\n<p>表示程序所占用 FLASH 的大小，即代码区（FLASH）；</p>\n<h2 id=\"定义演示\"><a href=\"#定义演示\" class=\"headerlink\" title=\"定义演示\"></a>定义演示</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span>  a=<span class=\"hljs-number\">0</span>;   全局初始化区    <br><br><span class=\"hljs-type\">char</span> *p1;   全局未初始化区    <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>  <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>    </span><br><span class=\"hljs-function\"></span>&#123;    <br>  <span class=\"hljs-type\">int</span>  b; <span class=\"hljs-comment\">//栈    </span><br>  <span class=\"hljs-type\">char</span>  s[]=<span class=\"hljs-string\">&quot;abc&quot;</span>; <span class=\"hljs-comment\">//栈    </span><br>  <span class=\"hljs-type\">char</span>  *p2; <span class=\"hljs-comment\">//栈    </span><br>  <span class=\"hljs-type\">char</span>  *p3=<span class=\"hljs-string\">&quot;123456&quot;</span>; <span class=\"hljs-comment\">//123456/0在常量区，p3在栈上。    </span><br><br>  <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> c =<span class=\"hljs-number\">0</span>；<span class=\"hljs-comment\">//全局（静态）初始化区    </span><br>  p1 =  (<span class=\"hljs-type\">char</span>  *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">//分配得来得10和20字节的区域就在堆区</span><br>  p2  = (<span class=\"hljs-type\">char</span>  *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">20</span>);       <br>  <span class=\"hljs-built_in\">strcpy</span>(p3,<span class=\"hljs-string\">&quot;123456&quot;</span>); <span class=\"hljs-comment\">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;  优化成一个地方。    </span><br>&#125; <br></code></pre></td></tr></table></figure>\n\n<h2 id=\"RAM和ROM\"><a href=\"#RAM和ROM\" class=\"headerlink\" title=\"RAM和ROM\"></a>RAM和ROM</h2><h4 id=\"RAM是“Random-Access-Memory”的缩写，被译为随机存储器。\"><a href=\"#RAM是“Random-Access-Memory”的缩写，被译为随机存储器。\" class=\"headerlink\" title=\"RAM是“Random Access Memory”的缩写，被译为随机存储器。\"></a>RAM是“Random Access Memory”的缩写，被译为随机存储器。</h4><p>根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种。</p>\n<p>动态随机存储器DRAM的存储单元以电容的电荷来表示数据，有电荷代表1，无电荷代表0， 但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，因此它需要定期刷新操作，这就是“动态(Dynamic)”一词所形容的特性。 刷新操作会对电容进行检查，若电量大于满电量的1&#x2F;2，则认为其代表1，并把电容充满电；若电量小于1&#x2F;2，则认为其代表0，并把电容放电，藉此来保证数据的正确性。</p>\n<p>静态随机存储器SRAM的存储单元以锁存器来存储数据，这种电路结构不需要定时刷新充电，就能保持状态(当然，如果断电了，数据还是会丢失的)，所以这种存储器被称为“静态(Static)”RAM。</p>\n<h4 id=\"ROM是“Read-Only-Memory”的缩写，意为只能读的存储器。\"><a href=\"#ROM是“Read-Only-Memory”的缩写，意为只能读的存储器。\" class=\"headerlink\" title=\"ROM是“Read Only Memory”的缩写，意为只能读的存储器。\"></a>ROM是“Read Only Memory”的缩写，意为只能读的存储器。</h4><p>EEPROM(Electrically Erasable Programmable ROM)是电可擦除存储器。 EEPROM可以重复擦写，它的擦除和写入都是直接使用电路控制， 不需要再使用外部设备来擦写。而且可以按字节为单位修改数据，无需整个芯片擦除。现在主要使用的ROM芯片都是EEPROM。</p>\n<p>FLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多， 且在擦除时，一般以多个字节为单位。</p>\n"},{"title":"Linux信号signal学习","date":"2024-08-08T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/5ZbTO7NnIPkCox8.png","_content":"\n# Linux信号signal学习\n\n### 感谢博主：\n\n[Linux 信号(Signal)-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2363224)\n\n我们经常会使用 `kill` 命令杀掉运行中的进程，对多次杀不死的进程进一步用 `kill -9` 干掉它。\n\n你可能知道这是在用 `kill` 命令向进程发送信号，优雅或粗暴的让进程退出。\n\n我们能向进程发送很多类型的信号，其中一些常见的信号 **SIGINT** 、**SIGQUIT**、 **SIGTERM** 和 **SIGKILL** 都是通知进程退出\n\n### 什么是信号\n\n信号（Signal）是 Linux 进程收到的一个通知。当进程收到一个信号时，该进程会中断其执行，并执行收到信号对应的处理程序。\n\n信号机制作为 Linux 进程间通信的一种方法。Linux 进程间通信常用的方法还有管道、消息、共享内存等。\n\n#### 信号的产生有多种来源：\n\n硬件来源，例如 CPU 内存访问出错，当前进程会收到信号 SIGSEGV；按下 `Ctrl+C` 键，当前运行的进程会收到信号 SIGINT 而退出；\n\n软件来源，例如用户通过命令 `kill [pid]`，直接向一个进程发送信号。进程使用系统调用 [int kill(pid_t pid, int sig)](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman2%2Fkill.2.html&source=article&objectId=2363224) 显示的向另一个进程发送信号。内核在某些情况下，也会给进程发送信号，例如当子进程退出时，内核给父进程发送 SIGCHLD 信号。\n\n#### 系统信号种类\n\n```\n$ kill -l\n 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP\n 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1\n11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM\n16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP\n21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ\n26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR\n31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3\n38) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8\n43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+13\n48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\t51) SIGRTMAX-13\t52) SIGRTMAX-12\n53) SIGRTMAX-11\t54) SIGRTMAX-10\t55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-7\n58) SIGRTMAX-6\t59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-2\n63) SIGRTMAX-1\t64) SIGRTMAX\n```\n\n### 信号和中断\n\n信号处理是一种典型的**异步事件处理方式**：进程需要提前向内核注册信号处理函数，当某个信号到来时，内核会就执行相应的信号处理函数。\n\n我们知道，硬件中断也是一种内核的**异步事件处理方式**。当外部设备出现一个必须由 CPU 处理的事件，如键盘敲击、数据到达网卡等，内核会收到中断通知，暂时打断当前程序的执行，跳转到该中断类型对应的中断处理程序。中断处理程序是由 BIOS 和操作系统在系统启动过程中预先注册在内核中的。\n\n中断和信号通知都是在内核产生。中断是完全在内核里完成处理，而**信号的处理则是在用户态完成的**。也就是说，内核只是将信号保存在进程相关的数据结构里面，在执行信号处理程序之前，需要从内核态切换到用户态，执行完信号处理程序之后，又回到内核态，再恢复进程正常的运行。\n\n可以看出，中断和信号的严重程度不一样。信号影响的是一个进程，信号处理出了问题，最多是这个进程被干掉。而中断影响的是整个系统，一旦中断处理程序出了问题，可能整个系统都会挂掉。\n\n### 信号处理\n\n一旦有信号产生，进程对它的处理都有下面三个选择。\n\n1. **执行缺省操作（Default）**。Linux 为每个信号都定义了一个缺省的行为。例如，信号 SIGKILL 的缺省操作是 Term，也就是终止进程的意思。信号 SIGQUIT 的缺省操作是 Core，即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面。\n2. **捕捉信号（Catch）**。这个是指让用户进程可以注册自己针对这个信号的处理函数。当信号发生时，就执行我们注册的信号处理函数。\n3. **忽略信号（Ignore）**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。\n\n有两个信号例外，对于 **SIGKILL** 和 **SIGSTOP** 这个两个信号，进程是无法捕捉和忽略，它们用于在任何时候中断或结束某一进程。**SIGKILL** 和 **SIGSTOP** 为内核和超级用户提供了删除任意进程的特权。\n","source":"_posts/Work No.19.md","raw":"---\ntitle: Linux信号signal学习\ntag: 信号signal\ndate: 2024-08-09\ncategories: Linux\nindex_img: https://s2.loli.net/2024/08/02/5ZbTO7NnIPkCox8.png\n---\n\n# Linux信号signal学习\n\n### 感谢博主：\n\n[Linux 信号(Signal)-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2363224)\n\n我们经常会使用 `kill` 命令杀掉运行中的进程，对多次杀不死的进程进一步用 `kill -9` 干掉它。\n\n你可能知道这是在用 `kill` 命令向进程发送信号，优雅或粗暴的让进程退出。\n\n我们能向进程发送很多类型的信号，其中一些常见的信号 **SIGINT** 、**SIGQUIT**、 **SIGTERM** 和 **SIGKILL** 都是通知进程退出\n\n### 什么是信号\n\n信号（Signal）是 Linux 进程收到的一个通知。当进程收到一个信号时，该进程会中断其执行，并执行收到信号对应的处理程序。\n\n信号机制作为 Linux 进程间通信的一种方法。Linux 进程间通信常用的方法还有管道、消息、共享内存等。\n\n#### 信号的产生有多种来源：\n\n硬件来源，例如 CPU 内存访问出错，当前进程会收到信号 SIGSEGV；按下 `Ctrl+C` 键，当前运行的进程会收到信号 SIGINT 而退出；\n\n软件来源，例如用户通过命令 `kill [pid]`，直接向一个进程发送信号。进程使用系统调用 [int kill(pid_t pid, int sig)](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman2%2Fkill.2.html&source=article&objectId=2363224) 显示的向另一个进程发送信号。内核在某些情况下，也会给进程发送信号，例如当子进程退出时，内核给父进程发送 SIGCHLD 信号。\n\n#### 系统信号种类\n\n```\n$ kill -l\n 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP\n 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1\n11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM\n16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP\n21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ\n26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR\n31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3\n38) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8\n43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+13\n48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\t51) SIGRTMAX-13\t52) SIGRTMAX-12\n53) SIGRTMAX-11\t54) SIGRTMAX-10\t55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-7\n58) SIGRTMAX-6\t59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-2\n63) SIGRTMAX-1\t64) SIGRTMAX\n```\n\n### 信号和中断\n\n信号处理是一种典型的**异步事件处理方式**：进程需要提前向内核注册信号处理函数，当某个信号到来时，内核会就执行相应的信号处理函数。\n\n我们知道，硬件中断也是一种内核的**异步事件处理方式**。当外部设备出现一个必须由 CPU 处理的事件，如键盘敲击、数据到达网卡等，内核会收到中断通知，暂时打断当前程序的执行，跳转到该中断类型对应的中断处理程序。中断处理程序是由 BIOS 和操作系统在系统启动过程中预先注册在内核中的。\n\n中断和信号通知都是在内核产生。中断是完全在内核里完成处理，而**信号的处理则是在用户态完成的**。也就是说，内核只是将信号保存在进程相关的数据结构里面，在执行信号处理程序之前，需要从内核态切换到用户态，执行完信号处理程序之后，又回到内核态，再恢复进程正常的运行。\n\n可以看出，中断和信号的严重程度不一样。信号影响的是一个进程，信号处理出了问题，最多是这个进程被干掉。而中断影响的是整个系统，一旦中断处理程序出了问题，可能整个系统都会挂掉。\n\n### 信号处理\n\n一旦有信号产生，进程对它的处理都有下面三个选择。\n\n1. **执行缺省操作（Default）**。Linux 为每个信号都定义了一个缺省的行为。例如，信号 SIGKILL 的缺省操作是 Term，也就是终止进程的意思。信号 SIGQUIT 的缺省操作是 Core，即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面。\n2. **捕捉信号（Catch）**。这个是指让用户进程可以注册自己针对这个信号的处理函数。当信号发生时，就执行我们注册的信号处理函数。\n3. **忽略信号（Ignore）**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。\n\n有两个信号例外，对于 **SIGKILL** 和 **SIGSTOP** 这个两个信号，进程是无法捕捉和忽略，它们用于在任何时候中断或结束某一进程。**SIGKILL** 和 **SIGSTOP** 为内核和超级用户提供了删除任意进程的特权。\n","slug":"Work No.19","published":1,"updated":"2024-08-09T06:47:26.040Z","comments":1,"layout":"post","photos":[],"_id":"clzmh9t9x0003gsfbf9cldd4v","content":"<h1 id=\"Linux信号signal学习\"><a href=\"#Linux信号signal学习\" class=\"headerlink\" title=\"Linux信号signal学习\"></a>Linux信号signal学习</h1><h3 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h3><p><a href=\"https://cloud.tencent.com/developer/article/2363224\">Linux 信号(Signal)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n<p>我们经常会使用 <code>kill</code> 命令杀掉运行中的进程，对多次杀不死的进程进一步用 <code>kill -9</code> 干掉它。</p>\n<p>你可能知道这是在用 <code>kill</code> 命令向进程发送信号，优雅或粗暴的让进程退出。</p>\n<p>我们能向进程发送很多类型的信号，其中一些常见的信号 <strong>SIGINT</strong> 、<strong>SIGQUIT</strong>、 <strong>SIGTERM</strong> 和 <strong>SIGKILL</strong> 都是通知进程退出</p>\n<h3 id=\"什么是信号\"><a href=\"#什么是信号\" class=\"headerlink\" title=\"什么是信号\"></a>什么是信号</h3><p>信号（Signal）是 Linux 进程收到的一个通知。当进程收到一个信号时，该进程会中断其执行，并执行收到信号对应的处理程序。</p>\n<p>信号机制作为 Linux 进程间通信的一种方法。Linux 进程间通信常用的方法还有管道、消息、共享内存等。</p>\n<h4 id=\"信号的产生有多种来源：\"><a href=\"#信号的产生有多种来源：\" class=\"headerlink\" title=\"信号的产生有多种来源：\"></a>信号的产生有多种来源：</h4><p>硬件来源，例如 CPU 内存访问出错，当前进程会收到信号 SIGSEGV；按下 <code>Ctrl+C</code> 键，当前运行的进程会收到信号 SIGINT 而退出；</p>\n<p>软件来源，例如用户通过命令 <code>kill [pid]</code>，直接向一个进程发送信号。进程使用系统调用 <a href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https://man7.org/linux/man-pages/man2/kill.2.html&source=article&objectId=2363224\">int kill(pid_t pid, int sig)</a> 显示的向另一个进程发送信号。内核在某些情况下，也会给进程发送信号，例如当子进程退出时，内核给父进程发送 SIGCHLD 信号。</p>\n<h4 id=\"系统信号种类\"><a href=\"#系统信号种类\" class=\"headerlink\" title=\"系统信号种类\"></a>系统信号种类</h4><figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs subunit\">$ kill -l<br> 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP<br> 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1<br>11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM<br>16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP<br>21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ<br>26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR<br>31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN<span class=\"hljs-string\">+1</span>\t36) SIGRTMIN<span class=\"hljs-string\">+2</span>\t37) SIGRTMIN<span class=\"hljs-string\">+3</span><br>38) SIGRTMIN<span class=\"hljs-string\">+4</span>\t39) SIGRTMIN<span class=\"hljs-string\">+5</span>\t40) SIGRTMIN<span class=\"hljs-string\">+6</span>\t41) SIGRTMIN<span class=\"hljs-string\">+7</span>\t42) SIGRTMIN<span class=\"hljs-string\">+8</span><br>43) SIGRTMIN<span class=\"hljs-string\">+9</span>\t44) SIGRTMIN<span class=\"hljs-string\">+10</span>\t45) SIGRTMIN<span class=\"hljs-string\">+11</span>\t46) SIGRTMIN<span class=\"hljs-string\">+12</span>\t47) SIGRTMIN<span class=\"hljs-string\">+13</span><br>48) SIGRTMIN<span class=\"hljs-string\">+14</span>\t49) SIGRTMIN<span class=\"hljs-string\">+15</span>\t50) SIGRTMAX<span class=\"hljs-string\">-14</span>\t51) SIGRTMAX<span class=\"hljs-string\">-13</span>\t52) SIGRTMAX<span class=\"hljs-string\">-12</span><br>53) SIGRTMAX<span class=\"hljs-string\">-11</span>\t54) SIGRTMAX<span class=\"hljs-string\">-10</span>\t55) SIGRTMAX<span class=\"hljs-string\">-9</span>\t56) SIGRTMAX<span class=\"hljs-string\">-8</span>\t57) SIGRTMAX<span class=\"hljs-string\">-7</span><br>58) SIGRTMAX<span class=\"hljs-string\">-6</span>\t59) SIGRTMAX<span class=\"hljs-string\">-5</span>\t60) SIGRTMAX<span class=\"hljs-string\">-4</span>\t61) SIGRTMAX<span class=\"hljs-string\">-3</span>\t62) SIGRTMAX<span class=\"hljs-string\">-2</span><br>63) SIGRTMAX<span class=\"hljs-string\">-1</span>\t64) SIGRTMAX<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"信号和中断\"><a href=\"#信号和中断\" class=\"headerlink\" title=\"信号和中断\"></a>信号和中断</h3><p>信号处理是一种典型的<strong>异步事件处理方式</strong>：进程需要提前向内核注册信号处理函数，当某个信号到来时，内核会就执行相应的信号处理函数。</p>\n<p>我们知道，硬件中断也是一种内核的<strong>异步事件处理方式</strong>。当外部设备出现一个必须由 CPU 处理的事件，如键盘敲击、数据到达网卡等，内核会收到中断通知，暂时打断当前程序的执行，跳转到该中断类型对应的中断处理程序。中断处理程序是由 BIOS 和操作系统在系统启动过程中预先注册在内核中的。</p>\n<p>中断和信号通知都是在内核产生。中断是完全在内核里完成处理，而<strong>信号的处理则是在用户态完成的</strong>。也就是说，内核只是将信号保存在进程相关的数据结构里面，在执行信号处理程序之前，需要从内核态切换到用户态，执行完信号处理程序之后，又回到内核态，再恢复进程正常的运行。</p>\n<p>可以看出，中断和信号的严重程度不一样。信号影响的是一个进程，信号处理出了问题，最多是这个进程被干掉。而中断影响的是整个系统，一旦中断处理程序出了问题，可能整个系统都会挂掉。</p>\n<h3 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h3><p>一旦有信号产生，进程对它的处理都有下面三个选择。</p>\n<ol>\n<li><strong>执行缺省操作（Default）</strong>。Linux 为每个信号都定义了一个缺省的行为。例如，信号 SIGKILL 的缺省操作是 Term，也就是终止进程的意思。信号 SIGQUIT 的缺省操作是 Core，即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面。</li>\n<li><strong>捕捉信号（Catch）</strong>。这个是指让用户进程可以注册自己针对这个信号的处理函数。当信号发生时，就执行我们注册的信号处理函数。</li>\n<li><strong>忽略信号（Ignore）</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</li>\n</ol>\n<p>有两个信号例外，对于 <strong>SIGKILL</strong> 和 <strong>SIGSTOP</strong> 这个两个信号，进程是无法捕捉和忽略，它们用于在任何时候中断或结束某一进程。<strong>SIGKILL</strong> 和 <strong>SIGSTOP</strong> 为内核和超级用户提供了删除任意进程的特权。</p>\n","excerpt":"","more":"<h1 id=\"Linux信号signal学习\"><a href=\"#Linux信号signal学习\" class=\"headerlink\" title=\"Linux信号signal学习\"></a>Linux信号signal学习</h1><h3 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h3><p><a href=\"https://cloud.tencent.com/developer/article/2363224\">Linux 信号(Signal)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n<p>我们经常会使用 <code>kill</code> 命令杀掉运行中的进程，对多次杀不死的进程进一步用 <code>kill -9</code> 干掉它。</p>\n<p>你可能知道这是在用 <code>kill</code> 命令向进程发送信号，优雅或粗暴的让进程退出。</p>\n<p>我们能向进程发送很多类型的信号，其中一些常见的信号 <strong>SIGINT</strong> 、<strong>SIGQUIT</strong>、 <strong>SIGTERM</strong> 和 <strong>SIGKILL</strong> 都是通知进程退出</p>\n<h3 id=\"什么是信号\"><a href=\"#什么是信号\" class=\"headerlink\" title=\"什么是信号\"></a>什么是信号</h3><p>信号（Signal）是 Linux 进程收到的一个通知。当进程收到一个信号时，该进程会中断其执行，并执行收到信号对应的处理程序。</p>\n<p>信号机制作为 Linux 进程间通信的一种方法。Linux 进程间通信常用的方法还有管道、消息、共享内存等。</p>\n<h4 id=\"信号的产生有多种来源：\"><a href=\"#信号的产生有多种来源：\" class=\"headerlink\" title=\"信号的产生有多种来源：\"></a>信号的产生有多种来源：</h4><p>硬件来源，例如 CPU 内存访问出错，当前进程会收到信号 SIGSEGV；按下 <code>Ctrl+C</code> 键，当前运行的进程会收到信号 SIGINT 而退出；</p>\n<p>软件来源，例如用户通过命令 <code>kill [pid]</code>，直接向一个进程发送信号。进程使用系统调用 <a href=\"https://cloud.tencent.com/developer/tools/blog-entry?target=https://man7.org/linux/man-pages/man2/kill.2.html&source=article&objectId=2363224\">int kill(pid_t pid, int sig)</a> 显示的向另一个进程发送信号。内核在某些情况下，也会给进程发送信号，例如当子进程退出时，内核给父进程发送 SIGCHLD 信号。</p>\n<h4 id=\"系统信号种类\"><a href=\"#系统信号种类\" class=\"headerlink\" title=\"系统信号种类\"></a>系统信号种类</h4><figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs subunit\">$ kill -l<br> 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP<br> 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1<br>11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM<br>16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP<br>21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ<br>26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR<br>31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN<span class=\"hljs-string\">+1</span>\t36) SIGRTMIN<span class=\"hljs-string\">+2</span>\t37) SIGRTMIN<span class=\"hljs-string\">+3</span><br>38) SIGRTMIN<span class=\"hljs-string\">+4</span>\t39) SIGRTMIN<span class=\"hljs-string\">+5</span>\t40) SIGRTMIN<span class=\"hljs-string\">+6</span>\t41) SIGRTMIN<span class=\"hljs-string\">+7</span>\t42) SIGRTMIN<span class=\"hljs-string\">+8</span><br>43) SIGRTMIN<span class=\"hljs-string\">+9</span>\t44) SIGRTMIN<span class=\"hljs-string\">+10</span>\t45) SIGRTMIN<span class=\"hljs-string\">+11</span>\t46) SIGRTMIN<span class=\"hljs-string\">+12</span>\t47) SIGRTMIN<span class=\"hljs-string\">+13</span><br>48) SIGRTMIN<span class=\"hljs-string\">+14</span>\t49) SIGRTMIN<span class=\"hljs-string\">+15</span>\t50) SIGRTMAX<span class=\"hljs-string\">-14</span>\t51) SIGRTMAX<span class=\"hljs-string\">-13</span>\t52) SIGRTMAX<span class=\"hljs-string\">-12</span><br>53) SIGRTMAX<span class=\"hljs-string\">-11</span>\t54) SIGRTMAX<span class=\"hljs-string\">-10</span>\t55) SIGRTMAX<span class=\"hljs-string\">-9</span>\t56) SIGRTMAX<span class=\"hljs-string\">-8</span>\t57) SIGRTMAX<span class=\"hljs-string\">-7</span><br>58) SIGRTMAX<span class=\"hljs-string\">-6</span>\t59) SIGRTMAX<span class=\"hljs-string\">-5</span>\t60) SIGRTMAX<span class=\"hljs-string\">-4</span>\t61) SIGRTMAX<span class=\"hljs-string\">-3</span>\t62) SIGRTMAX<span class=\"hljs-string\">-2</span><br>63) SIGRTMAX<span class=\"hljs-string\">-1</span>\t64) SIGRTMAX<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"信号和中断\"><a href=\"#信号和中断\" class=\"headerlink\" title=\"信号和中断\"></a>信号和中断</h3><p>信号处理是一种典型的<strong>异步事件处理方式</strong>：进程需要提前向内核注册信号处理函数，当某个信号到来时，内核会就执行相应的信号处理函数。</p>\n<p>我们知道，硬件中断也是一种内核的<strong>异步事件处理方式</strong>。当外部设备出现一个必须由 CPU 处理的事件，如键盘敲击、数据到达网卡等，内核会收到中断通知，暂时打断当前程序的执行，跳转到该中断类型对应的中断处理程序。中断处理程序是由 BIOS 和操作系统在系统启动过程中预先注册在内核中的。</p>\n<p>中断和信号通知都是在内核产生。中断是完全在内核里完成处理，而<strong>信号的处理则是在用户态完成的</strong>。也就是说，内核只是将信号保存在进程相关的数据结构里面，在执行信号处理程序之前，需要从内核态切换到用户态，执行完信号处理程序之后，又回到内核态，再恢复进程正常的运行。</p>\n<p>可以看出，中断和信号的严重程度不一样。信号影响的是一个进程，信号处理出了问题，最多是这个进程被干掉。而中断影响的是整个系统，一旦中断处理程序出了问题，可能整个系统都会挂掉。</p>\n<h3 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h3><p>一旦有信号产生，进程对它的处理都有下面三个选择。</p>\n<ol>\n<li><strong>执行缺省操作（Default）</strong>。Linux 为每个信号都定义了一个缺省的行为。例如，信号 SIGKILL 的缺省操作是 Term，也就是终止进程的意思。信号 SIGQUIT 的缺省操作是 Core，即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面。</li>\n<li><strong>捕捉信号（Catch）</strong>。这个是指让用户进程可以注册自己针对这个信号的处理函数。当信号发生时，就执行我们注册的信号处理函数。</li>\n<li><strong>忽略信号（Ignore）</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</li>\n</ol>\n<p>有两个信号例外，对于 <strong>SIGKILL</strong> 和 <strong>SIGSTOP</strong> 这个两个信号，进程是无法捕捉和忽略，它们用于在任何时候中断或结束某一进程。<strong>SIGKILL</strong> 和 <strong>SIGSTOP</strong> 为内核和超级用户提供了删除任意进程的特权。</p>\n"},{"title":"Linux消息队列学习","date":"2024-08-08T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/smPFoif4rdC3xeW.png","_content":"\n# Linux消息队列学习\n\n## 感谢博主：\n\n[消息队列（定义、结构、如何创建、消息队列的发送与接收、发送与接收实例）_vc中如何定义使用消息队列-CSDN博客](https://blog.csdn.net/scarificed/article/details/121475146)\n\n## 消息队列概述\n\n官方说法是，MQ（全称Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式，队列就是一个消息容器\n\n现实使用中，我们将消息队列称之为**中间件**，从它的名字就可以看出，消息队列不存储消息内容的本身，它只是消息的搬运工\n\n消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。\n\n#### 消息和队列\n\n**消息：**需要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式\n\n**队列：**一种先进先出的数据结构，在这里是存放消息的容器，入队即发消息的过程，出队即收消息的过程\n\n**过程：**生产者将消息投递到一个叫做 队列 的容器中，然后再从容器中取出消息，最后转发给消费者\n\n#### 队列模型（又叫做点对点模型）\n\n**点对点模式（PTP）**：一个生产者发送的每一个消息，都只有一个消费者消费，看起来就像消息从一个点被传递到另一个点，也就是**单播**\n\n它允许多个生产者向同一个队列里发送消息，但是只有一个消费者能拿到数据，如果有多个消费者，那么多个消费者是竞争者关系，最终一条消息只能被其中一个消费者接收到，读完即会被删除\n\n#### 发布订阅模式\n\n一个生产者发送的每一个消息，都会发送到所有订阅了此队列的消费者，也就是**广播**\n\n在发布订阅模型中，存放消息的容器变成了主题（主题也是一个队列），订阅者在接收消息之前需要先订阅主题，最终，每个订阅者都可以收到同一个主题的全量消息，可以看到和队列模式唯一不同的就是，发布订阅模式中的**一份消息数据可以被多次消费**\n\n## 消息队列结构\n\n消息队列中消息本身由消息类型和消息数据组成，通常使用如下结构：\n\n```\nstruct msgbuf\n{\n\tlong \tmtype;//mtype指定了消息类型，为正整数。\n\tchar\tmtext[1];//mtext指定了消息的数据。我们可以定义任意的数据类型甚至包括结构来描述消息数据\n}\n```\n\n**mtype：**引入消息类型之后，消息队列在逻辑上由一个消息链表转化为多个消息链表。发送进程仍然无条件把消息写入队列的尾部，但接收进程却可以有选择地读取某个特定类型的消息中最接近队列头的一个，即使该消息不在队列头。相应消息一旦被读取，就从队列中删除，其它消息维持不变。\n\n#### 创建消息队列\n\n```\nint msgget(key_t key, int msgflg);\n//参数key是消息队列的关键字\n//参数msgflg的低9位指定队列的属主、属组和其他用户的访问权限，其它位指定消息队列的创建方式。\n\t//IPC_CREAT：创建，如存在则打开；\n\t//IPC_EXCL：与IPC_CREAT使用，单独使用无意义。创建时，如存在则失败。\n\t\n//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在返回其标识号。\nint msgid;\nmsgid = msgget(0x1234, 0666|IPC_CREAT);\n\n//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在则报错。\nint msgid;\nmsgid = msgget(0x1234, 0666|IPC_CREAT|IPC_EXCL);\n```\n\n#### 消息队列发送\n\n```\n//发送消息\nint msgsnd(int msqid, void *msgp, int msgsz, int msgflg);\n    //msgid：指定发送消息队列的标识号；\n    //msgp：指向存储待发送消息内容的内存地址，用户可设计自己的消息结构；\n    //msgsz：指定长度，仅记载数据的长度，不包括消息类型部分，且必须大于0；\n    //msgflg：控制消息发送的方式，有阻塞和非阻塞（IPC_NOWAIT）两种方式。\n```\n\n#### 消息队列的发送流程\n\n```\n//第一步，定义消息结构\nstruct msgbuf{\t\n\tlong mtype;\t\t\n\tchar ctext[100];\n}\t\n\n//第二步，创建消息队列\nint msgid;\nmsgid = msgget(KEY, 0666|IPC_CREAT);\nif(msgid < 0)\t//打开或创建消息失败；\n\n//第三步，组织消息\nstruct msgbuf buf;\nbuf.mtype = 100;\nstrcpy(buf.ctext, “HELLO UNIX!”);\n\n//第四步，发送消息\nint ret;\nret = msgsnd(msgid, &buf, strlen(buf.ctext), 0);\n\n//第五步，判断发送是否成功\nif(ret == -1)\n{\n\tif(errno == EINTR)\t//信号中断，重新发送；\n\telse //系统错误\n}\n```\n\n#### 从消息队列中接收消息\n\n```\n//接收队列消息\nint msgrcv(int msgid, void *msgp, int msgsz, long msgtyp, int msgflg);\n\n\t//msgid：消息队列标识号；\n\t//msgp：指向接收消息的内存缓冲区；\n\t//msgsz：指定该缓冲区的最大容量，不包括消息类型占用的部分；\n\t//msgtyp：指定读取消息的类型；\n```\n\n#### 消息队列的接收流程\n\n```\n//第一步，定义消息结构\nstruct msgbuf{\t\n\tlong mtype;\t\t\n\tchar ctext[100];\n}\t\n\n//打开（创建）消息队列\nint msgid;\nmsgid = msgget(KEY, 0666|IPC_CREAT);\n\n//准备接收消息缓冲区\nstruct msgbuf buf;\nmemset(buf, 0, sizeof(buf));\n\n//接收消息\nint ret;\nret = msgrcv(msgid, &buf, sizeof(buf.ctext), TYPE, 0);\n\n//接收判断\nif(ret == -1)\n{\n\tif(errno == EINTR)\t //信号中断，重新接收；\n\telse                 //系统错误\n}\n```\n\n### 消息队列信息情况核实\n\n```\n    struct msqid_ds queue_info;\n    if (msgctl(ID, IPC_STAT, &queue_info) == -1) {\n        printf(\"Failed to get queue info for control_queue_ID: %d, errno = %d, error: %s\\n\", ID, errno, strerror(errno));\n    } else {\n        printf(\"Control queue status - messages: %ld\\n\", queue_info.msg_qnum);//检查消息的数量\n        printf(\"Max size of message: %ld\\n\", queue_info.msg_qbytes);//检查消息的最大限制长度\n    }\n    \n    //output\n    Control queue status - messages: 0\n```\n\n### 终端查看消息队列\n\n```\nipcs命令\nipcs -a ：显示全部可以显示的信息\nipcs -q：显示活动的消息队列\nipcs -m：显示活动的共享内存信息\nipcs -s：显示活动的信号量信息\n\nipcrm命令：\nipcrm -m id：删除共享内存标识\nipcrm -M key：删除由关键字创建的共享内存标识\nipcrm -q id ：删除消息队列标识 id和其相关的消息队列和数据结构\nipcrm -Q key：删除由关键字key创建的消息队列和其相关的消息队列和数据结构\nipcs -s id：删除信号标识符id和其相关的信号量集及数据结构\nipcs -S key:删除由关键字key创建的信号量标识及其相关的信号量集及数据结构\n```\n\n## 消息队列优势\n\n1、采用消息队列通信比采用管道通信具有更多的灵活性，通信的进程不但没有血缘上的要求，也不需要进行同步处理。\n2、消息队列是一种先进先出的队列型数据结构；\n3、消息队列将输出的信息进行了打包处理，可以保证以消息为单位进行接收；\n4、消息队列对信息进行分类服务，根据消息的类别进行分别处理。\n5、提供消息数据自动拆分功能，同时不能接受两次发送的消息。\n6、消息队列提供了不完全随机读取的服务。\n7、消息队列提供了完全异步的读写服务。\n","source":"_posts/Work No.20.md","raw":"---\ntitle: Linux消息队列学习\ntag: 消息队列\ndate: 2024-08-09\ncategories: Linux\nindex_img: https://s2.loli.net/2024/08/02/smPFoif4rdC3xeW.png\n---\n\n# Linux消息队列学习\n\n## 感谢博主：\n\n[消息队列（定义、结构、如何创建、消息队列的发送与接收、发送与接收实例）_vc中如何定义使用消息队列-CSDN博客](https://blog.csdn.net/scarificed/article/details/121475146)\n\n## 消息队列概述\n\n官方说法是，MQ（全称Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式，队列就是一个消息容器\n\n现实使用中，我们将消息队列称之为**中间件**，从它的名字就可以看出，消息队列不存储消息内容的本身，它只是消息的搬运工\n\n消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。\n\n#### 消息和队列\n\n**消息：**需要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式\n\n**队列：**一种先进先出的数据结构，在这里是存放消息的容器，入队即发消息的过程，出队即收消息的过程\n\n**过程：**生产者将消息投递到一个叫做 队列 的容器中，然后再从容器中取出消息，最后转发给消费者\n\n#### 队列模型（又叫做点对点模型）\n\n**点对点模式（PTP）**：一个生产者发送的每一个消息，都只有一个消费者消费，看起来就像消息从一个点被传递到另一个点，也就是**单播**\n\n它允许多个生产者向同一个队列里发送消息，但是只有一个消费者能拿到数据，如果有多个消费者，那么多个消费者是竞争者关系，最终一条消息只能被其中一个消费者接收到，读完即会被删除\n\n#### 发布订阅模式\n\n一个生产者发送的每一个消息，都会发送到所有订阅了此队列的消费者，也就是**广播**\n\n在发布订阅模型中，存放消息的容器变成了主题（主题也是一个队列），订阅者在接收消息之前需要先订阅主题，最终，每个订阅者都可以收到同一个主题的全量消息，可以看到和队列模式唯一不同的就是，发布订阅模式中的**一份消息数据可以被多次消费**\n\n## 消息队列结构\n\n消息队列中消息本身由消息类型和消息数据组成，通常使用如下结构：\n\n```\nstruct msgbuf\n{\n\tlong \tmtype;//mtype指定了消息类型，为正整数。\n\tchar\tmtext[1];//mtext指定了消息的数据。我们可以定义任意的数据类型甚至包括结构来描述消息数据\n}\n```\n\n**mtype：**引入消息类型之后，消息队列在逻辑上由一个消息链表转化为多个消息链表。发送进程仍然无条件把消息写入队列的尾部，但接收进程却可以有选择地读取某个特定类型的消息中最接近队列头的一个，即使该消息不在队列头。相应消息一旦被读取，就从队列中删除，其它消息维持不变。\n\n#### 创建消息队列\n\n```\nint msgget(key_t key, int msgflg);\n//参数key是消息队列的关键字\n//参数msgflg的低9位指定队列的属主、属组和其他用户的访问权限，其它位指定消息队列的创建方式。\n\t//IPC_CREAT：创建，如存在则打开；\n\t//IPC_EXCL：与IPC_CREAT使用，单独使用无意义。创建时，如存在则失败。\n\t\n//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在返回其标识号。\nint msgid;\nmsgid = msgget(0x1234, 0666|IPC_CREAT);\n\n//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在则报错。\nint msgid;\nmsgid = msgget(0x1234, 0666|IPC_CREAT|IPC_EXCL);\n```\n\n#### 消息队列发送\n\n```\n//发送消息\nint msgsnd(int msqid, void *msgp, int msgsz, int msgflg);\n    //msgid：指定发送消息队列的标识号；\n    //msgp：指向存储待发送消息内容的内存地址，用户可设计自己的消息结构；\n    //msgsz：指定长度，仅记载数据的长度，不包括消息类型部分，且必须大于0；\n    //msgflg：控制消息发送的方式，有阻塞和非阻塞（IPC_NOWAIT）两种方式。\n```\n\n#### 消息队列的发送流程\n\n```\n//第一步，定义消息结构\nstruct msgbuf{\t\n\tlong mtype;\t\t\n\tchar ctext[100];\n}\t\n\n//第二步，创建消息队列\nint msgid;\nmsgid = msgget(KEY, 0666|IPC_CREAT);\nif(msgid < 0)\t//打开或创建消息失败；\n\n//第三步，组织消息\nstruct msgbuf buf;\nbuf.mtype = 100;\nstrcpy(buf.ctext, “HELLO UNIX!”);\n\n//第四步，发送消息\nint ret;\nret = msgsnd(msgid, &buf, strlen(buf.ctext), 0);\n\n//第五步，判断发送是否成功\nif(ret == -1)\n{\n\tif(errno == EINTR)\t//信号中断，重新发送；\n\telse //系统错误\n}\n```\n\n#### 从消息队列中接收消息\n\n```\n//接收队列消息\nint msgrcv(int msgid, void *msgp, int msgsz, long msgtyp, int msgflg);\n\n\t//msgid：消息队列标识号；\n\t//msgp：指向接收消息的内存缓冲区；\n\t//msgsz：指定该缓冲区的最大容量，不包括消息类型占用的部分；\n\t//msgtyp：指定读取消息的类型；\n```\n\n#### 消息队列的接收流程\n\n```\n//第一步，定义消息结构\nstruct msgbuf{\t\n\tlong mtype;\t\t\n\tchar ctext[100];\n}\t\n\n//打开（创建）消息队列\nint msgid;\nmsgid = msgget(KEY, 0666|IPC_CREAT);\n\n//准备接收消息缓冲区\nstruct msgbuf buf;\nmemset(buf, 0, sizeof(buf));\n\n//接收消息\nint ret;\nret = msgrcv(msgid, &buf, sizeof(buf.ctext), TYPE, 0);\n\n//接收判断\nif(ret == -1)\n{\n\tif(errno == EINTR)\t //信号中断，重新接收；\n\telse                 //系统错误\n}\n```\n\n### 消息队列信息情况核实\n\n```\n    struct msqid_ds queue_info;\n    if (msgctl(ID, IPC_STAT, &queue_info) == -1) {\n        printf(\"Failed to get queue info for control_queue_ID: %d, errno = %d, error: %s\\n\", ID, errno, strerror(errno));\n    } else {\n        printf(\"Control queue status - messages: %ld\\n\", queue_info.msg_qnum);//检查消息的数量\n        printf(\"Max size of message: %ld\\n\", queue_info.msg_qbytes);//检查消息的最大限制长度\n    }\n    \n    //output\n    Control queue status - messages: 0\n```\n\n### 终端查看消息队列\n\n```\nipcs命令\nipcs -a ：显示全部可以显示的信息\nipcs -q：显示活动的消息队列\nipcs -m：显示活动的共享内存信息\nipcs -s：显示活动的信号量信息\n\nipcrm命令：\nipcrm -m id：删除共享内存标识\nipcrm -M key：删除由关键字创建的共享内存标识\nipcrm -q id ：删除消息队列标识 id和其相关的消息队列和数据结构\nipcrm -Q key：删除由关键字key创建的消息队列和其相关的消息队列和数据结构\nipcs -s id：删除信号标识符id和其相关的信号量集及数据结构\nipcs -S key:删除由关键字key创建的信号量标识及其相关的信号量集及数据结构\n```\n\n## 消息队列优势\n\n1、采用消息队列通信比采用管道通信具有更多的灵活性，通信的进程不但没有血缘上的要求，也不需要进行同步处理。\n2、消息队列是一种先进先出的队列型数据结构；\n3、消息队列将输出的信息进行了打包处理，可以保证以消息为单位进行接收；\n4、消息队列对信息进行分类服务，根据消息的类别进行分别处理。\n5、提供消息数据自动拆分功能，同时不能接受两次发送的消息。\n6、消息队列提供了不完全随机读取的服务。\n7、消息队列提供了完全异步的读写服务。\n","slug":"Work No.20","published":1,"updated":"2024-09-02T02:44:12.135Z","_id":"clzmh9t9x0006gsfbfr9md9j1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Linux消息队列学习\"><a href=\"#Linux消息队列学习\" class=\"headerlink\" title=\"Linux消息队列学习\"></a>Linux消息队列学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/scarificed/article/details/121475146\">消息队列（定义、结构、如何创建、消息队列的发送与接收、发送与接收实例）_vc中如何定义使用消息队列-CSDN博客</a></p>\n<h2 id=\"消息队列概述\"><a href=\"#消息队列概述\" class=\"headerlink\" title=\"消息队列概述\"></a>消息队列概述</h2><p>官方说法是，MQ（全称Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式，队列就是一个消息容器</p>\n<p>现实使用中，我们将消息队列称之为<strong>中间件</strong>，从它的名字就可以看出，消息队列不存储消息内容的本身，它只是消息的搬运工</p>\n<p>消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。</p>\n<h4 id=\"消息和队列\"><a href=\"#消息和队列\" class=\"headerlink\" title=\"消息和队列\"></a>消息和队列</h4><p><strong>消息：</strong>需要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式</p>\n<p><strong>队列：</strong>一种先进先出的数据结构，在这里是存放消息的容器，入队即发消息的过程，出队即收消息的过程</p>\n<p><strong>过程：</strong>生产者将消息投递到一个叫做 队列 的容器中，然后再从容器中取出消息，最后转发给消费者</p>\n<h4 id=\"队列模型（又叫做点对点模型）\"><a href=\"#队列模型（又叫做点对点模型）\" class=\"headerlink\" title=\"队列模型（又叫做点对点模型）\"></a>队列模型（又叫做点对点模型）</h4><p><strong>点对点模式（PTP）</strong>：一个生产者发送的每一个消息，都只有一个消费者消费，看起来就像消息从一个点被传递到另一个点，也就是<strong>单播</strong></p>\n<p>它允许多个生产者向同一个队列里发送消息，但是只有一个消费者能拿到数据，如果有多个消费者，那么多个消费者是竞争者关系，最终一条消息只能被其中一个消费者接收到，读完即会被删除</p>\n<h4 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h4><p>一个生产者发送的每一个消息，都会发送到所有订阅了此队列的消费者，也就是<strong>广播</strong></p>\n<p>在发布订阅模型中，存放消息的容器变成了主题（主题也是一个队列），订阅者在接收消息之前需要先订阅主题，最终，每个订阅者都可以收到同一个主题的全量消息，可以看到和队列模式唯一不同的就是，发布订阅模式中的<strong>一份消息数据可以被多次消费</strong></p>\n<h2 id=\"消息队列结构\"><a href=\"#消息队列结构\" class=\"headerlink\" title=\"消息队列结构\"></a>消息队列结构</h2><p>消息队列中消息本身由消息类型和消息数据组成，通常使用如下结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">msgbuf</span><br>&#123;<br>\t<span class=\"hljs-type\">long</span> \tmtype;<span class=\"hljs-comment\">//mtype指定了消息类型，为正整数。</span><br>\t<span class=\"hljs-type\">char</span>\tmtext[<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//mtext指定了消息的数据。我们可以定义任意的数据类型甚至包括结构来描述消息数据</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>mtype：</strong>引入消息类型之后，消息队列在逻辑上由一个消息链表转化为多个消息链表。发送进程仍然无条件把消息写入队列的尾部，但接收进程却可以有选择地读取某个特定类型的消息中最接近队列头的一个，即使该消息不在队列头。相应消息一旦被读取，就从队列中删除，其它消息维持不变。</p>\n<h4 id=\"创建消息队列\"><a href=\"#创建消息队列\" class=\"headerlink\" title=\"创建消息队列\"></a>创建消息队列</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">msgget</span><span class=\"hljs-params\">(<span class=\"hljs-type\">key_t</span> key, <span class=\"hljs-type\">int</span> msgflg)</span></span>;<br><span class=\"hljs-comment\">//参数key是消息队列的关键字</span><br><span class=\"hljs-comment\">//参数msgflg的低9位指定队列的属主、属组和其他用户的访问权限，其它位指定消息队列的创建方式。</span><br>\t<span class=\"hljs-comment\">//IPC_CREAT：创建，如存在则打开；</span><br>\t<span class=\"hljs-comment\">//IPC_EXCL：与IPC_CREAT使用，单独使用无意义。创建时，如存在则失败。</span><br>\t<br><span class=\"hljs-comment\">//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在返回其标识号。</span><br><span class=\"hljs-type\">int</span> msgid;<br>msgid = <span class=\"hljs-built_in\">msgget</span>(<span class=\"hljs-number\">0x1234</span>, <span class=\"hljs-number\">0666</span>|IPC_CREAT);<br><br><span class=\"hljs-comment\">//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在则报错。</span><br><span class=\"hljs-type\">int</span> msgid;<br>msgid = <span class=\"hljs-built_in\">msgget</span>(<span class=\"hljs-number\">0x1234</span>, <span class=\"hljs-number\">0666</span>|IPC_CREAT|IPC_EXCL);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"消息队列发送\"><a href=\"#消息队列发送\" class=\"headerlink\" title=\"消息队列发送\"></a>消息队列发送</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//发送消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">msgsnd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> msqid, <span class=\"hljs-type\">void</span> *msgp, <span class=\"hljs-type\">int</span> msgsz, <span class=\"hljs-type\">int</span> msgflg)</span></span>;<br>    <span class=\"hljs-comment\">//msgid：指定发送消息队列的标识号；</span><br>    <span class=\"hljs-comment\">//msgp：指向存储待发送消息内容的内存地址，用户可设计自己的消息结构；</span><br>    <span class=\"hljs-comment\">//msgsz：指定长度，仅记载数据的长度，不包括消息类型部分，且必须大于0；</span><br>    <span class=\"hljs-comment\">//msgflg：控制消息发送的方式，有阻塞和非阻塞（IPC_NOWAIT）两种方式。</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"消息队列的发送流程\"><a href=\"#消息队列的发送流程\" class=\"headerlink\" title=\"消息队列的发送流程\"></a>消息队列的发送流程</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//第一步，定义消息结构</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">msgbuf</span>&#123;\t<br>\t<span class=\"hljs-type\">long</span> mtype;\t\t<br>\t<span class=\"hljs-type\">char</span> ctext[<span class=\"hljs-number\">100</span>];<br>&#125;\t<br><br><span class=\"hljs-comment\">//第二步，创建消息队列</span><br><span class=\"hljs-type\">int</span> msgid;<br>msgid = <span class=\"hljs-built_in\">msgget</span>(KEY, <span class=\"hljs-number\">0666</span>|IPC_CREAT);<br><span class=\"hljs-keyword\">if</span>(msgid &lt; <span class=\"hljs-number\">0</span>)\t<span class=\"hljs-comment\">//打开或创建消息失败；</span><br><br><span class=\"hljs-comment\">//第三步，组织消息</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">msgbuf</span> buf;<br>buf.mtype = <span class=\"hljs-number\">100</span>;<br><span class=\"hljs-built_in\">strcpy</span>(buf.ctext, “HELLO UNIX!”);<br><br><span class=\"hljs-comment\">//第四步，发送消息</span><br><span class=\"hljs-type\">int</span> ret;<br>ret = <span class=\"hljs-built_in\">msgsnd</span>(msgid, &amp;buf, <span class=\"hljs-built_in\">strlen</span>(buf.ctext), <span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-comment\">//第五步，判断发送是否成功</span><br><span class=\"hljs-keyword\">if</span>(ret == <span class=\"hljs-number\">-1</span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(errno == EINTR)\t<span class=\"hljs-comment\">//信号中断，重新发送；</span><br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">//系统错误</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"从消息队列中接收消息\"><a href=\"#从消息队列中接收消息\" class=\"headerlink\" title=\"从消息队列中接收消息\"></a>从消息队列中接收消息</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//接收队列消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">msgrcv</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> msgid, <span class=\"hljs-type\">void</span> *msgp, <span class=\"hljs-type\">int</span> msgsz, <span class=\"hljs-type\">long</span> msgtyp, <span class=\"hljs-type\">int</span> msgflg)</span></span>;<br><br>\t<span class=\"hljs-comment\">//msgid：消息队列标识号；</span><br>\t<span class=\"hljs-comment\">//msgp：指向接收消息的内存缓冲区；</span><br>\t<span class=\"hljs-comment\">//msgsz：指定该缓冲区的最大容量，不包括消息类型占用的部分；</span><br>\t<span class=\"hljs-comment\">//msgtyp：指定读取消息的类型；</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"消息队列的接收流程\"><a href=\"#消息队列的接收流程\" class=\"headerlink\" title=\"消息队列的接收流程\"></a>消息队列的接收流程</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//第一步，定义消息结构</span><br><span class=\"hljs-keyword\">struct</span> msgbuf&#123;\t<br>\t<span class=\"hljs-built_in\">long</span> mtype;\t\t<br>\t<span class=\"hljs-built_in\">char</span> ctext[<span class=\"hljs-number\">100</span>];<br>&#125;\t<br><br><span class=\"hljs-comment\">//打开（创建）消息队列</span><br><span class=\"hljs-built_in\">int</span> msgid;<br>msgid = msgget(KEY, <span class=\"hljs-number\">0666</span>|IPC_CREAT);<br><br><span class=\"hljs-comment\">//准备接收消息缓冲区</span><br><span class=\"hljs-keyword\">struct</span> msgbuf buf;<br>memset(buf, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(buf));<br><br><span class=\"hljs-comment\">//接收消息</span><br><span class=\"hljs-built_in\">int</span> ret;<br>ret = msgrcv(msgid, &amp;buf, <span class=\"hljs-keyword\">sizeof</span>(buf.ctext), TYPE, <span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-comment\">//接收判断</span><br><span class=\"hljs-keyword\">if</span>(ret == <span class=\"hljs-number\">-1</span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(errno == EINTR)\t <span class=\"hljs-comment\">//信号中断，重新接收；</span><br>\t<span class=\"hljs-keyword\">else</span>                 <span class=\"hljs-comment\">//系统错误</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"消息队列信息情况核实\"><a href=\"#消息队列信息情况核实\" class=\"headerlink\" title=\"消息队列信息情况核实\"></a>消息队列信息情况核实</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">struct msqid_ds queue_info;<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">msgctl</span>(ID, IPC_STAT, &amp;queue_info) == -<span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Failed to get queue info for control_queue_ID: <span class=\"hljs-variable\">%d</span>, errno = <span class=\"hljs-variable\">%d</span>, error: <span class=\"hljs-variable\">%s</span>\\n&quot;</span>, ID, errno, strerror(errno));<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Control queue status - messages: <span class=\"hljs-variable\">%ld</span>\\n&quot;</span>, queue_info.msg_qnum);<span class=\"hljs-regexp\">//</span>检查消息的数量<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Max size of message: <span class=\"hljs-variable\">%ld</span>\\n&quot;</span>, queue_info.msg_qbytes);<span class=\"hljs-regexp\">//</span>检查消息的最大限制长度<br>&#125;<br><br>//output<br>Control queue status - messages: <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"终端查看消息队列\"><a href=\"#终端查看消息队列\" class=\"headerlink\" title=\"终端查看消息队列\"></a>终端查看消息队列</h3><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xquery\">ipcs命令<br>ipcs -a ：显示全部可以显示的信息<br>ipcs -q：显示活动的消息队列<br>ipcs -m：显示活动的共享内存信息<br>ipcs -s：显示活动的信号量信息<br><br>ipcrm命令：<br>ipcrm -m<span class=\"hljs-built_in\"> id</span>：删除共享内存标识<br>ipcrm -M<span class=\"hljs-built_in\"> key</span>：删除由关键字创建的共享内存标识<br>ipcrm -q<span class=\"hljs-built_in\"> id</span> ：删除消息队列标识<span class=\"hljs-built_in\"> id</span>和其相关的消息队列和数据结构<br>ipcrm -Q<span class=\"hljs-built_in\"> key</span>：删除由关键<span class=\"hljs-built_in\">字key</span>创建的消息队列和其相关的消息队列和数据结构<br>ipcs -s<span class=\"hljs-built_in\"> id</span>：删除信号标识<span class=\"hljs-built_in\">符id</span>和其相关的信号量集及数据结构<br>ipcs -S<span class=\"hljs-built_in\"> key</span>:删除由关键<span class=\"hljs-built_in\">字key</span>创建的信号量标识及其相关的信号量集及数据结构<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"消息队列优势\"><a href=\"#消息队列优势\" class=\"headerlink\" title=\"消息队列优势\"></a>消息队列优势</h2><p>1、采用消息队列通信比采用管道通信具有更多的灵活性，通信的进程不但没有血缘上的要求，也不需要进行同步处理。<br>2、消息队列是一种先进先出的队列型数据结构；<br>3、消息队列将输出的信息进行了打包处理，可以保证以消息为单位进行接收；<br>4、消息队列对信息进行分类服务，根据消息的类别进行分别处理。<br>5、提供消息数据自动拆分功能，同时不能接受两次发送的消息。<br>6、消息队列提供了不完全随机读取的服务。<br>7、消息队列提供了完全异步的读写服务。</p>\n","excerpt":"","more":"<h1 id=\"Linux消息队列学习\"><a href=\"#Linux消息队列学习\" class=\"headerlink\" title=\"Linux消息队列学习\"></a>Linux消息队列学习</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://blog.csdn.net/scarificed/article/details/121475146\">消息队列（定义、结构、如何创建、消息队列的发送与接收、发送与接收实例）_vc中如何定义使用消息队列-CSDN博客</a></p>\n<h2 id=\"消息队列概述\"><a href=\"#消息队列概述\" class=\"headerlink\" title=\"消息队列概述\"></a>消息队列概述</h2><p>官方说法是，MQ（全称Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式，队列就是一个消息容器</p>\n<p>现实使用中，我们将消息队列称之为<strong>中间件</strong>，从它的名字就可以看出，消息队列不存储消息内容的本身，它只是消息的搬运工</p>\n<p>消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。</p>\n<h4 id=\"消息和队列\"><a href=\"#消息和队列\" class=\"headerlink\" title=\"消息和队列\"></a>消息和队列</h4><p><strong>消息：</strong>需要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式</p>\n<p><strong>队列：</strong>一种先进先出的数据结构，在这里是存放消息的容器，入队即发消息的过程，出队即收消息的过程</p>\n<p><strong>过程：</strong>生产者将消息投递到一个叫做 队列 的容器中，然后再从容器中取出消息，最后转发给消费者</p>\n<h4 id=\"队列模型（又叫做点对点模型）\"><a href=\"#队列模型（又叫做点对点模型）\" class=\"headerlink\" title=\"队列模型（又叫做点对点模型）\"></a>队列模型（又叫做点对点模型）</h4><p><strong>点对点模式（PTP）</strong>：一个生产者发送的每一个消息，都只有一个消费者消费，看起来就像消息从一个点被传递到另一个点，也就是<strong>单播</strong></p>\n<p>它允许多个生产者向同一个队列里发送消息，但是只有一个消费者能拿到数据，如果有多个消费者，那么多个消费者是竞争者关系，最终一条消息只能被其中一个消费者接收到，读完即会被删除</p>\n<h4 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h4><p>一个生产者发送的每一个消息，都会发送到所有订阅了此队列的消费者，也就是<strong>广播</strong></p>\n<p>在发布订阅模型中，存放消息的容器变成了主题（主题也是一个队列），订阅者在接收消息之前需要先订阅主题，最终，每个订阅者都可以收到同一个主题的全量消息，可以看到和队列模式唯一不同的就是，发布订阅模式中的<strong>一份消息数据可以被多次消费</strong></p>\n<h2 id=\"消息队列结构\"><a href=\"#消息队列结构\" class=\"headerlink\" title=\"消息队列结构\"></a>消息队列结构</h2><p>消息队列中消息本身由消息类型和消息数据组成，通常使用如下结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">msgbuf</span><br>&#123;<br>\t<span class=\"hljs-type\">long</span> \tmtype;<span class=\"hljs-comment\">//mtype指定了消息类型，为正整数。</span><br>\t<span class=\"hljs-type\">char</span>\tmtext[<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//mtext指定了消息的数据。我们可以定义任意的数据类型甚至包括结构来描述消息数据</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>mtype：</strong>引入消息类型之后，消息队列在逻辑上由一个消息链表转化为多个消息链表。发送进程仍然无条件把消息写入队列的尾部，但接收进程却可以有选择地读取某个特定类型的消息中最接近队列头的一个，即使该消息不在队列头。相应消息一旦被读取，就从队列中删除，其它消息维持不变。</p>\n<h4 id=\"创建消息队列\"><a href=\"#创建消息队列\" class=\"headerlink\" title=\"创建消息队列\"></a>创建消息队列</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">msgget</span><span class=\"hljs-params\">(<span class=\"hljs-type\">key_t</span> key, <span class=\"hljs-type\">int</span> msgflg)</span></span>;<br><span class=\"hljs-comment\">//参数key是消息队列的关键字</span><br><span class=\"hljs-comment\">//参数msgflg的低9位指定队列的属主、属组和其他用户的访问权限，其它位指定消息队列的创建方式。</span><br>\t<span class=\"hljs-comment\">//IPC_CREAT：创建，如存在则打开；</span><br>\t<span class=\"hljs-comment\">//IPC_EXCL：与IPC_CREAT使用，单独使用无意义。创建时，如存在则失败。</span><br>\t<br><span class=\"hljs-comment\">//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在返回其标识号。</span><br><span class=\"hljs-type\">int</span> msgid;<br>msgid = <span class=\"hljs-built_in\">msgget</span>(<span class=\"hljs-number\">0x1234</span>, <span class=\"hljs-number\">0666</span>|IPC_CREAT);<br><br><span class=\"hljs-comment\">//创建关键字为0x1234，访问权限为0666的消息队列，如队列已存在则报错。</span><br><span class=\"hljs-type\">int</span> msgid;<br>msgid = <span class=\"hljs-built_in\">msgget</span>(<span class=\"hljs-number\">0x1234</span>, <span class=\"hljs-number\">0666</span>|IPC_CREAT|IPC_EXCL);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"消息队列发送\"><a href=\"#消息队列发送\" class=\"headerlink\" title=\"消息队列发送\"></a>消息队列发送</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//发送消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">msgsnd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> msqid, <span class=\"hljs-type\">void</span> *msgp, <span class=\"hljs-type\">int</span> msgsz, <span class=\"hljs-type\">int</span> msgflg)</span></span>;<br>    <span class=\"hljs-comment\">//msgid：指定发送消息队列的标识号；</span><br>    <span class=\"hljs-comment\">//msgp：指向存储待发送消息内容的内存地址，用户可设计自己的消息结构；</span><br>    <span class=\"hljs-comment\">//msgsz：指定长度，仅记载数据的长度，不包括消息类型部分，且必须大于0；</span><br>    <span class=\"hljs-comment\">//msgflg：控制消息发送的方式，有阻塞和非阻塞（IPC_NOWAIT）两种方式。</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"消息队列的发送流程\"><a href=\"#消息队列的发送流程\" class=\"headerlink\" title=\"消息队列的发送流程\"></a>消息队列的发送流程</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//第一步，定义消息结构</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">msgbuf</span>&#123;\t<br>\t<span class=\"hljs-type\">long</span> mtype;\t\t<br>\t<span class=\"hljs-type\">char</span> ctext[<span class=\"hljs-number\">100</span>];<br>&#125;\t<br><br><span class=\"hljs-comment\">//第二步，创建消息队列</span><br><span class=\"hljs-type\">int</span> msgid;<br>msgid = <span class=\"hljs-built_in\">msgget</span>(KEY, <span class=\"hljs-number\">0666</span>|IPC_CREAT);<br><span class=\"hljs-keyword\">if</span>(msgid &lt; <span class=\"hljs-number\">0</span>)\t<span class=\"hljs-comment\">//打开或创建消息失败；</span><br><br><span class=\"hljs-comment\">//第三步，组织消息</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">msgbuf</span> buf;<br>buf.mtype = <span class=\"hljs-number\">100</span>;<br><span class=\"hljs-built_in\">strcpy</span>(buf.ctext, “HELLO UNIX!”);<br><br><span class=\"hljs-comment\">//第四步，发送消息</span><br><span class=\"hljs-type\">int</span> ret;<br>ret = <span class=\"hljs-built_in\">msgsnd</span>(msgid, &amp;buf, <span class=\"hljs-built_in\">strlen</span>(buf.ctext), <span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-comment\">//第五步，判断发送是否成功</span><br><span class=\"hljs-keyword\">if</span>(ret == <span class=\"hljs-number\">-1</span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(errno == EINTR)\t<span class=\"hljs-comment\">//信号中断，重新发送；</span><br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">//系统错误</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"从消息队列中接收消息\"><a href=\"#从消息队列中接收消息\" class=\"headerlink\" title=\"从消息队列中接收消息\"></a>从消息队列中接收消息</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//接收队列消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">msgrcv</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> msgid, <span class=\"hljs-type\">void</span> *msgp, <span class=\"hljs-type\">int</span> msgsz, <span class=\"hljs-type\">long</span> msgtyp, <span class=\"hljs-type\">int</span> msgflg)</span></span>;<br><br>\t<span class=\"hljs-comment\">//msgid：消息队列标识号；</span><br>\t<span class=\"hljs-comment\">//msgp：指向接收消息的内存缓冲区；</span><br>\t<span class=\"hljs-comment\">//msgsz：指定该缓冲区的最大容量，不包括消息类型占用的部分；</span><br>\t<span class=\"hljs-comment\">//msgtyp：指定读取消息的类型；</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"消息队列的接收流程\"><a href=\"#消息队列的接收流程\" class=\"headerlink\" title=\"消息队列的接收流程\"></a>消息队列的接收流程</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//第一步，定义消息结构</span><br><span class=\"hljs-keyword\">struct</span> msgbuf&#123;\t<br>\t<span class=\"hljs-built_in\">long</span> mtype;\t\t<br>\t<span class=\"hljs-built_in\">char</span> ctext[<span class=\"hljs-number\">100</span>];<br>&#125;\t<br><br><span class=\"hljs-comment\">//打开（创建）消息队列</span><br><span class=\"hljs-built_in\">int</span> msgid;<br>msgid = msgget(KEY, <span class=\"hljs-number\">0666</span>|IPC_CREAT);<br><br><span class=\"hljs-comment\">//准备接收消息缓冲区</span><br><span class=\"hljs-keyword\">struct</span> msgbuf buf;<br>memset(buf, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(buf));<br><br><span class=\"hljs-comment\">//接收消息</span><br><span class=\"hljs-built_in\">int</span> ret;<br>ret = msgrcv(msgid, &amp;buf, <span class=\"hljs-keyword\">sizeof</span>(buf.ctext), TYPE, <span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-comment\">//接收判断</span><br><span class=\"hljs-keyword\">if</span>(ret == <span class=\"hljs-number\">-1</span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(errno == EINTR)\t <span class=\"hljs-comment\">//信号中断，重新接收；</span><br>\t<span class=\"hljs-keyword\">else</span>                 <span class=\"hljs-comment\">//系统错误</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"消息队列信息情况核实\"><a href=\"#消息队列信息情况核实\" class=\"headerlink\" title=\"消息队列信息情况核实\"></a>消息队列信息情况核实</h3><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">struct msqid_ds queue_info;<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">msgctl</span>(ID, IPC_STAT, &amp;queue_info) == -<span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Failed to get queue info for control_queue_ID: <span class=\"hljs-variable\">%d</span>, errno = <span class=\"hljs-variable\">%d</span>, error: <span class=\"hljs-variable\">%s</span>\\n&quot;</span>, ID, errno, strerror(errno));<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Control queue status - messages: <span class=\"hljs-variable\">%ld</span>\\n&quot;</span>, queue_info.msg_qnum);<span class=\"hljs-regexp\">//</span>检查消息的数量<br>    <span class=\"hljs-keyword\">printf</span>(<span class=\"hljs-string\">&quot;Max size of message: <span class=\"hljs-variable\">%ld</span>\\n&quot;</span>, queue_info.msg_qbytes);<span class=\"hljs-regexp\">//</span>检查消息的最大限制长度<br>&#125;<br><br>//output<br>Control queue status - messages: <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"终端查看消息队列\"><a href=\"#终端查看消息队列\" class=\"headerlink\" title=\"终端查看消息队列\"></a>终端查看消息队列</h3><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xquery\">ipcs命令<br>ipcs -a ：显示全部可以显示的信息<br>ipcs -q：显示活动的消息队列<br>ipcs -m：显示活动的共享内存信息<br>ipcs -s：显示活动的信号量信息<br><br>ipcrm命令：<br>ipcrm -m<span class=\"hljs-built_in\"> id</span>：删除共享内存标识<br>ipcrm -M<span class=\"hljs-built_in\"> key</span>：删除由关键字创建的共享内存标识<br>ipcrm -q<span class=\"hljs-built_in\"> id</span> ：删除消息队列标识<span class=\"hljs-built_in\"> id</span>和其相关的消息队列和数据结构<br>ipcrm -Q<span class=\"hljs-built_in\"> key</span>：删除由关键<span class=\"hljs-built_in\">字key</span>创建的消息队列和其相关的消息队列和数据结构<br>ipcs -s<span class=\"hljs-built_in\"> id</span>：删除信号标识<span class=\"hljs-built_in\">符id</span>和其相关的信号量集及数据结构<br>ipcs -S<span class=\"hljs-built_in\"> key</span>:删除由关键<span class=\"hljs-built_in\">字key</span>创建的信号量标识及其相关的信号量集及数据结构<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"消息队列优势\"><a href=\"#消息队列优势\" class=\"headerlink\" title=\"消息队列优势\"></a>消息队列优势</h2><p>1、采用消息队列通信比采用管道通信具有更多的灵活性，通信的进程不但没有血缘上的要求，也不需要进行同步处理。<br>2、消息队列是一种先进先出的队列型数据结构；<br>3、消息队列将输出的信息进行了打包处理，可以保证以消息为单位进行接收；<br>4、消息队列对信息进行分类服务，根据消息的类别进行分别处理。<br>5、提供消息数据自动拆分功能，同时不能接受两次发送的消息。<br>6、消息队列提供了不完全随机读取的服务。<br>7、消息队列提供了完全异步的读写服务。</p>\n"},{"title":"STM32的DMA收发配置","date":"2024-08-07T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/Jw2m6LlYHhnTg5q.jpg","_content":"\n# STM32的DMA收发配置\n\nDMA(Direct Memory Access)—直接存储器存取，是单片机的一个外设，它的主要功能是用来搬数据，但是不需要占用 CPU，即在传输数据的时候， CPU 可以干其他的事情，好像是多线程一样\n\nDMA主要组成有控制器请求、通道、仲裁器\n\n### 控制器\n\n请求的话主要由想要使用方发起，如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求， DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。\n\n### 通道\n\nDMA 控制器包含了 DMA1 和 DMA2，其中 DMA1 有 7 个通道， DMA2 有 5 个通道，通道的地址也是DMA存储器的地址\n\n每个通道对应不同的外设的 DMA 请求。**虽然每个通道可以接收多个外设的请求，但是同一时间只能接收一个，不能同时接收多个。**\n\n### 仲裁器\n\n当发生多个 DMA 通道请求时，就意味着有先后响应处理的顺序问题，这个就由仲裁器也管理。\n\n仲裁器管理 DMA 通道请求分为两个阶段。\n\n第一阶段属于软件阶段，可以在 **DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级。**\n\n第二阶段属于硬件阶段，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高，比如通道 0 高于通道1。\n\n### 数据传输\n\nDMA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器\n\nDMA_CCR 位 4 DIR 配置： 0 表示从外设到存储器， 1 表示从存储器到外设。储存器到储存器有单独设置。\n\n当我们使用从外设到存储器传输时，以 ADC 采集为例。 **DMA 外设寄存器的地址对应的就是 ADC数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量**（用来接收存储 AD 采集的数据）的地址。\n\n当我们使用从存储器到外设传输时，以串口向电脑端发送数据为例。 **DMA 外设寄存器的地址对应的就是串口数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量**（相当于一个缓冲区，用来存储通过串口发送到电脑的数据）的地址。  \n\n当我们使用从存储器到存储器传输时，以内部 FLASH 向内部 SRAM 复制数据为例。 DMA 外设寄存器的地址对应的就是内部 FLASH（我们这里把内部 FALSH 当作一个外设来看）的地址， DMA存储器的地址就是我们自定义的变量  \n\n一个 32 位的寄存器，一次最多只能传输 65535 个数据。  \n\n要想数据传输正确，源和目标地址存储的数据宽度还必须一致，串口数据寄存器是 8 位的，所以我们定义的要发送的数据也必须是 8 位。  \n\n### 代码解释\n\nDMA的配置上也比较清晰，跟之前的类似，首先要初始化结构体，并且打开DMA1的时钟，所有的外设都要有这个操作\n\n```\n\tDMA_InitTypeDef DMA_InitStruct;//初始化结构体\n\t\n\tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);//打开DMA1的时钟\n```\n\n第一部分是定义数据的去向和大小，分别是要去的地址(外设)，从哪里来的地址(DMA1地址)，传输方向和传输数目\n\n```\n\tDMA_InitStruct.DMA_PeripheralBaseAddr = (uint32_t)(USART1_BASE+0x04);//外设地址，定义数据去向地址\n\t\n\tDMA_InitStruct.DMA_MemoryBaseAddr = (uint32_t)DMA1_Channel4;//存储器地址\n\t\n\tDMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralDST;//传输方向选择，可选外设到存储器、存储器到外设。\n\t\n\tDMA_InitStruct.DMA_BufferSize = 256;//设定待传输数据数目\n```\n\n第二部分是设定数据的传输模式和宽度\n\n首先是外设数据的模式要设为不自动递增，因为寄存器就只有一个，无法多次递增，在设置外设数据的宽度，外设数据的宽度要和DMA1存储器的宽度一致，如果不一致的话，会导致数据丢失\n\n```\n\t//一般外设都是只有一个数据寄存器，所以一般不会使能该位\n\tDMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//使能外设地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据宽度\n```\n\n在设置存储器的数据模式和宽度，数据模式选择递增的方式，因为数据寄存器要接收多个数据，接受完一个要继续接收，可以理解为外设接收完数据直接清零，所以不需要递增，存储器无法清零，所以要递增，宽度一致\n\n```\n\t//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。\n\tDMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;//使能存储器地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;//存储器数据宽度\n```\n\n在设置数据的传输模式，是循环还是单次传输\n\n```\n\tDMA_InitStruct.DMA_Mode = DMA_Mode_Normal;//DMA 传输模式选择，可选一次传输或者循环传输\n```\n\n第三部分是数据的软优先级设置，以及数据初始化、数据使能和标志位清零\n\n```\n\tDMA_InitStruct.DMA_Priority = DMA_Priority_High;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低\n\t\n\tDMA_InitStruct.DMA_M2M = DMA_M2M_Disable;//存储器到存储器模式，使用存储器到存储器时用到\n\t\n\tDMA_Init(DMA1_Channel4, &DMA_InitStruct);//对配置进行初始化\n\t\n\t//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰\n\tDMA_ClearFlag(DMA1_FLAG_TC4);\n\t\n\tDMA_Cmd(DMA1_Channel4, ENABLE);//启动或者停止 DMA 数据传输\n```\n\n### 配置总代码\n\n```\nvoid UtM_DMA_Config(void)\n{\n\tDMA_InitTypeDef DMA_InitStruct;//初始化结构体\n\t\n\tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);//打开DMA1的时钟\n\t\n\tDMA_InitStruct.DMA_PeripheralBaseAddr = (uint32_t)(USART1_BASE+0x04);//外设地址，定义数据去向地址\n\t\n\tDMA_InitStruct.DMA_MemoryBaseAddr = (uint32_t)DMA1_Channel4;//存储器地址\n\t\n\tDMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralDST;//传输方向选择，可选外设到存储器、存储器到外设。\n\t\n\tDMA_InitStruct.DMA_BufferSize = 256;//设定待传输数据数目\n\t\n\t//一般外设都是只有一个数据寄存器，所以一般不会使能该位\n\tDMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//使能外设地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据宽度\n\t\n\t//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。\n\tDMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;//使能存储器地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;//存储器数据宽度\n\t\n\tDMA_InitStruct.DMA_Mode = DMA_Mode_Normal;//DMA 传输模式选择，可选一次传输或者循环传输\n\t\n\tDMA_InitStruct.DMA_Priority = DMA_Priority_High;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低\n\t\n\tDMA_InitStruct.DMA_M2M = DMA_M2M_Disable;//存储器到存储器模式，使用存储器到存储器时用到\n\t\n\tDMA_Init(DMA1_Channel4, &DMA_InitStruct);//对配置进行初始化\n\t\n\t//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰\n\tDMA_ClearFlag(DMA1_FLAG_TC4);\n\t\n\tDMA_Cmd(DMA1_Channel4, ENABLE);//启动或者停止 DMA 数据传输\n}\n```\n\n","source":"_posts/STM32的DMA收发.md","raw":"---\ntitle: STM32的DMA收发配置\ntag: DMA数据传输\ndate: 2024-08-08\ncategories: STM32\nindex_img: https://s2.loli.net/2024/08/02/Jw2m6LlYHhnTg5q.jpg\n---\n\n# STM32的DMA收发配置\n\nDMA(Direct Memory Access)—直接存储器存取，是单片机的一个外设，它的主要功能是用来搬数据，但是不需要占用 CPU，即在传输数据的时候， CPU 可以干其他的事情，好像是多线程一样\n\nDMA主要组成有控制器请求、通道、仲裁器\n\n### 控制器\n\n请求的话主要由想要使用方发起，如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求， DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。\n\n### 通道\n\nDMA 控制器包含了 DMA1 和 DMA2，其中 DMA1 有 7 个通道， DMA2 有 5 个通道，通道的地址也是DMA存储器的地址\n\n每个通道对应不同的外设的 DMA 请求。**虽然每个通道可以接收多个外设的请求，但是同一时间只能接收一个，不能同时接收多个。**\n\n### 仲裁器\n\n当发生多个 DMA 通道请求时，就意味着有先后响应处理的顺序问题，这个就由仲裁器也管理。\n\n仲裁器管理 DMA 通道请求分为两个阶段。\n\n第一阶段属于软件阶段，可以在 **DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级。**\n\n第二阶段属于硬件阶段，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高，比如通道 0 高于通道1。\n\n### 数据传输\n\nDMA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器\n\nDMA_CCR 位 4 DIR 配置： 0 表示从外设到存储器， 1 表示从存储器到外设。储存器到储存器有单独设置。\n\n当我们使用从外设到存储器传输时，以 ADC 采集为例。 **DMA 外设寄存器的地址对应的就是 ADC数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量**（用来接收存储 AD 采集的数据）的地址。\n\n当我们使用从存储器到外设传输时，以串口向电脑端发送数据为例。 **DMA 外设寄存器的地址对应的就是串口数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量**（相当于一个缓冲区，用来存储通过串口发送到电脑的数据）的地址。  \n\n当我们使用从存储器到存储器传输时，以内部 FLASH 向内部 SRAM 复制数据为例。 DMA 外设寄存器的地址对应的就是内部 FLASH（我们这里把内部 FALSH 当作一个外设来看）的地址， DMA存储器的地址就是我们自定义的变量  \n\n一个 32 位的寄存器，一次最多只能传输 65535 个数据。  \n\n要想数据传输正确，源和目标地址存储的数据宽度还必须一致，串口数据寄存器是 8 位的，所以我们定义的要发送的数据也必须是 8 位。  \n\n### 代码解释\n\nDMA的配置上也比较清晰，跟之前的类似，首先要初始化结构体，并且打开DMA1的时钟，所有的外设都要有这个操作\n\n```\n\tDMA_InitTypeDef DMA_InitStruct;//初始化结构体\n\t\n\tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);//打开DMA1的时钟\n```\n\n第一部分是定义数据的去向和大小，分别是要去的地址(外设)，从哪里来的地址(DMA1地址)，传输方向和传输数目\n\n```\n\tDMA_InitStruct.DMA_PeripheralBaseAddr = (uint32_t)(USART1_BASE+0x04);//外设地址，定义数据去向地址\n\t\n\tDMA_InitStruct.DMA_MemoryBaseAddr = (uint32_t)DMA1_Channel4;//存储器地址\n\t\n\tDMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralDST;//传输方向选择，可选外设到存储器、存储器到外设。\n\t\n\tDMA_InitStruct.DMA_BufferSize = 256;//设定待传输数据数目\n```\n\n第二部分是设定数据的传输模式和宽度\n\n首先是外设数据的模式要设为不自动递增，因为寄存器就只有一个，无法多次递增，在设置外设数据的宽度，外设数据的宽度要和DMA1存储器的宽度一致，如果不一致的话，会导致数据丢失\n\n```\n\t//一般外设都是只有一个数据寄存器，所以一般不会使能该位\n\tDMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//使能外设地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据宽度\n```\n\n在设置存储器的数据模式和宽度，数据模式选择递增的方式，因为数据寄存器要接收多个数据，接受完一个要继续接收，可以理解为外设接收完数据直接清零，所以不需要递增，存储器无法清零，所以要递增，宽度一致\n\n```\n\t//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。\n\tDMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;//使能存储器地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;//存储器数据宽度\n```\n\n在设置数据的传输模式，是循环还是单次传输\n\n```\n\tDMA_InitStruct.DMA_Mode = DMA_Mode_Normal;//DMA 传输模式选择，可选一次传输或者循环传输\n```\n\n第三部分是数据的软优先级设置，以及数据初始化、数据使能和标志位清零\n\n```\n\tDMA_InitStruct.DMA_Priority = DMA_Priority_High;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低\n\t\n\tDMA_InitStruct.DMA_M2M = DMA_M2M_Disable;//存储器到存储器模式，使用存储器到存储器时用到\n\t\n\tDMA_Init(DMA1_Channel4, &DMA_InitStruct);//对配置进行初始化\n\t\n\t//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰\n\tDMA_ClearFlag(DMA1_FLAG_TC4);\n\t\n\tDMA_Cmd(DMA1_Channel4, ENABLE);//启动或者停止 DMA 数据传输\n```\n\n### 配置总代码\n\n```\nvoid UtM_DMA_Config(void)\n{\n\tDMA_InitTypeDef DMA_InitStruct;//初始化结构体\n\t\n\tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);//打开DMA1的时钟\n\t\n\tDMA_InitStruct.DMA_PeripheralBaseAddr = (uint32_t)(USART1_BASE+0x04);//外设地址，定义数据去向地址\n\t\n\tDMA_InitStruct.DMA_MemoryBaseAddr = (uint32_t)DMA1_Channel4;//存储器地址\n\t\n\tDMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralDST;//传输方向选择，可选外设到存储器、存储器到外设。\n\t\n\tDMA_InitStruct.DMA_BufferSize = 256;//设定待传输数据数目\n\t\n\t//一般外设都是只有一个数据寄存器，所以一般不会使能该位\n\tDMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//使能外设地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据宽度\n\t\n\t//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。\n\tDMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;//使能存储器地址自动递增功能\n\t\n\tDMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;//存储器数据宽度\n\t\n\tDMA_InitStruct.DMA_Mode = DMA_Mode_Normal;//DMA 传输模式选择，可选一次传输或者循环传输\n\t\n\tDMA_InitStruct.DMA_Priority = DMA_Priority_High;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低\n\t\n\tDMA_InitStruct.DMA_M2M = DMA_M2M_Disable;//存储器到存储器模式，使用存储器到存储器时用到\n\t\n\tDMA_Init(DMA1_Channel4, &DMA_InitStruct);//对配置进行初始化\n\t\n\t//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰\n\tDMA_ClearFlag(DMA1_FLAG_TC4);\n\t\n\tDMA_Cmd(DMA1_Channel4, ENABLE);//启动或者停止 DMA 数据传输\n}\n```\n\n","slug":"STM32的DMA收发","published":1,"updated":"2024-08-12T12:26:59.316Z","comments":1,"layout":"post","photos":[],"_id":"clzqyyajg0000b0fbh6a3hox1","content":"<h1 id=\"STM32的DMA收发配置\"><a href=\"#STM32的DMA收发配置\" class=\"headerlink\" title=\"STM32的DMA收发配置\"></a>STM32的DMA收发配置</h1><p>DMA(Direct Memory Access)—直接存储器存取，是单片机的一个外设，它的主要功能是用来搬数据，但是不需要占用 CPU，即在传输数据的时候， CPU 可以干其他的事情，好像是多线程一样</p>\n<p>DMA主要组成有控制器请求、通道、仲裁器</p>\n<h3 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h3><p>请求的话主要由想要使用方发起，如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求， DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。</p>\n<h3 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h3><p>DMA 控制器包含了 DMA1 和 DMA2，其中 DMA1 有 7 个通道， DMA2 有 5 个通道，通道的地址也是DMA存储器的地址</p>\n<p>每个通道对应不同的外设的 DMA 请求。<strong>虽然每个通道可以接收多个外设的请求，但是同一时间只能接收一个，不能同时接收多个。</strong></p>\n<h3 id=\"仲裁器\"><a href=\"#仲裁器\" class=\"headerlink\" title=\"仲裁器\"></a>仲裁器</h3><p>当发生多个 DMA 通道请求时，就意味着有先后响应处理的顺序问题，这个就由仲裁器也管理。</p>\n<p>仲裁器管理 DMA 通道请求分为两个阶段。</p>\n<p>第一阶段属于软件阶段，可以在 <strong>DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级。</strong></p>\n<p>第二阶段属于硬件阶段，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高，比如通道 0 高于通道1。</p>\n<h3 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h3><p>DMA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器</p>\n<p>DMA_CCR 位 4 DIR 配置： 0 表示从外设到存储器， 1 表示从存储器到外设。储存器到储存器有单独设置。</p>\n<p>当我们使用从外设到存储器传输时，以 ADC 采集为例。 <strong>DMA 外设寄存器的地址对应的就是 ADC数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量</strong>（用来接收存储 AD 采集的数据）的地址。</p>\n<p>当我们使用从存储器到外设传输时，以串口向电脑端发送数据为例。 <strong>DMA 外设寄存器的地址对应的就是串口数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量</strong>（相当于一个缓冲区，用来存储通过串口发送到电脑的数据）的地址。  </p>\n<p>当我们使用从存储器到存储器传输时，以内部 FLASH 向内部 SRAM 复制数据为例。 DMA 外设寄存器的地址对应的就是内部 FLASH（我们这里把内部 FALSH 当作一个外设来看）的地址， DMA存储器的地址就是我们自定义的变量  </p>\n<p>一个 32 位的寄存器，一次最多只能传输 65535 个数据。  </p>\n<p>要想数据传输正确，源和目标地址存储的数据宽度还必须一致，串口数据寄存器是 8 位的，所以我们定义的要发送的数据也必须是 8 位。  </p>\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><p>DMA的配置上也比较清晰，跟之前的类似，首先要初始化结构体，并且打开DMA1的时钟，所有的外设都要有这个操作</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">DMA_InitTypeDef DMA_InitStruct;<span class=\"hljs-comment\">//初始化结构体</span><br><br><span class=\"hljs-built_in\">RCC_AHBPeriphClockCmd</span>(RCC_AHBPeriph_DMA1, ENABLE);<span class=\"hljs-comment\">//打开DMA1的时钟</span><br></code></pre></td></tr></table></figure>\n\n<p>第一部分是定义数据的去向和大小，分别是要去的地址(外设)，从哪里来的地址(DMA1地址)，传输方向和传输数目</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">DMA_InitStruct.DMA_PeripheralBaseAddr</span> = (uint32_t)(USART1_BASE+<span class=\"hljs-number\">0</span>x04)<span class=\"hljs-comment\">;//外设地址，定义数据去向地址</span><br><br><span class=\"hljs-attr\">DMA_InitStruct.DMA_MemoryBaseAddr</span> = (uint32_t)DMA1_Channel4<span class=\"hljs-comment\">;//存储器地址</span><br><br><span class=\"hljs-attr\">DMA_InitStruct.DMA_DIR</span> = DMA_DIR_PeripheralDST<span class=\"hljs-comment\">;//传输方向选择，可选外设到存储器、存储器到外设。</span><br><br><span class=\"hljs-attr\">DMA_InitStruct.DMA_BufferSize</span> = <span class=\"hljs-number\">256</span><span class=\"hljs-comment\">;//设定待传输数据数目</span><br></code></pre></td></tr></table></figure>\n\n<p>第二部分是设定数据的传输模式和宽度</p>\n<p>首先是外设数据的模式要设为不自动递增，因为寄存器就只有一个，无法多次递增，在设置外设数据的宽度，外设数据的宽度要和DMA1存储器的宽度一致，如果不一致的话，会导致数据丢失</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">//一般外设都是只有一个数据寄存器，所以一般不会使能该位<br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralInc</span> = DM<span class=\"hljs-built_in\">A_PeripheralInc</span>_Disable<span class=\"hljs-comment\">;//使能外设地址自动递增功能</span><br><br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//外设数据宽度</span><br></code></pre></td></tr></table></figure>\n\n<p>在设置存储器的数据模式和宽度，数据模式选择递增的方式，因为数据寄存器要接收多个数据，接受完一个要继续接收，可以理解为外设接收完数据直接清零，所以不需要递增，存储器无法清零，所以要递增，宽度一致</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。<br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryInc</span> = DM<span class=\"hljs-built_in\">A_MemoryInc</span>_Enable<span class=\"hljs-comment\">;//使能存储器地址自动递增功能</span><br><br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//存储器数据宽度</span><br></code></pre></td></tr></table></figure>\n\n<p>在设置数据的传输模式，是循环还是单次传输</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Mode</span> = DM<span class=\"hljs-built_in\">A_Mode</span>_Normal<span class=\"hljs-comment\">;//DMA 传输模式选择，可选一次传输或者循环传输</span><br></code></pre></td></tr></table></figure>\n\n<p>第三部分是数据的软优先级设置，以及数据初始化、数据使能和标志位清零</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Priority</span> = DM<span class=\"hljs-built_in\">A_Priority</span>_High<span class=\"hljs-comment\">;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低</span><br><br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_M2M</span> = DM<span class=\"hljs-built_in\">A_M2M</span>_Disable<span class=\"hljs-comment\">;//存储器到存储器模式，使用存储器到存储器时用到</span><br><br>DM<span class=\"hljs-built_in\">A_Init</span>(DMA1_Channel4, &amp;DM<span class=\"hljs-built_in\">A_InitStruct</span>)<span class=\"hljs-comment\">;//对配置进行初始化</span><br><br>//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰<br>DM<span class=\"hljs-built_in\">A_ClearFlag</span>(DMA1_FLAG_TC4)<span class=\"hljs-comment\">;</span><br><br>DM<span class=\"hljs-built_in\">A_Cmd</span>(DMA1_Channel4, ENABLE)<span class=\"hljs-comment\">;//启动或者停止 DMA 数据传输</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置总代码\"><a href=\"#配置总代码\" class=\"headerlink\" title=\"配置总代码\"></a>配置总代码</h3><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">void UtM_DM<span class=\"hljs-built_in\">A_Config</span>(void)<br>&#123;<br>\tDM<span class=\"hljs-built_in\">A_InitTypeDef</span> DM<span class=\"hljs-built_in\">A_InitStruct</span><span class=\"hljs-comment\">;//初始化结构体</span><br>\t<br>\tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE)<span class=\"hljs-comment\">;//打开DMA1的时钟</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralBaseAddr</span> = (uint32_t)(USART1_BASE+<span class=\"hljs-number\">0</span>x04)<span class=\"hljs-comment\">;//外设地址，定义数据去向地址</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryBaseAddr</span> = (uint32_t)DMA1_Channel4<span class=\"hljs-comment\">;//存储器地址</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_DIR</span> = DM<span class=\"hljs-built_in\">A_DIR</span>_PeripheralDST<span class=\"hljs-comment\">;//传输方向选择，可选外设到存储器、存储器到外设。</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_BufferSize</span> = <span class=\"hljs-number\">256</span><span class=\"hljs-comment\">;//设定待传输数据数目</span><br>\t<br>\t//一般外设都是只有一个数据寄存器，所以一般不会使能该位<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralInc</span> = DM<span class=\"hljs-built_in\">A_PeripheralInc</span>_Disable<span class=\"hljs-comment\">;//使能外设地址自动递增功能</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//外设数据宽度</span><br>\t<br>\t//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryInc</span> = DM<span class=\"hljs-built_in\">A_MemoryInc</span>_Enable<span class=\"hljs-comment\">;//使能存储器地址自动递增功能</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//存储器数据宽度</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Mode</span> = DM<span class=\"hljs-built_in\">A_Mode</span>_Normal<span class=\"hljs-comment\">;//DMA 传输模式选择，可选一次传输或者循环传输</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Priority</span> = DM<span class=\"hljs-built_in\">A_Priority</span>_High<span class=\"hljs-comment\">;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_M2M</span> = DM<span class=\"hljs-built_in\">A_M2M</span>_Disable<span class=\"hljs-comment\">;//存储器到存储器模式，使用存储器到存储器时用到</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_Init</span>(DMA1_Channel4, &amp;DM<span class=\"hljs-built_in\">A_InitStruct</span>)<span class=\"hljs-comment\">;//对配置进行初始化</span><br>\t<br>\t//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰<br>\tDM<span class=\"hljs-built_in\">A_ClearFlag</span>(DMA1_FLAG_TC4)<span class=\"hljs-comment\">;</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_Cmd</span>(DMA1_Channel4, ENABLE)<span class=\"hljs-comment\">;//启动或者停止 DMA 数据传输</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"STM32的DMA收发配置\"><a href=\"#STM32的DMA收发配置\" class=\"headerlink\" title=\"STM32的DMA收发配置\"></a>STM32的DMA收发配置</h1><p>DMA(Direct Memory Access)—直接存储器存取，是单片机的一个外设，它的主要功能是用来搬数据，但是不需要占用 CPU，即在传输数据的时候， CPU 可以干其他的事情，好像是多线程一样</p>\n<p>DMA主要组成有控制器请求、通道、仲裁器</p>\n<h3 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h3><p>请求的话主要由想要使用方发起，如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求， DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。</p>\n<h3 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h3><p>DMA 控制器包含了 DMA1 和 DMA2，其中 DMA1 有 7 个通道， DMA2 有 5 个通道，通道的地址也是DMA存储器的地址</p>\n<p>每个通道对应不同的外设的 DMA 请求。<strong>虽然每个通道可以接收多个外设的请求，但是同一时间只能接收一个，不能同时接收多个。</strong></p>\n<h3 id=\"仲裁器\"><a href=\"#仲裁器\" class=\"headerlink\" title=\"仲裁器\"></a>仲裁器</h3><p>当发生多个 DMA 通道请求时，就意味着有先后响应处理的顺序问题，这个就由仲裁器也管理。</p>\n<p>仲裁器管理 DMA 通道请求分为两个阶段。</p>\n<p>第一阶段属于软件阶段，可以在 <strong>DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级。</strong></p>\n<p>第二阶段属于硬件阶段，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高，比如通道 0 高于通道1。</p>\n<h3 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h3><p>DMA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器</p>\n<p>DMA_CCR 位 4 DIR 配置： 0 表示从外设到存储器， 1 表示从存储器到外设。储存器到储存器有单独设置。</p>\n<p>当我们使用从外设到存储器传输时，以 ADC 采集为例。 <strong>DMA 外设寄存器的地址对应的就是 ADC数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量</strong>（用来接收存储 AD 采集的数据）的地址。</p>\n<p>当我们使用从存储器到外设传输时，以串口向电脑端发送数据为例。 <strong>DMA 外设寄存器的地址对应的就是串口数据寄存器的地址， DMA 存储器的地址就是我们自定义的变量</strong>（相当于一个缓冲区，用来存储通过串口发送到电脑的数据）的地址。  </p>\n<p>当我们使用从存储器到存储器传输时，以内部 FLASH 向内部 SRAM 复制数据为例。 DMA 外设寄存器的地址对应的就是内部 FLASH（我们这里把内部 FALSH 当作一个外设来看）的地址， DMA存储器的地址就是我们自定义的变量  </p>\n<p>一个 32 位的寄存器，一次最多只能传输 65535 个数据。  </p>\n<p>要想数据传输正确，源和目标地址存储的数据宽度还必须一致，串口数据寄存器是 8 位的，所以我们定义的要发送的数据也必须是 8 位。  </p>\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><p>DMA的配置上也比较清晰，跟之前的类似，首先要初始化结构体，并且打开DMA1的时钟，所有的外设都要有这个操作</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">DMA_InitTypeDef DMA_InitStruct;<span class=\"hljs-comment\">//初始化结构体</span><br><br><span class=\"hljs-built_in\">RCC_AHBPeriphClockCmd</span>(RCC_AHBPeriph_DMA1, ENABLE);<span class=\"hljs-comment\">//打开DMA1的时钟</span><br></code></pre></td></tr></table></figure>\n\n<p>第一部分是定义数据的去向和大小，分别是要去的地址(外设)，从哪里来的地址(DMA1地址)，传输方向和传输数目</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">DMA_InitStruct.DMA_PeripheralBaseAddr</span> = (uint32_t)(USART1_BASE+<span class=\"hljs-number\">0</span>x04)<span class=\"hljs-comment\">;//外设地址，定义数据去向地址</span><br><br><span class=\"hljs-attr\">DMA_InitStruct.DMA_MemoryBaseAddr</span> = (uint32_t)DMA1_Channel4<span class=\"hljs-comment\">;//存储器地址</span><br><br><span class=\"hljs-attr\">DMA_InitStruct.DMA_DIR</span> = DMA_DIR_PeripheralDST<span class=\"hljs-comment\">;//传输方向选择，可选外设到存储器、存储器到外设。</span><br><br><span class=\"hljs-attr\">DMA_InitStruct.DMA_BufferSize</span> = <span class=\"hljs-number\">256</span><span class=\"hljs-comment\">;//设定待传输数据数目</span><br></code></pre></td></tr></table></figure>\n\n<p>第二部分是设定数据的传输模式和宽度</p>\n<p>首先是外设数据的模式要设为不自动递增，因为寄存器就只有一个，无法多次递增，在设置外设数据的宽度，外设数据的宽度要和DMA1存储器的宽度一致，如果不一致的话，会导致数据丢失</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">//一般外设都是只有一个数据寄存器，所以一般不会使能该位<br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralInc</span> = DM<span class=\"hljs-built_in\">A_PeripheralInc</span>_Disable<span class=\"hljs-comment\">;//使能外设地址自动递增功能</span><br><br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//外设数据宽度</span><br></code></pre></td></tr></table></figure>\n\n<p>在设置存储器的数据模式和宽度，数据模式选择递增的方式，因为数据寄存器要接收多个数据，接受完一个要继续接收，可以理解为外设接收完数据直接清零，所以不需要递增，存储器无法清零，所以要递增，宽度一致</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。<br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryInc</span> = DM<span class=\"hljs-built_in\">A_MemoryInc</span>_Enable<span class=\"hljs-comment\">;//使能存储器地址自动递增功能</span><br><br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//存储器数据宽度</span><br></code></pre></td></tr></table></figure>\n\n<p>在设置数据的传输模式，是循环还是单次传输</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Mode</span> = DM<span class=\"hljs-built_in\">A_Mode</span>_Normal<span class=\"hljs-comment\">;//DMA 传输模式选择，可选一次传输或者循环传输</span><br></code></pre></td></tr></table></figure>\n\n<p>第三部分是数据的软优先级设置，以及数据初始化、数据使能和标志位清零</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Priority</span> = DM<span class=\"hljs-built_in\">A_Priority</span>_High<span class=\"hljs-comment\">;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低</span><br><br>DM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_M2M</span> = DM<span class=\"hljs-built_in\">A_M2M</span>_Disable<span class=\"hljs-comment\">;//存储器到存储器模式，使用存储器到存储器时用到</span><br><br>DM<span class=\"hljs-built_in\">A_Init</span>(DMA1_Channel4, &amp;DM<span class=\"hljs-built_in\">A_InitStruct</span>)<span class=\"hljs-comment\">;//对配置进行初始化</span><br><br>//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰<br>DM<span class=\"hljs-built_in\">A_ClearFlag</span>(DMA1_FLAG_TC4)<span class=\"hljs-comment\">;</span><br><br>DM<span class=\"hljs-built_in\">A_Cmd</span>(DMA1_Channel4, ENABLE)<span class=\"hljs-comment\">;//启动或者停止 DMA 数据传输</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置总代码\"><a href=\"#配置总代码\" class=\"headerlink\" title=\"配置总代码\"></a>配置总代码</h3><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">void UtM_DM<span class=\"hljs-built_in\">A_Config</span>(void)<br>&#123;<br>\tDM<span class=\"hljs-built_in\">A_InitTypeDef</span> DM<span class=\"hljs-built_in\">A_InitStruct</span><span class=\"hljs-comment\">;//初始化结构体</span><br>\t<br>\tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE)<span class=\"hljs-comment\">;//打开DMA1的时钟</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralBaseAddr</span> = (uint32_t)(USART1_BASE+<span class=\"hljs-number\">0</span>x04)<span class=\"hljs-comment\">;//外设地址，定义数据去向地址</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryBaseAddr</span> = (uint32_t)DMA1_Channel4<span class=\"hljs-comment\">;//存储器地址</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_DIR</span> = DM<span class=\"hljs-built_in\">A_DIR</span>_PeripheralDST<span class=\"hljs-comment\">;//传输方向选择，可选外设到存储器、存储器到外设。</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_BufferSize</span> = <span class=\"hljs-number\">256</span><span class=\"hljs-comment\">;//设定待传输数据数目</span><br>\t<br>\t//一般外设都是只有一个数据寄存器，所以一般不会使能该位<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralInc</span> = DM<span class=\"hljs-built_in\">A_PeripheralInc</span>_Disable<span class=\"hljs-comment\">;//使能外设地址自动递增功能</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//外设数据宽度</span><br>\t<br>\t//我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryInc</span> = DM<span class=\"hljs-built_in\">A_MemoryInc</span>_Enable<span class=\"hljs-comment\">;//使能存储器地址自动递增功能</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_MemoryDataSize</span> = DM<span class=\"hljs-built_in\">A_PeripheralDataSize</span>_Byte<span class=\"hljs-comment\">;//存储器数据宽度</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Mode</span> = DM<span class=\"hljs-built_in\">A_Mode</span>_Normal<span class=\"hljs-comment\">;//DMA 传输模式选择，可选一次传输或者循环传输</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_Priority</span> = DM<span class=\"hljs-built_in\">A_Priority</span>_High<span class=\"hljs-comment\">;//软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_InitStruct</span>.DM<span class=\"hljs-built_in\">A_M2M</span> = DM<span class=\"hljs-built_in\">A_M2M</span>_Disable<span class=\"hljs-comment\">;//存储器到存储器模式，使用存储器到存储器时用到</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_Init</span>(DMA1_Channel4, &amp;DM<span class=\"hljs-built_in\">A_InitStruct</span>)<span class=\"hljs-comment\">;//对配置进行初始化</span><br>\t<br>\t//用于清除 DMA 标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰<br>\tDM<span class=\"hljs-built_in\">A_ClearFlag</span>(DMA1_FLAG_TC4)<span class=\"hljs-comment\">;</span><br>\t<br>\tDM<span class=\"hljs-built_in\">A_Cmd</span>(DMA1_Channel4, ENABLE)<span class=\"hljs-comment\">;//启动或者停止 DMA 数据传输</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Python-变量、列表、元组、字典、函数","date":"2024-08-11T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/Saf2h5bePzUvB4A.jpg","_content":"\n# Python-变量、列表、元组、字典、函数\n\n## 感谢博主：\n\n[数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/python/basic/data-types/index.html)\n\n## Python 简介\n\n**Python 是一种解释型语言：** 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言\n\n**Python 是交互式语言：** 这意味着，您可以在一个 Python 提示符 **>>>** 后直接执行代码。\n\n**Python 是面向对象语言:** 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。\n\n**Python 是初学者的语言：**Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。\n\n## 数据类型和变量\n\n转义字符`\\`可以转义很多字符，比如`\\n`表示换行，`\\t`表示制表符，字符`\\`本身也要转义，所以`\\\\`表示的字符就是`\\`\n\n这种**变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言**。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。Python是动态语言，根据上下文判断变量赋值\n\n在Python中，通常用全部大写的变量名表示常量\n\n`/`除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：\n\n```python\n>>> 9 / 3\n3.0\n```\n\n还有一种除法是`//`，称为地板除，两个整数的除法仍然是整数：\n\n```python\n>>> 10 // 3\n3\n```\n\n整数的地板除`//`永远是整数，即使除不尽。要做精确的除法，使用`/`就可以。\n\n因为`//`除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：\n\n```python\n>>> 10 % 3\n1\n```\n\n## 列表List\n\nPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n\n定义一个列表`classmates`，里面数据包含了班级同学的名字，其实列表等于c语言里面的数组\n\n```python\nclassmates =['kangkang','lihua',\"xiaoming\",\"zhengzheng\",'liuyang']\n```\n\n求这个列表的长度\n\n```python\n>>> len(classmates)\n3\n```\n\n用索引来访问list中每一个位置的元素，记得索引是从`0`开始的：\n\n```python\n>>> classmates[1] \n'lihua'\n>>> classmates[0] \n'kangkang'\n```\n\n如果索引值是负号，说明索引是倒数执行的\n\n```python\n>>> classmates[-2]  \n'zhengzheng'\n>>> classmates[-1] \n'liuyang'\n```\n\nlist是一个可变的有序表，所以，可以往list中追加元素到末尾：\n\n```python\n>>> classmates.append('chenyu') \n>>> classmates\n['kangkang', 'lihua', 'xiaoming', 'zhengzheng', 'liuyang', 'chenyu']\n```\n\n也可以把元素插入到指定的位置，比如索引号为`2`的位置：\n\n```python\n>>> classmates.insert(2,'yangfeng') \n>>> classmates\n['kangkang', 'lihua', 'yangfeng', 'xiaoming', 'zhengzheng', 'liuyang', 'chenyu']\n```\n\n要删除list末尾的元素，用`pop()`方法：\n\n```python\n>>> classmates.pop()\n'chenyu'\n>>> classmates \n['kangkang', 'lihua', 'yangfeng', 'xiaoming', 'zhengzheng', 'liuyang']\n```\n\n要删除指定位置的元素，用`pop(i)`方法，其中`i`是索引位置：\n\n```python\n>>> classmates.pop(2) \n'yangfeng'\n>>> classmates\n['kangkang', 'lihua', 'xiaoming', 'zhengzheng', 'liuyang']\n```\n\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：\n\n```python\n>>> classmates[1]='jack' \n>>> classmates\n['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang']\n```\n\nlist里面的元素的数据类型也可以不同，比如：\n\n```python\n>>> str= [1,2,3,'clast',3.001,-2]        \n>>> str\n[1, 2, 3, 'clast', 3.001, -2]\n```\n\nlist元素也可以是另一个list，比如：\n\n```python\n>>> str.insert(4,classmates) \n>>> str\n[1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2]\n```\n\n## 元组tuple\n\n另一种有序列表叫元组：tuple。tuple和list非常类似，**但是tuple一旦初始化就不能修改**\n\n因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n\n当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来\n\n如果要定义一个空的tuple，可以写成`()`\n\n要定义一个只有1个元素的tuple，如果你这么定义：\n\n```python\n>>> yuanzu = (1) \n>>> yuanzu\n1\n```\n\n定义的不是tuple，是`1`这个数！这是因为括号`()`既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是`1`。\n\n所以，只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义：\n\n```python\n>>> yuanzu = (1,) \n>>> yuanzu\n(1,)\n```\n\n查找元组的位置跟列表一致\n\n```python\n>>> yuanzu[0] \n1\n```\n\n元组里面的数据也是可以添加列表和元组\n\n```python\n>>> yuanzu = (0,1,3.33,-5,str)   \n>>> yuanzu\n(0, 1, 3.33, -5, [1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n```\n\n查找元组的个数也跟列表一样，但是如果元组里面包好列表或者元组，这个只会被当作一个元素\n\n```python\n>>> yuanzu\n(0, 1, 3.33, -5, [1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n>>> len(yuanzu) \n5\n```\n\n元组可以查找元组单元里面的元组子数据或者列表子数据，只能查找两重\n\n```python\n>>> yuanzu         \n(0, 1, 3.33, -5, [1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n>>> yuanzu[4][4] \n['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang']\n>>>\n```\n\n如果元组里面包含了列表，那元组里面的列表值是可以进行修改的\n\n```python\n>>> yuanzu[4][2] = 'x' \n>>> yuanzu             \n(0, 1, 3.33, -5, [1, 2, 'x', 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n```\n\n元组的数组是不能直接增删的，但是我们可以对里面的列表做增删改查，元组的数据也会相应的变化\n\n```python\n>>> yuanzu.pop([4][2]) \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'tuple' object has no attribute 'pop'\n>>> classmates.pop()\n'liuyang'\n>>> yuanzu\n(0, 1, 3.33, -5, [1, 2, 'x', 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng'], 3.001, -2])\n```\n\n## 判断和输入\n\n根据Python的缩进规则，如果`if`语句判断是`True`，就把缩进的两行print语句执行了，否则，什么也不做。\n\n#### if、elif、else\n\n也可以给`if`添加一个`else`语句，意思是，如果`if`判断是`False`，不要执行`if`的内容，去把`else`执行了：\n\n`elif`是`else if`的缩写，完全可以有多个`elif`\n\n```python\nif`语句执行有个特点，它是从上往下判断，如果在某个判断上是`True`，把该判断对应的语句执行后，就忽略掉剩下的`elif`和`else\n```\n\n`input()`读取用户的输入，这样可以自己输入，但是input()的输入值的定义是字符串，如果直接进行比较，就会报错\n\n```python\nbirth = input('birth: ')\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n```\n\n所以就需要进行字符的转换，用到了int()\n\n```python\ns = input('birth: ')\nbirth = int(s)\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n```\n\n#### match case\n\n多个匹配的时候就需要用到match case语句，和c语言的switch case一样的用法\n\n```python\nmatch score:\n    case 'A':\n        print('score is A.')\n    case 'B':\n        print('score is B.')\n    case 'C':\n        print('score is C.')\n    case _: # _表示匹配到其他任何情况\n        print('score is ???.')\n```\n\n`match`语句还可以匹配列表，功能非常强大。\n\n```python\nargs = ['gcc', 'hello.c', 'world.c']\n# args = ['clean']\n# args = ['gcc']\n\nmatch args:\n    # 如果仅出现gcc，报错:\n    case ['gcc']:\n        print('gcc: missing source file(s).')\n    # 出现gcc，且至少指定了一个文件:\n    case ['gcc', file1, *files]:\n        print('gcc compile: ' + file1 + ', ' + ', '.join(files))\n    # 仅出现clean:\n    case ['clean']:\n        print('clean')\n    case _:\n        print('invalid command.')\n        \n第一个case ['gcc']表示列表仅有'gcc'一个字符串，没有指定文件名，报错；\n\n第二个case ['gcc', file1, *files]表示列表第一个字符串是'gcc'，第二个字符串绑定到变量file1，后面的任意个字符串绑定到*files（符号*的作用将在函数的参数中讲解），它实际上表示至少指定一个文件；\n如果第一个不是gcc，那么就不能进行判断\n\n第三个case ['clean']表示列表仅有'clean'一个字符串；\n\n最后一个case _表示其他所有情况。\n```\n\n## 循环\n\n#### for...in\n\nPython的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nfor x in names:\n    print(x)\n```\n\n所以`for x in ...`循环就是把每个元素代入变量`x`，然后执行缩进块的语句。\n\n再比如我们想计算1-10的整数之和，可以用一个`sum`变量做累加：\n\n```python\nnumbers = [1,2,3,4,5,6,7,8,9]\nsum = 0\nfor x in numbers:\n    sum =sum + x\n    print(sum)\n```\n\n#### range()\n\nPython提供一个`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数：\n\n```python\n>>> list(range(5)) \n[0, 1, 2, 3, 4]\n>>> list(range(101))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n```\n\n所以就可以直接用if in来累加\n\n```python\nsum = 0\nfor x in range(101):\n    sum =sum + x\n    print(sum)\n```\n\n#### while\n\n第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\n\n```python\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\n\n在循环中，`break`语句可以提前退出循环。\n\n```python\nn = 1\nwhile n <= 100:\n    if n > 10: # 当n = 11时，条件满足，执行break语句\n        break # break语句会结束当前循环\n    print(n)\n    n = n + 1\nprint('END')\n```\n\n在循环过程中，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。\n\n```python\nn = 0\nwhile n < 10:\n    n = n + 1\n    if n % 2 == 0: # 如果n是偶数，执行continue语句\n        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行\n    print(n)\n```\n\n## 字典\n\nPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n\n字典其实也是类似于C语言的结构体，但是使用方法会比结构体更加简单一些\n\n```python\n>>> dict = {'lihua': 94,'yangyang': 44,\"kangkang\": 55} \n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55}\n```\n\n所以我们就可以根据前面的键值直接找到后面的值\n\n```python\n>>> dict['lihua'] \n94\n```\n\n为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\n\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\n\ndict就是第二种实现方式，给定一个名字，比如`'Michael'`，dict在内部就可以直接计算出`Michael`对应的存放成绩的“页码”，也就是`95`这个数字存放的内存地址，直接取出来，所以速度非常快。\n\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\n\n```python\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55}\n>>> dict[\"liuyang\"] = 97\n>>> dict                 \n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 97}\n```\n\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n\n```python\n>>> dict                 \n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 97}\n>>> dict['liuyang'] = 94\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 94}\n```\n\n二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value。\n\n```python\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 94}\n>>> dict.get('yangyang') \n44\n```\n\n要想删除字典里面的值，直接用pop选取该字典里面的键值就可以把键和值都删掉\n\n```python\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 94}\n>>> dict.pop('yangyang')\n44\n>>> dict                 \n{'lihua': 94, 'kangkang': 55, 'liuyang': 94}\n```\n\n### set\n\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n要创建一个set，用`{x,y,z,...}`列出每个元素：\n\n```python\n>>> s = {1, 2, 3}\n>>> s\n{1, 2, 3}\n```\n\n或者提供一个list作为输入集合：\n\n```python\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n```\n\n注意，传入的参数`[1, 2, 3]`是一个list，而显示的`{1, 2, 3}`只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。\n\n重复元素在set中自动被过滤：\n\n```python\n>>> s = {1, 1, 2, 2, 3, 3}\n>>> s\n{1, 2, 3}\n```\n\n通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：\n\n```python\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n```\n\n通过`remove(key)`方法可以删除元素：\n\n```python\n>>> s.remove(4)\n>>> s\n{1, 2, 3}\n```\n\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n\n```python\n>>> s1 = {1, 2, 3}\n>>> s2 = {2, 3, 4}\n>>> s1 & s2\n{2, 3}\n>>> s1 | s2\n{1, 2, 3, 4}\n```\n\nset和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n\n## 函数\n\n在Python中，定义一个函数要使用`def`语句，依次写出函数名、括号、括号中的参数和冒号`:`，然后，在缩进块中编写函数体，函数的返回值用`return`语句返回。\n\n假设我们自己去写一个绝对值判断函数\n\n```python\ndef abs_self(x):\n    if x>0:\n        print(x)\n        return x\n    elif x<0:\n        print(-x)\n        return -x\n\nprint(abs_self(-10))\n```\n\n函数体内部的语句在执行时，一旦执行到`return`时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。\n\n如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。`return None`可以简写为`return`。\n\n在Python交互环境中定义函数时，注意Python会出现`...`的提示。函数定义结束后需要按两次回车重新回到`>>>`提示符下\n\n```python\n>>> def zzzz(x):\n...     if x>0:\n...             return x\n...     if x<0:\n...             return -x\n...\n>>> zzzz(-20) \n20\n```\n\n如果想定义一个什么事也不做的空函数，可以用`pass`语句：\n\n```python\ndef nop():\n    pass\n```\n\n`pass`语句什么都不做，那有什么用？实际上`pass`可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个`pass`，让代码能运行起来。\n\n`pass`还可以用在其他语句里，比如：\n\n```python\nif age >= 18:\n    pass\n```\n\n缺少了`pass`，代码运行就会有语法错误。\n\n当传入了不恰当的参数时，内置函数`abs`会检查出参数错误，而我们定义的`zzzz`没有参数检查，会导致`if`语句出错，出错信息和`abs`不一样。所以，这个函数定义不够完善。\n\n修改一下`zzzz`的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数`isinstance()`实现：\n\n```python\n>>> def zzzz(x):\n...     if not isinstance(x,(int,float)):\n...             raise TypeError('Error')\n...     if x>0:\n...             return x\n...     if x<0:\n...             return -x\n...\n\n>>> zzzz('a') \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 3, in zzzz\nTypeError: Error\n```\n\n函数也可以返回多个参数值，只需要在return的时候进行多个值的指定\n\n```python\ndef text(x,y):\n    a=10\n    if x>y:\n        print(x)\n        return x\n    elif x<y:\n        print(y)\n        return x\n    elif x==y:\n        print(x,y)\n        return x ,y,a\nprint(text(10,10))\n\n//output\n10 10\n(10, 10, 10)\n```\n\n#### 函数的默认参数\n\n很多时候，我们在定义函数的时候，参数的类型很多，因此每次我们调用函数都需要填入多个参数，如果少一个就会报错，因此我们可以在定义函数的时候添加默认参数，这样的话我们只需要调用函数的时候直接输入没有默认的参数，就可以实现函数的调用\n\n```python\ndef xx(x,n=2):\n    c=1\n    for i in range(n):\n        c=c*x\n    return c\n\nprint(xx(5))//调用默认参数\nprint(xx(7,3))//定义其他参数\n```\n\n有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用`enroll('Bob', 'M', 7)`，意思是，除了`name`，`gender`这两个参数外，最后1个参数应用在参数`age`上，`city`参数由于没有提供，仍然使用默认值。\n\n也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用`enroll('Adam', 'M', city='Tianjin')`，意思是，`city`参数用传进去的值，其他默认参数继续使用默认值。\n\n在定义函数的时候，会选择默认参数，默认参数必须是指向不变的值，如果它指向的是可变的值，那么会出现该参数数据混乱的情况，所以使用none来指定一些可变参数转换成固定参数\n\n```python\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n#### 函数的可变参数\n\n在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n\n常规办法的话可以将函数的参数传入定义成一个列表或者元组，这样我们可以从里面填充这些可变值进行传入，就可以实现类似的可变参数，但是这样的可变参数操作起来比较复杂，需要很多步骤\n\n所以，我们把函数的参数改为可变参数：\n\n```python\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n```\n\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\n\n```python\n>>> calc(1, 2)\n5\n>>> calc()\n0\n```\n\n如果已经定义好可变参数函数，但是我又想导入一个列表和元组，就可以在列表和元组上添加*符号，代表可变参数，函数会自动遍历该值，进行输出\n\n```python\n>>> nums = [1, 2, 3]\n>>> calc(*nums)\n14\n```\n\n`*nums`表示把`nums`这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n\n#### 关键字参数\n\n而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。\n\n```python\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n```\n\n函数`person`除了必选参数`name`和`age`外，还接受关键字参数`kw`。在调用该函数时，可以只传入必选参数：\n\n```python\n>>> person('Michael', 30)\nname: Michael age: 30 other: {}\n```\n\n也可以传入任意个数的关键字参数：\n\n```python\n>>> person('Bob', 35, city='Beijing')\nname: Bob age: 35 other: {'city': 'Beijing'}\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n```\n\n和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n\n```\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, city=extra['city'], job=extra['job'])\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n\n当然，上面复杂的调用可以用简化的写法：\n\n```\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n\n`**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra`。\n\n#### 命令关键字参数\n\n主要对关键字进行限制，关键字可以传入任意的参数，而命令关键字对他进行限定，限定只能传入限定的关键字\n\n```\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\n```\n\n和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。\n\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了\n\n```\ndef person(name, age, *args, city, job):\n    print(name, age, args, city, job)\n```\n\n命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：\n\n```\n>>> person('Jack', 24, 'Beijing', 'Engineer')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: person() missing 2 required keyword-only arguments: 'city' and 'job'\n```\n\n由于调用时缺少参数名`city`和`job`，Python解释器把前两个参数视为位置参数，后两个参数传给`*args`，但缺少命名关键字参数导致报错。\n\n命名关键字参数可以有缺省值，从而简化调用：\n\n```\ndef person(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n```\n\n#### 参数组合\n\n在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n\n```\ndef f1(a, b, c=0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\n\ndef f2(a, b, c=0, *, d, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)\n    \n>>> f1(1, 2)\na = 1 b = 2 c = 0 args = () kw = {}\n>>> f1(1, 2, c=3)\na = 1 b = 2 c = 3 args = () kw = {}\n>>> f1(1, 2, 3, 'a', 'b')\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n>>> f1(1, 2, 3, 'a', 'b', x=99)\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n>>> f2(1, 2, d=99, ext=None)\na = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n```\n\n#### 递归函数\n\n在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n\n举个例子，我们来计算阶乘`n! = 1 x 2 x 3 x ... x n`，用函数`fact(n)`表示，可以看出：\n\n*f**a**c**t*(*n*)=*n*!=1×2×3×⋅⋅⋅×(*n*−1)×*n*=(*n*−1)!×*n*=*f**a**c**t*(*n*−1)×*n*\n\n所以，`fact(n)`可以表示为`n x fact(n-1)`，只有n=1时需要特殊处理。\n\n于是，`fact(n)`用递归的方式写出来就是：\n\n```python\ndef fact(n):\n    if n==1:\n        return 1\n    return n * fact(n - 1)\n```\n\n其实递归函数就是在return的地方假设函数所需的运算，返回的自然就是想要的值\n\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n","source":"_posts/Work No.21.md","raw":"---\ntitle: Python-变量、列表、元组、字典、函数\ntag: Python\ndate: 2024-08-12\ncategories: Python\nindex_img: https://s2.loli.net/2024/08/02/Saf2h5bePzUvB4A.jpg\n---\n\n# Python-变量、列表、元组、字典、函数\n\n## 感谢博主：\n\n[数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/python/basic/data-types/index.html)\n\n## Python 简介\n\n**Python 是一种解释型语言：** 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言\n\n**Python 是交互式语言：** 这意味着，您可以在一个 Python 提示符 **>>>** 后直接执行代码。\n\n**Python 是面向对象语言:** 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。\n\n**Python 是初学者的语言：**Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。\n\n## 数据类型和变量\n\n转义字符`\\`可以转义很多字符，比如`\\n`表示换行，`\\t`表示制表符，字符`\\`本身也要转义，所以`\\\\`表示的字符就是`\\`\n\n这种**变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言**。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。Python是动态语言，根据上下文判断变量赋值\n\n在Python中，通常用全部大写的变量名表示常量\n\n`/`除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：\n\n```python\n>>> 9 / 3\n3.0\n```\n\n还有一种除法是`//`，称为地板除，两个整数的除法仍然是整数：\n\n```python\n>>> 10 // 3\n3\n```\n\n整数的地板除`//`永远是整数，即使除不尽。要做精确的除法，使用`/`就可以。\n\n因为`//`除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：\n\n```python\n>>> 10 % 3\n1\n```\n\n## 列表List\n\nPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n\n定义一个列表`classmates`，里面数据包含了班级同学的名字，其实列表等于c语言里面的数组\n\n```python\nclassmates =['kangkang','lihua',\"xiaoming\",\"zhengzheng\",'liuyang']\n```\n\n求这个列表的长度\n\n```python\n>>> len(classmates)\n3\n```\n\n用索引来访问list中每一个位置的元素，记得索引是从`0`开始的：\n\n```python\n>>> classmates[1] \n'lihua'\n>>> classmates[0] \n'kangkang'\n```\n\n如果索引值是负号，说明索引是倒数执行的\n\n```python\n>>> classmates[-2]  \n'zhengzheng'\n>>> classmates[-1] \n'liuyang'\n```\n\nlist是一个可变的有序表，所以，可以往list中追加元素到末尾：\n\n```python\n>>> classmates.append('chenyu') \n>>> classmates\n['kangkang', 'lihua', 'xiaoming', 'zhengzheng', 'liuyang', 'chenyu']\n```\n\n也可以把元素插入到指定的位置，比如索引号为`2`的位置：\n\n```python\n>>> classmates.insert(2,'yangfeng') \n>>> classmates\n['kangkang', 'lihua', 'yangfeng', 'xiaoming', 'zhengzheng', 'liuyang', 'chenyu']\n```\n\n要删除list末尾的元素，用`pop()`方法：\n\n```python\n>>> classmates.pop()\n'chenyu'\n>>> classmates \n['kangkang', 'lihua', 'yangfeng', 'xiaoming', 'zhengzheng', 'liuyang']\n```\n\n要删除指定位置的元素，用`pop(i)`方法，其中`i`是索引位置：\n\n```python\n>>> classmates.pop(2) \n'yangfeng'\n>>> classmates\n['kangkang', 'lihua', 'xiaoming', 'zhengzheng', 'liuyang']\n```\n\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：\n\n```python\n>>> classmates[1]='jack' \n>>> classmates\n['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang']\n```\n\nlist里面的元素的数据类型也可以不同，比如：\n\n```python\n>>> str= [1,2,3,'clast',3.001,-2]        \n>>> str\n[1, 2, 3, 'clast', 3.001, -2]\n```\n\nlist元素也可以是另一个list，比如：\n\n```python\n>>> str.insert(4,classmates) \n>>> str\n[1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2]\n```\n\n## 元组tuple\n\n另一种有序列表叫元组：tuple。tuple和list非常类似，**但是tuple一旦初始化就不能修改**\n\n因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n\n当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来\n\n如果要定义一个空的tuple，可以写成`()`\n\n要定义一个只有1个元素的tuple，如果你这么定义：\n\n```python\n>>> yuanzu = (1) \n>>> yuanzu\n1\n```\n\n定义的不是tuple，是`1`这个数！这是因为括号`()`既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是`1`。\n\n所以，只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义：\n\n```python\n>>> yuanzu = (1,) \n>>> yuanzu\n(1,)\n```\n\n查找元组的位置跟列表一致\n\n```python\n>>> yuanzu[0] \n1\n```\n\n元组里面的数据也是可以添加列表和元组\n\n```python\n>>> yuanzu = (0,1,3.33,-5,str)   \n>>> yuanzu\n(0, 1, 3.33, -5, [1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n```\n\n查找元组的个数也跟列表一样，但是如果元组里面包好列表或者元组，这个只会被当作一个元素\n\n```python\n>>> yuanzu\n(0, 1, 3.33, -5, [1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n>>> len(yuanzu) \n5\n```\n\n元组可以查找元组单元里面的元组子数据或者列表子数据，只能查找两重\n\n```python\n>>> yuanzu         \n(0, 1, 3.33, -5, [1, 2, 3, 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n>>> yuanzu[4][4] \n['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang']\n>>>\n```\n\n如果元组里面包含了列表，那元组里面的列表值是可以进行修改的\n\n```python\n>>> yuanzu[4][2] = 'x' \n>>> yuanzu             \n(0, 1, 3.33, -5, [1, 2, 'x', 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng', 'liuyang'], 3.001, -2])\n```\n\n元组的数组是不能直接增删的，但是我们可以对里面的列表做增删改查，元组的数据也会相应的变化\n\n```python\n>>> yuanzu.pop([4][2]) \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'tuple' object has no attribute 'pop'\n>>> classmates.pop()\n'liuyang'\n>>> yuanzu\n(0, 1, 3.33, -5, [1, 2, 'x', 'clast', ['kangkang', 'jack', 'xiaoming', 'zhengzheng'], 3.001, -2])\n```\n\n## 判断和输入\n\n根据Python的缩进规则，如果`if`语句判断是`True`，就把缩进的两行print语句执行了，否则，什么也不做。\n\n#### if、elif、else\n\n也可以给`if`添加一个`else`语句，意思是，如果`if`判断是`False`，不要执行`if`的内容，去把`else`执行了：\n\n`elif`是`else if`的缩写，完全可以有多个`elif`\n\n```python\nif`语句执行有个特点，它是从上往下判断，如果在某个判断上是`True`，把该判断对应的语句执行后，就忽略掉剩下的`elif`和`else\n```\n\n`input()`读取用户的输入，这样可以自己输入，但是input()的输入值的定义是字符串，如果直接进行比较，就会报错\n\n```python\nbirth = input('birth: ')\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n```\n\n所以就需要进行字符的转换，用到了int()\n\n```python\ns = input('birth: ')\nbirth = int(s)\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n```\n\n#### match case\n\n多个匹配的时候就需要用到match case语句，和c语言的switch case一样的用法\n\n```python\nmatch score:\n    case 'A':\n        print('score is A.')\n    case 'B':\n        print('score is B.')\n    case 'C':\n        print('score is C.')\n    case _: # _表示匹配到其他任何情况\n        print('score is ???.')\n```\n\n`match`语句还可以匹配列表，功能非常强大。\n\n```python\nargs = ['gcc', 'hello.c', 'world.c']\n# args = ['clean']\n# args = ['gcc']\n\nmatch args:\n    # 如果仅出现gcc，报错:\n    case ['gcc']:\n        print('gcc: missing source file(s).')\n    # 出现gcc，且至少指定了一个文件:\n    case ['gcc', file1, *files]:\n        print('gcc compile: ' + file1 + ', ' + ', '.join(files))\n    # 仅出现clean:\n    case ['clean']:\n        print('clean')\n    case _:\n        print('invalid command.')\n        \n第一个case ['gcc']表示列表仅有'gcc'一个字符串，没有指定文件名，报错；\n\n第二个case ['gcc', file1, *files]表示列表第一个字符串是'gcc'，第二个字符串绑定到变量file1，后面的任意个字符串绑定到*files（符号*的作用将在函数的参数中讲解），它实际上表示至少指定一个文件；\n如果第一个不是gcc，那么就不能进行判断\n\n第三个case ['clean']表示列表仅有'clean'一个字符串；\n\n最后一个case _表示其他所有情况。\n```\n\n## 循环\n\n#### for...in\n\nPython的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来\n\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nfor x in names:\n    print(x)\n```\n\n所以`for x in ...`循环就是把每个元素代入变量`x`，然后执行缩进块的语句。\n\n再比如我们想计算1-10的整数之和，可以用一个`sum`变量做累加：\n\n```python\nnumbers = [1,2,3,4,5,6,7,8,9]\nsum = 0\nfor x in numbers:\n    sum =sum + x\n    print(sum)\n```\n\n#### range()\n\nPython提供一个`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数：\n\n```python\n>>> list(range(5)) \n[0, 1, 2, 3, 4]\n>>> list(range(101))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n```\n\n所以就可以直接用if in来累加\n\n```python\nsum = 0\nfor x in range(101):\n    sum =sum + x\n    print(sum)\n```\n\n#### while\n\n第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\n\n```python\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\n\n在循环中，`break`语句可以提前退出循环。\n\n```python\nn = 1\nwhile n <= 100:\n    if n > 10: # 当n = 11时，条件满足，执行break语句\n        break # break语句会结束当前循环\n    print(n)\n    n = n + 1\nprint('END')\n```\n\n在循环过程中，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。\n\n```python\nn = 0\nwhile n < 10:\n    n = n + 1\n    if n % 2 == 0: # 如果n是偶数，执行continue语句\n        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行\n    print(n)\n```\n\n## 字典\n\nPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n\n字典其实也是类似于C语言的结构体，但是使用方法会比结构体更加简单一些\n\n```python\n>>> dict = {'lihua': 94,'yangyang': 44,\"kangkang\": 55} \n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55}\n```\n\n所以我们就可以根据前面的键值直接找到后面的值\n\n```python\n>>> dict['lihua'] \n94\n```\n\n为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\n\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\n\ndict就是第二种实现方式，给定一个名字，比如`'Michael'`，dict在内部就可以直接计算出`Michael`对应的存放成绩的“页码”，也就是`95`这个数字存放的内存地址，直接取出来，所以速度非常快。\n\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\n\n```python\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55}\n>>> dict[\"liuyang\"] = 97\n>>> dict                 \n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 97}\n```\n\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n\n```python\n>>> dict                 \n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 97}\n>>> dict['liuyang'] = 94\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 94}\n```\n\n二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value。\n\n```python\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 94}\n>>> dict.get('yangyang') \n44\n```\n\n要想删除字典里面的值，直接用pop选取该字典里面的键值就可以把键和值都删掉\n\n```python\n>>> dict\n{'lihua': 94, 'yangyang': 44, 'kangkang': 55, 'liuyang': 94}\n>>> dict.pop('yangyang')\n44\n>>> dict                 \n{'lihua': 94, 'kangkang': 55, 'liuyang': 94}\n```\n\n### set\n\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n要创建一个set，用`{x,y,z,...}`列出每个元素：\n\n```python\n>>> s = {1, 2, 3}\n>>> s\n{1, 2, 3}\n```\n\n或者提供一个list作为输入集合：\n\n```python\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n```\n\n注意，传入的参数`[1, 2, 3]`是一个list，而显示的`{1, 2, 3}`只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。\n\n重复元素在set中自动被过滤：\n\n```python\n>>> s = {1, 1, 2, 2, 3, 3}\n>>> s\n{1, 2, 3}\n```\n\n通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：\n\n```python\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n```\n\n通过`remove(key)`方法可以删除元素：\n\n```python\n>>> s.remove(4)\n>>> s\n{1, 2, 3}\n```\n\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n\n```python\n>>> s1 = {1, 2, 3}\n>>> s2 = {2, 3, 4}\n>>> s1 & s2\n{2, 3}\n>>> s1 | s2\n{1, 2, 3, 4}\n```\n\nset和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n\n## 函数\n\n在Python中，定义一个函数要使用`def`语句，依次写出函数名、括号、括号中的参数和冒号`:`，然后，在缩进块中编写函数体，函数的返回值用`return`语句返回。\n\n假设我们自己去写一个绝对值判断函数\n\n```python\ndef abs_self(x):\n    if x>0:\n        print(x)\n        return x\n    elif x<0:\n        print(-x)\n        return -x\n\nprint(abs_self(-10))\n```\n\n函数体内部的语句在执行时，一旦执行到`return`时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。\n\n如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。`return None`可以简写为`return`。\n\n在Python交互环境中定义函数时，注意Python会出现`...`的提示。函数定义结束后需要按两次回车重新回到`>>>`提示符下\n\n```python\n>>> def zzzz(x):\n...     if x>0:\n...             return x\n...     if x<0:\n...             return -x\n...\n>>> zzzz(-20) \n20\n```\n\n如果想定义一个什么事也不做的空函数，可以用`pass`语句：\n\n```python\ndef nop():\n    pass\n```\n\n`pass`语句什么都不做，那有什么用？实际上`pass`可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个`pass`，让代码能运行起来。\n\n`pass`还可以用在其他语句里，比如：\n\n```python\nif age >= 18:\n    pass\n```\n\n缺少了`pass`，代码运行就会有语法错误。\n\n当传入了不恰当的参数时，内置函数`abs`会检查出参数错误，而我们定义的`zzzz`没有参数检查，会导致`if`语句出错，出错信息和`abs`不一样。所以，这个函数定义不够完善。\n\n修改一下`zzzz`的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数`isinstance()`实现：\n\n```python\n>>> def zzzz(x):\n...     if not isinstance(x,(int,float)):\n...             raise TypeError('Error')\n...     if x>0:\n...             return x\n...     if x<0:\n...             return -x\n...\n\n>>> zzzz('a') \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 3, in zzzz\nTypeError: Error\n```\n\n函数也可以返回多个参数值，只需要在return的时候进行多个值的指定\n\n```python\ndef text(x,y):\n    a=10\n    if x>y:\n        print(x)\n        return x\n    elif x<y:\n        print(y)\n        return x\n    elif x==y:\n        print(x,y)\n        return x ,y,a\nprint(text(10,10))\n\n//output\n10 10\n(10, 10, 10)\n```\n\n#### 函数的默认参数\n\n很多时候，我们在定义函数的时候，参数的类型很多，因此每次我们调用函数都需要填入多个参数，如果少一个就会报错，因此我们可以在定义函数的时候添加默认参数，这样的话我们只需要调用函数的时候直接输入没有默认的参数，就可以实现函数的调用\n\n```python\ndef xx(x,n=2):\n    c=1\n    for i in range(n):\n        c=c*x\n    return c\n\nprint(xx(5))//调用默认参数\nprint(xx(7,3))//定义其他参数\n```\n\n有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用`enroll('Bob', 'M', 7)`，意思是，除了`name`，`gender`这两个参数外，最后1个参数应用在参数`age`上，`city`参数由于没有提供，仍然使用默认值。\n\n也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用`enroll('Adam', 'M', city='Tianjin')`，意思是，`city`参数用传进去的值，其他默认参数继续使用默认值。\n\n在定义函数的时候，会选择默认参数，默认参数必须是指向不变的值，如果它指向的是可变的值，那么会出现该参数数据混乱的情况，所以使用none来指定一些可变参数转换成固定参数\n\n```python\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n#### 函数的可变参数\n\n在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n\n常规办法的话可以将函数的参数传入定义成一个列表或者元组，这样我们可以从里面填充这些可变值进行传入，就可以实现类似的可变参数，但是这样的可变参数操作起来比较复杂，需要很多步骤\n\n所以，我们把函数的参数改为可变参数：\n\n```python\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n```\n\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\n\n```python\n>>> calc(1, 2)\n5\n>>> calc()\n0\n```\n\n如果已经定义好可变参数函数，但是我又想导入一个列表和元组，就可以在列表和元组上添加*符号，代表可变参数，函数会自动遍历该值，进行输出\n\n```python\n>>> nums = [1, 2, 3]\n>>> calc(*nums)\n14\n```\n\n`*nums`表示把`nums`这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n\n#### 关键字参数\n\n而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。\n\n```python\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n```\n\n函数`person`除了必选参数`name`和`age`外，还接受关键字参数`kw`。在调用该函数时，可以只传入必选参数：\n\n```python\n>>> person('Michael', 30)\nname: Michael age: 30 other: {}\n```\n\n也可以传入任意个数的关键字参数：\n\n```python\n>>> person('Bob', 35, city='Beijing')\nname: Bob age: 35 other: {'city': 'Beijing'}\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n```\n\n和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n\n```\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, city=extra['city'], job=extra['job'])\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n\n当然，上面复杂的调用可以用简化的写法：\n\n```\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n\n`**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra`。\n\n#### 命令关键字参数\n\n主要对关键字进行限制，关键字可以传入任意的参数，而命令关键字对他进行限定，限定只能传入限定的关键字\n\n```\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\n```\n\n和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。\n\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了\n\n```\ndef person(name, age, *args, city, job):\n    print(name, age, args, city, job)\n```\n\n命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：\n\n```\n>>> person('Jack', 24, 'Beijing', 'Engineer')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: person() missing 2 required keyword-only arguments: 'city' and 'job'\n```\n\n由于调用时缺少参数名`city`和`job`，Python解释器把前两个参数视为位置参数，后两个参数传给`*args`，但缺少命名关键字参数导致报错。\n\n命名关键字参数可以有缺省值，从而简化调用：\n\n```\ndef person(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n```\n\n#### 参数组合\n\n在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n\n```\ndef f1(a, b, c=0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\n\ndef f2(a, b, c=0, *, d, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)\n    \n>>> f1(1, 2)\na = 1 b = 2 c = 0 args = () kw = {}\n>>> f1(1, 2, c=3)\na = 1 b = 2 c = 3 args = () kw = {}\n>>> f1(1, 2, 3, 'a', 'b')\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n>>> f1(1, 2, 3, 'a', 'b', x=99)\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n>>> f2(1, 2, d=99, ext=None)\na = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n```\n\n#### 递归函数\n\n在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n\n举个例子，我们来计算阶乘`n! = 1 x 2 x 3 x ... x n`，用函数`fact(n)`表示，可以看出：\n\n*f**a**c**t*(*n*)=*n*!=1×2×3×⋅⋅⋅×(*n*−1)×*n*=(*n*−1)!×*n*=*f**a**c**t*(*n*−1)×*n*\n\n所以，`fact(n)`可以表示为`n x fact(n-1)`，只有n=1时需要特殊处理。\n\n于是，`fact(n)`用递归的方式写出来就是：\n\n```python\ndef fact(n):\n    if n==1:\n        return 1\n    return n * fact(n - 1)\n```\n\n其实递归函数就是在return的地方假设函数所需的运算，返回的自然就是想要的值\n\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n","slug":"Work No.21","published":1,"updated":"2024-08-13T03:57:45.462Z","_id":"clzqyyaji0001b0fb9hu7euj0","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Python-变量、列表、元组、字典、函数\"><a href=\"#Python-变量、列表、元组、字典、函数\" class=\"headerlink\" title=\"Python-变量、列表、元组、字典、函数\"></a>Python-变量、列表、元组、字典、函数</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://liaoxuefeng.com/books/python/basic/data-types/index.html\">数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>\n<h2 id=\"Python-简介\"><a href=\"#Python-简介\" class=\"headerlink\" title=\"Python 简介\"></a>Python 简介</h2><p><strong>Python 是一种解释型语言：</strong> 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言</p>\n<p><strong>Python 是交互式语言：</strong> 这意味着，您可以在一个 Python 提示符 <strong>&gt;&gt;&gt;</strong> 后直接执行代码。</p>\n<p><strong>Python 是面向对象语言:</strong> 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p>\n<p><strong>Python 是初学者的语言：</strong>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</p>\n<h2 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h2><p>转义字符<code>\\</code>可以转义很多字符，比如<code>\\n</code>表示换行，<code>\\t</code>表示制表符，字符<code>\\</code>本身也要转义，所以<code>\\\\</code>表示的字符就是<code>\\</code></p>\n<p>这种<strong>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。Python是动态语言，根据上下文判断变量赋值</p>\n<p>在Python中，通常用全部大写的变量名表示常量</p>\n<p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-number\">9</span> / <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">3.0</span><br></code></pre></td></tr></table></figure>\n\n<p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-number\">10</span> // <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<p>整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</p>\n<p>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-number\">10</span> % <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"列表List\"><a href=\"#列表List\" class=\"headerlink\" title=\"列表List\"></a>列表List</h2><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>\n<p>定义一个列表<code>classmates</code>，里面数据包含了班级同学的名字，其实列表等于c语言里面的数组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">classmates =[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>,<span class=\"hljs-string\">&#x27;lihua&#x27;</span>,<span class=\"hljs-string\">&quot;xiaoming&quot;</span>,<span class=\"hljs-string\">&quot;zhengzheng&quot;</span>,<span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>求这个列表的长度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">len</span>(classmates)<br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<p>用索引来访问list中每一个位置的元素，记得索引是从<code>0</code>开始的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[<span class=\"hljs-number\">1</span>] <br><span class=\"hljs-string\">&#x27;lihua&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[<span class=\"hljs-number\">0</span>] <br><span class=\"hljs-string\">&#x27;kangkang&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果索引值是负号，说明索引是倒数执行的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[-<span class=\"hljs-number\">2</span>]  <br><span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[-<span class=\"hljs-number\">1</span>] <br><span class=\"hljs-string\">&#x27;liuyang&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.append(<span class=\"hljs-string\">&#x27;chenyu&#x27;</span>) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>, <span class=\"hljs-string\">&#x27;chenyu&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>也可以把元素插入到指定的位置，比如索引号为<code>2</code>的位置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.insert(<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;yangfeng&#x27;</span>) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;yangfeng&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>, <span class=\"hljs-string\">&#x27;chenyu&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>要删除list末尾的元素，用<code>pop()</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.pop()<br><span class=\"hljs-string\">&#x27;chenyu&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates <br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;yangfeng&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.pop(<span class=\"hljs-number\">2</span>) <br><span class=\"hljs-string\">&#x27;yangfeng&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[<span class=\"hljs-number\">1</span>]=<span class=\"hljs-string\">&#x27;jack&#x27;</span> <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>list里面的元素的数据类型也可以不同，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span>= [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;clast&#x27;</span>,<span class=\"hljs-number\">3.001</span>,-<span class=\"hljs-number\">2</span>]        <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>]<br></code></pre></td></tr></table></figure>\n\n<p>list元素也可以是另一个list，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span>.insert(<span class=\"hljs-number\">4</span>,classmates) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"元组tuple\"><a href=\"#元组tuple\" class=\"headerlink\" title=\"元组tuple\"></a>元组tuple</h2><p>另一种有序列表叫元组：tuple。tuple和list非常类似，<strong>但是tuple一旦初始化就不能修改</strong></p>\n<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>\n<p>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来</p>\n<p>如果要定义一个空的tuple，可以写成<code>()</code></p>\n<p>要定义一个只有1个元素的tuple，如果你这么定义：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu = (<span class=\"hljs-number\">1</span>) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p>\n<p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu = (<span class=\"hljs-number\">1</span>,) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">1</span>,)<br></code></pre></td></tr></table></figure>\n\n<p>查找元组的位置跟列表一致</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu[<span class=\"hljs-number\">0</span>] <br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>元组里面的数据也是可以添加列表和元组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu = (<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3.33</span>,-<span class=\"hljs-number\">5</span>,<span class=\"hljs-built_in\">str</span>)   <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br></code></pre></td></tr></table></figure>\n\n<p>查找元组的个数也跟列表一样，但是如果元组里面包好列表或者元组，这个只会被当作一个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">len</span>(yuanzu) <br><span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n<p>元组可以查找元组单元里面的元组子数据或者列表子数据，只能查找两重</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu         <br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>] <br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure>\n\n<p>如果元组里面包含了列表，那元组里面的列表值是可以进行修改的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">&#x27;x&#x27;</span> <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu             <br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br></code></pre></td></tr></table></figure>\n\n<p>元组的数组是不能直接增删的，但是我们可以对里面的列表做增删改查，元组的数据也会相应的变化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu.pop([<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>]) <br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>AttributeError: <span class=\"hljs-string\">&#x27;tuple&#x27;</span> <span class=\"hljs-built_in\">object</span> has no attribute <span class=\"hljs-string\">&#x27;pop&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.pop()<br><span class=\"hljs-string\">&#x27;liuyang&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"判断和输入\"><a href=\"#判断和输入\" class=\"headerlink\" title=\"判断和输入\"></a>判断和输入</h2><p>根据Python的缩进规则，如果<code>if</code>语句判断是<code>True</code>，就把缩进的两行print语句执行了，否则，什么也不做。</p>\n<h4 id=\"if、elif、else\"><a href=\"#if、elif、else\" class=\"headerlink\" title=\"if、elif、else\"></a>if、elif、else</h4><p>也可以给<code>if</code>添加一个<code>else</code>语句，意思是，如果<code>if</code>判断是<code>False</code>，不要执行<code>if</code>的内容，去把<code>else</code>执行了：</p>\n<p><code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span>`语句执行有个特点，它是从上往下判断，如果在某个判断上是`<span class=\"hljs-literal\">True</span>`，把该判断对应的语句执行后，就忽略掉剩下的`<span class=\"hljs-keyword\">elif</span>`和`<span class=\"hljs-keyword\">else</span><br></code></pre></td></tr></table></figure>\n\n<p><code>input()</code>读取用户的输入，这样可以自己输入，但是input()的输入值的定义是字符串，如果直接进行比较，就会报错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">birth = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&#x27;birth: &#x27;</span>)<br><span class=\"hljs-keyword\">if</span> birth &lt; <span class=\"hljs-number\">2000</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00前&#x27;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00后&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>所以就需要进行字符的转换，用到了int()</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">s = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&#x27;birth: &#x27;</span>)<br>birth = <span class=\"hljs-built_in\">int</span>(s)<br><span class=\"hljs-keyword\">if</span> birth &lt; <span class=\"hljs-number\">2000</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00前&#x27;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00后&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"match-case\"><a href=\"#match-case\" class=\"headerlink\" title=\"match case\"></a>match case</h4><p>多个匹配的时候就需要用到match case语句，和c语言的switch case一样的用法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">match</span> score:<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;A&#x27;</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is A.&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;B&#x27;</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is B.&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;C&#x27;</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is C.&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> _: <span class=\"hljs-comment\"># _表示匹配到其他任何情况</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is ???.&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><code>match</code>语句还可以匹配列表，功能非常强大。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">args = [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>, <span class=\"hljs-string\">&#x27;hello.c&#x27;</span>, <span class=\"hljs-string\">&#x27;world.c&#x27;</span>]<br><span class=\"hljs-comment\"># args = [&#x27;clean&#x27;]</span><br><span class=\"hljs-comment\"># args = [&#x27;gcc&#x27;]</span><br><br><span class=\"hljs-keyword\">match</span> args:<br>    <span class=\"hljs-comment\"># 如果仅出现gcc，报错:</span><br>    <span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;gcc: missing source file(s).&#x27;</span>)<br>    <span class=\"hljs-comment\"># 出现gcc，且至少指定了一个文件:</span><br>    <span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>, file1, *files]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;gcc compile: &#x27;</span> + file1 + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span>.join(files))<br>    <span class=\"hljs-comment\"># 仅出现clean:</span><br>    <span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;clean&#x27;</span>]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;clean&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> _:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;invalid command.&#x27;</span>)<br>        <br>第一个<span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>]表示列表仅有<span class=\"hljs-string\">&#x27;gcc&#x27;</span>一个字符串，没有指定文件名，报错；<br><br>第二个<span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>, file1, *files]表示列表第一个字符串是<span class=\"hljs-string\">&#x27;gcc&#x27;</span>，第二个字符串绑定到变量file1，后面的任意个字符串绑定到*files（符号*的作用将在函数的参数中讲解），它实际上表示至少指定一个文件；<br>如果第一个不是gcc，那么就不能进行判断<br><br>第三个<span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;clean&#x27;</span>]表示列表仅有<span class=\"hljs-string\">&#x27;clean&#x27;</span>一个字符串；<br><br>最后一个<span class=\"hljs-keyword\">case</span> _表示其他所有情况。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><h4 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h4><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">names = [<span class=\"hljs-string\">&#x27;Michael&#x27;</span>, <span class=\"hljs-string\">&#x27;Bob&#x27;</span>, <span class=\"hljs-string\">&#x27;Tracy&#x27;</span>]<br><span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> names:<br>    <span class=\"hljs-built_in\">print</span>(x)<br></code></pre></td></tr></table></figure>\n\n<p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p>\n<p>再比如我们想计算1-10的整数之和，可以用一个<code>sum</code>变量做累加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">numbers = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>]<br><span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> numbers:<br>    <span class=\"hljs-built_in\">sum</span> =<span class=\"hljs-built_in\">sum</span> + x<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">sum</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range()\"></a>range()</h4><p>Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">5</span>)) <br>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">101</span>))<br>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">24</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">26</span>, <span class=\"hljs-number\">27</span>, <span class=\"hljs-number\">28</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">35</span>, <span class=\"hljs-number\">36</span>, <span class=\"hljs-number\">37</span>, <span class=\"hljs-number\">38</span>, <span class=\"hljs-number\">39</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">41</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-number\">44</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">46</span>, <span class=\"hljs-number\">47</span>, <span class=\"hljs-number\">48</span>, <span class=\"hljs-number\">49</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">51</span>, <span class=\"hljs-number\">52</span>, <span class=\"hljs-number\">53</span>, <span class=\"hljs-number\">54</span>, <span class=\"hljs-number\">55</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">57</span>, <span class=\"hljs-number\">58</span>, <span class=\"hljs-number\">59</span>, <span class=\"hljs-number\">60</span>, <span class=\"hljs-number\">61</span>, <span class=\"hljs-number\">62</span>, <span class=\"hljs-number\">63</span>, <span class=\"hljs-number\">64</span>, <span class=\"hljs-number\">65</span>, <span class=\"hljs-number\">66</span>, <span class=\"hljs-number\">67</span>, <span class=\"hljs-number\">68</span>, <span class=\"hljs-number\">69</span>, <span class=\"hljs-number\">70</span>, <span class=\"hljs-number\">71</span>, <span class=\"hljs-number\">72</span>, <span class=\"hljs-number\">73</span>, <span class=\"hljs-number\">74</span>, <span class=\"hljs-number\">75</span>, <span class=\"hljs-number\">76</span>, <span class=\"hljs-number\">77</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">79</span>, <span class=\"hljs-number\">80</span>, <span class=\"hljs-number\">81</span>, <span class=\"hljs-number\">82</span>, <span class=\"hljs-number\">83</span>, <span class=\"hljs-number\">84</span>, <span class=\"hljs-number\">85</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">87</span>, <span class=\"hljs-number\">88</span>, <span class=\"hljs-number\">89</span>, <span class=\"hljs-number\">90</span>, <span class=\"hljs-number\">91</span>, <span class=\"hljs-number\">92</span>, <span class=\"hljs-number\">93</span>, <span class=\"hljs-number\">94</span>, <span class=\"hljs-number\">95</span>, <span class=\"hljs-number\">96</span>, <span class=\"hljs-number\">97</span>, <span class=\"hljs-number\">98</span>, <span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">100</span>]<br></code></pre></td></tr></table></figure>\n\n<p>所以就可以直接用if in来累加</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">101</span>):<br>    <span class=\"hljs-built_in\">sum</span> =<span class=\"hljs-built_in\">sum</span> + x<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">sum</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br>n = <span class=\"hljs-number\">99</span><br><span class=\"hljs-keyword\">while</span> n &gt; <span class=\"hljs-number\">0</span>:<br>    <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-built_in\">sum</span> + n<br>    n = n - <span class=\"hljs-number\">2</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">sum</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在循环中，<code>break</code>语句可以提前退出循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n = <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">while</span> n &lt;= <span class=\"hljs-number\">100</span>:<br>    <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">10</span>: <span class=\"hljs-comment\"># 当n = 11时，条件满足，执行break语句</span><br>        <span class=\"hljs-keyword\">break</span> <span class=\"hljs-comment\"># break语句会结束当前循环</span><br>    <span class=\"hljs-built_in\">print</span>(n)<br>    n = n + <span class=\"hljs-number\">1</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">while</span> n &lt; <span class=\"hljs-number\">10</span>:<br>    n = n + <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">if</span> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\"># 如果n是偶数，执行continue语句</span><br>        <span class=\"hljs-keyword\">continue</span> <span class=\"hljs-comment\"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span><br>    <span class=\"hljs-built_in\">print</span>(n)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>\n<p>字典其实也是类似于C语言的结构体，但是使用方法会比结构体更加简单一些</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span> = &#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>,<span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>,<span class=\"hljs-string\">&quot;kangkang&quot;</span>: <span class=\"hljs-number\">55</span>&#125; <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>所以我们就可以根据前面的键值直接找到后面的值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-string\">&#x27;lihua&#x27;</span>] <br><span class=\"hljs-number\">94</span><br></code></pre></td></tr></table></figure>\n\n<p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p>\n<p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p>\n<p>dict就是第二种实现方式，给定一个名字，比如<code>&#39;Michael&#39;</code>，dict在内部就可以直接计算出<code>Michael</code>对应的存放成绩的“页码”，也就是<code>95</code>这个数字存放的内存地址，直接取出来，所以速度非常快。</p>\n<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-string\">&quot;liuyang&quot;</span>] = <span class=\"hljs-number\">97</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>                 <br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">97</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>                 <br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">97</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-string\">&#x27;liuyang&#x27;</span>] = <span class=\"hljs-number\">94</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>.get(<span class=\"hljs-string\">&#x27;yangyang&#x27;</span>) <br><span class=\"hljs-number\">44</span><br></code></pre></td></tr></table></figure>\n\n<p>要想删除字典里面的值，直接用pop选取该字典里面的键值就可以把键和值都删掉</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>.pop(<span class=\"hljs-string\">&#x27;yangyang&#x27;</span>)<br><span class=\"hljs-number\">44</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>                 <br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>\n<p>要创建一个set，用<code>&#123;x,y,z,...&#125;</code>列出每个元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或者提供一个list作为输入集合：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = <span class=\"hljs-built_in\">set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>&#123;1, 2, 3&#125;</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。</p>\n<p>重复元素在set中自动被过滤：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s.add(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s.add(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>remove(key)</code>方法可以删除元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s.remove(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s1 = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s2 = &#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s1 &amp; s2<br>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s1 | s2<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>\n<p>假设我们自己去写一个绝对值判断函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">abs_self</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">if</span> x&gt;<span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-built_in\">print</span>(x)<br>        <span class=\"hljs-keyword\">return</span> x<br>    <span class=\"hljs-keyword\">elif</span> x&lt;<span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-built_in\">print</span>(-x)<br>        <span class=\"hljs-keyword\">return</span> -x<br><br><span class=\"hljs-built_in\">print</span>(abs_self(-<span class=\"hljs-number\">10</span>))<br></code></pre></td></tr></table></figure>\n\n<p>函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>\n<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p>\n<p>在Python交互环境中定义函数时，注意Python会出现<code>...</code>的提示。函数定义结束后需要按两次回车重新回到<code>&gt;&gt;&gt;</code>提示符下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">zzzz</span>(<span class=\"hljs-params\">x</span>):<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&gt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> x<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&lt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> -x<br>...<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>zzzz(-<span class=\"hljs-number\">20</span>) <br><span class=\"hljs-number\">20</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">nop</span>():<br>    <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n\n<p><code>pass</code>语句什么都不做，那有什么用？实际上<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p>\n<p><code>pass</code>还可以用在其他语句里，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> age &gt;= <span class=\"hljs-number\">18</span>:<br>    <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n\n<p>缺少了<code>pass</code>，代码运行就会有语法错误。</p>\n<p>当传入了不恰当的参数时，内置函数<code>abs</code>会检查出参数错误，而我们定义的<code>zzzz</code>没有参数检查，会导致<code>if</code>语句出错，出错信息和<code>abs</code>不一样。所以，这个函数定义不够完善。</p>\n<p>修改一下<code>zzzz</code>的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance()</code>实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">zzzz</span>(<span class=\"hljs-params\">x</span>):<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">isinstance</span>(x,(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">float</span>)):<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">raise</span> TypeError(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&gt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> x<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&lt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> -x<br>...<br><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>zzzz(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>  File <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"hljs-number\">3</span>, <span class=\"hljs-keyword\">in</span> zzzz<br>TypeError: Error<br></code></pre></td></tr></table></figure>\n\n<p>函数也可以返回多个参数值，只需要在return的时候进行多个值的指定</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-params\">x,y</span>):<br>    a=<span class=\"hljs-number\">10</span><br>    <span class=\"hljs-keyword\">if</span> x&gt;y:<br>        <span class=\"hljs-built_in\">print</span>(x)<br>        <span class=\"hljs-keyword\">return</span> x<br>    <span class=\"hljs-keyword\">elif</span> x&lt;y:<br>        <span class=\"hljs-built_in\">print</span>(y)<br>        <span class=\"hljs-keyword\">return</span> x<br>    <span class=\"hljs-keyword\">elif</span> x==y:<br>        <span class=\"hljs-built_in\">print</span>(x,y)<br>        <span class=\"hljs-keyword\">return</span> x ,y,a<br><span class=\"hljs-built_in\">print</span>(text(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">10</span>))<br><br>//output<br><span class=\"hljs-number\">10</span> <span class=\"hljs-number\">10</span><br>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"函数的默认参数\"><a href=\"#函数的默认参数\" class=\"headerlink\" title=\"函数的默认参数\"></a>函数的默认参数</h4><p>很多时候，我们在定义函数的时候，参数的类型很多，因此每次我们调用函数都需要填入多个参数，如果少一个就会报错，因此我们可以在定义函数的时候添加默认参数，这样的话我们只需要调用函数的时候直接输入没有默认的参数，就可以实现函数的调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">xx</span>(<span class=\"hljs-params\">x,n=<span class=\"hljs-number\">2</span></span>):<br>    c=<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):<br>        c=c*x<br>    <span class=\"hljs-keyword\">return</span> c<br><br><span class=\"hljs-built_in\">print</span>(xx(<span class=\"hljs-number\">5</span>))//调用默认参数<br><span class=\"hljs-built_in\">print</span>(xx(<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">3</span>))//定义其他参数<br></code></pre></td></tr></table></figure>\n\n<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值。</p>\n<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p>\n<p>在定义函数的时候，会选择默认参数，默认参数必须是指向不变的值，如果它指向的是可变的值，那么会出现该参数数据混乱的情况，所以使用none来指定一些可变参数转换成固定参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_end</span>(<span class=\"hljs-params\">L=<span class=\"hljs-literal\">None</span></span>):<br>    <span class=\"hljs-keyword\">if</span> L <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:<br>        L = []<br>    L.append(<span class=\"hljs-string\">&#x27;END&#x27;</span>)<br>    <span class=\"hljs-keyword\">return</span> L<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"函数的可变参数\"><a href=\"#函数的可变参数\" class=\"headerlink\" title=\"函数的可变参数\"></a>函数的可变参数</h4><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p>\n<p>常规办法的话可以将函数的参数传入定义成一个列表或者元组，这样我们可以从里面填充这些可变值进行传入，就可以实现类似的可变参数，但是这样的可变参数操作起来比较复杂，需要很多步骤</p>\n<p>所以，我们把函数的参数改为可变参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">calc</span>(<span class=\"hljs-params\">*numbers</span>):<br>    <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers:<br>        <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-built_in\">sum</span> + n * n<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">sum</span><br></code></pre></td></tr></table></figure>\n\n<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>calc(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)<br><span class=\"hljs-number\">5</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>calc()<br><span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>如果已经定义好可变参数函数，但是我又想导入一个列表和元组，就可以在列表和元组上添加*符号，代表可变参数，函数会自动遍历该值，进行输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>calc(*nums)<br><span class=\"hljs-number\">14</span><br></code></pre></td></tr></table></figure>\n\n<p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>\n<h4 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h4><p>而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">person</span>(<span class=\"hljs-params\">name, age, **kw</span>):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;name:&#x27;</span>, name, <span class=\"hljs-string\">&#x27;age:&#x27;</span>, age, <span class=\"hljs-string\">&#x27;other:&#x27;</span>, kw)<br></code></pre></td></tr></table></figure>\n\n<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>, <span class=\"hljs-number\">30</span>)<br>name: Michael age: <span class=\"hljs-number\">30</span> other: &#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>也可以传入任意个数的关键字参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Bob&#x27;</span>, <span class=\"hljs-number\">35</span>, city=<span class=\"hljs-string\">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class=\"hljs-number\">35</span> other: &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Adam&#x27;</span>, <span class=\"hljs-number\">45</span>, gender=<span class=\"hljs-string\">&#x27;M&#x27;</span>, job=<span class=\"hljs-string\">&#x27;Engineer&#x27;</span>)<br>name: Adam age: <span class=\"hljs-number\">45</span> other: &#123;<span class=\"hljs-string\">&#x27;gender&#x27;</span>: <span class=\"hljs-string\">&#x27;M&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">&gt;&gt;&gt; extra = &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br>&gt;&gt;&gt; person(<span class=\"hljs-string\">&#x27;Jack&#x27;</span>, 24, <span class=\"hljs-attribute\">city</span>=extra[<span class=\"hljs-string\">&#x27;city&#x27;</span>], <span class=\"hljs-attribute\">job</span>=extra[<span class=\"hljs-string\">&#x27;job&#x27;</span>])<br>name: Jack age: 24 other: &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当然，上面复杂的调用可以用简化的写法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>extra = &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Jack&#x27;</span>, <span class=\"hljs-number\">24</span>, **extra)<br>name: Jack age: <span class=\"hljs-number\">24</span> other: &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p>\n<h4 id=\"命令关键字参数\"><a href=\"#命令关键字参数\" class=\"headerlink\" title=\"命令关键字参数\"></a>命令关键字参数</h4><p>主要对关键字进行限制，关键字可以传入任意的参数，而命令关键字对他进行限定，限定只能传入限定的关键字</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">def person(name, age, *, city, <span class=\"hljs-keyword\">job</span>):<br>    <span class=\"hljs-keyword\">print</span>(name, age, city, <span class=\"hljs-keyword\">job</span>)<br></code></pre></td></tr></table></figure>\n\n<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p>\n<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">def person(name, age, *args, city, <span class=\"hljs-keyword\">job</span>):<br>    <span class=\"hljs-keyword\">print</span>(name, age, args, city, <span class=\"hljs-keyword\">job</span>)<br></code></pre></td></tr></table></figure>\n\n<p>命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：</p>\n<figure class=\"highlight sas\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sas\">&gt;&gt;&gt; perso<span class=\"hljs-meta\">n</span>(<span class=\"hljs-string\">&#x27;Jack&#x27;</span>, 24, <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>)<br>Traceback (most recent <span class=\"hljs-keyword\">call</span> last):<br>  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>TypeError: perso<span class=\"hljs-meta\">n</span>() <span class=\"hljs-keyword\">missing</span> 2 required keyword-only arguments: <span class=\"hljs-string\">&#x27;city&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-string\">&#x27;job&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>由于调用时缺少参数名<code>city</code>和<code>job</code>，Python解释器把前两个参数视为位置参数，后两个参数传给<code>*args</code>，但缺少命名关键字参数导致报错。</p>\n<p>命名关键字参数可以有缺省值，从而简化调用：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">def person(name, age, *, <span class=\"hljs-attribute\">city</span>=<span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, job):<br>    <span class=\"hljs-built_in\">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参数组合\"><a href=\"#参数组合\" class=\"headerlink\" title=\"参数组合\"></a>参数组合</h4><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">def f1(a, b, <span class=\"hljs-attribute\">c</span>=0, <span class=\"hljs-number\">*a</span>rgs, **kw):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;a =&#x27;</span>, a, <span class=\"hljs-string\">&#x27;b =&#x27;</span>, b, <span class=\"hljs-string\">&#x27;c =&#x27;</span>, c, <span class=\"hljs-string\">&#x27;args =&#x27;</span>, args, <span class=\"hljs-string\">&#x27;kw =&#x27;</span>, kw)<br><br>def f2(a, b, <span class=\"hljs-attribute\">c</span>=0, *, d, **kw):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;a =&#x27;</span>, a, <span class=\"hljs-string\">&#x27;b =&#x27;</span>, b, <span class=\"hljs-string\">&#x27;c =&#x27;</span>, c, <span class=\"hljs-string\">&#x27;d =&#x27;</span>, d, <span class=\"hljs-string\">&#x27;kw =&#x27;</span>, kw)<br>    <br>&gt;&gt;&gt; f1(1, 2)<br>a = 1 b = 2 c = 0 args = () kw = &#123;&#125;<br>&gt;&gt;&gt; f1(1, 2, <span class=\"hljs-attribute\">c</span>=3)<br>a = 1 b = 2 c = 3 args = () kw = &#123;&#125;<br>&gt;&gt;&gt; f1(1, 2, 3, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>)<br>a = 1 b = 2 c = 3 args = (<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>) kw = &#123;&#125;<br>&gt;&gt;&gt; f1(1, 2, 3, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-attribute\">x</span>=99)<br>a = 1 b = 2 c = 3 args = (<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>) kw = &#123;<span class=\"hljs-string\">&#x27;x&#x27;</span>: 99&#125;<br>&gt;&gt;&gt; f2(1, 2, <span class=\"hljs-attribute\">d</span>=99, <span class=\"hljs-attribute\">ext</span>=None)<br>a = 1 b = 2 c = 0 d = 99 kw = &#123;<span class=\"hljs-string\">&#x27;ext&#x27;</span>: None&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h4><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>\n<p>举个例子，我们来计算阶乘<code>n! = 1 x 2 x 3 x ... x n</code>，用函数<code>fact(n)</code>表示，可以看出：</p>\n<p><em>f<strong>a</strong>c**t</em>(<em>n</em>)&#x3D;<em>n</em>!&#x3D;1×2×3×⋅⋅⋅×(<em>n</em>−1)×<em>n</em>&#x3D;(<em>n</em>−1)!×<em>n</em>&#x3D;<em>f<strong>a</strong>c**t</em>(<em>n</em>−1)×<em>n</em></p>\n<p>所以，<code>fact(n)</code>可以表示为<code>n x fact(n-1)</code>，只有n&#x3D;1时需要特殊处理。</p>\n<p>于是，<code>fact(n)</code>用递归的方式写出来就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fact</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-keyword\">if</span> n==<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> n * fact(n - <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>其实递归函数就是在return的地方假设函数所需的运算，返回的自然就是想要的值</p>\n<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>\n","excerpt":"","more":"<h1 id=\"Python-变量、列表、元组、字典、函数\"><a href=\"#Python-变量、列表、元组、字典、函数\" class=\"headerlink\" title=\"Python-变量、列表、元组、字典、函数\"></a>Python-变量、列表、元组、字典、函数</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://liaoxuefeng.com/books/python/basic/data-types/index.html\">数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>\n<h2 id=\"Python-简介\"><a href=\"#Python-简介\" class=\"headerlink\" title=\"Python 简介\"></a>Python 简介</h2><p><strong>Python 是一种解释型语言：</strong> 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言</p>\n<p><strong>Python 是交互式语言：</strong> 这意味着，您可以在一个 Python 提示符 <strong>&gt;&gt;&gt;</strong> 后直接执行代码。</p>\n<p><strong>Python 是面向对象语言:</strong> 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p>\n<p><strong>Python 是初学者的语言：</strong>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</p>\n<h2 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h2><p>转义字符<code>\\</code>可以转义很多字符，比如<code>\\n</code>表示换行，<code>\\t</code>表示制表符，字符<code>\\</code>本身也要转义，所以<code>\\\\</code>表示的字符就是<code>\\</code></p>\n<p>这种<strong>变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。Python是动态语言，根据上下文判断变量赋值</p>\n<p>在Python中，通常用全部大写的变量名表示常量</p>\n<p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-number\">9</span> / <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">3.0</span><br></code></pre></td></tr></table></figure>\n\n<p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-number\">10</span> // <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<p>整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</p>\n<p>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-number\">10</span> % <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"列表List\"><a href=\"#列表List\" class=\"headerlink\" title=\"列表List\"></a>列表List</h2><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>\n<p>定义一个列表<code>classmates</code>，里面数据包含了班级同学的名字，其实列表等于c语言里面的数组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">classmates =[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>,<span class=\"hljs-string\">&#x27;lihua&#x27;</span>,<span class=\"hljs-string\">&quot;xiaoming&quot;</span>,<span class=\"hljs-string\">&quot;zhengzheng&quot;</span>,<span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>求这个列表的长度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">len</span>(classmates)<br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<p>用索引来访问list中每一个位置的元素，记得索引是从<code>0</code>开始的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[<span class=\"hljs-number\">1</span>] <br><span class=\"hljs-string\">&#x27;lihua&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[<span class=\"hljs-number\">0</span>] <br><span class=\"hljs-string\">&#x27;kangkang&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果索引值是负号，说明索引是倒数执行的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[-<span class=\"hljs-number\">2</span>]  <br><span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[-<span class=\"hljs-number\">1</span>] <br><span class=\"hljs-string\">&#x27;liuyang&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.append(<span class=\"hljs-string\">&#x27;chenyu&#x27;</span>) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>, <span class=\"hljs-string\">&#x27;chenyu&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>也可以把元素插入到指定的位置，比如索引号为<code>2</code>的位置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.insert(<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;yangfeng&#x27;</span>) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;yangfeng&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>, <span class=\"hljs-string\">&#x27;chenyu&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>要删除list末尾的元素，用<code>pop()</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.pop()<br><span class=\"hljs-string\">&#x27;chenyu&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates <br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;yangfeng&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.pop(<span class=\"hljs-number\">2</span>) <br><span class=\"hljs-string\">&#x27;yangfeng&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;lihua&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates[<span class=\"hljs-number\">1</span>]=<span class=\"hljs-string\">&#x27;jack&#x27;</span> <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates<br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>list里面的元素的数据类型也可以不同，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span>= [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">&#x27;clast&#x27;</span>,<span class=\"hljs-number\">3.001</span>,-<span class=\"hljs-number\">2</span>]        <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>]<br></code></pre></td></tr></table></figure>\n\n<p>list元素也可以是另一个list，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span>.insert(<span class=\"hljs-number\">4</span>,classmates) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">str</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"元组tuple\"><a href=\"#元组tuple\" class=\"headerlink\" title=\"元组tuple\"></a>元组tuple</h2><p>另一种有序列表叫元组：tuple。tuple和list非常类似，<strong>但是tuple一旦初始化就不能修改</strong></p>\n<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>\n<p>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来</p>\n<p>如果要定义一个空的tuple，可以写成<code>()</code></p>\n<p>要定义一个只有1个元素的tuple，如果你这么定义：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu = (<span class=\"hljs-number\">1</span>) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p>\n<p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu = (<span class=\"hljs-number\">1</span>,) <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">1</span>,)<br></code></pre></td></tr></table></figure>\n\n<p>查找元组的位置跟列表一致</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu[<span class=\"hljs-number\">0</span>] <br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>元组里面的数据也是可以添加列表和元组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu = (<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3.33</span>,-<span class=\"hljs-number\">5</span>,<span class=\"hljs-built_in\">str</span>)   <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br></code></pre></td></tr></table></figure>\n\n<p>查找元组的个数也跟列表一样，但是如果元组里面包好列表或者元组，这个只会被当作一个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">len</span>(yuanzu) <br><span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n<p>元组可以查找元组单元里面的元组子数据或者列表子数据，只能查找两重</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu         <br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>] <br>[<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure>\n\n<p>如果元组里面包含了列表，那元组里面的列表值是可以进行修改的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">&#x27;x&#x27;</span> <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu             <br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br></code></pre></td></tr></table></figure>\n\n<p>元组的数组是不能直接增删的，但是我们可以对里面的列表做增删改查，元组的数据也会相应的变化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu.pop([<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>]) <br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>AttributeError: <span class=\"hljs-string\">&#x27;tuple&#x27;</span> <span class=\"hljs-built_in\">object</span> has no attribute <span class=\"hljs-string\">&#x27;pop&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>classmates.pop()<br><span class=\"hljs-string\">&#x27;liuyang&#x27;</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>yuanzu<br>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3.33</span>, -<span class=\"hljs-number\">5</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-string\">&#x27;clast&#x27;</span>, [<span class=\"hljs-string\">&#x27;kangkang&#x27;</span>, <span class=\"hljs-string\">&#x27;jack&#x27;</span>, <span class=\"hljs-string\">&#x27;xiaoming&#x27;</span>, <span class=\"hljs-string\">&#x27;zhengzheng&#x27;</span>], <span class=\"hljs-number\">3.001</span>, -<span class=\"hljs-number\">2</span>])<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"判断和输入\"><a href=\"#判断和输入\" class=\"headerlink\" title=\"判断和输入\"></a>判断和输入</h2><p>根据Python的缩进规则，如果<code>if</code>语句判断是<code>True</code>，就把缩进的两行print语句执行了，否则，什么也不做。</p>\n<h4 id=\"if、elif、else\"><a href=\"#if、elif、else\" class=\"headerlink\" title=\"if、elif、else\"></a>if、elif、else</h4><p>也可以给<code>if</code>添加一个<code>else</code>语句，意思是，如果<code>if</code>判断是<code>False</code>，不要执行<code>if</code>的内容，去把<code>else</code>执行了：</p>\n<p><code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span>`语句执行有个特点，它是从上往下判断，如果在某个判断上是`<span class=\"hljs-literal\">True</span>`，把该判断对应的语句执行后，就忽略掉剩下的`<span class=\"hljs-keyword\">elif</span>`和`<span class=\"hljs-keyword\">else</span><br></code></pre></td></tr></table></figure>\n\n<p><code>input()</code>读取用户的输入，这样可以自己输入，但是input()的输入值的定义是字符串，如果直接进行比较，就会报错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">birth = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&#x27;birth: &#x27;</span>)<br><span class=\"hljs-keyword\">if</span> birth &lt; <span class=\"hljs-number\">2000</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00前&#x27;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00后&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>所以就需要进行字符的转换，用到了int()</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">s = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&#x27;birth: &#x27;</span>)<br>birth = <span class=\"hljs-built_in\">int</span>(s)<br><span class=\"hljs-keyword\">if</span> birth &lt; <span class=\"hljs-number\">2000</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00前&#x27;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;00后&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"match-case\"><a href=\"#match-case\" class=\"headerlink\" title=\"match case\"></a>match case</h4><p>多个匹配的时候就需要用到match case语句，和c语言的switch case一样的用法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">match</span> score:<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;A&#x27;</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is A.&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;B&#x27;</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is B.&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;C&#x27;</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is C.&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> _: <span class=\"hljs-comment\"># _表示匹配到其他任何情况</span><br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;score is ???.&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><code>match</code>语句还可以匹配列表，功能非常强大。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">args = [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>, <span class=\"hljs-string\">&#x27;hello.c&#x27;</span>, <span class=\"hljs-string\">&#x27;world.c&#x27;</span>]<br><span class=\"hljs-comment\"># args = [&#x27;clean&#x27;]</span><br><span class=\"hljs-comment\"># args = [&#x27;gcc&#x27;]</span><br><br><span class=\"hljs-keyword\">match</span> args:<br>    <span class=\"hljs-comment\"># 如果仅出现gcc，报错:</span><br>    <span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;gcc: missing source file(s).&#x27;</span>)<br>    <span class=\"hljs-comment\"># 出现gcc，且至少指定了一个文件:</span><br>    <span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>, file1, *files]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;gcc compile: &#x27;</span> + file1 + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span>.join(files))<br>    <span class=\"hljs-comment\"># 仅出现clean:</span><br>    <span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;clean&#x27;</span>]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;clean&#x27;</span>)<br>    <span class=\"hljs-keyword\">case</span> _:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;invalid command.&#x27;</span>)<br>        <br>第一个<span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>]表示列表仅有<span class=\"hljs-string\">&#x27;gcc&#x27;</span>一个字符串，没有指定文件名，报错；<br><br>第二个<span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;gcc&#x27;</span>, file1, *files]表示列表第一个字符串是<span class=\"hljs-string\">&#x27;gcc&#x27;</span>，第二个字符串绑定到变量file1，后面的任意个字符串绑定到*files（符号*的作用将在函数的参数中讲解），它实际上表示至少指定一个文件；<br>如果第一个不是gcc，那么就不能进行判断<br><br>第三个<span class=\"hljs-keyword\">case</span> [<span class=\"hljs-string\">&#x27;clean&#x27;</span>]表示列表仅有<span class=\"hljs-string\">&#x27;clean&#x27;</span>一个字符串；<br><br>最后一个<span class=\"hljs-keyword\">case</span> _表示其他所有情况。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><h4 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h4><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">names = [<span class=\"hljs-string\">&#x27;Michael&#x27;</span>, <span class=\"hljs-string\">&#x27;Bob&#x27;</span>, <span class=\"hljs-string\">&#x27;Tracy&#x27;</span>]<br><span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> names:<br>    <span class=\"hljs-built_in\">print</span>(x)<br></code></pre></td></tr></table></figure>\n\n<p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p>\n<p>再比如我们想计算1-10的整数之和，可以用一个<code>sum</code>变量做累加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">numbers = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>]<br><span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> numbers:<br>    <span class=\"hljs-built_in\">sum</span> =<span class=\"hljs-built_in\">sum</span> + x<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">sum</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range()\"></a>range()</h4><p>Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">5</span>)) <br>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">101</span>))<br>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">24</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">26</span>, <span class=\"hljs-number\">27</span>, <span class=\"hljs-number\">28</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">35</span>, <span class=\"hljs-number\">36</span>, <span class=\"hljs-number\">37</span>, <span class=\"hljs-number\">38</span>, <span class=\"hljs-number\">39</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">41</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-number\">44</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">46</span>, <span class=\"hljs-number\">47</span>, <span class=\"hljs-number\">48</span>, <span class=\"hljs-number\">49</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">51</span>, <span class=\"hljs-number\">52</span>, <span class=\"hljs-number\">53</span>, <span class=\"hljs-number\">54</span>, <span class=\"hljs-number\">55</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">57</span>, <span class=\"hljs-number\">58</span>, <span class=\"hljs-number\">59</span>, <span class=\"hljs-number\">60</span>, <span class=\"hljs-number\">61</span>, <span class=\"hljs-number\">62</span>, <span class=\"hljs-number\">63</span>, <span class=\"hljs-number\">64</span>, <span class=\"hljs-number\">65</span>, <span class=\"hljs-number\">66</span>, <span class=\"hljs-number\">67</span>, <span class=\"hljs-number\">68</span>, <span class=\"hljs-number\">69</span>, <span class=\"hljs-number\">70</span>, <span class=\"hljs-number\">71</span>, <span class=\"hljs-number\">72</span>, <span class=\"hljs-number\">73</span>, <span class=\"hljs-number\">74</span>, <span class=\"hljs-number\">75</span>, <span class=\"hljs-number\">76</span>, <span class=\"hljs-number\">77</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">79</span>, <span class=\"hljs-number\">80</span>, <span class=\"hljs-number\">81</span>, <span class=\"hljs-number\">82</span>, <span class=\"hljs-number\">83</span>, <span class=\"hljs-number\">84</span>, <span class=\"hljs-number\">85</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">87</span>, <span class=\"hljs-number\">88</span>, <span class=\"hljs-number\">89</span>, <span class=\"hljs-number\">90</span>, <span class=\"hljs-number\">91</span>, <span class=\"hljs-number\">92</span>, <span class=\"hljs-number\">93</span>, <span class=\"hljs-number\">94</span>, <span class=\"hljs-number\">95</span>, <span class=\"hljs-number\">96</span>, <span class=\"hljs-number\">97</span>, <span class=\"hljs-number\">98</span>, <span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">100</span>]<br></code></pre></td></tr></table></figure>\n\n<p>所以就可以直接用if in来累加</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">101</span>):<br>    <span class=\"hljs-built_in\">sum</span> =<span class=\"hljs-built_in\">sum</span> + x<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">sum</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br>n = <span class=\"hljs-number\">99</span><br><span class=\"hljs-keyword\">while</span> n &gt; <span class=\"hljs-number\">0</span>:<br>    <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-built_in\">sum</span> + n<br>    n = n - <span class=\"hljs-number\">2</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">sum</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在循环中，<code>break</code>语句可以提前退出循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n = <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">while</span> n &lt;= <span class=\"hljs-number\">100</span>:<br>    <span class=\"hljs-keyword\">if</span> n &gt; <span class=\"hljs-number\">10</span>: <span class=\"hljs-comment\"># 当n = 11时，条件满足，执行break语句</span><br>        <span class=\"hljs-keyword\">break</span> <span class=\"hljs-comment\"># break语句会结束当前循环</span><br>    <span class=\"hljs-built_in\">print</span>(n)<br>    n = n + <span class=\"hljs-number\">1</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">while</span> n &lt; <span class=\"hljs-number\">10</span>:<br>    n = n + <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">if</span> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\"># 如果n是偶数，执行continue语句</span><br>        <span class=\"hljs-keyword\">continue</span> <span class=\"hljs-comment\"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span><br>    <span class=\"hljs-built_in\">print</span>(n)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>\n<p>字典其实也是类似于C语言的结构体，但是使用方法会比结构体更加简单一些</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span> = &#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>,<span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>,<span class=\"hljs-string\">&quot;kangkang&quot;</span>: <span class=\"hljs-number\">55</span>&#125; <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>所以我们就可以根据前面的键值直接找到后面的值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-string\">&#x27;lihua&#x27;</span>] <br><span class=\"hljs-number\">94</span><br></code></pre></td></tr></table></figure>\n\n<p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p>\n<p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p>\n<p>dict就是第二种实现方式，给定一个名字，比如<code>&#39;Michael&#39;</code>，dict在内部就可以直接计算出<code>Michael</code>对应的存放成绩的“页码”，也就是<code>95</code>这个数字存放的内存地址，直接取出来，所以速度非常快。</p>\n<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-string\">&quot;liuyang&quot;</span>] = <span class=\"hljs-number\">97</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>                 <br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">97</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>                 <br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">97</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-string\">&#x27;liuyang&#x27;</span>] = <span class=\"hljs-number\">94</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>.get(<span class=\"hljs-string\">&#x27;yangyang&#x27;</span>) <br><span class=\"hljs-number\">44</span><br></code></pre></td></tr></table></figure>\n\n<p>要想删除字典里面的值，直接用pop选取该字典里面的键值就可以把键和值都删掉</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span><br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;yangyang&#x27;</span>: <span class=\"hljs-number\">44</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>.pop(<span class=\"hljs-string\">&#x27;yangyang&#x27;</span>)<br><span class=\"hljs-number\">44</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">dict</span>                 <br>&#123;<span class=\"hljs-string\">&#x27;lihua&#x27;</span>: <span class=\"hljs-number\">94</span>, <span class=\"hljs-string\">&#x27;kangkang&#x27;</span>: <span class=\"hljs-number\">55</span>, <span class=\"hljs-string\">&#x27;liuyang&#x27;</span>: <span class=\"hljs-number\">94</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>\n<p>要创建一个set，用<code>&#123;x,y,z,...&#125;</code>列出每个元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或者提供一个list作为输入集合：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = <span class=\"hljs-built_in\">set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>&#123;1, 2, 3&#125;</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。</p>\n<p>重复元素在set中自动被过滤：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s.add(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s.add(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>remove(key)</code>方法可以删除元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s.remove(<span class=\"hljs-number\">4</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s1 = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s2 = &#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s1 &amp; s2<br>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s1 | s2<br>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>\n<p>假设我们自己去写一个绝对值判断函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">abs_self</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">if</span> x&gt;<span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-built_in\">print</span>(x)<br>        <span class=\"hljs-keyword\">return</span> x<br>    <span class=\"hljs-keyword\">elif</span> x&lt;<span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-built_in\">print</span>(-x)<br>        <span class=\"hljs-keyword\">return</span> -x<br><br><span class=\"hljs-built_in\">print</span>(abs_self(-<span class=\"hljs-number\">10</span>))<br></code></pre></td></tr></table></figure>\n\n<p>函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>\n<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p>\n<p>在Python交互环境中定义函数时，注意Python会出现<code>...</code>的提示。函数定义结束后需要按两次回车重新回到<code>&gt;&gt;&gt;</code>提示符下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">zzzz</span>(<span class=\"hljs-params\">x</span>):<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&gt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> x<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&lt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> -x<br>...<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>zzzz(-<span class=\"hljs-number\">20</span>) <br><span class=\"hljs-number\">20</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">nop</span>():<br>    <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n\n<p><code>pass</code>语句什么都不做，那有什么用？实际上<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p>\n<p><code>pass</code>还可以用在其他语句里，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> age &gt;= <span class=\"hljs-number\">18</span>:<br>    <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n\n<p>缺少了<code>pass</code>，代码运行就会有语法错误。</p>\n<p>当传入了不恰当的参数时，内置函数<code>abs</code>会检查出参数错误，而我们定义的<code>zzzz</code>没有参数检查，会导致<code>if</code>语句出错，出错信息和<code>abs</code>不一样。所以，这个函数定义不够完善。</p>\n<p>修改一下<code>zzzz</code>的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance()</code>实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">zzzz</span>(<span class=\"hljs-params\">x</span>):<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">isinstance</span>(x,(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">float</span>)):<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">raise</span> TypeError(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&gt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> x<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">if</span> x&lt;<span class=\"hljs-number\">0</span>:<br><span class=\"hljs-meta\">... </span>            <span class=\"hljs-keyword\">return</span> -x<br>...<br><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>zzzz(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>  File <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"hljs-number\">3</span>, <span class=\"hljs-keyword\">in</span> zzzz<br>TypeError: Error<br></code></pre></td></tr></table></figure>\n\n<p>函数也可以返回多个参数值，只需要在return的时候进行多个值的指定</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-params\">x,y</span>):<br>    a=<span class=\"hljs-number\">10</span><br>    <span class=\"hljs-keyword\">if</span> x&gt;y:<br>        <span class=\"hljs-built_in\">print</span>(x)<br>        <span class=\"hljs-keyword\">return</span> x<br>    <span class=\"hljs-keyword\">elif</span> x&lt;y:<br>        <span class=\"hljs-built_in\">print</span>(y)<br>        <span class=\"hljs-keyword\">return</span> x<br>    <span class=\"hljs-keyword\">elif</span> x==y:<br>        <span class=\"hljs-built_in\">print</span>(x,y)<br>        <span class=\"hljs-keyword\">return</span> x ,y,a<br><span class=\"hljs-built_in\">print</span>(text(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">10</span>))<br><br>//output<br><span class=\"hljs-number\">10</span> <span class=\"hljs-number\">10</span><br>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"函数的默认参数\"><a href=\"#函数的默认参数\" class=\"headerlink\" title=\"函数的默认参数\"></a>函数的默认参数</h4><p>很多时候，我们在定义函数的时候，参数的类型很多，因此每次我们调用函数都需要填入多个参数，如果少一个就会报错，因此我们可以在定义函数的时候添加默认参数，这样的话我们只需要调用函数的时候直接输入没有默认的参数，就可以实现函数的调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">xx</span>(<span class=\"hljs-params\">x,n=<span class=\"hljs-number\">2</span></span>):<br>    c=<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):<br>        c=c*x<br>    <span class=\"hljs-keyword\">return</span> c<br><br><span class=\"hljs-built_in\">print</span>(xx(<span class=\"hljs-number\">5</span>))//调用默认参数<br><span class=\"hljs-built_in\">print</span>(xx(<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">3</span>))//定义其他参数<br></code></pre></td></tr></table></figure>\n\n<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll(&#39;Bob&#39;, &#39;M&#39;, 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值。</p>\n<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p>\n<p>在定义函数的时候，会选择默认参数，默认参数必须是指向不变的值，如果它指向的是可变的值，那么会出现该参数数据混乱的情况，所以使用none来指定一些可变参数转换成固定参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_end</span>(<span class=\"hljs-params\">L=<span class=\"hljs-literal\">None</span></span>):<br>    <span class=\"hljs-keyword\">if</span> L <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:<br>        L = []<br>    L.append(<span class=\"hljs-string\">&#x27;END&#x27;</span>)<br>    <span class=\"hljs-keyword\">return</span> L<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"函数的可变参数\"><a href=\"#函数的可变参数\" class=\"headerlink\" title=\"函数的可变参数\"></a>函数的可变参数</h4><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p>\n<p>常规办法的话可以将函数的参数传入定义成一个列表或者元组，这样我们可以从里面填充这些可变值进行传入，就可以实现类似的可变参数，但是这样的可变参数操作起来比较复杂，需要很多步骤</p>\n<p>所以，我们把函数的参数改为可变参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">calc</span>(<span class=\"hljs-params\">*numbers</span>):<br>    <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers:<br>        <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-built_in\">sum</span> + n * n<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">sum</span><br></code></pre></td></tr></table></figure>\n\n<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>calc(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)<br><span class=\"hljs-number\">5</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>calc()<br><span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>如果已经定义好可变参数函数，但是我又想导入一个列表和元组，就可以在列表和元组上添加*符号，代表可变参数，函数会自动遍历该值，进行输出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>calc(*nums)<br><span class=\"hljs-number\">14</span><br></code></pre></td></tr></table></figure>\n\n<p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>\n<h4 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h4><p>而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">person</span>(<span class=\"hljs-params\">name, age, **kw</span>):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;name:&#x27;</span>, name, <span class=\"hljs-string\">&#x27;age:&#x27;</span>, age, <span class=\"hljs-string\">&#x27;other:&#x27;</span>, kw)<br></code></pre></td></tr></table></figure>\n\n<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>, <span class=\"hljs-number\">30</span>)<br>name: Michael age: <span class=\"hljs-number\">30</span> other: &#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>也可以传入任意个数的关键字参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Bob&#x27;</span>, <span class=\"hljs-number\">35</span>, city=<span class=\"hljs-string\">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class=\"hljs-number\">35</span> other: &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Adam&#x27;</span>, <span class=\"hljs-number\">45</span>, gender=<span class=\"hljs-string\">&#x27;M&#x27;</span>, job=<span class=\"hljs-string\">&#x27;Engineer&#x27;</span>)<br>name: Adam age: <span class=\"hljs-number\">45</span> other: &#123;<span class=\"hljs-string\">&#x27;gender&#x27;</span>: <span class=\"hljs-string\">&#x27;M&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">&gt;&gt;&gt; extra = &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br>&gt;&gt;&gt; person(<span class=\"hljs-string\">&#x27;Jack&#x27;</span>, 24, <span class=\"hljs-attribute\">city</span>=extra[<span class=\"hljs-string\">&#x27;city&#x27;</span>], <span class=\"hljs-attribute\">job</span>=extra[<span class=\"hljs-string\">&#x27;job&#x27;</span>])<br>name: Jack age: 24 other: &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当然，上面复杂的调用可以用简化的写法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>extra = &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>person(<span class=\"hljs-string\">&#x27;Jack&#x27;</span>, <span class=\"hljs-number\">24</span>, **extra)<br>name: Jack age: <span class=\"hljs-number\">24</span> other: &#123;<span class=\"hljs-string\">&#x27;city&#x27;</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;job&#x27;</span>: <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p>\n<h4 id=\"命令关键字参数\"><a href=\"#命令关键字参数\" class=\"headerlink\" title=\"命令关键字参数\"></a>命令关键字参数</h4><p>主要对关键字进行限制，关键字可以传入任意的参数，而命令关键字对他进行限定，限定只能传入限定的关键字</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">def person(name, age, *, city, <span class=\"hljs-keyword\">job</span>):<br>    <span class=\"hljs-keyword\">print</span>(name, age, city, <span class=\"hljs-keyword\">job</span>)<br></code></pre></td></tr></table></figure>\n\n<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p>\n<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">def person(name, age, *args, city, <span class=\"hljs-keyword\">job</span>):<br>    <span class=\"hljs-keyword\">print</span>(name, age, args, city, <span class=\"hljs-keyword\">job</span>)<br></code></pre></td></tr></table></figure>\n\n<p>命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：</p>\n<figure class=\"highlight sas\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sas\">&gt;&gt;&gt; perso<span class=\"hljs-meta\">n</span>(<span class=\"hljs-string\">&#x27;Jack&#x27;</span>, 24, <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, <span class=\"hljs-string\">&#x27;Engineer&#x27;</span>)<br>Traceback (most recent <span class=\"hljs-keyword\">call</span> last):<br>  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>TypeError: perso<span class=\"hljs-meta\">n</span>() <span class=\"hljs-keyword\">missing</span> 2 required keyword-only arguments: <span class=\"hljs-string\">&#x27;city&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-string\">&#x27;job&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>由于调用时缺少参数名<code>city</code>和<code>job</code>，Python解释器把前两个参数视为位置参数，后两个参数传给<code>*args</code>，但缺少命名关键字参数导致报错。</p>\n<p>命名关键字参数可以有缺省值，从而简化调用：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">def person(name, age, *, <span class=\"hljs-attribute\">city</span>=<span class=\"hljs-string\">&#x27;Beijing&#x27;</span>, job):<br>    <span class=\"hljs-built_in\">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参数组合\"><a href=\"#参数组合\" class=\"headerlink\" title=\"参数组合\"></a>参数组合</h4><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">def f1(a, b, <span class=\"hljs-attribute\">c</span>=0, <span class=\"hljs-number\">*a</span>rgs, **kw):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;a =&#x27;</span>, a, <span class=\"hljs-string\">&#x27;b =&#x27;</span>, b, <span class=\"hljs-string\">&#x27;c =&#x27;</span>, c, <span class=\"hljs-string\">&#x27;args =&#x27;</span>, args, <span class=\"hljs-string\">&#x27;kw =&#x27;</span>, kw)<br><br>def f2(a, b, <span class=\"hljs-attribute\">c</span>=0, *, d, **kw):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;a =&#x27;</span>, a, <span class=\"hljs-string\">&#x27;b =&#x27;</span>, b, <span class=\"hljs-string\">&#x27;c =&#x27;</span>, c, <span class=\"hljs-string\">&#x27;d =&#x27;</span>, d, <span class=\"hljs-string\">&#x27;kw =&#x27;</span>, kw)<br>    <br>&gt;&gt;&gt; f1(1, 2)<br>a = 1 b = 2 c = 0 args = () kw = &#123;&#125;<br>&gt;&gt;&gt; f1(1, 2, <span class=\"hljs-attribute\">c</span>=3)<br>a = 1 b = 2 c = 3 args = () kw = &#123;&#125;<br>&gt;&gt;&gt; f1(1, 2, 3, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>)<br>a = 1 b = 2 c = 3 args = (<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>) kw = &#123;&#125;<br>&gt;&gt;&gt; f1(1, 2, 3, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-attribute\">x</span>=99)<br>a = 1 b = 2 c = 3 args = (<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>) kw = &#123;<span class=\"hljs-string\">&#x27;x&#x27;</span>: 99&#125;<br>&gt;&gt;&gt; f2(1, 2, <span class=\"hljs-attribute\">d</span>=99, <span class=\"hljs-attribute\">ext</span>=None)<br>a = 1 b = 2 c = 0 d = 99 kw = &#123;<span class=\"hljs-string\">&#x27;ext&#x27;</span>: None&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h4><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>\n<p>举个例子，我们来计算阶乘<code>n! = 1 x 2 x 3 x ... x n</code>，用函数<code>fact(n)</code>表示，可以看出：</p>\n<p><em>f<strong>a</strong>c**t</em>(<em>n</em>)&#x3D;<em>n</em>!&#x3D;1×2×3×⋅⋅⋅×(<em>n</em>−1)×<em>n</em>&#x3D;(<em>n</em>−1)!×<em>n</em>&#x3D;<em>f<strong>a</strong>c**t</em>(<em>n</em>−1)×<em>n</em></p>\n<p>所以，<code>fact(n)</code>可以表示为<code>n x fact(n-1)</code>，只有n&#x3D;1时需要特殊处理。</p>\n<p>于是，<code>fact(n)</code>用递归的方式写出来就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fact</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-keyword\">if</span> n==<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> n * fact(n - <span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n\n<p>其实递归函数就是在return的地方假设函数所需的运算，返回的自然就是想要的值</p>\n<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>\n"},{"title":"Python-切片、迭代、类和实例","date":"2024-08-11T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/1wdIJmxaylcsK9j.jpg","_content":"\n# Python-切片、迭代、类和实例\n\n## 感谢博主：\n\n[数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/python/basic/data-types/index.html)\n\n## 切片\n\n假设一个列表或者元组有如下的元素\n\n```\n>>> qiepian = [1,2,3,4,5,6,7,8,9]    \n>>> qiepian\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n现在我想访问第五个元素\n\n```\n>>> qiepian[4]\n5\n```\n\n我想访问第五个到第七个元素\n\n```\n>>> [qiepian[5],qiepian[6],qiepian[7]]\n[6, 7, 8]\n```\n\n有点过于繁琐，所以python有一个切片的方式去访问所需的元素，比如我想访问第五个到第七个元素\n\n```\n>>> qiepian[5:8] \n[6, 7, 8]\n```\n\n从索引`5`开始取，直到索引`8`为止，但不包括索引`8`。即索引`5`，`6`，`7`，正好是3个元素。\n\n切片操作十分有用。我们先创建一个0-99的数列：\n\n```bash\n>>> L = list(range(100))\n>>> L\n[0, 1, 2, 3, ..., 99]\n```\n\n可以通过切片轻松取出某一段数列。比如前10个数：\n\n```bash\n>>> L[:10]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n后10个数：\n\n```bash\n>>> L[-10:]\n[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n```\n\n前11-20个数：\n\n```bash\n>>> L[10:20]\n[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n```\n\n前10个数，每两个取一个：\n\n```bash\n>>> L[:10:2]\n[0, 2, 4, 6, 8]\n```\n\n所有数，每5个取一个：\n\n```bash\n>>> L[::5]\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n```\n\n甚至什么都不写，只写`[:]`就可以原样复制一个list：\n\n```bash\n>>> L[:]\n[0, 1, 2, 3, ..., 99]\n```\n\ntuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：\n\n```bash\n>>> (0, 1, 2, 3, 4, 5)[:3]\n(0, 1, 2)\n```\n\n字符串`'xxx'`也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n\n```bash\n>>> 'ABCDEFG'[:3]\n'ABC'\n>>> 'ABCDEFG'[::2]\n'ACEG'\n```\n\n## 迭代\n\n如果给定一个`list`或`tuple`，我们可以通过`for`循环来遍历这个`list`或`tuple`，这种遍历我们称为迭代（Iteration）。\n\n在Python中，迭代是通过`for ... in`来完成的\n\n列表和元组的迭代比较简单，直接定义一个值，然后把列表和元组塞到for循环里面打印遍历就行\n\n```\n>>> for list in classmates:\n...     print(list)\n...\nkangkang\njack\nxiaoming\nzhengzheng\n>>> classmates\n['kangkang', 'jack', 'xiaoming', 'zhengzheng']\n```\n\n但是dist字典的存储不想列表和元组那样有顺序，他是键和值一起结合在一起的，所以直接使用迭代的话只能迭代出键的值， 如果想要迭代出值，需要如下操作：\n\n```\n>>> for key in dict:\n...     print(key)\n...\nlihua\nkangkang\nliuyang\n>>> dict\n{'lihua': 94, 'kangkang': 55, 'liuyang': 94}\n\n\n>>> for value in dict.values(): \n...     print(value) \n...\n94\n55\n94\n\n>>> for dict, value in dict.items(): \n...     print(dict,value) \n...\nlihua 94\nkangkang 55\nliuyang 94\n\n```\n\n## 类和实例\n\n面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\n\n`class`后面紧接着是类名，即`Student`，类名通常是大写开头的单词，紧接着是`(object)`，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用`object`类，这是所有类最终都会继承的类。\n\npython的class（类）相当于一个多个函数组成的家族，如果在这个Myclass大家族里有一个人叫f，假如这个f具有print天气的作用，那么如果有一天我需要这个f来print一下今天的天气，那么我必须叫他的全名MyClass.f才可以让他给我print，即在调用他的时候需要带上他的家族名称+他的名称。\n\n```\n#Myclass家族，但是这个家族只有一个人f\nclass MyClass:   \n  \"\"\"一个简单的类实例\"\"\"    \n  i = 12345    \n  def f(self):        \n    return 'hello world'\n# 实例化类\nx = MyClass() \n# 访问类的属性和方法\nprint(\"MyClass 类的属性 i 为：\", x.i) #家族x + 物品名i\nprint(\"MyClass 类的方法 f 输出为：\", x.f()) #家族x + 人名f\n```\n\n假如init()也是人，但是他是家族和外界联络员，当外界的人想调用自己家族的人，就必须要先告诉他，所以只要家族的人被调用，那么init()就会被先执行，然后由他去告诉那个被调用的人，执行被调用的。\n\n```\nclass Complex:\n    def __init__(self, realpart, imagpart): #必须要有一个self参数，\n        self.r = realpart\n        self.i = imagpart\nx = Complex(3.0, -4.5)\nprint(x.r, x.i)   # 输出结果：3.0 -4.5\n```\n\n在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法**必须**包含参数`self`, 且为第一个参数，`self`代表的是类的实例。\n\nself：类的方法与普通的函数只有一个特别的区别——必须有一个额外的第一个参数名称, 按照惯例它的名称是self。\n类的实例：是将类应用在实例场景之中，比如有个类里的函数是f，假如这个f具有print某一时刻的天气状况的能力，那么如果我需要这个f来print一下今天12点的天气，那么让他打印今天12点的天气这个动作，就是类的实例化，让类中的函数具有的能力变成真实的动作。\n\n```\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    #定义构造方法\n    def __init__(self,n,a):\n        self.name = n\n        self.age = a\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n\n# 实例化类\np = people('Python',10,30)\np.speak()\n```\n\n#### 继承\n\n假如有两个家族，有一个家族A开始没落了，另一个新兴的家族B想继承A家族的物资和佣人，那么就可以通过如下的方式实现继承，在这里，家族A即是父类，家族B是子类。在用法上，如果B家族可以任意使用A家族的物品和佣人。\n\n```\nclass [子类]([父类]):\n```\n\npython还支持**多继承**，即可以继承多个父类。继承方式和单继承方式一样，方式如下：\n\n```\nclass [子类]([父类]1, [父类]2, [父类]3):\n```\n\n```\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n#单继承示例\nclass student(people):\n    grade = ''\n    def __init__(self,n,a,w,g):\n        #调用父类的构函\n        people.__init__(self,n,a,w)\n        self.grade = g\n    #覆写父类的方法\n    def speak(self):\n        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))\n \n#另一个类，多继承之前的准备\nclass speaker():\n    topic = ''\n    name = ''\n    def __init__(self,n,t):\n        self.name = n\n        self.topic = t\n    def speak(self):\n        print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic))\n \n#多继承\nclass sample(speaker,student):\n    a =''\n    def __init__(self,n,a,w,g,t):\n        student.__init__(self,n,a,w,g)\n        speaker.__init__(self,n,t)\n \ntest = sample(\"Tim\",25,80,4,\"Python\")\ntest.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法\n```\n\n在类里面，还可以动态的添加参数\n\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\ns = Student('Bob')\ns.score = 90\n```\n\n但是这种动态的添加参数并不能改变类的格式，只能储存在类的该实例当中，这个数据只为这个实例而存在，并不会改变类的结构\n\n还可以给这个实例绑定一个方法\n\n```\n>>> def set_age(self, age): # 定义一个函数作为实例方法\n...     self.age = age\n...\n>>> from types import MethodType\n>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法\n>>> s.set_age(25) # 调用实例方法\n>>> s.age # 测试结果\n25\n```\n\n#### 限制实例的属性\n\n为了达到限制的目的，Python允许在定义`class`的时候，定义一个特殊的`__slots__`变量，来限制该`class`实例能添加的属性：\n\n```\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n\n#### 数据限制\n\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问\n\n```\nclass Student(object):\n    def __init__(self, name, score):\n        self.__name = name\n        self.__score = score\n\n    def print_score(self):\n        print('%s: %s' % (self.__name, self.__score))\n```\n\n改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问`实例变量.__name`和`实例变量.__score`了，这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。\n\n如果外部想要获取内部变量，可以定义两个实例，用于将内部变量引出，从而达到访问的目的\n\n```\nclass Student(object):\n    ...\n\n    def get_name(self):\n        return self.__name\n\n    def get_score(self):\n        return self.__score\n```\n\n#### type()判断对象类型\n\n基本类型都可以用`type()`判断：\n\n```\n>>> type(123)\n<class 'int'>\n>>> type('str')\n<class 'str'>\n>>> type(None)\n<type(None) 'NoneType'>\n```\n\n如果一个变量指向函数或者类，也可以用`type()`判断：\n\n```plain\n>>> type(abs)\n<class 'builtin_function_or_method'>\n>>> type(a)\n<class '__main__.Animal'>\n```\n","source":"_posts/Work No.22.md","raw":"---\ntitle: Python-切片、迭代、类和实例\ntag: Python\ndate: 2024-08-12\ncategories: Python\nindex_img: https://s2.loli.net/2024/08/02/1wdIJmxaylcsK9j.jpg\n---\n\n# Python-切片、迭代、类和实例\n\n## 感谢博主：\n\n[数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/python/basic/data-types/index.html)\n\n## 切片\n\n假设一个列表或者元组有如下的元素\n\n```\n>>> qiepian = [1,2,3,4,5,6,7,8,9]    \n>>> qiepian\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n现在我想访问第五个元素\n\n```\n>>> qiepian[4]\n5\n```\n\n我想访问第五个到第七个元素\n\n```\n>>> [qiepian[5],qiepian[6],qiepian[7]]\n[6, 7, 8]\n```\n\n有点过于繁琐，所以python有一个切片的方式去访问所需的元素，比如我想访问第五个到第七个元素\n\n```\n>>> qiepian[5:8] \n[6, 7, 8]\n```\n\n从索引`5`开始取，直到索引`8`为止，但不包括索引`8`。即索引`5`，`6`，`7`，正好是3个元素。\n\n切片操作十分有用。我们先创建一个0-99的数列：\n\n```bash\n>>> L = list(range(100))\n>>> L\n[0, 1, 2, 3, ..., 99]\n```\n\n可以通过切片轻松取出某一段数列。比如前10个数：\n\n```bash\n>>> L[:10]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n后10个数：\n\n```bash\n>>> L[-10:]\n[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n```\n\n前11-20个数：\n\n```bash\n>>> L[10:20]\n[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n```\n\n前10个数，每两个取一个：\n\n```bash\n>>> L[:10:2]\n[0, 2, 4, 6, 8]\n```\n\n所有数，每5个取一个：\n\n```bash\n>>> L[::5]\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n```\n\n甚至什么都不写，只写`[:]`就可以原样复制一个list：\n\n```bash\n>>> L[:]\n[0, 1, 2, 3, ..., 99]\n```\n\ntuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：\n\n```bash\n>>> (0, 1, 2, 3, 4, 5)[:3]\n(0, 1, 2)\n```\n\n字符串`'xxx'`也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n\n```bash\n>>> 'ABCDEFG'[:3]\n'ABC'\n>>> 'ABCDEFG'[::2]\n'ACEG'\n```\n\n## 迭代\n\n如果给定一个`list`或`tuple`，我们可以通过`for`循环来遍历这个`list`或`tuple`，这种遍历我们称为迭代（Iteration）。\n\n在Python中，迭代是通过`for ... in`来完成的\n\n列表和元组的迭代比较简单，直接定义一个值，然后把列表和元组塞到for循环里面打印遍历就行\n\n```\n>>> for list in classmates:\n...     print(list)\n...\nkangkang\njack\nxiaoming\nzhengzheng\n>>> classmates\n['kangkang', 'jack', 'xiaoming', 'zhengzheng']\n```\n\n但是dist字典的存储不想列表和元组那样有顺序，他是键和值一起结合在一起的，所以直接使用迭代的话只能迭代出键的值， 如果想要迭代出值，需要如下操作：\n\n```\n>>> for key in dict:\n...     print(key)\n...\nlihua\nkangkang\nliuyang\n>>> dict\n{'lihua': 94, 'kangkang': 55, 'liuyang': 94}\n\n\n>>> for value in dict.values(): \n...     print(value) \n...\n94\n55\n94\n\n>>> for dict, value in dict.items(): \n...     print(dict,value) \n...\nlihua 94\nkangkang 55\nliuyang 94\n\n```\n\n## 类和实例\n\n面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\n\n`class`后面紧接着是类名，即`Student`，类名通常是大写开头的单词，紧接着是`(object)`，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用`object`类，这是所有类最终都会继承的类。\n\npython的class（类）相当于一个多个函数组成的家族，如果在这个Myclass大家族里有一个人叫f，假如这个f具有print天气的作用，那么如果有一天我需要这个f来print一下今天的天气，那么我必须叫他的全名MyClass.f才可以让他给我print，即在调用他的时候需要带上他的家族名称+他的名称。\n\n```\n#Myclass家族，但是这个家族只有一个人f\nclass MyClass:   \n  \"\"\"一个简单的类实例\"\"\"    \n  i = 12345    \n  def f(self):        \n    return 'hello world'\n# 实例化类\nx = MyClass() \n# 访问类的属性和方法\nprint(\"MyClass 类的属性 i 为：\", x.i) #家族x + 物品名i\nprint(\"MyClass 类的方法 f 输出为：\", x.f()) #家族x + 人名f\n```\n\n假如init()也是人，但是他是家族和外界联络员，当外界的人想调用自己家族的人，就必须要先告诉他，所以只要家族的人被调用，那么init()就会被先执行，然后由他去告诉那个被调用的人，执行被调用的。\n\n```\nclass Complex:\n    def __init__(self, realpart, imagpart): #必须要有一个self参数，\n        self.r = realpart\n        self.i = imagpart\nx = Complex(3.0, -4.5)\nprint(x.r, x.i)   # 输出结果：3.0 -4.5\n```\n\n在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法**必须**包含参数`self`, 且为第一个参数，`self`代表的是类的实例。\n\nself：类的方法与普通的函数只有一个特别的区别——必须有一个额外的第一个参数名称, 按照惯例它的名称是self。\n类的实例：是将类应用在实例场景之中，比如有个类里的函数是f，假如这个f具有print某一时刻的天气状况的能力，那么如果我需要这个f来print一下今天12点的天气，那么让他打印今天12点的天气这个动作，就是类的实例化，让类中的函数具有的能力变成真实的动作。\n\n```\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    #定义构造方法\n    def __init__(self,n,a):\n        self.name = n\n        self.age = a\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n\n# 实例化类\np = people('Python',10,30)\np.speak()\n```\n\n#### 继承\n\n假如有两个家族，有一个家族A开始没落了，另一个新兴的家族B想继承A家族的物资和佣人，那么就可以通过如下的方式实现继承，在这里，家族A即是父类，家族B是子类。在用法上，如果B家族可以任意使用A家族的物品和佣人。\n\n```\nclass [子类]([父类]):\n```\n\npython还支持**多继承**，即可以继承多个父类。继承方式和单继承方式一样，方式如下：\n\n```\nclass [子类]([父类]1, [父类]2, [父类]3):\n```\n\n```\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n#单继承示例\nclass student(people):\n    grade = ''\n    def __init__(self,n,a,w,g):\n        #调用父类的构函\n        people.__init__(self,n,a,w)\n        self.grade = g\n    #覆写父类的方法\n    def speak(self):\n        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))\n \n#另一个类，多继承之前的准备\nclass speaker():\n    topic = ''\n    name = ''\n    def __init__(self,n,t):\n        self.name = n\n        self.topic = t\n    def speak(self):\n        print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic))\n \n#多继承\nclass sample(speaker,student):\n    a =''\n    def __init__(self,n,a,w,g,t):\n        student.__init__(self,n,a,w,g)\n        speaker.__init__(self,n,t)\n \ntest = sample(\"Tim\",25,80,4,\"Python\")\ntest.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法\n```\n\n在类里面，还可以动态的添加参数\n\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\ns = Student('Bob')\ns.score = 90\n```\n\n但是这种动态的添加参数并不能改变类的格式，只能储存在类的该实例当中，这个数据只为这个实例而存在，并不会改变类的结构\n\n还可以给这个实例绑定一个方法\n\n```\n>>> def set_age(self, age): # 定义一个函数作为实例方法\n...     self.age = age\n...\n>>> from types import MethodType\n>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法\n>>> s.set_age(25) # 调用实例方法\n>>> s.age # 测试结果\n25\n```\n\n#### 限制实例的属性\n\n为了达到限制的目的，Python允许在定义`class`的时候，定义一个特殊的`__slots__`变量，来限制该`class`实例能添加的属性：\n\n```\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n\n#### 数据限制\n\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问\n\n```\nclass Student(object):\n    def __init__(self, name, score):\n        self.__name = name\n        self.__score = score\n\n    def print_score(self):\n        print('%s: %s' % (self.__name, self.__score))\n```\n\n改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问`实例变量.__name`和`实例变量.__score`了，这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。\n\n如果外部想要获取内部变量，可以定义两个实例，用于将内部变量引出，从而达到访问的目的\n\n```\nclass Student(object):\n    ...\n\n    def get_name(self):\n        return self.__name\n\n    def get_score(self):\n        return self.__score\n```\n\n#### type()判断对象类型\n\n基本类型都可以用`type()`判断：\n\n```\n>>> type(123)\n<class 'int'>\n>>> type('str')\n<class 'str'>\n>>> type(None)\n<type(None) 'NoneType'>\n```\n\n如果一个变量指向函数或者类，也可以用`type()`判断：\n\n```plain\n>>> type(abs)\n<class 'builtin_function_or_method'>\n>>> type(a)\n<class '__main__.Animal'>\n```\n","slug":"Work No.22","published":1,"updated":"2024-08-13T03:54:47.408Z","_id":"clzqyyajo0009b0fb1nj61y2l","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Python-切片、迭代、类和实例\"><a href=\"#Python-切片、迭代、类和实例\" class=\"headerlink\" title=\"Python-切片、迭代、类和实例\"></a>Python-切片、迭代、类和实例</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://liaoxuefeng.com/books/python/basic/data-types/index.html\">数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><p>假设一个列表或者元组有如下的元素</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">qiepian = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>]    </span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">qiepian</span><br>[1, 2, 3, 4, 5, 6, 7, 8, 9]<br></code></pre></td></tr></table></figure>\n\n<p>现在我想访问第五个元素</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">qiepian[<span class=\"hljs-number\">4</span>]</span><br>5<br></code></pre></td></tr></table></figure>\n\n<p>我想访问第五个到第七个元素</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;&gt;&gt; <span class=\"hljs-comment\">[qiepian<span class=\"hljs-comment\">[5]</span>,qiepian<span class=\"hljs-comment\">[6]</span>,qiepian<span class=\"hljs-comment\">[7]</span>]</span><br><span class=\"hljs-comment\">[6, 7, 8]</span><br></code></pre></td></tr></table></figure>\n\n<p>有点过于繁琐，所以python有一个切片的方式去访问所需的元素，比如我想访问第五个到第七个元素</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&gt;&gt;&gt; qiepian<span class=\"hljs-selector-attr\">[5:8]</span> <br><span class=\"hljs-selector-attr\">[6, 7, 8]</span><br></code></pre></td></tr></table></figure>\n\n<p>从索引<code>5</code>开始取，直到索引<code>8</code>为止，但不包括索引<code>8</code>。即索引<code>5</code>，<code>6</code>，<code>7</code>，正好是3个元素。</p>\n<p>切片操作十分有用。我们先创建一个0-99的数列：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L = list(range(100))<br>&gt;&gt;&gt; L<br>[0, 1, 2, 3, ..., 99]<br></code></pre></td></tr></table></figure>\n\n<p>可以通过切片轻松取出某一段数列。比如前10个数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[:10]<br>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br></code></pre></td></tr></table></figure>\n\n<p>后10个数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[-10:]<br>[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]<br></code></pre></td></tr></table></figure>\n\n<p>前11-20个数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[10:20]<br>[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]<br></code></pre></td></tr></table></figure>\n\n<p>前10个数，每两个取一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[:10:2]<br>[0, 2, 4, 6, 8]<br></code></pre></td></tr></table></figure>\n\n<p>所有数，每5个取一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[::5]<br>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]<br></code></pre></td></tr></table></figure>\n\n<p>甚至什么都不写，只写<code>[:]</code>就可以原样复制一个list：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[:]<br>[0, 1, 2, 3, ..., 99]<br></code></pre></td></tr></table></figure>\n\n<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]<br>(0, 1, 2)<br></code></pre></td></tr></table></figure>\n\n<p>字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; <span class=\"hljs-string\">&#x27;ABCDEFG&#x27;</span>[:3]<br><span class=\"hljs-string\">&#x27;ABC&#x27;</span><br>&gt;&gt;&gt; <span class=\"hljs-string\">&#x27;ABCDEFG&#x27;</span>[::2]<br><span class=\"hljs-string\">&#x27;ACEG&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>如果给定一个<code>list</code>或<code>tuple</code>，我们可以通过<code>for</code>循环来遍历这个<code>list</code>或<code>tuple</code>，这种遍历我们称为迭代（Iteration）。</p>\n<p>在Python中，迭代是通过<code>for ... in</code>来完成的</p>\n<p>列表和元组的迭代比较简单，直接定义一个值，然后把列表和元组塞到for循环里面打印遍历就行</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">list</span> <span class=\"hljs-keyword\">in</span> classmates:</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">list</span>)</span><br><span class=\"hljs-meta prompt_\">...</span><br>kangkang<br>jack<br>xiaoming<br>zhengzheng<br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">classmates</span><br>[&#x27;kangkang&#x27;, &#x27;jack&#x27;, &#x27;xiaoming&#x27;, &#x27;zhengzheng&#x27;]<br></code></pre></td></tr></table></figure>\n\n<p>但是dist字典的存储不想列表和元组那样有顺序，他是键和值一起结合在一起的，所以直接使用迭代的话只能迭代出键的值， 如果想要迭代出值，需要如下操作：</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> key <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">dict</span>:</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(key)</span><br><span class=\"hljs-meta prompt_\">...</span><br>lihua<br>kangkang<br>liuyang<br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-built_in\">dict</span></span><br>&#123;&#x27;lihua&#x27;: 94, &#x27;kangkang&#x27;: 55, &#x27;liuyang&#x27;: 94&#125;<br><br><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">dict</span>.values(): </span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(value) </span><br><span class=\"hljs-meta prompt_\">...</span><br>94<br>55<br>94<br><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">dict</span>, value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">dict</span>.items(): </span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">dict</span>,value) </span><br><span class=\"hljs-meta prompt_\">...</span><br>lihua 94<br>kangkang 55<br>liuyang 94<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>\n<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>\n<p>python的class（类）相当于一个多个函数组成的家族，如果在这个Myclass大家族里有一个人叫f，假如这个f具有print天气的作用，那么如果有一天我需要这个f来print一下今天的天气，那么我必须叫他的全名MyClass.f才可以让他给我print，即在调用他的时候需要带上他的家族名称+他的名称。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#Myclass家族，但是这个家族只有一个人f</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span>:   <br>  <span class=\"hljs-string\">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span>    <br>  i = <span class=\"hljs-number\">12345</span>    <br>  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">self</span>):        <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br><span class=\"hljs-comment\"># 实例化类</span><br>x = MyClass() <br><span class=\"hljs-comment\"># 访问类的属性和方法</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i) <span class=\"hljs-comment\">#家族x + 物品名i</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f()) <span class=\"hljs-comment\">#家族x + 人名f</span><br></code></pre></td></tr></table></figure>\n\n<p>假如init()也是人，但是他是家族和外界联络员，当外界的人想调用自己家族的人，就必须要先告诉他，所以只要家族的人被调用，那么init()就会被先执行，然后由他去告诉那个被调用的人，执行被调用的。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Complex</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, realpart, imagpart</span>): <span class=\"hljs-comment\">#必须要有一个self参数，</span><br>        <span class=\"hljs-variable language_\">self</span>.r = realpart<br>        <span class=\"hljs-variable language_\">self</span>.i = imagpart<br>x = <span class=\"hljs-title class_\">Complex</span>(<span class=\"hljs-number\">3.0</span>, -<span class=\"hljs-number\">4.5</span>)<br>print(x.r, x.i)   <span class=\"hljs-comment\"># 输出结果：3.0 -4.5</span><br></code></pre></td></tr></table></figure>\n\n<p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法<strong>必须</strong>包含参数<code>self</code>, 且为第一个参数，<code>self</code>代表的是类的实例。</p>\n<p>self：类的方法与普通的函数只有一个特别的区别——必须有一个额外的第一个参数名称, 按照惯例它的名称是self。<br>类的实例：是将类应用在实例场景之中，比如有个类里的函数是f，假如这个f具有print某一时刻的天气状况的能力，那么如果我需要这个f来print一下今天12点的天气，那么让他打印今天12点的天气这个动作，就是类的实例化，让类中的函数具有的能力变成真实的动作。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#类定义</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">people:</span><br>    <span class=\"hljs-comment\">#定义基本属性</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    age = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    <span class=\"hljs-comment\">#定义构造方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>,n,a</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = n<br>        <span class=\"hljs-variable language_\">self</span>.age = a<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;%s 说: 我 %d 岁。&quot;</span> <span class=\"hljs-string\">%(self.name,self.age)</span>)<br><br><span class=\"hljs-comment\"># 实例化类</span><br>p = people(<span class=\"hljs-string\">&#x27;Python&#x27;</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">30</span>)<br>p.speak()<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>假如有两个家族，有一个家族A开始没落了，另一个新兴的家族B想继承A家族的物资和佣人，那么就可以通过如下的方式实现继承，在这里，家族A即是父类，家族B是子类。在用法上，如果B家族可以任意使用A家族的物品和佣人。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">class <span class=\"hljs-selector-attr\">[子类]</span>(<span class=\"hljs-selector-attr\">[父类]</span>):<br></code></pre></td></tr></table></figure>\n\n<p>python还支持<strong>多继承</strong>，即可以继承多个父类。继承方式和单继承方式一样，方式如下：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">class</span> [子类]([父类]<span class=\"hljs-symbol\">1, </span>[父类]<span class=\"hljs-symbol\">2, </span>[父类]<span class=\"hljs-symbol\">3</span>):<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#类定义</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">people</span>:<br>    <span class=\"hljs-comment\">#定义基本属性</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    age = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">#定义构造方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,a,w</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = n<br>        <span class=\"hljs-variable language_\">self</span>.age = a<br>        <span class=\"hljs-variable language_\">self</span>.__weight = w<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s 说: 我 %d 岁。&quot;</span> %(<span class=\"hljs-variable language_\">self</span>.name,<span class=\"hljs-variable language_\">self</span>.age))<br> <br><span class=\"hljs-comment\">#单继承示例</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">student</span>(<span class=\"hljs-title class_ inherited__\">people</span>):<br>    grade = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,a,w,g</span>):<br>        <span class=\"hljs-comment\">#调用父类的构函</span><br>        people.__init__(<span class=\"hljs-variable language_\">self</span>,n,a,w)<br>        <span class=\"hljs-variable language_\">self</span>.grade = g<br>    <span class=\"hljs-comment\">#覆写父类的方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(<span class=\"hljs-variable language_\">self</span>.name,<span class=\"hljs-variable language_\">self</span>.age,<span class=\"hljs-variable language_\">self</span>.grade))<br> <br><span class=\"hljs-comment\">#另一个类，多继承之前的准备</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">speaker</span>():<br>    topic = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,t</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = n<br>        <span class=\"hljs-variable language_\">self</span>.topic = t<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(<span class=\"hljs-variable language_\">self</span>.name,<span class=\"hljs-variable language_\">self</span>.topic))<br> <br><span class=\"hljs-comment\">#多继承</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">sample</span>(speaker,student):<br>    a =<span class=\"hljs-string\">&#x27;&#x27;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,a,w,g,t</span>):<br>        student.__init__(<span class=\"hljs-variable language_\">self</span>,n,a,w,g)<br>        speaker.__init__(<span class=\"hljs-variable language_\">self</span>,n,t)<br> <br>test = sample(<span class=\"hljs-string\">&quot;Tim&quot;</span>,<span class=\"hljs-number\">25</span>,<span class=\"hljs-number\">80</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">&quot;Python&quot;</span>)<br>test.speak()   <span class=\"hljs-comment\">#方法名同，默认调用的是在括号中参数位置排前父类的方法</span><br></code></pre></td></tr></table></figure>\n\n<p>在类里面，还可以动态的添加参数</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br><br>s = <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-string\">&#x27;Bob&#x27;</span>)<br>s.score = <span class=\"hljs-number\">90</span><br></code></pre></td></tr></table></figure>\n\n<p>但是这种动态的添加参数并不能改变类的格式，只能储存在类的该实例当中，这个数据只为这个实例而存在，并不会改变类的结构</p>\n<p>还可以给这个实例绑定一个方法</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">set_age</span>(<span class=\"hljs-params\">self, age</span>): <span class=\"hljs-comment\"># 定义一个函数作为实例方法</span></span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-variable language_\">self</span>.age = age</span><br><span class=\"hljs-meta prompt_\">...</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">from</span> types <span class=\"hljs-keyword\">import</span> MethodType</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">s.set_age = MethodType(set_age, s) <span class=\"hljs-comment\"># 给实例绑定一个方法</span></span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">s.set_age(<span class=\"hljs-number\">25</span>) <span class=\"hljs-comment\"># 调用实例方法</span></span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">s.age <span class=\"hljs-comment\"># 测试结果</span></span><br>25<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"限制实例的属性\"><a href=\"#限制实例的属性\" class=\"headerlink\" title=\"限制实例的属性\"></a>限制实例的属性</h4><p>为了达到限制的目的，Python允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量，来限制该<code>class</code>实例能添加的属性：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">Student</span>(<span class=\"hljs-symbol\">object</span>):<br>    <span class=\"hljs-symbol\">__slots__</span> = (&#x27;<span class=\"hljs-symbol\">name</span>&#x27;, &#x27;<span class=\"hljs-symbol\">age</span>&#x27;) # 用<span class=\"hljs-symbol\">tuple</span>定义允许绑定的属性名称<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"数据限制\"><a href=\"#数据限制\" class=\"headerlink\" title=\"数据限制\"></a>数据限制</h4><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, score</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__name = name<br>        <span class=\"hljs-variable language_\">self</span>.__score = score<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_score</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&#x27;%s: %s&#x27;</span> % (<span class=\"hljs-variable language_\">self</span>.__name, <span class=\"hljs-variable language_\">self</span>.__score))<br></code></pre></td></tr></table></figure>\n\n<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了，这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>\n<p>如果外部想要获取内部变量，可以定义两个实例，用于将内部变量引出，从而达到访问的目的</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    ...<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_name</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__name<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_score</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__score<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"type-判断对象类型\"><a href=\"#type-判断对象类型\" class=\"headerlink\" title=\"type()判断对象类型\"></a>type()判断对象类型</h4><p>基本类型都可以用<code>type()</code>判断：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haskell\">&gt;&gt;&gt; <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(123)</span><br>&lt;<span class=\"hljs-keyword\">class</span> &#x27;int&#x27;&gt;<br>&gt;&gt;&gt; <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(&#x27;<span class=\"hljs-title\">str&#x27;</span>)</span><br>&lt;<span class=\"hljs-keyword\">class</span> &#x27;str&#x27;&gt;<br>&gt;&gt;&gt; <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(<span class=\"hljs-type\">None</span>)</span><br>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(<span class=\"hljs-type\">None</span>) &#x27;<span class=\"hljs-type\">NoneType&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果一个变量指向函数或者类，也可以用<code>type()</code>判断：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&gt;&gt;&gt; type(abs)<br>&lt;class &#x27;builtin_function_or_method&#x27;&gt;<br>&gt;&gt;&gt; type(a)<br>&lt;class &#x27;__main__.Animal&#x27;&gt;<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Python-切片、迭代、类和实例\"><a href=\"#Python-切片、迭代、类和实例\" class=\"headerlink\" title=\"Python-切片、迭代、类和实例\"></a>Python-切片、迭代、类和实例</h1><h2 id=\"感谢博主：\"><a href=\"#感谢博主：\" class=\"headerlink\" title=\"感谢博主：\"></a>感谢博主：</h2><p><a href=\"https://liaoxuefeng.com/books/python/basic/data-types/index.html\">数据类型和变量 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><p>假设一个列表或者元组有如下的元素</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">qiepian = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>]    </span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">qiepian</span><br>[1, 2, 3, 4, 5, 6, 7, 8, 9]<br></code></pre></td></tr></table></figure>\n\n<p>现在我想访问第五个元素</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">qiepian[<span class=\"hljs-number\">4</span>]</span><br>5<br></code></pre></td></tr></table></figure>\n\n<p>我想访问第五个到第七个元素</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">&gt;&gt;&gt; <span class=\"hljs-comment\">[qiepian<span class=\"hljs-comment\">[5]</span>,qiepian<span class=\"hljs-comment\">[6]</span>,qiepian<span class=\"hljs-comment\">[7]</span>]</span><br><span class=\"hljs-comment\">[6, 7, 8]</span><br></code></pre></td></tr></table></figure>\n\n<p>有点过于繁琐，所以python有一个切片的方式去访问所需的元素，比如我想访问第五个到第七个元素</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&gt;&gt;&gt; qiepian<span class=\"hljs-selector-attr\">[5:8]</span> <br><span class=\"hljs-selector-attr\">[6, 7, 8]</span><br></code></pre></td></tr></table></figure>\n\n<p>从索引<code>5</code>开始取，直到索引<code>8</code>为止，但不包括索引<code>8</code>。即索引<code>5</code>，<code>6</code>，<code>7</code>，正好是3个元素。</p>\n<p>切片操作十分有用。我们先创建一个0-99的数列：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L = list(range(100))<br>&gt;&gt;&gt; L<br>[0, 1, 2, 3, ..., 99]<br></code></pre></td></tr></table></figure>\n\n<p>可以通过切片轻松取出某一段数列。比如前10个数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[:10]<br>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br></code></pre></td></tr></table></figure>\n\n<p>后10个数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[-10:]<br>[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]<br></code></pre></td></tr></table></figure>\n\n<p>前11-20个数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[10:20]<br>[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]<br></code></pre></td></tr></table></figure>\n\n<p>前10个数，每两个取一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[:10:2]<br>[0, 2, 4, 6, 8]<br></code></pre></td></tr></table></figure>\n\n<p>所有数，每5个取一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[::5]<br>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]<br></code></pre></td></tr></table></figure>\n\n<p>甚至什么都不写，只写<code>[:]</code>就可以原样复制一个list：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; L[:]<br>[0, 1, 2, 3, ..., 99]<br></code></pre></td></tr></table></figure>\n\n<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]<br>(0, 1, 2)<br></code></pre></td></tr></table></figure>\n\n<p>字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&gt;&gt;&gt; <span class=\"hljs-string\">&#x27;ABCDEFG&#x27;</span>[:3]<br><span class=\"hljs-string\">&#x27;ABC&#x27;</span><br>&gt;&gt;&gt; <span class=\"hljs-string\">&#x27;ABCDEFG&#x27;</span>[::2]<br><span class=\"hljs-string\">&#x27;ACEG&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>如果给定一个<code>list</code>或<code>tuple</code>，我们可以通过<code>for</code>循环来遍历这个<code>list</code>或<code>tuple</code>，这种遍历我们称为迭代（Iteration）。</p>\n<p>在Python中，迭代是通过<code>for ... in</code>来完成的</p>\n<p>列表和元组的迭代比较简单，直接定义一个值，然后把列表和元组塞到for循环里面打印遍历就行</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">list</span> <span class=\"hljs-keyword\">in</span> classmates:</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">list</span>)</span><br><span class=\"hljs-meta prompt_\">...</span><br>kangkang<br>jack<br>xiaoming<br>zhengzheng<br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">classmates</span><br>[&#x27;kangkang&#x27;, &#x27;jack&#x27;, &#x27;xiaoming&#x27;, &#x27;zhengzheng&#x27;]<br></code></pre></td></tr></table></figure>\n\n<p>但是dist字典的存储不想列表和元组那样有顺序，他是键和值一起结合在一起的，所以直接使用迭代的话只能迭代出键的值， 如果想要迭代出值，需要如下操作：</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> key <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">dict</span>:</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(key)</span><br><span class=\"hljs-meta prompt_\">...</span><br>lihua<br>kangkang<br>liuyang<br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-built_in\">dict</span></span><br>&#123;&#x27;lihua&#x27;: 94, &#x27;kangkang&#x27;: 55, &#x27;liuyang&#x27;: 94&#125;<br><br><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">dict</span>.values(): </span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(value) </span><br><span class=\"hljs-meta prompt_\">...</span><br>94<br>55<br>94<br><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">dict</span>, value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">dict</span>.items(): </span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">dict</span>,value) </span><br><span class=\"hljs-meta prompt_\">...</span><br>lihua 94<br>kangkang 55<br>liuyang 94<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>\n<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>\n<p>python的class（类）相当于一个多个函数组成的家族，如果在这个Myclass大家族里有一个人叫f，假如这个f具有print天气的作用，那么如果有一天我需要这个f来print一下今天的天气，那么我必须叫他的全名MyClass.f才可以让他给我print，即在调用他的时候需要带上他的家族名称+他的名称。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#Myclass家族，但是这个家族只有一个人f</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span>:   <br>  <span class=\"hljs-string\">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span>    <br>  i = <span class=\"hljs-number\">12345</span>    <br>  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">self</span>):        <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br><span class=\"hljs-comment\"># 实例化类</span><br>x = MyClass() <br><span class=\"hljs-comment\"># 访问类的属性和方法</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i) <span class=\"hljs-comment\">#家族x + 物品名i</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f()) <span class=\"hljs-comment\">#家族x + 人名f</span><br></code></pre></td></tr></table></figure>\n\n<p>假如init()也是人，但是他是家族和外界联络员，当外界的人想调用自己家族的人，就必须要先告诉他，所以只要家族的人被调用，那么init()就会被先执行，然后由他去告诉那个被调用的人，执行被调用的。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Complex</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, realpart, imagpart</span>): <span class=\"hljs-comment\">#必须要有一个self参数，</span><br>        <span class=\"hljs-variable language_\">self</span>.r = realpart<br>        <span class=\"hljs-variable language_\">self</span>.i = imagpart<br>x = <span class=\"hljs-title class_\">Complex</span>(<span class=\"hljs-number\">3.0</span>, -<span class=\"hljs-number\">4.5</span>)<br>print(x.r, x.i)   <span class=\"hljs-comment\"># 输出结果：3.0 -4.5</span><br></code></pre></td></tr></table></figure>\n\n<p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法<strong>必须</strong>包含参数<code>self</code>, 且为第一个参数，<code>self</code>代表的是类的实例。</p>\n<p>self：类的方法与普通的函数只有一个特别的区别——必须有一个额外的第一个参数名称, 按照惯例它的名称是self。<br>类的实例：是将类应用在实例场景之中，比如有个类里的函数是f，假如这个f具有print某一时刻的天气状况的能力，那么如果我需要这个f来print一下今天12点的天气，那么让他打印今天12点的天气这个动作，就是类的实例化，让类中的函数具有的能力变成真实的动作。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#类定义</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">people:</span><br>    <span class=\"hljs-comment\">#定义基本属性</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    age = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    <span class=\"hljs-comment\">#定义构造方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>,n,a</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = n<br>        <span class=\"hljs-variable language_\">self</span>.age = a<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;%s 说: 我 %d 岁。&quot;</span> <span class=\"hljs-string\">%(self.name,self.age)</span>)<br><br><span class=\"hljs-comment\"># 实例化类</span><br>p = people(<span class=\"hljs-string\">&#x27;Python&#x27;</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">30</span>)<br>p.speak()<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>假如有两个家族，有一个家族A开始没落了，另一个新兴的家族B想继承A家族的物资和佣人，那么就可以通过如下的方式实现继承，在这里，家族A即是父类，家族B是子类。在用法上，如果B家族可以任意使用A家族的物品和佣人。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">class <span class=\"hljs-selector-attr\">[子类]</span>(<span class=\"hljs-selector-attr\">[父类]</span>):<br></code></pre></td></tr></table></figure>\n\n<p>python还支持<strong>多继承</strong>，即可以继承多个父类。继承方式和单继承方式一样，方式如下：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">class</span> [子类]([父类]<span class=\"hljs-symbol\">1, </span>[父类]<span class=\"hljs-symbol\">2, </span>[父类]<span class=\"hljs-symbol\">3</span>):<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#类定义</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">people</span>:<br>    <span class=\"hljs-comment\">#定义基本属性</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    age = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-comment\">#定义构造方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,a,w</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = n<br>        <span class=\"hljs-variable language_\">self</span>.age = a<br>        <span class=\"hljs-variable language_\">self</span>.__weight = w<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s 说: 我 %d 岁。&quot;</span> %(<span class=\"hljs-variable language_\">self</span>.name,<span class=\"hljs-variable language_\">self</span>.age))<br> <br><span class=\"hljs-comment\">#单继承示例</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">student</span>(<span class=\"hljs-title class_ inherited__\">people</span>):<br>    grade = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,a,w,g</span>):<br>        <span class=\"hljs-comment\">#调用父类的构函</span><br>        people.__init__(<span class=\"hljs-variable language_\">self</span>,n,a,w)<br>        <span class=\"hljs-variable language_\">self</span>.grade = g<br>    <span class=\"hljs-comment\">#覆写父类的方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(<span class=\"hljs-variable language_\">self</span>.name,<span class=\"hljs-variable language_\">self</span>.age,<span class=\"hljs-variable language_\">self</span>.grade))<br> <br><span class=\"hljs-comment\">#另一个类，多继承之前的准备</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">speaker</span>():<br>    topic = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    name = <span class=\"hljs-string\">&#x27;&#x27;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,t</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = n<br>        <span class=\"hljs-variable language_\">self</span>.topic = t<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">speak</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(<span class=\"hljs-variable language_\">self</span>.name,<span class=\"hljs-variable language_\">self</span>.topic))<br> <br><span class=\"hljs-comment\">#多继承</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">sample</span>(speaker,student):<br>    a =<span class=\"hljs-string\">&#x27;&#x27;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self,n,a,w,g,t</span>):<br>        student.__init__(<span class=\"hljs-variable language_\">self</span>,n,a,w,g)<br>        speaker.__init__(<span class=\"hljs-variable language_\">self</span>,n,t)<br> <br>test = sample(<span class=\"hljs-string\">&quot;Tim&quot;</span>,<span class=\"hljs-number\">25</span>,<span class=\"hljs-number\">80</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">&quot;Python&quot;</span>)<br>test.speak()   <span class=\"hljs-comment\">#方法名同，默认调用的是在括号中参数位置排前父类的方法</span><br></code></pre></td></tr></table></figure>\n\n<p>在类里面，还可以动态的添加参数</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br><br>s = <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-string\">&#x27;Bob&#x27;</span>)<br>s.score = <span class=\"hljs-number\">90</span><br></code></pre></td></tr></table></figure>\n\n<p>但是这种动态的添加参数并不能改变类的格式，只能储存在类的该实例当中，这个数据只为这个实例而存在，并不会改变类的结构</p>\n<p>还可以给这个实例绑定一个方法</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">set_age</span>(<span class=\"hljs-params\">self, age</span>): <span class=\"hljs-comment\"># 定义一个函数作为实例方法</span></span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-variable language_\">self</span>.age = age</span><br><span class=\"hljs-meta prompt_\">...</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">from</span> types <span class=\"hljs-keyword\">import</span> MethodType</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">s.set_age = MethodType(set_age, s) <span class=\"hljs-comment\"># 给实例绑定一个方法</span></span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">s.set_age(<span class=\"hljs-number\">25</span>) <span class=\"hljs-comment\"># 调用实例方法</span></span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\">s.age <span class=\"hljs-comment\"># 测试结果</span></span><br>25<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"限制实例的属性\"><a href=\"#限制实例的属性\" class=\"headerlink\" title=\"限制实例的属性\"></a>限制实例的属性</h4><p>为了达到限制的目的，Python允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量，来限制该<code>class</code>实例能添加的属性：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">Student</span>(<span class=\"hljs-symbol\">object</span>):<br>    <span class=\"hljs-symbol\">__slots__</span> = (&#x27;<span class=\"hljs-symbol\">name</span>&#x27;, &#x27;<span class=\"hljs-symbol\">age</span>&#x27;) # 用<span class=\"hljs-symbol\">tuple</span>定义允许绑定的属性名称<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"数据限制\"><a href=\"#数据限制\" class=\"headerlink\" title=\"数据限制\"></a>数据限制</h4><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, score</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__name = name<br>        <span class=\"hljs-variable language_\">self</span>.__score = score<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_score</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&#x27;%s: %s&#x27;</span> % (<span class=\"hljs-variable language_\">self</span>.__name, <span class=\"hljs-variable language_\">self</span>.__score))<br></code></pre></td></tr></table></figure>\n\n<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了，这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>\n<p>如果外部想要获取内部变量，可以定义两个实例，用于将内部变量引出，从而达到访问的目的</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    ...<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_name</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__name<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_score</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__score<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"type-判断对象类型\"><a href=\"#type-判断对象类型\" class=\"headerlink\" title=\"type()判断对象类型\"></a>type()判断对象类型</h4><p>基本类型都可以用<code>type()</code>判断：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haskell\">&gt;&gt;&gt; <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(123)</span><br>&lt;<span class=\"hljs-keyword\">class</span> &#x27;int&#x27;&gt;<br>&gt;&gt;&gt; <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(&#x27;<span class=\"hljs-title\">str&#x27;</span>)</span><br>&lt;<span class=\"hljs-keyword\">class</span> &#x27;str&#x27;&gt;<br>&gt;&gt;&gt; <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(<span class=\"hljs-type\">None</span>)</span><br>&lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>(<span class=\"hljs-type\">None</span>) &#x27;<span class=\"hljs-type\">NoneType&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果一个变量指向函数或者类，也可以用<code>type()</code>判断：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&gt;&gt;&gt; type(abs)<br>&lt;class &#x27;builtin_function_or_method&#x27;&gt;<br>&gt;&gt;&gt; type(a)<br>&lt;class &#x27;__main__.Animal&#x27;&gt;<br></code></pre></td></tr></table></figure>\n"},{"title":"Python-类和实例补充","date":"2024-08-12T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/CqTcyiJGYHR8k3L.jpg","_content":"\n# Python-类和实例补充\n\n## 类和实例的补充\n\n其实在学习类的过程中还是非常的懵逼，主要感觉讲的并不是很好，所以特地再重新学习补充一下\n\n类其实就是一大类，就比如学生这就是一个类，而中学生，大学生，却是这个类里面的一个子类，但是他们也具备学生的特性，只不过因为阶段不同，所以存在差异性，因此我们可以将假设的类定义一下\n\n```\nclass Student(Object):\n```\n\n其中，这个Object类似什么呢，学生是不是人类，那肯定是人类，所以学生这个类其实也包含在一个大类里面，这个大类就是Object，也就是程序中最高的大类\n\n那这个类定义好之后，我们要开始对他进行初始化，初始化是什么呢，初始化其实就是初始化学生的一些基本信息，比如姓名、年龄、性别，这些是在输入到这个数据结构中，必须要提前标识好的，如果没有标识好，就会出现信息不足，导致没办法区别这个人，因此我们就可以进行函数初始化\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex \n```\n\n这样的话，这个调用这个类，他就必须要有这三个参数，否则就会出现报错，那self是什么呢，我觉得他是代表这个类的数据结构，如果你将数据前面加一个self的定义，那么这个数据就存到了这个类里面，他就可以在这个类里面随便使用了\n\n之后呢，我们想要对中学生、大学生进行区分开，分别填入他们相应的数据，比如中学生要面对高考痛苦，大学生要面对就业痛苦，因此我们就可以根据他们面对不同的问题进行在这个类里面进行区分\n\n我们再来分析一下中学生，他们的高考痛苦来源于语数英...我们这边列举两门作为示例，比如他们的数学和英语，他们看重成绩，那是不是在评价这个学生的时候，要看看这个学生的成绩，所以这两门的成绩成为了他们的必选参数，但是大学生不需要这个参数啊，那我们就在中学生的这个实例里面定义一个传参的初始化，其实也就是把中学生的数据塞到self数据中，虽然大学生也能用，但是并不是必选参数\n\n```\n    def Middle_Exam_pain(self, English, Math):\n        self.English = English\n        self.Math = Math\n        if self.English >=90 and self.Math >= 90:\n            print(\"%s英语考%d、数学考%d，一点也不痛苦\" % (self.name, self.English, self.Math))\n        elif self.English >=80 and self.English < 90 and self.Math >= 80 and self.Math < 90:\n            print(\"%s英语考%d、数学考%d，有点痛苦\" % (self.name, self.English, self.Math))\n        else:\n            print(\"%s英语考%d、数学考%d，超级痛苦\" % (self.name, self.English, self.Math))\n```\n\n我们就可以将英语和数学的成绩单独赋值出来，只对中学生进行调用，这样中学生就可以自己进行判断了\n\n那大学生的痛苦来自哪里呢，大学生的痛苦有来自考研考上和没考上，找工作找没找到，以及他们的月薪是多少，那我们就可以类似的，再创建大学生的实例来表达\n\n```\n    def College_pain(self, Graduate=None, School=None, Employment=None, wage=None):\n        self.Graduate = Graduate\n        self.School = School\n        self.Employment = Employment\n        self.wage = wage\n        if self.Graduate is not None and self.School is not None:\n            if self.Graduate > 400:\n                print(\"%s考研考了%d分，考上了%s，一点也不痛苦\" % (self.name, self.Graduate, self.School))\n            else:\n                print(\"%s考研考了%d分，考上了%s，有点痛苦\" % (self.name, self.Graduate, self.School))\n        elif self.Graduate is not None and self.School == None:\n            print(\"%s考研考了%d分，没考上学习，非常痛苦\" % (self.name, self.Graduate))\n        elif self.Employment is not None and self.Graduate == None and self.School == None:\n            if self.wage >10000:\n                print(\"%s找到了工作，在%s上班，工资是%s，一点也不痛苦\" % (self.name, self.Employment, self.wage))\n            else:\n                print(\"%s找到了工作，在%s上班，工资是%s，有点痛苦\" % (self.name, self.Employment, self.wage))\n        elif self.Employment == None and self.wage == None and self.Graduate == None and self.School == None:\n            print(\"%s没找到工作，非常痛苦\" % self.name)\n```\n\n首先对要传入的数据进行初始化，这样我们就可以对其传参了，然后先判断是考研还是找工作，再去判断相对应考研或者找工作的类别，其实这两个凑一起是比较混乱的，可以考虑新建一个实例，如果是考研就调用考研的，如果是找工作的就调用找工作的\n\n完成类的初始化和实例设定后，我们可以来验证我们的代码是什么样子的，有没有bug之类的，首先，需要将实例复制给一个叫lihua的学生，当然别忘记我们的init里面要强制输入的参数\n\n```\nlihua = Student(\"lihua\", 18, \"boy\")\n```\n\n然后我们就可以在传入lihua的中学生参数，比如，他英语考了90分，数学考了99分，将数据传入这个函数\n\n```\nlihua.Middle_Exam_pain(90,99)\nlihua.Middle_Exam_pain(89,87)\nlihua.Middle_Exam_pain(77,66)\n\n#output\nlihua英语考90、数学考99，一点也不痛苦\nlihua英语考89、数学考87，有点痛苦\nlihua英语考77、数学考66，超级痛苦\n```\n\n验证大学生，假设一个大学生kangkang，先初始化固定参数\n\n```\nkangkang = Student(\"kangkang\", 22, \"boy\")\n```\n\n之后我们可以传入他的一些内容，比如他是考研的，或者是找工作的\n\n```\nkangkang = Student(\"kangkang\", 22, \"boy\")\nkangkang.College_pain(410,'北京大学')\nkangkang.College_pain(250,'野鸡大学')\nkangkang.College_pain(200)\nkangkang.College_pain(None,None,\"华为\", 20000)\nkangkang.College_pain(None,None,\"美团外卖\", 4000)\nkangkang.College_pain(None,None,None, None)\n\n#output\nkangkang考研考了410分，考上了北京大学，一点也不痛苦\nkangkang考研考了250分，考上了野鸡大学，有点痛苦\nkangkang考研考了200分，没考上学习，非常痛苦\nkangkang找到了工作，在华为上班，工资是20000，一点也不痛苦\nkangkang找到了工作，在美团外卖上班，工资是4000，有点痛苦\nkangkang没找到工作，非常痛苦\n```\n\n## 整个程序完整代码\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n    def Middle_Exam_pain(self, English, Math):\n        self.English = English\n        self.Math = Math\n        if self.English >=90 and self.Math >= 90:\n            print(\"%s英语考%d、数学考%d，一点也不痛苦\" % (self.name, self.English, self.Math))\n        elif self.English >=80 and self.English < 90 and self.Math >= 80 and self.Math < 90:\n            print(\"%s英语考%d、数学考%d，有点痛苦\" % (self.name, self.English, self.Math))\n        else:\n            print(\"%s英语考%d、数学考%d，超级痛苦\" % (self.name, self.English, self.Math))\n\n    def College_pain(self, Graduate=None, School=None, Employment=None, wage=None):\n        self.Graduate = Graduate\n        self.School = School\n        self.Employment = Employment\n        self.wage = wage\n        if self.Graduate is not None and self.School is not None:\n            if self.Graduate > 400:\n                print(\"%s考研考了%d分，考上了%s，一点也不痛苦\" % (self.name, self.Graduate, self.School))\n            else:\n                print(\"%s考研考了%d分，考上了%s，有点痛苦\" % (self.name, self.Graduate, self.School))\n        elif self.Graduate is not None and self.School == None:\n            print(\"%s考研考了%d分，没考上学习，非常痛苦\" % (self.name, self.Graduate))\n        elif self.Employment is not None and self.Graduate == None and self.School == None:\n            if self.wage >10000:\n                print(\"%s找到了工作，在%s上班，工资是%s，一点也不痛苦\" % (self.name, self.Employment, self.wage))\n            else:\n                print(\"%s找到了工作，在%s上班，工资是%s，有点痛苦\" % (self.name, self.Employment, self.wage))\n        elif self.Employment == None and self.wage == None and self.Graduate == None and self.School == None:\n            print(\"%s没找到工作，非常痛苦\" % self.name)\n\n#output\nlihua = Student(\"lihua\", 16, \"boy\")\nlihua.Middle_Exam_pain(90,99)\nlihua.Middle_Exam_pain(89,87)\nlihua.Middle_Exam_pain(77,66)\nkangkang = Student(\"kangkang\", 22, \"boy\")\nkangkang.College_pain(410,'北京大学')\nkangkang.College_pain(250,'野鸡大学')\nkangkang.College_pain(200)\nkangkang.College_pain(None,None,\"华为\", 20000)\nkangkang.College_pain(None,None,\"美团外卖\", 4000)\nkangkang.College_pain(None,None,None, None)\n```\n\n## 继承\n\n继承的话，其实简单来说就是可以用父类里面的实例和参数，当然如果想用参数，需要在init里面去继承父类的init才可以传入参数，如果实例没有参数的话，可以直接引用\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n\tdef father(self):\n        print(\"继承了父类\")\n        \nclass Primary(Student):\n    def __init__(self):\n        pass\n        \njack = Primary()\njack.father()\n\n#output\n继承了父类\n```\n\n当然如果里面有参数，那就要在init里面进行引用\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n    def Middle_Exam_pain(self, English, Math):\n        self.English = English\n        self.Math = Math\n        if self.English >=90 and self.Math >= 90:\n            print(\"%s英语考%d、数学考%d，一点也不痛苦\" % (self.name, self.English, self.Math))\n        elif self.English >=80 and self.English < 90 and self.Math >= 80 and self.Math < 90:\n            print(\"%s英语考%d、数学考%d，有点痛苦\" % (self.name, self.English, self.Math))\n        else:\n            print(\"%s英语考%d、数学考%d，超级痛苦\" % (self.name, self.English, self.Math))\n\nclass Primary(Student):\n    def __init__(self, name, age, sex):\n        super().__init__(name, age, sex)\n\njack = Primary(\"jack\",18,\"boy\")\njack.Middle_Exam_pain(90,100)\n\n#output\njack英语考90、数学考100，一点也不痛苦\n```\n\n如果是多重继承的话，其实有个比较简单的套娃方式\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex \n    def father(self):\n        print(\"继承了Student\")\n        \nclass Teacher(Student):\n    def __init__(self, name, age, sex):\n        super().__init__(name, age, sex)\n    def talk(self):\n        print(\"继承了Teacher\")\n        \nclass Primary(Teacher):\n    def __init__(self, name, age, sex):\n        super().__init__(name, age, sex)\n```\n\n然后，我们就可以顺利的使用Student和Teacher的所有内容了\n\n```\njack = Primary(\"jack\",18,\"boy\")\njack.father()\njack.talk()\njack.Middle_Exam_pain(90,100)\n\n#output\n继承了Student\n继承了Teacher\njack英语考90、数学考100，一点也不痛苦\n```\n\n","source":"_posts/Work No.23.md","raw":"---\ntitle: Python-类和实例补充\ntag: Python\ndate: 2024-08-13\ncategories: Python\nindex_img: https://s2.loli.net/2024/08/02/CqTcyiJGYHR8k3L.jpg\n---\n\n# Python-类和实例补充\n\n## 类和实例的补充\n\n其实在学习类的过程中还是非常的懵逼，主要感觉讲的并不是很好，所以特地再重新学习补充一下\n\n类其实就是一大类，就比如学生这就是一个类，而中学生，大学生，却是这个类里面的一个子类，但是他们也具备学生的特性，只不过因为阶段不同，所以存在差异性，因此我们可以将假设的类定义一下\n\n```\nclass Student(Object):\n```\n\n其中，这个Object类似什么呢，学生是不是人类，那肯定是人类，所以学生这个类其实也包含在一个大类里面，这个大类就是Object，也就是程序中最高的大类\n\n那这个类定义好之后，我们要开始对他进行初始化，初始化是什么呢，初始化其实就是初始化学生的一些基本信息，比如姓名、年龄、性别，这些是在输入到这个数据结构中，必须要提前标识好的，如果没有标识好，就会出现信息不足，导致没办法区别这个人，因此我们就可以进行函数初始化\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex \n```\n\n这样的话，这个调用这个类，他就必须要有这三个参数，否则就会出现报错，那self是什么呢，我觉得他是代表这个类的数据结构，如果你将数据前面加一个self的定义，那么这个数据就存到了这个类里面，他就可以在这个类里面随便使用了\n\n之后呢，我们想要对中学生、大学生进行区分开，分别填入他们相应的数据，比如中学生要面对高考痛苦，大学生要面对就业痛苦，因此我们就可以根据他们面对不同的问题进行在这个类里面进行区分\n\n我们再来分析一下中学生，他们的高考痛苦来源于语数英...我们这边列举两门作为示例，比如他们的数学和英语，他们看重成绩，那是不是在评价这个学生的时候，要看看这个学生的成绩，所以这两门的成绩成为了他们的必选参数，但是大学生不需要这个参数啊，那我们就在中学生的这个实例里面定义一个传参的初始化，其实也就是把中学生的数据塞到self数据中，虽然大学生也能用，但是并不是必选参数\n\n```\n    def Middle_Exam_pain(self, English, Math):\n        self.English = English\n        self.Math = Math\n        if self.English >=90 and self.Math >= 90:\n            print(\"%s英语考%d、数学考%d，一点也不痛苦\" % (self.name, self.English, self.Math))\n        elif self.English >=80 and self.English < 90 and self.Math >= 80 and self.Math < 90:\n            print(\"%s英语考%d、数学考%d，有点痛苦\" % (self.name, self.English, self.Math))\n        else:\n            print(\"%s英语考%d、数学考%d，超级痛苦\" % (self.name, self.English, self.Math))\n```\n\n我们就可以将英语和数学的成绩单独赋值出来，只对中学生进行调用，这样中学生就可以自己进行判断了\n\n那大学生的痛苦来自哪里呢，大学生的痛苦有来自考研考上和没考上，找工作找没找到，以及他们的月薪是多少，那我们就可以类似的，再创建大学生的实例来表达\n\n```\n    def College_pain(self, Graduate=None, School=None, Employment=None, wage=None):\n        self.Graduate = Graduate\n        self.School = School\n        self.Employment = Employment\n        self.wage = wage\n        if self.Graduate is not None and self.School is not None:\n            if self.Graduate > 400:\n                print(\"%s考研考了%d分，考上了%s，一点也不痛苦\" % (self.name, self.Graduate, self.School))\n            else:\n                print(\"%s考研考了%d分，考上了%s，有点痛苦\" % (self.name, self.Graduate, self.School))\n        elif self.Graduate is not None and self.School == None:\n            print(\"%s考研考了%d分，没考上学习，非常痛苦\" % (self.name, self.Graduate))\n        elif self.Employment is not None and self.Graduate == None and self.School == None:\n            if self.wage >10000:\n                print(\"%s找到了工作，在%s上班，工资是%s，一点也不痛苦\" % (self.name, self.Employment, self.wage))\n            else:\n                print(\"%s找到了工作，在%s上班，工资是%s，有点痛苦\" % (self.name, self.Employment, self.wage))\n        elif self.Employment == None and self.wage == None and self.Graduate == None and self.School == None:\n            print(\"%s没找到工作，非常痛苦\" % self.name)\n```\n\n首先对要传入的数据进行初始化，这样我们就可以对其传参了，然后先判断是考研还是找工作，再去判断相对应考研或者找工作的类别，其实这两个凑一起是比较混乱的，可以考虑新建一个实例，如果是考研就调用考研的，如果是找工作的就调用找工作的\n\n完成类的初始化和实例设定后，我们可以来验证我们的代码是什么样子的，有没有bug之类的，首先，需要将实例复制给一个叫lihua的学生，当然别忘记我们的init里面要强制输入的参数\n\n```\nlihua = Student(\"lihua\", 18, \"boy\")\n```\n\n然后我们就可以在传入lihua的中学生参数，比如，他英语考了90分，数学考了99分，将数据传入这个函数\n\n```\nlihua.Middle_Exam_pain(90,99)\nlihua.Middle_Exam_pain(89,87)\nlihua.Middle_Exam_pain(77,66)\n\n#output\nlihua英语考90、数学考99，一点也不痛苦\nlihua英语考89、数学考87，有点痛苦\nlihua英语考77、数学考66，超级痛苦\n```\n\n验证大学生，假设一个大学生kangkang，先初始化固定参数\n\n```\nkangkang = Student(\"kangkang\", 22, \"boy\")\n```\n\n之后我们可以传入他的一些内容，比如他是考研的，或者是找工作的\n\n```\nkangkang = Student(\"kangkang\", 22, \"boy\")\nkangkang.College_pain(410,'北京大学')\nkangkang.College_pain(250,'野鸡大学')\nkangkang.College_pain(200)\nkangkang.College_pain(None,None,\"华为\", 20000)\nkangkang.College_pain(None,None,\"美团外卖\", 4000)\nkangkang.College_pain(None,None,None, None)\n\n#output\nkangkang考研考了410分，考上了北京大学，一点也不痛苦\nkangkang考研考了250分，考上了野鸡大学，有点痛苦\nkangkang考研考了200分，没考上学习，非常痛苦\nkangkang找到了工作，在华为上班，工资是20000，一点也不痛苦\nkangkang找到了工作，在美团外卖上班，工资是4000，有点痛苦\nkangkang没找到工作，非常痛苦\n```\n\n## 整个程序完整代码\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n    def Middle_Exam_pain(self, English, Math):\n        self.English = English\n        self.Math = Math\n        if self.English >=90 and self.Math >= 90:\n            print(\"%s英语考%d、数学考%d，一点也不痛苦\" % (self.name, self.English, self.Math))\n        elif self.English >=80 and self.English < 90 and self.Math >= 80 and self.Math < 90:\n            print(\"%s英语考%d、数学考%d，有点痛苦\" % (self.name, self.English, self.Math))\n        else:\n            print(\"%s英语考%d、数学考%d，超级痛苦\" % (self.name, self.English, self.Math))\n\n    def College_pain(self, Graduate=None, School=None, Employment=None, wage=None):\n        self.Graduate = Graduate\n        self.School = School\n        self.Employment = Employment\n        self.wage = wage\n        if self.Graduate is not None and self.School is not None:\n            if self.Graduate > 400:\n                print(\"%s考研考了%d分，考上了%s，一点也不痛苦\" % (self.name, self.Graduate, self.School))\n            else:\n                print(\"%s考研考了%d分，考上了%s，有点痛苦\" % (self.name, self.Graduate, self.School))\n        elif self.Graduate is not None and self.School == None:\n            print(\"%s考研考了%d分，没考上学习，非常痛苦\" % (self.name, self.Graduate))\n        elif self.Employment is not None and self.Graduate == None and self.School == None:\n            if self.wage >10000:\n                print(\"%s找到了工作，在%s上班，工资是%s，一点也不痛苦\" % (self.name, self.Employment, self.wage))\n            else:\n                print(\"%s找到了工作，在%s上班，工资是%s，有点痛苦\" % (self.name, self.Employment, self.wage))\n        elif self.Employment == None and self.wage == None and self.Graduate == None and self.School == None:\n            print(\"%s没找到工作，非常痛苦\" % self.name)\n\n#output\nlihua = Student(\"lihua\", 16, \"boy\")\nlihua.Middle_Exam_pain(90,99)\nlihua.Middle_Exam_pain(89,87)\nlihua.Middle_Exam_pain(77,66)\nkangkang = Student(\"kangkang\", 22, \"boy\")\nkangkang.College_pain(410,'北京大学')\nkangkang.College_pain(250,'野鸡大学')\nkangkang.College_pain(200)\nkangkang.College_pain(None,None,\"华为\", 20000)\nkangkang.College_pain(None,None,\"美团外卖\", 4000)\nkangkang.College_pain(None,None,None, None)\n```\n\n## 继承\n\n继承的话，其实简单来说就是可以用父类里面的实例和参数，当然如果想用参数，需要在init里面去继承父类的init才可以传入参数，如果实例没有参数的话，可以直接引用\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n\tdef father(self):\n        print(\"继承了父类\")\n        \nclass Primary(Student):\n    def __init__(self):\n        pass\n        \njack = Primary()\njack.father()\n\n#output\n继承了父类\n```\n\n当然如果里面有参数，那就要在init里面进行引用\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n    def Middle_Exam_pain(self, English, Math):\n        self.English = English\n        self.Math = Math\n        if self.English >=90 and self.Math >= 90:\n            print(\"%s英语考%d、数学考%d，一点也不痛苦\" % (self.name, self.English, self.Math))\n        elif self.English >=80 and self.English < 90 and self.Math >= 80 and self.Math < 90:\n            print(\"%s英语考%d、数学考%d，有点痛苦\" % (self.name, self.English, self.Math))\n        else:\n            print(\"%s英语考%d、数学考%d，超级痛苦\" % (self.name, self.English, self.Math))\n\nclass Primary(Student):\n    def __init__(self, name, age, sex):\n        super().__init__(name, age, sex)\n\njack = Primary(\"jack\",18,\"boy\")\njack.Middle_Exam_pain(90,100)\n\n#output\njack英语考90、数学考100，一点也不痛苦\n```\n\n如果是多重继承的话，其实有个比较简单的套娃方式\n\n```\nclass Student(object):\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex \n    def father(self):\n        print(\"继承了Student\")\n        \nclass Teacher(Student):\n    def __init__(self, name, age, sex):\n        super().__init__(name, age, sex)\n    def talk(self):\n        print(\"继承了Teacher\")\n        \nclass Primary(Teacher):\n    def __init__(self, name, age, sex):\n        super().__init__(name, age, sex)\n```\n\n然后，我们就可以顺利的使用Student和Teacher的所有内容了\n\n```\njack = Primary(\"jack\",18,\"boy\")\njack.father()\njack.talk()\njack.Middle_Exam_pain(90,100)\n\n#output\n继承了Student\n继承了Teacher\njack英语考90、数学考100，一点也不痛苦\n```\n\n","slug":"Work No.23","published":1,"updated":"2024-08-13T03:54:13.710Z","_id":"clzrvyz0z0000kofbap828q5f","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Python-类和实例补充\"><a href=\"#Python-类和实例补充\" class=\"headerlink\" title=\"Python-类和实例补充\"></a>Python-类和实例补充</h1><h2 id=\"类和实例的补充\"><a href=\"#类和实例的补充\" class=\"headerlink\" title=\"类和实例的补充\"></a>类和实例的补充</h2><p>其实在学习类的过程中还是非常的懵逼，主要感觉讲的并不是很好，所以特地再重新学习补充一下</p>\n<p>类其实就是一大类，就比如学生这就是一个类，而中学生，大学生，却是这个类里面的一个子类，但是他们也具备学生的特性，只不过因为阶段不同，所以存在差异性，因此我们可以将假设的类定义一下</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">Student</span>(<span class=\"hljs-symbol\">Object</span>):<br></code></pre></td></tr></table></figure>\n\n<p>其中，这个Object类似什么呢，学生是不是人类，那肯定是人类，所以学生这个类其实也包含在一个大类里面，这个大类就是Object，也就是程序中最高的大类</p>\n<p>那这个类定义好之后，我们要开始对他进行初始化，初始化是什么呢，初始化其实就是初始化学生的一些基本信息，比如姓名、年龄、性别，这些是在输入到这个数据结构中，必须要提前标识好的，如果没有标识好，就会出现信息不足，导致没办法区别这个人，因此我们就可以进行函数初始化</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex <br></code></pre></td></tr></table></figure>\n\n<p>这样的话，这个调用这个类，他就必须要有这三个参数，否则就会出现报错，那self是什么呢，我觉得他是代表这个类的数据结构，如果你将数据前面加一个self的定义，那么这个数据就存到了这个类里面，他就可以在这个类里面随便使用了</p>\n<p>之后呢，我们想要对中学生、大学生进行区分开，分别填入他们相应的数据，比如中学生要面对高考痛苦，大学生要面对就业痛苦，因此我们就可以根据他们面对不同的问题进行在这个类里面进行区分</p>\n<p>我们再来分析一下中学生，他们的高考痛苦来源于语数英…我们这边列举两门作为示例，比如他们的数学和英语，他们看重成绩，那是不是在评价这个学生的时候，要看看这个学生的成绩，所以这两门的成绩成为了他们的必选参数，但是大学生不需要这个参数啊，那我们就在中学生的这个实例里面定义一个传参的初始化，其实也就是把中学生的数据塞到self数据中，虽然大学生也能用，但是并不是必选参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">Middle_Exam_pain</span>(<span class=\"hljs-params\">self, English, Math</span>):<br>    <span class=\"hljs-variable language_\">self</span>.English = English<br>    <span class=\"hljs-variable language_\">self</span>.Math = Math<br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">90</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.English &lt; <span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &lt; <span class=\"hljs-number\">90</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，超级痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br></code></pre></td></tr></table></figure>\n\n<p>我们就可以将英语和数学的成绩单独赋值出来，只对中学生进行调用，这样中学生就可以自己进行判断了</p>\n<p>那大学生的痛苦来自哪里呢，大学生的痛苦有来自考研考上和没考上，找工作找没找到，以及他们的月薪是多少，那我们就可以类似的，再创建大学生的实例来表达</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">College_pain</span>(<span class=\"hljs-params\">self, Graduate=<span class=\"hljs-literal\">None</span>, School=<span class=\"hljs-literal\">None</span>, Employment=<span class=\"hljs-literal\">None</span>, wage=<span class=\"hljs-literal\">None</span></span>):<br>    <span class=\"hljs-variable language_\">self</span>.Graduate = Graduate<br>    <span class=\"hljs-variable language_\">self</span>.School = School<br>    <span class=\"hljs-variable language_\">self</span>.Employment = Employment<br>    <span class=\"hljs-variable language_\">self</span>.wage = wage<br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate &gt; <span class=\"hljs-number\">400</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，没考上学习，非常痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.wage &gt;<span class=\"hljs-number\">10000</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.wage == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s没找到工作，非常痛苦&quot;</span> % <span class=\"hljs-variable language_\">self</span>.name)<br></code></pre></td></tr></table></figure>\n\n<p>首先对要传入的数据进行初始化，这样我们就可以对其传参了，然后先判断是考研还是找工作，再去判断相对应考研或者找工作的类别，其实这两个凑一起是比较混乱的，可以考虑新建一个实例，如果是考研就调用考研的，如果是找工作的就调用找工作的</p>\n<p>完成类的初始化和实例设定后，我们可以来验证我们的代码是什么样子的，有没有bug之类的，首先，需要将实例复制给一个叫lihua的学生，当然别忘记我们的init里面要强制输入的参数</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">lihua</span> = Student(<span class=\"hljs-string\">&quot;lihua&quot;</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>然后我们就可以在传入lihua的中学生参数，比如，他英语考了90分，数学考了99分，将数据传入这个函数</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">lihua</span>.Middle_Exam_pain(<span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">99</span>)<br><span class=\"hljs-attribute\">lihua</span>.Middle_Exam_pain(<span class=\"hljs-number\">89</span>,<span class=\"hljs-number\">87</span>)<br><span class=\"hljs-attribute\">lihua</span>.Middle_Exam_pain(<span class=\"hljs-number\">77</span>,<span class=\"hljs-number\">66</span>)<br><br><span class=\"hljs-comment\">#output</span><br><span class=\"hljs-attribute\">lihua</span>英语考<span class=\"hljs-number\">90</span>、数学考<span class=\"hljs-number\">99</span>，一点也不痛苦<br><span class=\"hljs-attribute\">lihua</span>英语考<span class=\"hljs-number\">89</span>、数学考<span class=\"hljs-number\">87</span>，有点痛苦<br><span class=\"hljs-attribute\">lihua</span>英语考<span class=\"hljs-number\">77</span>、数学考<span class=\"hljs-number\">66</span>，超级痛苦<br></code></pre></td></tr></table></figure>\n\n<p>验证大学生，假设一个大学生kangkang，先初始化固定参数</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">kangkang</span> = Student(<span class=\"hljs-string\">&quot;kangkang&quot;</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>之后我们可以传入他的一些内容，比如他是考研的，或者是找工作的</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">kangkang</span> = Student(<span class=\"hljs-string\">&quot;kangkang&quot;</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(<span class=\"hljs-number\">410</span>,&#x27;北京大学&#x27;)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(<span class=\"hljs-number\">250</span>,&#x27;野鸡大学&#x27;)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(<span class=\"hljs-number\">200</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(None,None,<span class=\"hljs-string\">&quot;华为&quot;</span>, <span class=\"hljs-number\">20000</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(None,None,<span class=\"hljs-string\">&quot;美团外卖&quot;</span>, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(None,None,None, None)<br><br><span class=\"hljs-comment\">#output</span><br><span class=\"hljs-attribute\">kangkang</span>考研考了<span class=\"hljs-number\">410</span>分，考上了北京大学，一点也不痛苦<br><span class=\"hljs-attribute\">kangkang</span>考研考了<span class=\"hljs-number\">250</span>分，考上了野鸡大学，有点痛苦<br><span class=\"hljs-attribute\">kangkang</span>考研考了<span class=\"hljs-number\">200</span>分，没考上学习，非常痛苦<br><span class=\"hljs-attribute\">kangkang</span>找到了工作，在华为上班，工资是<span class=\"hljs-number\">20000</span>，一点也不痛苦<br><span class=\"hljs-attribute\">kangkang</span>找到了工作，在美团外卖上班，工资是<span class=\"hljs-number\">4000</span>，有点痛苦<br><span class=\"hljs-attribute\">kangkang</span>没找到工作，非常痛苦<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"整个程序完整代码\"><a href=\"#整个程序完整代码\" class=\"headerlink\" title=\"整个程序完整代码\"></a>整个程序完整代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">Middle_Exam_pain</span>(<span class=\"hljs-params\">self, English, Math</span>):<br>        <span class=\"hljs-variable language_\">self</span>.English = English<br>        <span class=\"hljs-variable language_\">self</span>.Math = Math<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.English &lt; <span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &lt; <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，超级痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">College_pain</span>(<span class=\"hljs-params\">self, Graduate=<span class=\"hljs-literal\">None</span>, School=<span class=\"hljs-literal\">None</span>, Employment=<span class=\"hljs-literal\">None</span>, wage=<span class=\"hljs-literal\">None</span></span>):<br>        <span class=\"hljs-variable language_\">self</span>.Graduate = Graduate<br>        <span class=\"hljs-variable language_\">self</span>.School = School<br>        <span class=\"hljs-variable language_\">self</span>.Employment = Employment<br>        <span class=\"hljs-variable language_\">self</span>.wage = wage<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate &gt; <span class=\"hljs-number\">400</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>            <span class=\"hljs-keyword\">else</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，没考上学习，非常痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.wage &gt;<span class=\"hljs-number\">10000</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>            <span class=\"hljs-keyword\">else</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.wage == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s没找到工作，非常痛苦&quot;</span> % <span class=\"hljs-variable language_\">self</span>.name)<br><br><span class=\"hljs-comment\">#output</span><br>lihua = Student(<span class=\"hljs-string\">&quot;lihua&quot;</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br>lihua.Middle_Exam_pain(<span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">99</span>)<br>lihua.Middle_Exam_pain(<span class=\"hljs-number\">89</span>,<span class=\"hljs-number\">87</span>)<br>lihua.Middle_Exam_pain(<span class=\"hljs-number\">77</span>,<span class=\"hljs-number\">66</span>)<br>kangkang = Student(<span class=\"hljs-string\">&quot;kangkang&quot;</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br>kangkang.College_pain(<span class=\"hljs-number\">410</span>,<span class=\"hljs-string\">&#x27;北京大学&#x27;</span>)<br>kangkang.College_pain(<span class=\"hljs-number\">250</span>,<span class=\"hljs-string\">&#x27;野鸡大学&#x27;</span>)<br>kangkang.College_pain(<span class=\"hljs-number\">200</span>)<br>kangkang.College_pain(<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>,<span class=\"hljs-string\">&quot;华为&quot;</span>, <span class=\"hljs-number\">20000</span>)<br>kangkang.College_pain(<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>,<span class=\"hljs-string\">&quot;美团外卖&quot;</span>, <span class=\"hljs-number\">4000</span>)<br>kangkang.College_pain(<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>, <span class=\"hljs-literal\">None</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>继承的话，其实简单来说就是可以用父类里面的实例和参数，当然如果想用参数，需要在init里面去继承父类的init才可以传入参数，如果实例没有参数的话，可以直接引用</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex<br>\t<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">father</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;继承了父类&quot;</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Primary</span>(<span class=\"hljs-title class_\">Student</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        pass<br>        <br>jack = <span class=\"hljs-title class_\">Primary</span>()<br>jack.father()<br><br><span class=\"hljs-comment\">#output</span><br>继承了父类<br></code></pre></td></tr></table></figure>\n\n<p>当然如果里面有参数，那就要在init里面进行引用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">Middle_Exam_pain</span>(<span class=\"hljs-params\">self, English, Math</span>):<br>        <span class=\"hljs-variable language_\">self</span>.English = English<br>        <span class=\"hljs-variable language_\">self</span>.Math = Math<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.English &lt; <span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &lt; <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，超级痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Primary</span>(<span class=\"hljs-title class_ inherited__\">Student</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-built_in\">super</span>().__init__(name, age, sex)<br><br>jack = Primary(<span class=\"hljs-string\">&quot;jack&quot;</span>,<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">&quot;boy&quot;</span>)<br>jack.Middle_Exam_pain(<span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">100</span>)<br><br><span class=\"hljs-comment\">#output</span><br>jack英语考<span class=\"hljs-number\">90</span>、数学考<span class=\"hljs-number\">100</span>，一点也不痛苦<br></code></pre></td></tr></table></figure>\n\n<p>如果是多重继承的话，其实有个比较简单的套娃方式</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">father</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;继承了Student&quot;</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Teacher</span>(<span class=\"hljs-title class_\">Student</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">super</span>().__init__(name, age, sex)<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">talk</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;继承了Teacher&quot;</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Primary</span>(<span class=\"hljs-title class_\">Teacher</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">super</span>().__init__(name, age, sex)<br></code></pre></td></tr></table></figure>\n\n<p>然后，我们就可以顺利的使用Student和Teacher的所有内容了</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">jack </span>= Primary(<span class=\"hljs-string\">&quot;jack&quot;</span>,<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">&quot;boy&quot;</span>)<br><span class=\"hljs-keyword\">jack.father()</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">jack.talk()</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">jack.Middle_Exam_pain(90,100)</span><br><span class=\"hljs-keyword\"></span><br><span class=\"hljs-comment\">#output</span><br>继承了Student<br>继承了Teacher<br><span class=\"hljs-keyword\">jack英语考90、数学考100，一点也不痛苦</span><br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"Python-类和实例补充\"><a href=\"#Python-类和实例补充\" class=\"headerlink\" title=\"Python-类和实例补充\"></a>Python-类和实例补充</h1><h2 id=\"类和实例的补充\"><a href=\"#类和实例的补充\" class=\"headerlink\" title=\"类和实例的补充\"></a>类和实例的补充</h2><p>其实在学习类的过程中还是非常的懵逼，主要感觉讲的并不是很好，所以特地再重新学习补充一下</p>\n<p>类其实就是一大类，就比如学生这就是一个类，而中学生，大学生，却是这个类里面的一个子类，但是他们也具备学生的特性，只不过因为阶段不同，所以存在差异性，因此我们可以将假设的类定义一下</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">Student</span>(<span class=\"hljs-symbol\">Object</span>):<br></code></pre></td></tr></table></figure>\n\n<p>其中，这个Object类似什么呢，学生是不是人类，那肯定是人类，所以学生这个类其实也包含在一个大类里面，这个大类就是Object，也就是程序中最高的大类</p>\n<p>那这个类定义好之后，我们要开始对他进行初始化，初始化是什么呢，初始化其实就是初始化学生的一些基本信息，比如姓名、年龄、性别，这些是在输入到这个数据结构中，必须要提前标识好的，如果没有标识好，就会出现信息不足，导致没办法区别这个人，因此我们就可以进行函数初始化</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex <br></code></pre></td></tr></table></figure>\n\n<p>这样的话，这个调用这个类，他就必须要有这三个参数，否则就会出现报错，那self是什么呢，我觉得他是代表这个类的数据结构，如果你将数据前面加一个self的定义，那么这个数据就存到了这个类里面，他就可以在这个类里面随便使用了</p>\n<p>之后呢，我们想要对中学生、大学生进行区分开，分别填入他们相应的数据，比如中学生要面对高考痛苦，大学生要面对就业痛苦，因此我们就可以根据他们面对不同的问题进行在这个类里面进行区分</p>\n<p>我们再来分析一下中学生，他们的高考痛苦来源于语数英…我们这边列举两门作为示例，比如他们的数学和英语，他们看重成绩，那是不是在评价这个学生的时候，要看看这个学生的成绩，所以这两门的成绩成为了他们的必选参数，但是大学生不需要这个参数啊，那我们就在中学生的这个实例里面定义一个传参的初始化，其实也就是把中学生的数据塞到self数据中，虽然大学生也能用，但是并不是必选参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">Middle_Exam_pain</span>(<span class=\"hljs-params\">self, English, Math</span>):<br>    <span class=\"hljs-variable language_\">self</span>.English = English<br>    <span class=\"hljs-variable language_\">self</span>.Math = Math<br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">90</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.English &lt; <span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &lt; <span class=\"hljs-number\">90</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，超级痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br></code></pre></td></tr></table></figure>\n\n<p>我们就可以将英语和数学的成绩单独赋值出来，只对中学生进行调用，这样中学生就可以自己进行判断了</p>\n<p>那大学生的痛苦来自哪里呢，大学生的痛苦有来自考研考上和没考上，找工作找没找到，以及他们的月薪是多少，那我们就可以类似的，再创建大学生的实例来表达</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">College_pain</span>(<span class=\"hljs-params\">self, Graduate=<span class=\"hljs-literal\">None</span>, School=<span class=\"hljs-literal\">None</span>, Employment=<span class=\"hljs-literal\">None</span>, wage=<span class=\"hljs-literal\">None</span></span>):<br>    <span class=\"hljs-variable language_\">self</span>.Graduate = Graduate<br>    <span class=\"hljs-variable language_\">self</span>.School = School<br>    <span class=\"hljs-variable language_\">self</span>.Employment = Employment<br>    <span class=\"hljs-variable language_\">self</span>.wage = wage<br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate &gt; <span class=\"hljs-number\">400</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，没考上学习，非常痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.wage &gt;<span class=\"hljs-number\">10000</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>    <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.wage == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s没找到工作，非常痛苦&quot;</span> % <span class=\"hljs-variable language_\">self</span>.name)<br></code></pre></td></tr></table></figure>\n\n<p>首先对要传入的数据进行初始化，这样我们就可以对其传参了，然后先判断是考研还是找工作，再去判断相对应考研或者找工作的类别，其实这两个凑一起是比较混乱的，可以考虑新建一个实例，如果是考研就调用考研的，如果是找工作的就调用找工作的</p>\n<p>完成类的初始化和实例设定后，我们可以来验证我们的代码是什么样子的，有没有bug之类的，首先，需要将实例复制给一个叫lihua的学生，当然别忘记我们的init里面要强制输入的参数</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">lihua</span> = Student(<span class=\"hljs-string\">&quot;lihua&quot;</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>然后我们就可以在传入lihua的中学生参数，比如，他英语考了90分，数学考了99分，将数据传入这个函数</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">lihua</span>.Middle_Exam_pain(<span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">99</span>)<br><span class=\"hljs-attribute\">lihua</span>.Middle_Exam_pain(<span class=\"hljs-number\">89</span>,<span class=\"hljs-number\">87</span>)<br><span class=\"hljs-attribute\">lihua</span>.Middle_Exam_pain(<span class=\"hljs-number\">77</span>,<span class=\"hljs-number\">66</span>)<br><br><span class=\"hljs-comment\">#output</span><br><span class=\"hljs-attribute\">lihua</span>英语考<span class=\"hljs-number\">90</span>、数学考<span class=\"hljs-number\">99</span>，一点也不痛苦<br><span class=\"hljs-attribute\">lihua</span>英语考<span class=\"hljs-number\">89</span>、数学考<span class=\"hljs-number\">87</span>，有点痛苦<br><span class=\"hljs-attribute\">lihua</span>英语考<span class=\"hljs-number\">77</span>、数学考<span class=\"hljs-number\">66</span>，超级痛苦<br></code></pre></td></tr></table></figure>\n\n<p>验证大学生，假设一个大学生kangkang，先初始化固定参数</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">kangkang</span> = Student(<span class=\"hljs-string\">&quot;kangkang&quot;</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>之后我们可以传入他的一些内容，比如他是考研的，或者是找工作的</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">kangkang</span> = Student(<span class=\"hljs-string\">&quot;kangkang&quot;</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(<span class=\"hljs-number\">410</span>,&#x27;北京大学&#x27;)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(<span class=\"hljs-number\">250</span>,&#x27;野鸡大学&#x27;)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(<span class=\"hljs-number\">200</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(None,None,<span class=\"hljs-string\">&quot;华为&quot;</span>, <span class=\"hljs-number\">20000</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(None,None,<span class=\"hljs-string\">&quot;美团外卖&quot;</span>, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-attribute\">kangkang</span>.College_pain(None,None,None, None)<br><br><span class=\"hljs-comment\">#output</span><br><span class=\"hljs-attribute\">kangkang</span>考研考了<span class=\"hljs-number\">410</span>分，考上了北京大学，一点也不痛苦<br><span class=\"hljs-attribute\">kangkang</span>考研考了<span class=\"hljs-number\">250</span>分，考上了野鸡大学，有点痛苦<br><span class=\"hljs-attribute\">kangkang</span>考研考了<span class=\"hljs-number\">200</span>分，没考上学习，非常痛苦<br><span class=\"hljs-attribute\">kangkang</span>找到了工作，在华为上班，工资是<span class=\"hljs-number\">20000</span>，一点也不痛苦<br><span class=\"hljs-attribute\">kangkang</span>找到了工作，在美团外卖上班，工资是<span class=\"hljs-number\">4000</span>，有点痛苦<br><span class=\"hljs-attribute\">kangkang</span>没找到工作，非常痛苦<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"整个程序完整代码\"><a href=\"#整个程序完整代码\" class=\"headerlink\" title=\"整个程序完整代码\"></a>整个程序完整代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">Middle_Exam_pain</span>(<span class=\"hljs-params\">self, English, Math</span>):<br>        <span class=\"hljs-variable language_\">self</span>.English = English<br>        <span class=\"hljs-variable language_\">self</span>.Math = Math<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.English &lt; <span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &lt; <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，超级痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">College_pain</span>(<span class=\"hljs-params\">self, Graduate=<span class=\"hljs-literal\">None</span>, School=<span class=\"hljs-literal\">None</span>, Employment=<span class=\"hljs-literal\">None</span>, wage=<span class=\"hljs-literal\">None</span></span>):<br>        <span class=\"hljs-variable language_\">self</span>.Graduate = Graduate<br>        <span class=\"hljs-variable language_\">self</span>.School = School<br>        <span class=\"hljs-variable language_\">self</span>.Employment = Employment<br>        <span class=\"hljs-variable language_\">self</span>.wage = wage<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.Graduate &gt; <span class=\"hljs-number\">400</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>            <span class=\"hljs-keyword\">else</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，考上了%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate, <span class=\"hljs-variable language_\">self</span>.School))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Graduate <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s考研考了%d分，没考上学习，非常痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Graduate))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.wage &gt;<span class=\"hljs-number\">10000</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>            <span class=\"hljs-keyword\">else</span>:<br>                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s找到了工作，在%s上班，工资是%s，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.Employment, <span class=\"hljs-variable language_\">self</span>.wage))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.Employment == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.wage == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Graduate == <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.School == <span class=\"hljs-literal\">None</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s没找到工作，非常痛苦&quot;</span> % <span class=\"hljs-variable language_\">self</span>.name)<br><br><span class=\"hljs-comment\">#output</span><br>lihua = Student(<span class=\"hljs-string\">&quot;lihua&quot;</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br>lihua.Middle_Exam_pain(<span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">99</span>)<br>lihua.Middle_Exam_pain(<span class=\"hljs-number\">89</span>,<span class=\"hljs-number\">87</span>)<br>lihua.Middle_Exam_pain(<span class=\"hljs-number\">77</span>,<span class=\"hljs-number\">66</span>)<br>kangkang = Student(<span class=\"hljs-string\">&quot;kangkang&quot;</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-string\">&quot;boy&quot;</span>)<br>kangkang.College_pain(<span class=\"hljs-number\">410</span>,<span class=\"hljs-string\">&#x27;北京大学&#x27;</span>)<br>kangkang.College_pain(<span class=\"hljs-number\">250</span>,<span class=\"hljs-string\">&#x27;野鸡大学&#x27;</span>)<br>kangkang.College_pain(<span class=\"hljs-number\">200</span>)<br>kangkang.College_pain(<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>,<span class=\"hljs-string\">&quot;华为&quot;</span>, <span class=\"hljs-number\">20000</span>)<br>kangkang.College_pain(<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>,<span class=\"hljs-string\">&quot;美团外卖&quot;</span>, <span class=\"hljs-number\">4000</span>)<br>kangkang.College_pain(<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>,<span class=\"hljs-literal\">None</span>, <span class=\"hljs-literal\">None</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>继承的话，其实简单来说就是可以用父类里面的实例和参数，当然如果想用参数，需要在init里面去继承父类的init才可以传入参数，如果实例没有参数的话，可以直接引用</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex<br>\t<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">father</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;继承了父类&quot;</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Primary</span>(<span class=\"hljs-title class_\">Student</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        pass<br>        <br>jack = <span class=\"hljs-title class_\">Primary</span>()<br>jack.father()<br><br><span class=\"hljs-comment\">#output</span><br>继承了父类<br></code></pre></td></tr></table></figure>\n\n<p>当然如果里面有参数，那就要在init里面进行引用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">Middle_Exam_pain</span>(<span class=\"hljs-params\">self, English, Math</span>):<br>        <span class=\"hljs-variable language_\">self</span>.English = English<br>        <span class=\"hljs-variable language_\">self</span>.Math = Math<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，一点也不痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-variable language_\">self</span>.English &gt;=<span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.English &lt; <span class=\"hljs-number\">90</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &gt;= <span class=\"hljs-number\">80</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-variable language_\">self</span>.Math &lt; <span class=\"hljs-number\">90</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，有点痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;%s英语考%d、数学考%d，超级痛苦&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.English, <span class=\"hljs-variable language_\">self</span>.Math))<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Primary</span>(<span class=\"hljs-title class_ inherited__\">Student</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-built_in\">super</span>().__init__(name, age, sex)<br><br>jack = Primary(<span class=\"hljs-string\">&quot;jack&quot;</span>,<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">&quot;boy&quot;</span>)<br>jack.Middle_Exam_pain(<span class=\"hljs-number\">90</span>,<span class=\"hljs-number\">100</span>)<br><br><span class=\"hljs-comment\">#output</span><br>jack英语考<span class=\"hljs-number\">90</span>、数学考<span class=\"hljs-number\">100</span>，一点也不痛苦<br></code></pre></td></tr></table></figure>\n\n<p>如果是多重继承的话，其实有个比较简单的套娃方式</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(object):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-variable language_\">self</span>.sex = sex <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">father</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;继承了Student&quot;</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Teacher</span>(<span class=\"hljs-title class_\">Student</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">super</span>().__init__(name, age, sex)<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">talk</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;继承了Teacher&quot;</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Primary</span>(<span class=\"hljs-title class_\">Teacher</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">super</span>().__init__(name, age, sex)<br></code></pre></td></tr></table></figure>\n\n<p>然后，我们就可以顺利的使用Student和Teacher的所有内容了</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">jack </span>= Primary(<span class=\"hljs-string\">&quot;jack&quot;</span>,<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">&quot;boy&quot;</span>)<br><span class=\"hljs-keyword\">jack.father()</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">jack.talk()</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">jack.Middle_Exam_pain(90,100)</span><br><span class=\"hljs-keyword\"></span><br><span class=\"hljs-comment\">#output</span><br>继承了Student<br>继承了Teacher<br><span class=\"hljs-keyword\">jack英语考90、数学考100，一点也不痛苦</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"Python-定制类函数和枚举","date":"2024-08-12T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/02/BjQzmUC6DXIvGPK.jpg","_content":"\n# Python-定制类函数和枚举\n\n## 定制类函数的使用\n\n### `__str__`\n\n使用这个函数后，打印出来的字符会比较简洁，更加的清晰\n\n```\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...\n>>> print(Student('Michael'))\n<__main__.Student object at 0x109afb190>\n```\n\n使用这个函数后\n\n```\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return 'Student object (name: %s)' % self.name\n...\n>>> print(Student('Michael'))\nStudent object (name: Michael)\n```\n\n### `__call__`\n\n我们定义这个函数之后，我们就可以在外部很轻松的调用\n\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\n        \n>>> s = Student('Michael')\n>>> s() # self参数不要传入\nMy name is Michael.\n```\n\n## 枚举\n\n当我们需要定义常量时，更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了`Enum`类来实现这个功能：\n\n```\nfrom enum import Enum\n\nMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n```\n\n这样我们就获得了`Month`类型的枚举类，可以直接使用`Month.Jan`来引用一个常量\n\n如果需要更精确地控制枚举类型，可以从`Enum`派生出自定义类：\n\n```\nfrom enum import Enum, unique\n\n@unique #@unique装饰器可以帮助我们检查保证没有重复值。\nclass Weekday(Enum):\n    Sun = 0 # Sun的value被设定为0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Work No.24.md","raw":"---\ntitle: Python-定制类函数和枚举\ntag: Python\ndate: 2024-08-13\ncategories: Python\nindex_img: https://s2.loli.net/2024/08/02/BjQzmUC6DXIvGPK.jpg\n---\n\n# Python-定制类函数和枚举\n\n## 定制类函数的使用\n\n### `__str__`\n\n使用这个函数后，打印出来的字符会比较简洁，更加的清晰\n\n```\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...\n>>> print(Student('Michael'))\n<__main__.Student object at 0x109afb190>\n```\n\n使用这个函数后\n\n```\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return 'Student object (name: %s)' % self.name\n...\n>>> print(Student('Michael'))\nStudent object (name: Michael)\n```\n\n### `__call__`\n\n我们定义这个函数之后，我们就可以在外部很轻松的调用\n\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\n        \n>>> s = Student('Michael')\n>>> s() # self参数不要传入\nMy name is Michael.\n```\n\n## 枚举\n\n当我们需要定义常量时，更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了`Enum`类来实现这个功能：\n\n```\nfrom enum import Enum\n\nMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n```\n\n这样我们就获得了`Month`类型的枚举类，可以直接使用`Month.Jan`来引用一个常量\n\n如果需要更精确地控制枚举类型，可以从`Enum`派生出自定义类：\n\n```\nfrom enum import Enum, unique\n\n@unique #@unique装饰器可以帮助我们检查保证没有重复值。\nclass Weekday(Enum):\n    Sun = 0 # Sun的value被设定为0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Work No.24","published":1,"updated":"2024-08-13T03:53:59.635Z","_id":"clzrvyz110001kofbax5a7o8r","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Python-定制类函数和枚举\"><a href=\"#Python-定制类函数和枚举\" class=\"headerlink\" title=\"Python-定制类函数和枚举\"></a>Python-定制类函数和枚举</h1><h2 id=\"定制类函数的使用\"><a href=\"#定制类函数的使用\" class=\"headerlink\" title=\"定制类函数的使用\"></a>定制类函数的使用</h2><h3 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"__str__\"></a><code>__str__</code></h3><p>使用这个函数后，打印出来的字符会比较简洁，更加的清晰</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">        <span class=\"hljs-variable language_\">self</span>.name = name</span><br><span class=\"hljs-meta prompt_\">...</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-built_in\">print</span>(Student(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>))</span><br>&lt;__main__.Student object at 0x109afb190&gt;<br></code></pre></td></tr></table></figure>\n\n<p>使用这个函数后</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">        <span class=\"hljs-variable language_\">self</span>.name = name</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Student object (name: %s)&#x27;</span> % <span class=\"hljs-variable language_\">self</span>.name</span><br><span class=\"hljs-meta prompt_\">...</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-built_in\">print</span>(Student(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>))</span><br>Student object (name: Michael)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"__call__\"></a><code>__call__</code></h3><p>我们定义这个函数之后，我们就可以在外部很轻松的调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__call__</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;My name is %s.&#x27;</span> % <span class=\"hljs-variable language_\">self</span>.name)<br>        <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = Student(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s() <span class=\"hljs-comment\"># self参数不要传入</span><br>My name <span class=\"hljs-keyword\">is</span> Michael.<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>当我们需要定义常量时，更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">enum</span> import <span class=\"hljs-keyword\">Enum</span><br><br>Month = <span class=\"hljs-keyword\">Enum</span>(<span class=\"hljs-string\">&#x27;Month&#x27;</span>, (<span class=\"hljs-string\">&#x27;Jan&#x27;</span>, <span class=\"hljs-string\">&#x27;Feb&#x27;</span>, <span class=\"hljs-string\">&#x27;Mar&#x27;</span>, <span class=\"hljs-string\">&#x27;Apr&#x27;</span>, <span class=\"hljs-string\">&#x27;May&#x27;</span>, <span class=\"hljs-string\">&#x27;Jun&#x27;</span>, <span class=\"hljs-string\">&#x27;Jul&#x27;</span>, <span class=\"hljs-string\">&#x27;Aug&#x27;</span>, <span class=\"hljs-string\">&#x27;Sep&#x27;</span>, <span class=\"hljs-string\">&#x27;Oct&#x27;</span>, <span class=\"hljs-string\">&#x27;Nov&#x27;</span>, <span class=\"hljs-string\">&#x27;Dec&#x27;</span>))<br></code></pre></td></tr></table></figure>\n\n<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量</p>\n<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-keyword\">import</span> Enum, unique<br><br>@unique #@unique装饰器可以帮助我们检查保证没有重复值。<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">Weekday</span>(<span class=\"hljs-symbol\">Enum</span>):<br>    <span class=\"hljs-symbol\">Sun</span> = <span class=\"hljs-symbol\">0</span> # <span class=\"hljs-symbol\">Sun</span>的<span class=\"hljs-symbol\">value</span>被设定为<span class=\"hljs-symbol\">0</span><br>    <span class=\"hljs-symbol\">Mon</span> = <span class=\"hljs-symbol\">1</span><br>    <span class=\"hljs-symbol\">Tue</span> = <span class=\"hljs-symbol\">2</span><br>    <span class=\"hljs-symbol\">Wed</span> = <span class=\"hljs-symbol\">3</span><br>    <span class=\"hljs-symbol\">Thu</span> = <span class=\"hljs-symbol\">4</span><br>    <span class=\"hljs-symbol\">Fri</span> = <span class=\"hljs-symbol\">5</span><br>    <span class=\"hljs-symbol\">Sat</span> = <span class=\"hljs-symbol\">6</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"","more":"<h1 id=\"Python-定制类函数和枚举\"><a href=\"#Python-定制类函数和枚举\" class=\"headerlink\" title=\"Python-定制类函数和枚举\"></a>Python-定制类函数和枚举</h1><h2 id=\"定制类函数的使用\"><a href=\"#定制类函数的使用\" class=\"headerlink\" title=\"定制类函数的使用\"></a>定制类函数的使用</h2><h3 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"__str__\"></a><code>__str__</code></h3><p>使用这个函数后，打印出来的字符会比较简洁，更加的清晰</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">        <span class=\"hljs-variable language_\">self</span>.name = name</span><br><span class=\"hljs-meta prompt_\">...</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-built_in\">print</span>(Student(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>))</span><br>&lt;__main__.Student object at 0x109afb190&gt;<br></code></pre></td></tr></table></figure>\n\n<p>使用这个函数后</p>\n<figure class=\"highlight python-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python-repl\"><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">        <span class=\"hljs-variable language_\">self</span>.name = name</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):</span><br><span class=\"hljs-meta prompt_\">...</span> <span class=\"language-python\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Student object (name: %s)&#x27;</span> % <span class=\"hljs-variable language_\">self</span>.name</span><br><span class=\"hljs-meta prompt_\">...</span><br><span class=\"hljs-meta prompt_\">&gt;&gt;&gt;</span> <span class=\"language-python\"><span class=\"hljs-built_in\">print</span>(Student(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>))</span><br>Student object (name: Michael)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"__call__\"></a><code>__call__</code></h3><p>我们定义这个函数之后，我们就可以在外部很轻松的调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__call__</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;My name is %s.&#x27;</span> % <span class=\"hljs-variable language_\">self</span>.name)<br>        <br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s = Student(<span class=\"hljs-string\">&#x27;Michael&#x27;</span>)<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>s() <span class=\"hljs-comment\"># self参数不要传入</span><br>My name <span class=\"hljs-keyword\">is</span> Michael.<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>当我们需要定义常量时，更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">enum</span> import <span class=\"hljs-keyword\">Enum</span><br><br>Month = <span class=\"hljs-keyword\">Enum</span>(<span class=\"hljs-string\">&#x27;Month&#x27;</span>, (<span class=\"hljs-string\">&#x27;Jan&#x27;</span>, <span class=\"hljs-string\">&#x27;Feb&#x27;</span>, <span class=\"hljs-string\">&#x27;Mar&#x27;</span>, <span class=\"hljs-string\">&#x27;Apr&#x27;</span>, <span class=\"hljs-string\">&#x27;May&#x27;</span>, <span class=\"hljs-string\">&#x27;Jun&#x27;</span>, <span class=\"hljs-string\">&#x27;Jul&#x27;</span>, <span class=\"hljs-string\">&#x27;Aug&#x27;</span>, <span class=\"hljs-string\">&#x27;Sep&#x27;</span>, <span class=\"hljs-string\">&#x27;Oct&#x27;</span>, <span class=\"hljs-string\">&#x27;Nov&#x27;</span>, <span class=\"hljs-string\">&#x27;Dec&#x27;</span>))<br></code></pre></td></tr></table></figure>\n\n<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量</p>\n<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-keyword\">import</span> Enum, unique<br><br>@unique #@unique装饰器可以帮助我们检查保证没有重复值。<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">Weekday</span>(<span class=\"hljs-symbol\">Enum</span>):<br>    <span class=\"hljs-symbol\">Sun</span> = <span class=\"hljs-symbol\">0</span> # <span class=\"hljs-symbol\">Sun</span>的<span class=\"hljs-symbol\">value</span>被设定为<span class=\"hljs-symbol\">0</span><br>    <span class=\"hljs-symbol\">Mon</span> = <span class=\"hljs-symbol\">1</span><br>    <span class=\"hljs-symbol\">Tue</span> = <span class=\"hljs-symbol\">2</span><br>    <span class=\"hljs-symbol\">Wed</span> = <span class=\"hljs-symbol\">3</span><br>    <span class=\"hljs-symbol\">Thu</span> = <span class=\"hljs-symbol\">4</span><br>    <span class=\"hljs-symbol\">Fri</span> = <span class=\"hljs-symbol\">5</span><br>    <span class=\"hljs-symbol\">Sat</span> = <span class=\"hljs-symbol\">6</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"Makefile文件","date":"2024-08-13T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/15/QdvBaUHkV3xjnFw.jpg","_content":"\n# Makefile文件\n\n## 单Makefile文件编译\n\n这个文件可以将c文件编译成机器可以解读的文件，使用GCC进行编译，所以使用前，必须保证有GCC环境\n\n这个文件其实是将GCC编译过程编程一个可执行脚本，然后执行该脚本，完成一系列操作\n\n#### 多个C文件生成多个可执行文件（多个main函数）\n\n该文件的作用是编译同一文件下的所有C文件，每个文件夹都会生成一个可执行文件，放在哪个文件夹，就执行哪个文件夹的编译\n\n```\n# 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。\nCC = gcc\n\n# 定义编译选项：\n# -Wall：启用所有常见的编译警告。\n# -g：生成调试信息，用于调试程序。\nCFLAGS = -Wall -g\n\n# 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件\n# $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表\nSRCS = $(wildcard *.c)\n\n# 生成与源文件同名的可执行文件列表：\n# 这里，%.c 被替换为 %，即去掉 .c 扩展名。\n# $(SRCS:.c=) 会将 SRCS 中所有的 .c 文件名的扩展名去掉，得到可执行文件名。\nEXES = $(SRCS:.c=)\n\n# 默认目标：'all' 目标是 Makefile 的默认目标。\n# 如果运行 `make` 而不指定目标，默认会执行 'all' 目标。\n# 这个目标依赖于所有的可执行文件名。\nall: $(EXES)\n\n# 规则：如何从源文件生成可执行文件。\n# %: %.c 是一个模式规则：\n# - $@ 表示目标文件（即可执行文件名）。\n# - $< 表示第一个依赖文件（即源文件）。\n# 这条规则定义了如何编译单个 C 文件生成与之同名的可执行文件。\n$(EXES): %: %.c\n\n# 使用 gcc 编译源文件，生成同名的可执行文件。\n\t$(CC) $(CFLAGS) -o $@ $<\n\n# 编译完成后，输出生成的可执行文件的名称。\n# @ 使这条命令不在命令行中显示，只显示输出的结果。\n\t@echo \"Compiled $@\"\n\n# 清理目标：'clean' 是一个伪目标，用于删除所有生成的可执行文件。\n# 这是为了保持工作目录的清洁，并且通常用在重新编译前。\nclean:\n\n# 删除所有在 EXES 中定义的可执行文件。\n\trm -f $(EXES)\n\n# .PHONY 是一个特殊的标志，用于声明 'all' 和 'clean' 目标是伪目标。\n# 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。\n.PHONY: all clean\n```\n\n#### 多个C文件生成一个可执行文件（只有一个main函数）\n\n下面的代码是一个文件夹所有c文件只生成一个可执行文件\n\n```\n# 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。\nCC = gcc\n\n# 定义编译选项：\n# -Wall：启用所有常见的编译警告。\n# -g：生成调试信息，用于调试程序。\nCFLAGS = -Wall -g\n\n# 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件\n# $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表\nSRCS = $(wildcard *.c)\n\n# 生成与当前目录同名的可执行文件名\n# 使用 notdir 和 basename 函数提取当前目录名并生成对应的可执行文件名\nEXE = $(notdir $(CURDIR))\n\n# 默认目标：'all' 目标是 Makefile 的默认目标。\n# 如果运行 `make` 而不指定目标，默认会执行 'all' 目标。\n# 这个目标依赖于生成的可执行文件。\nall: $(EXE)\n\n# 规则：如何从源文件生成可执行文件。\n# $@ 表示目标文件（即可执行文件名）。\n# $^ 表示所有的依赖文件（即所有的源文件）。\n$(EXE): $(SRCS)\n\n# 使用 gcc 编译源文件，生成一个与文件夹同名的可执行文件。\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# 编译完成后，输出生成的可执行文件的名称。\n# @ 使这条命令不在命令行中显示，只显示输出的结果。\n\t@echo \"Compiled $@\"\n\n# 清理目标：'clean' 是一个伪目标，用于删除生成的可执行文件。\n# 这是为了保持工作目录的清洁，并且通常用在重新编译前。\nclean:\n\n# 删除生成的可执行文件。\n\trm -f $(EXE)\n\n# .PHONY 是一个特殊的标志，用于声明 'all' 和 'clean' 目标是伪目标。\n# 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。\n.PHONY: all clean\n```\n\n## 多文件夹的Makefile编译\n\n上面的makefile只能编译一个文件夹，如果我想在主文件夹编译所有文件夹，就需要写一个总的Makefile来对所有的文件夹进行调用\n\n假设我的文件框架如下\n\n```\nproject/\n├── Makefile\n├── src/\n│   ├── file1.c\n│   ├── file2.c\n│   └── Makefile\n├── lib/\n│   ├── file3.c\n│   └── Makefile\n└── include/\n    └── file4.c\n```\n\n所以主文件夹的Makefile文件内容如下\n\n```\n# 主Makefile\n\n# 定义子目录的变量\n# 这里 SUBDIRS 包含了所有需要编译的子目录，并将它们分行排列以便清晰展示\nSUBDIRS = \\\n    src \\\n    lib \\\n    include\n\n# 默认目标是编译所有子目录\n# 当用户只输入 `make` 而不指定具体目标时，`all` 目标会被执行\nall: $(SUBDIRS)\n\n# 对于每个子目录，调用 `make` 命令并进入该目录 (`-C` 选项)\n# 这会在每个子目录中执行它们自己的 `Makefile`\n$(SUBDIRS):\n\t$(MAKE) -C $@\n\n# 清理所有子目录的目标\n# 这里定义了 `clean` 目标，当用户运行 `make clean` 时会被执行\n# 这个目标会遍历所有子目录，并在每个子目录中执行 `make clean`\nclean:\n# 遍历所有子目录,在每个子目录中执行 `make clean`\n\tfor dir in $(SUBDIRS); do \\\n\t\t$(MAKE) -C $$dir clean; \\\n\tdone\n\n# 伪目标声明\n# .PHONY 是一个特殊的伪目标声明，表示 `all`, `clean`, `$(SUBDIRS)` 等目标不对应实际文件\n# 即使当前目录下存在名为 `all` 或 `clean` 的文件，它们也不会被作为目标，而是执行与之对应的命令\n.PHONY: all clean $(SUBDIRS)\n```\n\n完成这个编写之后呢，就可以在主文件或者子文件夹随便执行编译\n\n## 文件编译操作\n\n完成该文件创建和内容编写，就可以开始执行，执行前先清除原有的编译文件\n\n```\nmake clean\n```\n\n再执行编译文件\n\n```\nmake\n```\n\n最后输出一个可执行的脚本，输入即可执行\n\n```\n./<name>\n```\n","source":"_posts/Work No.26.md","raw":"---\ntitle: Makefile文件\ntag: C/C++\ndate: 2024-08-14\ncategories: C/C++编译\nindex_img: https://s2.loli.net/2024/08/15/QdvBaUHkV3xjnFw.jpg\n---\n\n# Makefile文件\n\n## 单Makefile文件编译\n\n这个文件可以将c文件编译成机器可以解读的文件，使用GCC进行编译，所以使用前，必须保证有GCC环境\n\n这个文件其实是将GCC编译过程编程一个可执行脚本，然后执行该脚本，完成一系列操作\n\n#### 多个C文件生成多个可执行文件（多个main函数）\n\n该文件的作用是编译同一文件下的所有C文件，每个文件夹都会生成一个可执行文件，放在哪个文件夹，就执行哪个文件夹的编译\n\n```\n# 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。\nCC = gcc\n\n# 定义编译选项：\n# -Wall：启用所有常见的编译警告。\n# -g：生成调试信息，用于调试程序。\nCFLAGS = -Wall -g\n\n# 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件\n# $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表\nSRCS = $(wildcard *.c)\n\n# 生成与源文件同名的可执行文件列表：\n# 这里，%.c 被替换为 %，即去掉 .c 扩展名。\n# $(SRCS:.c=) 会将 SRCS 中所有的 .c 文件名的扩展名去掉，得到可执行文件名。\nEXES = $(SRCS:.c=)\n\n# 默认目标：'all' 目标是 Makefile 的默认目标。\n# 如果运行 `make` 而不指定目标，默认会执行 'all' 目标。\n# 这个目标依赖于所有的可执行文件名。\nall: $(EXES)\n\n# 规则：如何从源文件生成可执行文件。\n# %: %.c 是一个模式规则：\n# - $@ 表示目标文件（即可执行文件名）。\n# - $< 表示第一个依赖文件（即源文件）。\n# 这条规则定义了如何编译单个 C 文件生成与之同名的可执行文件。\n$(EXES): %: %.c\n\n# 使用 gcc 编译源文件，生成同名的可执行文件。\n\t$(CC) $(CFLAGS) -o $@ $<\n\n# 编译完成后，输出生成的可执行文件的名称。\n# @ 使这条命令不在命令行中显示，只显示输出的结果。\n\t@echo \"Compiled $@\"\n\n# 清理目标：'clean' 是一个伪目标，用于删除所有生成的可执行文件。\n# 这是为了保持工作目录的清洁，并且通常用在重新编译前。\nclean:\n\n# 删除所有在 EXES 中定义的可执行文件。\n\trm -f $(EXES)\n\n# .PHONY 是一个特殊的标志，用于声明 'all' 和 'clean' 目标是伪目标。\n# 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。\n.PHONY: all clean\n```\n\n#### 多个C文件生成一个可执行文件（只有一个main函数）\n\n下面的代码是一个文件夹所有c文件只生成一个可执行文件\n\n```\n# 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。\nCC = gcc\n\n# 定义编译选项：\n# -Wall：启用所有常见的编译警告。\n# -g：生成调试信息，用于调试程序。\nCFLAGS = -Wall -g\n\n# 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件\n# $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表\nSRCS = $(wildcard *.c)\n\n# 生成与当前目录同名的可执行文件名\n# 使用 notdir 和 basename 函数提取当前目录名并生成对应的可执行文件名\nEXE = $(notdir $(CURDIR))\n\n# 默认目标：'all' 目标是 Makefile 的默认目标。\n# 如果运行 `make` 而不指定目标，默认会执行 'all' 目标。\n# 这个目标依赖于生成的可执行文件。\nall: $(EXE)\n\n# 规则：如何从源文件生成可执行文件。\n# $@ 表示目标文件（即可执行文件名）。\n# $^ 表示所有的依赖文件（即所有的源文件）。\n$(EXE): $(SRCS)\n\n# 使用 gcc 编译源文件，生成一个与文件夹同名的可执行文件。\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# 编译完成后，输出生成的可执行文件的名称。\n# @ 使这条命令不在命令行中显示，只显示输出的结果。\n\t@echo \"Compiled $@\"\n\n# 清理目标：'clean' 是一个伪目标，用于删除生成的可执行文件。\n# 这是为了保持工作目录的清洁，并且通常用在重新编译前。\nclean:\n\n# 删除生成的可执行文件。\n\trm -f $(EXE)\n\n# .PHONY 是一个特殊的标志，用于声明 'all' 和 'clean' 目标是伪目标。\n# 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。\n.PHONY: all clean\n```\n\n## 多文件夹的Makefile编译\n\n上面的makefile只能编译一个文件夹，如果我想在主文件夹编译所有文件夹，就需要写一个总的Makefile来对所有的文件夹进行调用\n\n假设我的文件框架如下\n\n```\nproject/\n├── Makefile\n├── src/\n│   ├── file1.c\n│   ├── file2.c\n│   └── Makefile\n├── lib/\n│   ├── file3.c\n│   └── Makefile\n└── include/\n    └── file4.c\n```\n\n所以主文件夹的Makefile文件内容如下\n\n```\n# 主Makefile\n\n# 定义子目录的变量\n# 这里 SUBDIRS 包含了所有需要编译的子目录，并将它们分行排列以便清晰展示\nSUBDIRS = \\\n    src \\\n    lib \\\n    include\n\n# 默认目标是编译所有子目录\n# 当用户只输入 `make` 而不指定具体目标时，`all` 目标会被执行\nall: $(SUBDIRS)\n\n# 对于每个子目录，调用 `make` 命令并进入该目录 (`-C` 选项)\n# 这会在每个子目录中执行它们自己的 `Makefile`\n$(SUBDIRS):\n\t$(MAKE) -C $@\n\n# 清理所有子目录的目标\n# 这里定义了 `clean` 目标，当用户运行 `make clean` 时会被执行\n# 这个目标会遍历所有子目录，并在每个子目录中执行 `make clean`\nclean:\n# 遍历所有子目录,在每个子目录中执行 `make clean`\n\tfor dir in $(SUBDIRS); do \\\n\t\t$(MAKE) -C $$dir clean; \\\n\tdone\n\n# 伪目标声明\n# .PHONY 是一个特殊的伪目标声明，表示 `all`, `clean`, `$(SUBDIRS)` 等目标不对应实际文件\n# 即使当前目录下存在名为 `all` 或 `clean` 的文件，它们也不会被作为目标，而是执行与之对应的命令\n.PHONY: all clean $(SUBDIRS)\n```\n\n完成这个编写之后呢，就可以在主文件或者子文件夹随便执行编译\n\n## 文件编译操作\n\n完成该文件创建和内容编写，就可以开始执行，执行前先清除原有的编译文件\n\n```\nmake clean\n```\n\n再执行编译文件\n\n```\nmake\n```\n\n最后输出一个可执行的脚本，输入即可执行\n\n```\n./<name>\n```\n","slug":"Work No.26","published":1,"updated":"2024-08-15T01:13:12.617Z","_id":"clztv1uia0000sgfb3smg063r","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Makefile文件\"><a href=\"#Makefile文件\" class=\"headerlink\" title=\"Makefile文件\"></a>Makefile文件</h1><h2 id=\"单Makefile文件编译\"><a href=\"#单Makefile文件编译\" class=\"headerlink\" title=\"单Makefile文件编译\"></a>单Makefile文件编译</h2><p>这个文件可以将c文件编译成机器可以解读的文件，使用GCC进行编译，所以使用前，必须保证有GCC环境</p>\n<p>这个文件其实是将GCC编译过程编程一个可执行脚本，然后执行该脚本，完成一系列操作</p>\n<h4 id=\"多个C文件生成多个可执行文件（多个main函数）\"><a href=\"#多个C文件生成多个可执行文件（多个main函数）\" class=\"headerlink\" title=\"多个C文件生成多个可执行文件（多个main函数）\"></a>多个C文件生成多个可执行文件（多个main函数）</h4><p>该文件的作用是编译同一文件下的所有C文件，每个文件夹都会生成一个可执行文件，放在哪个文件夹，就执行哪个文件夹的编译</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。</span><br>CC = gcc<br><br><span class=\"hljs-comment\"># 定义编译选项：</span><br><span class=\"hljs-comment\"># -Wall：启用所有常见的编译警告。</span><br><span class=\"hljs-comment\"># -g：生成调试信息，用于调试程序。</span><br>CFLAGS = -Wall -g<br><br><span class=\"hljs-comment\"># 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件</span><br><span class=\"hljs-comment\"># $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表</span><br>SRCS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span><br><br><span class=\"hljs-comment\"># 生成与源文件同名的可执行文件列表：</span><br><span class=\"hljs-comment\"># 这里，%.c 被替换为 %，即去掉 .c 扩展名。</span><br><span class=\"hljs-comment\"># $(SRCS:.c=) 会将 SRCS 中所有的 .c 文件名的扩展名去掉，得到可执行文件名。</span><br>EXES = $(SRCS:.c=)<br><br><span class=\"hljs-comment\"># 默认目标：&#x27;all&#x27; 目标是 Makefile 的默认目标。</span><br><span class=\"hljs-comment\"># 如果运行 `make` 而不指定目标，默认会执行 &#x27;all&#x27; 目标。</span><br><span class=\"hljs-comment\"># 这个目标依赖于所有的可执行文件名。</span><br><span class=\"hljs-section\">all: <span class=\"hljs-variable\">$(EXES)</span></span><br><br><span class=\"hljs-comment\"># 规则：如何从源文件生成可执行文件。</span><br><span class=\"hljs-comment\"># %: %.c 是一个模式规则：</span><br><span class=\"hljs-comment\"># - $@ 表示目标文件（即可执行文件名）。</span><br><span class=\"hljs-comment\"># - $&lt; 表示第一个依赖文件（即源文件）。</span><br><span class=\"hljs-comment\"># 这条规则定义了如何编译单个 C 文件生成与之同名的可执行文件。</span><br><span class=\"hljs-variable\">$(EXES)</span>: %: %.c<br><br><span class=\"hljs-comment\"># 使用 gcc 编译源文件，生成同名的可执行文件。</span><br>\t<span class=\"hljs-variable\">$(CC)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> -o <span class=\"hljs-variable\">$@</span> <span class=\"hljs-variable\">$&lt;</span><br><br><span class=\"hljs-comment\"># 编译完成后，输出生成的可执行文件的名称。</span><br><span class=\"hljs-comment\"># @ 使这条命令不在命令行中显示，只显示输出的结果。</span><br>\t@echo <span class=\"hljs-string\">&quot;Compiled <span class=\"hljs-variable\">$@</span>&quot;</span><br><br><span class=\"hljs-comment\"># 清理目标：&#x27;clean&#x27; 是一个伪目标，用于删除所有生成的可执行文件。</span><br><span class=\"hljs-comment\"># 这是为了保持工作目录的清洁，并且通常用在重新编译前。</span><br><span class=\"hljs-section\">clean:</span><br><br><span class=\"hljs-comment\"># 删除所有在 EXES 中定义的可执行文件。</span><br>\trm -f <span class=\"hljs-variable\">$(EXES)</span><br><br><span class=\"hljs-comment\"># .PHONY 是一个特殊的标志，用于声明 &#x27;all&#x27; 和 &#x27;clean&#x27; 目标是伪目标。</span><br><span class=\"hljs-comment\"># 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: all clean</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"多个C文件生成一个可执行文件（只有一个main函数）\"><a href=\"#多个C文件生成一个可执行文件（只有一个main函数）\" class=\"headerlink\" title=\"多个C文件生成一个可执行文件（只有一个main函数）\"></a>多个C文件生成一个可执行文件（只有一个main函数）</h4><p>下面的代码是一个文件夹所有c文件只生成一个可执行文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。</span><br>CC = gcc<br><br><span class=\"hljs-comment\"># 定义编译选项：</span><br><span class=\"hljs-comment\"># -Wall：启用所有常见的编译警告。</span><br><span class=\"hljs-comment\"># -g：生成调试信息，用于调试程序。</span><br>CFLAGS = -Wall -g<br><br><span class=\"hljs-comment\"># 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件</span><br><span class=\"hljs-comment\"># $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表</span><br>SRCS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span><br><br><span class=\"hljs-comment\"># 生成与当前目录同名的可执行文件名</span><br><span class=\"hljs-comment\"># 使用 notdir 和 basename 函数提取当前目录名并生成对应的可执行文件名</span><br>EXE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">notdir</span> <span class=\"hljs-variable\">$(CURDIR)</span>)</span><br><br><span class=\"hljs-comment\"># 默认目标：&#x27;all&#x27; 目标是 Makefile 的默认目标。</span><br><span class=\"hljs-comment\"># 如果运行 `make` 而不指定目标，默认会执行 &#x27;all&#x27; 目标。</span><br><span class=\"hljs-comment\"># 这个目标依赖于生成的可执行文件。</span><br><span class=\"hljs-section\">all: <span class=\"hljs-variable\">$(EXE)</span></span><br><br><span class=\"hljs-comment\"># 规则：如何从源文件生成可执行文件。</span><br><span class=\"hljs-comment\"># $@ 表示目标文件（即可执行文件名）。</span><br><span class=\"hljs-comment\"># $^ 表示所有的依赖文件（即所有的源文件）。</span><br><span class=\"hljs-variable\">$(EXE)</span>: <span class=\"hljs-variable\">$(SRCS)</span><br><br><span class=\"hljs-comment\"># 使用 gcc 编译源文件，生成一个与文件夹同名的可执行文件。</span><br>\t<span class=\"hljs-variable\">$(CC)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> -o <span class=\"hljs-variable\">$@</span> <span class=\"hljs-variable\">$^</span><br><br><span class=\"hljs-comment\"># 编译完成后，输出生成的可执行文件的名称。</span><br><span class=\"hljs-comment\"># @ 使这条命令不在命令行中显示，只显示输出的结果。</span><br>\t@echo <span class=\"hljs-string\">&quot;Compiled <span class=\"hljs-variable\">$@</span>&quot;</span><br><br><span class=\"hljs-comment\"># 清理目标：&#x27;clean&#x27; 是一个伪目标，用于删除生成的可执行文件。</span><br><span class=\"hljs-comment\"># 这是为了保持工作目录的清洁，并且通常用在重新编译前。</span><br><span class=\"hljs-section\">clean:</span><br><br><span class=\"hljs-comment\"># 删除生成的可执行文件。</span><br>\trm -f <span class=\"hljs-variable\">$(EXE)</span><br><br><span class=\"hljs-comment\"># .PHONY 是一个特殊的标志，用于声明 &#x27;all&#x27; 和 &#x27;clean&#x27; 目标是伪目标。</span><br><span class=\"hljs-comment\"># 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: all clean</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"多文件夹的Makefile编译\"><a href=\"#多文件夹的Makefile编译\" class=\"headerlink\" title=\"多文件夹的Makefile编译\"></a>多文件夹的Makefile编译</h2><p>上面的makefile只能编译一个文件夹，如果我想在主文件夹编译所有文件夹，就需要写一个总的Makefile来对所有的文件夹进行调用</p>\n<p>假设我的文件框架如下</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">project/<br>├── Makefile<br>├── src/<br>│   ├── file<span class=\"hljs-number\">1</span>.<span class=\"hljs-keyword\">c</span><br>│   ├── file<span class=\"hljs-number\">2</span>.<span class=\"hljs-keyword\">c</span><br>│   └── Makefile<br>├── lib/<br>│   ├── file<span class=\"hljs-number\">3</span>.<span class=\"hljs-keyword\">c</span><br>│   └── Makefile<br>└── include/<br>    └── file<span class=\"hljs-number\">4</span>.<span class=\"hljs-keyword\">c</span><br></code></pre></td></tr></table></figure>\n\n<p>所以主文件夹的Makefile文件内容如下</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"># 主Makefile<br><br># 定义子目录的变量<br># 这里 SUBDIRS 包含了所有需要编译的子目录，并将它们分行排列以便清晰展示<br>SUBDIRS = \\<br>    src \\<br>    lib \\<br>    include<br><br># 默认目标是编译所有子目录<br># 当用户只输入 `make` 而不指定具体目标时，`all` 目标会被执行<br><span class=\"hljs-title\">all:</span> $(SUBDIRS)<br><br># 对于每个子目录，调用 `make` 命令并进入该目录 (`-C` 选项)<br># 这会在每个子目录中执行它们自己的 `Makefile`<br><span class=\"hljs-title\">$(SUBDIRS):</span><br>\t$(MAKE) -C $@<br><br># 清理所有子目录的目标<br># 这里定义了 `clean` 目标，当用户运行 `make clean` 时会被执行<br># 这个目标会遍历所有子目录，并在每个子目录中执行 `make clean`<br><span class=\"hljs-title\">clean:</span><br># 遍历所有子目录,在每个子目录中执行 `make clean`<br>\tfor dir in $(SUBDIRS)<span class=\"hljs-comment\">; do \\</span><br>\t\t$(MAKE) -C $$dir clean<span class=\"hljs-comment\">; \\</span><br>\tdone<br><br># 伪目标声明<br># .PHONY 是一个特殊的伪目标声明，表示 `all`, `clean`, `$(SUBDIRS)` 等目标不对应实际文件<br># 即使当前目录下存在名为 `all` 或 `clean` 的文件，它们也不会被作为目标，而是执行与之对应的命令<br><span class=\"hljs-title\">.PHONY:</span> all clean $(SUBDIRS)<br></code></pre></td></tr></table></figure>\n\n<p>完成这个编写之后呢，就可以在主文件或者子文件夹随便执行编译</p>\n<h2 id=\"文件编译操作\"><a href=\"#文件编译操作\" class=\"headerlink\" title=\"文件编译操作\"></a>文件编译操作</h2><p>完成该文件创建和内容编写，就可以开始执行，执行前先清除原有的编译文件</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">make clean</span><br></code></pre></td></tr></table></figure>\n\n<p>再执行编译文件</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">make</span><br></code></pre></td></tr></table></figure>\n\n<p>最后输出一个可执行的脚本，输入即可执行</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">./<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Makefile文件\"><a href=\"#Makefile文件\" class=\"headerlink\" title=\"Makefile文件\"></a>Makefile文件</h1><h2 id=\"单Makefile文件编译\"><a href=\"#单Makefile文件编译\" class=\"headerlink\" title=\"单Makefile文件编译\"></a>单Makefile文件编译</h2><p>这个文件可以将c文件编译成机器可以解读的文件，使用GCC进行编译，所以使用前，必须保证有GCC环境</p>\n<p>这个文件其实是将GCC编译过程编程一个可执行脚本，然后执行该脚本，完成一系列操作</p>\n<h4 id=\"多个C文件生成多个可执行文件（多个main函数）\"><a href=\"#多个C文件生成多个可执行文件（多个main函数）\" class=\"headerlink\" title=\"多个C文件生成多个可执行文件（多个main函数）\"></a>多个C文件生成多个可执行文件（多个main函数）</h4><p>该文件的作用是编译同一文件下的所有C文件，每个文件夹都会生成一个可执行文件，放在哪个文件夹，就执行哪个文件夹的编译</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。</span><br>CC = gcc<br><br><span class=\"hljs-comment\"># 定义编译选项：</span><br><span class=\"hljs-comment\"># -Wall：启用所有常见的编译警告。</span><br><span class=\"hljs-comment\"># -g：生成调试信息，用于调试程序。</span><br>CFLAGS = -Wall -g<br><br><span class=\"hljs-comment\"># 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件</span><br><span class=\"hljs-comment\"># $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表</span><br>SRCS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span><br><br><span class=\"hljs-comment\"># 生成与源文件同名的可执行文件列表：</span><br><span class=\"hljs-comment\"># 这里，%.c 被替换为 %，即去掉 .c 扩展名。</span><br><span class=\"hljs-comment\"># $(SRCS:.c=) 会将 SRCS 中所有的 .c 文件名的扩展名去掉，得到可执行文件名。</span><br>EXES = $(SRCS:.c=)<br><br><span class=\"hljs-comment\"># 默认目标：&#x27;all&#x27; 目标是 Makefile 的默认目标。</span><br><span class=\"hljs-comment\"># 如果运行 `make` 而不指定目标，默认会执行 &#x27;all&#x27; 目标。</span><br><span class=\"hljs-comment\"># 这个目标依赖于所有的可执行文件名。</span><br><span class=\"hljs-section\">all: <span class=\"hljs-variable\">$(EXES)</span></span><br><br><span class=\"hljs-comment\"># 规则：如何从源文件生成可执行文件。</span><br><span class=\"hljs-comment\"># %: %.c 是一个模式规则：</span><br><span class=\"hljs-comment\"># - $@ 表示目标文件（即可执行文件名）。</span><br><span class=\"hljs-comment\"># - $&lt; 表示第一个依赖文件（即源文件）。</span><br><span class=\"hljs-comment\"># 这条规则定义了如何编译单个 C 文件生成与之同名的可执行文件。</span><br><span class=\"hljs-variable\">$(EXES)</span>: %: %.c<br><br><span class=\"hljs-comment\"># 使用 gcc 编译源文件，生成同名的可执行文件。</span><br>\t<span class=\"hljs-variable\">$(CC)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> -o <span class=\"hljs-variable\">$@</span> <span class=\"hljs-variable\">$&lt;</span><br><br><span class=\"hljs-comment\"># 编译完成后，输出生成的可执行文件的名称。</span><br><span class=\"hljs-comment\"># @ 使这条命令不在命令行中显示，只显示输出的结果。</span><br>\t@echo <span class=\"hljs-string\">&quot;Compiled <span class=\"hljs-variable\">$@</span>&quot;</span><br><br><span class=\"hljs-comment\"># 清理目标：&#x27;clean&#x27; 是一个伪目标，用于删除所有生成的可执行文件。</span><br><span class=\"hljs-comment\"># 这是为了保持工作目录的清洁，并且通常用在重新编译前。</span><br><span class=\"hljs-section\">clean:</span><br><br><span class=\"hljs-comment\"># 删除所有在 EXES 中定义的可执行文件。</span><br>\trm -f <span class=\"hljs-variable\">$(EXES)</span><br><br><span class=\"hljs-comment\"># .PHONY 是一个特殊的标志，用于声明 &#x27;all&#x27; 和 &#x27;clean&#x27; 目标是伪目标。</span><br><span class=\"hljs-comment\"># 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: all clean</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"多个C文件生成一个可执行文件（只有一个main函数）\"><a href=\"#多个C文件生成一个可执行文件（只有一个main函数）\" class=\"headerlink\" title=\"多个C文件生成一个可执行文件（只有一个main函数）\"></a>多个C文件生成一个可执行文件（只有一个main函数）</h4><p>下面的代码是一个文件夹所有c文件只生成一个可执行文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义编译器为 gcc。这个变量可以在 make 命令行中覆盖。</span><br>CC = gcc<br><br><span class=\"hljs-comment\"># 定义编译选项：</span><br><span class=\"hljs-comment\"># -Wall：启用所有常见的编译警告。</span><br><span class=\"hljs-comment\"># -g：生成调试信息，用于调试程序。</span><br>CFLAGS = -Wall -g<br><br><span class=\"hljs-comment\"># 使用 wildcard 函数查找当前目录下所有以 .c 结尾的文件</span><br><span class=\"hljs-comment\"># $(wildcard *.c) 会返回一个以空格分隔的 C 源文件列表</span><br>SRCS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span><br><br><span class=\"hljs-comment\"># 生成与当前目录同名的可执行文件名</span><br><span class=\"hljs-comment\"># 使用 notdir 和 basename 函数提取当前目录名并生成对应的可执行文件名</span><br>EXE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">notdir</span> <span class=\"hljs-variable\">$(CURDIR)</span>)</span><br><br><span class=\"hljs-comment\"># 默认目标：&#x27;all&#x27; 目标是 Makefile 的默认目标。</span><br><span class=\"hljs-comment\"># 如果运行 `make` 而不指定目标，默认会执行 &#x27;all&#x27; 目标。</span><br><span class=\"hljs-comment\"># 这个目标依赖于生成的可执行文件。</span><br><span class=\"hljs-section\">all: <span class=\"hljs-variable\">$(EXE)</span></span><br><br><span class=\"hljs-comment\"># 规则：如何从源文件生成可执行文件。</span><br><span class=\"hljs-comment\"># $@ 表示目标文件（即可执行文件名）。</span><br><span class=\"hljs-comment\"># $^ 表示所有的依赖文件（即所有的源文件）。</span><br><span class=\"hljs-variable\">$(EXE)</span>: <span class=\"hljs-variable\">$(SRCS)</span><br><br><span class=\"hljs-comment\"># 使用 gcc 编译源文件，生成一个与文件夹同名的可执行文件。</span><br>\t<span class=\"hljs-variable\">$(CC)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> -o <span class=\"hljs-variable\">$@</span> <span class=\"hljs-variable\">$^</span><br><br><span class=\"hljs-comment\"># 编译完成后，输出生成的可执行文件的名称。</span><br><span class=\"hljs-comment\"># @ 使这条命令不在命令行中显示，只显示输出的结果。</span><br>\t@echo <span class=\"hljs-string\">&quot;Compiled <span class=\"hljs-variable\">$@</span>&quot;</span><br><br><span class=\"hljs-comment\"># 清理目标：&#x27;clean&#x27; 是一个伪目标，用于删除生成的可执行文件。</span><br><span class=\"hljs-comment\"># 这是为了保持工作目录的清洁，并且通常用在重新编译前。</span><br><span class=\"hljs-section\">clean:</span><br><br><span class=\"hljs-comment\"># 删除生成的可执行文件。</span><br>\trm -f <span class=\"hljs-variable\">$(EXE)</span><br><br><span class=\"hljs-comment\"># .PHONY 是一个特殊的标志，用于声明 &#x27;all&#x27; 和 &#x27;clean&#x27; 目标是伪目标。</span><br><span class=\"hljs-comment\"># 伪目标不对应实际的文件名，它们是为了方便定义的一些操作或命令。</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: all clean</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"多文件夹的Makefile编译\"><a href=\"#多文件夹的Makefile编译\" class=\"headerlink\" title=\"多文件夹的Makefile编译\"></a>多文件夹的Makefile编译</h2><p>上面的makefile只能编译一个文件夹，如果我想在主文件夹编译所有文件夹，就需要写一个总的Makefile来对所有的文件夹进行调用</p>\n<p>假设我的文件框架如下</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">project/<br>├── Makefile<br>├── src/<br>│   ├── file<span class=\"hljs-number\">1</span>.<span class=\"hljs-keyword\">c</span><br>│   ├── file<span class=\"hljs-number\">2</span>.<span class=\"hljs-keyword\">c</span><br>│   └── Makefile<br>├── lib/<br>│   ├── file<span class=\"hljs-number\">3</span>.<span class=\"hljs-keyword\">c</span><br>│   └── Makefile<br>└── include/<br>    └── file<span class=\"hljs-number\">4</span>.<span class=\"hljs-keyword\">c</span><br></code></pre></td></tr></table></figure>\n\n<p>所以主文件夹的Makefile文件内容如下</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"># 主Makefile<br><br># 定义子目录的变量<br># 这里 SUBDIRS 包含了所有需要编译的子目录，并将它们分行排列以便清晰展示<br>SUBDIRS = \\<br>    src \\<br>    lib \\<br>    include<br><br># 默认目标是编译所有子目录<br># 当用户只输入 `make` 而不指定具体目标时，`all` 目标会被执行<br><span class=\"hljs-title\">all:</span> $(SUBDIRS)<br><br># 对于每个子目录，调用 `make` 命令并进入该目录 (`-C` 选项)<br># 这会在每个子目录中执行它们自己的 `Makefile`<br><span class=\"hljs-title\">$(SUBDIRS):</span><br>\t$(MAKE) -C $@<br><br># 清理所有子目录的目标<br># 这里定义了 `clean` 目标，当用户运行 `make clean` 时会被执行<br># 这个目标会遍历所有子目录，并在每个子目录中执行 `make clean`<br><span class=\"hljs-title\">clean:</span><br># 遍历所有子目录,在每个子目录中执行 `make clean`<br>\tfor dir in $(SUBDIRS)<span class=\"hljs-comment\">; do \\</span><br>\t\t$(MAKE) -C $$dir clean<span class=\"hljs-comment\">; \\</span><br>\tdone<br><br># 伪目标声明<br># .PHONY 是一个特殊的伪目标声明，表示 `all`, `clean`, `$(SUBDIRS)` 等目标不对应实际文件<br># 即使当前目录下存在名为 `all` 或 `clean` 的文件，它们也不会被作为目标，而是执行与之对应的命令<br><span class=\"hljs-title\">.PHONY:</span> all clean $(SUBDIRS)<br></code></pre></td></tr></table></figure>\n\n<p>完成这个编写之后呢，就可以在主文件或者子文件夹随便执行编译</p>\n<h2 id=\"文件编译操作\"><a href=\"#文件编译操作\" class=\"headerlink\" title=\"文件编译操作\"></a>文件编译操作</h2><p>完成该文件创建和内容编写，就可以开始执行，执行前先清除原有的编译文件</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">make clean</span><br></code></pre></td></tr></table></figure>\n\n<p>再执行编译文件</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">make</span><br></code></pre></td></tr></table></figure>\n\n<p>最后输出一个可执行的脚本，输入即可执行</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">./<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"STM32的I2C通信学习","date":"2024-08-17T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/15/LZ7VJDqv4sKMilB.jpg","_content":"\n# STM32的I2C通信学习\n\n## 基本知识\n\nIIC总线上最好接一个4.7k的上拉电阻，可以防止互相干扰，SDL、SCL都接，上拉电阻接3.3v电源\n\nI2C的使用主要有两根总线，一根是SDL，一根是SDA，SDL上面主要连接的是时钟，SDA主要用来发送数据\n\n所有的设备都是连接在这两个总线上面，单次只能实现一个数据通信，因为通信会占用总线\n\n设备的对接基于I2C的地址分配，每个传感器在出厂的时候基本上是固定好I2C的地址，所以我们只需要输入发送这个地址，就能通过I2C找到这个设备，并把数据发给他\n\n在两个设备通信的过程中，其他的设备都处于高阻态状态，也就是等于断路，如果需要发送数据时，将会连接退出高阻态模式\n\nI2C在通信的过程中由于SDA线他发送数据时存在的干扰性比较强，所以其他设备无法知晓其是否发送成功，并且也无法表示什么时候开始发送，什么时候结束\n\n这个时候就需要SCL总线来协助，SCL是时钟线，当时钟线拉高的时候，SDA线也发送标志位，才表示数据开始发送，并且每个发送的位数据都必须在SCL总线有反应的情况下才算是数据，其他情况皆为干扰信号，不进行读取\n\nSTM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。\n\n## I2C系统配置\n\n因为I2C的引脚还是GPIO，所以我们在使用的时候，需要配置GPIO口，如之前配置所示\n\n```\n\tGPIO_InitTypeDef I2C_GPIO_InitStructure;  //初始化GPIO结构体\n\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\t\n\t//配置I2C SCL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n\t\n\t//配置I2C SDL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n```\n\n在选择上需要注意的是，引脚需要所有都改成复用浮空输入，复用代表着这个原先是GPIO的引脚被复用到了IIC所以，需要改成复用浮空输入\n\n在使用I2C引脚，就需要打开I2C的时钟\n\n```\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n```\n\n之后就需要配置I2C引脚的初始化\n\nI2C的配置主要为ACK使能，这个配置会在每次发送单字节数据结束后，发送一个方波，用来给下位机判别字节的结束，这个类似于换行符\n\n```\n\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;//配置i2c的应答使能\n```\n\nI2C的地址通常配置为7位，因为还有一位决定的是读和写，总共加起来8位数据\n\n```\n\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;//配置接收字节为7，还有一位是读写位\n```\n\n时钟的配置上可以直接选择400k，其中的计算过程如下\n\n```\n\tI2C_InitStructure.I2C_ClockSpeed = 400000;//配置配置SCL时钟频率为400k\n```\n\n```\n    标准模式：\n    Thigh=CCR*TPCKL1 Tlow = CCR*TPCLK1\n    快速模式中 Tlow/Thigh=2 时：\n    Thigh = CCR*TPCKL1 Tlow = 2*CCR*TPCKL1\n    快速模式中 Tlow/Thigh=16/9 时：\n    Thigh = 9*CCR*TPCKL1 Tlow = 16*CCR*TPCKL1\n\n    例如，我们的PCLK1=36MHz，想要配置400Kbit/s的速率，计算方式如下：\n\n    PCLK时钟周期： TPCLK1 = 1/36000000\n    目标SCL时钟周期： TSCL = 1/400000\n    SCL时钟周期内的高电平时间： THIGH = TSCL/3\n    SCL时钟周期内的低电平时间： TLOW = 2*TSCL/3\n    计算CCR的值： CCR = THIGH/TPCLK1 = 30\n```\n\n再就是占空比设置，这个影响不大，可以直接默认即可\n\n```\n\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;//配置占空比位2:1\n```\n\n模式采用I2C模式，还有一种SMBA通信，几乎不使用，所以直接配置I2C模式\n\n```\n\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;//配置为I2C模式，其他模式不考虑\n```\n\n我们还需要给MCU分配一个地址，这个是主机地址，可以用来和主机通信的地址\n\n```\n\tI2C_InitStructure.I2C_OwnAddress1 = 0x0A;//给主机一个地址，用于识别，随便定义七位的就行\n```\n\n完成所有结构体值的赋值，就需要对结构配置\n\n```\n\tI2C_Init(I2C1, &I2C_InitStructure);//结构体初始化\n```\n\n配置的最后一步是对I2C进行使能，以供使用\n\n```\n\t// 使能串口\n\tI2C_Cmd (I2C1, ENABLE);\t\n```\n\n## I2C单字节和多字节发送\n\nI2C的发送主要遵循两个图，单字节的和多字节的去别其实在于数据的多次发送\n\n![image.png](https://s2.loli.net/2024/08/18/oAU1rEYX9MjDPp4.png)\n\n我们实验里面采用的是EEPROM的读写，所以还需要发送EEPROM的读写位置，但是这个读写位置并不是他的地址，而是类似数据格式进行发送，由EEPROM自动判断其位置\n\n因此从这个图可以看出来，我们的发送步骤是\n\n1.发送起始位信号\n\n```\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n```\n\n2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功\n\n```\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  \t{\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);//超时等待函数，在最下面有介绍\n  \t}\n```\n\n3.发送设备地址(地址最后一位是是写方向)\n\n```\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Receiver);\n```\n\n4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)\n\n```\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  \t{\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  \t}\n```\n\n5.发送数据\n\n```\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n```\n\n6.（仅限单数据）发送数据，并使用EV8校验TxE是否置1，以此确定数据是否发送成功(在这边可能会出现一个bug，就是EV8和EV8_2的标识符太像了，导致你忘记用EV8_2，就会出现数据无法读取，所以我们有一个妙招，所有的数据位不用EV8校验，全部用EV8_2校验即可)\n\n```\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n\t\n\t//EV8_2最后位数据校验是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(4);\n  }\n```\n\n6.（仅限多数据）使用循环判断，直到数据完全发送成功\n\n```\n\t//循环执行发送函数，直到发送完毕\n\twhile(NumByteToRead--)  \n  {\n\t//发送数据\n    I2C_SendData(I2C1, *data);\n    //指针右移一位准备接收下一个数据\n    data++; \n\t\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(14);\n\t\t}\n  }\n```\n\n7.发送停止位信号\n\n```\n\t//发送结束信号\n\tI2C_GenerateSTOP(I2C1,ENABLE);\n```\n\n## I2C读取数据\n\n读取数据的话，也是遵循一个读取的图表\n\n![image.png](https://s2.loli.net/2024/08/18/ZlPnMOIbRqB52iS.png)\n\n接收的步骤是\n\n1.发送起始位信号\n\n```\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n```\n\n2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功\n\n```\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);\n  }\n```\n\n3.发送设备地址(地址最后一位是是读方向)\n\n```\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Receiver\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Receiver);\n\t\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  }\n```\n\n4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)\n\n```\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  }\n```\n\n5.读取数据，使用循环判断，直到数据接收完成，在最后一位的时候，关闭ACK信号，并且发送停止位\n\n```\n\twhile(NumByteToRead)  \n  \t{\n\t\t//如果只有一位数据，则直接发送结束信号和停止信号\n        if(NumByteToRead == 1)\n        {\n          //读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭\n          I2C_AcknowledgeConfig(I2C1, DISABLE);\n\n          //发送停止位\n          I2C_GenerateSTOP(I2C1, ENABLE);\n        }\n    \n\t\t//EV7校验数据是否接收成功\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))//EV6是检测地址是否发送成功\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(10);\n\t\t}\n        //接收数据到指针\n        *data = I2C_ReceiveData(I2C1);\n\n        //指针右移一位准备接收下一个数据\n        data++; \n\n        //数据长度减少，等到没有数据时，退出函数\n        NumByteToRead--;  \n  \t}\n```\n\n6.重启应答信号，方便下次使用\n\n```\n\t//重启应答信号，防止下次接收失败\n  I2C_AcknowledgeConfig(I2C1, ENABLE);\n```\n\n## I2C发送接收校验\n\n这个主要用于防止数据发送过程中出现死循环情况，出错会返回错误码\n\n```\n\tstatic __IO uint32_t  I2CTimeout = 10*(0x1000); \n\tstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n```\n\n## I2C发送超时等待函数\n\n这个函数主要用在发送或者接收的使用，由于MCU的执行速度很快，可能还没有完全写完或者读完，就执行下一程序，导致数据错误，所以需要编写一个等待函数，使用标志位进行读取，读取到代表已经全部写入或者读取，既可以继续执行其他程序\n\n```\nvoid EEPROM_WaitForWriteEnd(void)\n{\n\tdo\n\t{\n\t\t//产生起始信号\n\t\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\t\n\t\t//判断SB位是否被重置\n\t\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_SB) == RESET);\n\t\t\n\t\t//EV5事件被检测到，发送设备地址\n\t\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\t}  \n\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_ADDR) == RESET );\n\n\t//EEPROM内部时序完成传输完成\n\tI2C_GenerateSTOP(I2C1,ENABLE);\t\n}\n```\n\n## 总程序代码\n\n### I2C.c\n\n```\n#include \"bsp_i2c.h\"\n#include \"bsp_usart.h\"\n\nstatic __IO uint32_t  I2CTimeout = 10*(0x1000); \n\nstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n{\n  /* Block communication and all processes */\n  printf(\"I2C 等待超时!errorCode = %d\",errorCode);\n  \n  return 0;\n}\n\nvoid I2C_config(void)\n{\n\tGPIO_InitTypeDef I2C_GPIO_InitStructure;  //初始化GPIO结构体\n\tI2C_InitTypeDef  I2C_InitStructure;  //初始化I2C结构体\n\t\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\t\n\t//打开I2C的时钟\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);\n\t\n\t//配置I2C SCL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n\t\n\t//配置I2C SDL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n\t\n\t//初始化I2C结构体\n\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;//配置i2c的应答使能\n\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;//配置接收字节为7，还有一位是读写位\n\tI2C_InitStructure.I2C_ClockSpeed = 400000;//配置配置SCL时钟频率为400k\n\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;//配置占空比位2:1\n\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;//配置为I2C模式，其他模式不考虑\n\tI2C_InitStructure.I2C_OwnAddress1 = 0x0A;//给主机一个地址，用于识别，随便定义七位的就行\n\tI2C_Init(I2C1, &I2C_InitStructure);//结构体初始化\n\t\n\t// 使能串口\n\tI2C_Cmd (I2C1, ENABLE);\t\n}\n\nuint32_t I2C_ByteWrite(uint8_t addr, uint8_t data)\n{\n\t/************************************************************/\n\t\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }\n\t\n\t/************************************************************/\n\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED ))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(2);\n  }\n\n\t/************************************************************/\n\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n\t\n\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\twhile(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED ))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);\n  }\n\t\n\t/************************************************************/\n\n\t//发送数据\n\tI2C_SendData(I2C1,data);\n\t\n\t//EV8_2最后位数据校验是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(4);\n  }\n\t\n\t/************************************************************/\n\t\n\t//发送结束信号\n\tI2C_GenerateSTOP(I2C1,ENABLE);\n\t\n\treturn 0;\n}\n\nuint32_t I2C_ByteRead(uint8_t addr,uint8_t *data,uint8_t NumByteToRead)\n{\n\t\n\t/************************************************************/\n\t\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);\n  }\n\t\n\t/************************************************************/\n\t\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Receiver);\n\t\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  }\n\t\n\t/************************************************************/\n\t\n\twhile(NumByteToRead)  \n  {\n\t\t//如果只有一位数据，则直接发送结束信号和停止信号\n    if(NumByteToRead == 1)\n    {\n      //读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭\n      I2C_AcknowledgeConfig(I2C1, DISABLE);\n      \n      //发送停止位\n      I2C_GenerateSTOP(I2C1, ENABLE);\n    }\n    \n\t\t//EV7校验数据是否接收成功\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))//EV6是检测地址是否发送成功\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(10);\n\t\t}\n    //接收数据到指针\n    *data = I2C_ReceiveData(I2C1);\n\n    //指针右移一位准备接收下一个数据\n    data++; \n      \n    //数据长度减少，等到没有数据时，退出函数\n    NumByteToRead--;  \n  }\n\t\n\t/************************************************************/\n\t\n\t//重启应答信号，防止下次接收失败\n  I2C_AcknowledgeConfig(I2C1, ENABLE);\n  \n  return 0;\n}\n\nuint32_t I2C_PageWrite(uint8_t addr,uint8_t *data,uint8_t NumByteToRead)\n{\n\t/************************************************************/\n\t\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(11);\n  }\n\t\n\t/************************************************************/\n\t\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\t\n\t//这边跳过ACK位，因为他自动产生脉冲，我们使用EV8对他进行检测，这边选择忽略，不检测\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(12);\n  }\n\t\n\t/************************************************************/\n\t\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n\t\n\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(13);\n  }\n\t\n\t/************************************************************/\n\t\n\t//循环执行发送函数，直到发送完毕\n\twhile(NumByteToRead--)  \n  {\n\t\t//发送数据\n    I2C_SendData(I2C1, *data);\n    //指针右移一位准备接收下一个数据\n    data++; \n\t\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(14);\n\t\t}\n  }\n\t\n\t/************************************************************/\n\t\n\t//发送结束信号\n\tI2C_GenerateSTOP(I2C1,ENABLE);\n\t\n\treturn 0;\n}\n\nvoid EEPROM_WaitForWriteEnd(void)\n{\n\tdo\n\t{\n\t\t//产生起始信号\n\t\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\t\n\t\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_SB) == RESET);\n\t\t\n\t\t//EV5事件被检测到，发送设备地址\n\t\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\t}  \n\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_ADDR) == RESET );\n\n\t//EEPROM内部时序完成传输完成\n\tI2C_GenerateSTOP(I2C1,ENABLE);\t\n}\n```\n\n### I2C.h\n\n```\n#ifndef __BSP_I2C_H\n#define __BSP_I2C_H\n\n#include \"stm32f10x.h\"\n\nvoid I2C_config(void);\nuint32_t I2C_ByteWrite(uint8_t addr, uint8_t data);\nuint32_t I2C_ByteRead(uint8_t addr,uint8_t *data,uint8_t NumByteToRead);\nuint32_t I2C_PageWrite(uint8_t addr,uint8_t *data,uint8_t NumByteToRead);\nvoid EEPROM_WaitForWriteEnd(void);\n\n#endif  /* __BSP_I2C_H */\n```\n\n### main.c\n\n```\n#include \"stm32f10x.h\"//相当于51单片机中的#include <reg51.h>\n#include \"bsp_led.h\"\n#include \"bsp_rccclkconfig.h\"\n#include \"bsp_exti.h\"\n#include \"bsp_systick.h\"\n#include \"bsp_usart.h\"\n#include <stdio.h>\n#include \"bsp_dma.h\"\n#include \"bsp_usart.h\"\n#include \"bsp_i2c.h\"\n\nuint8_t readData[8]={0};\nuint8_t writeData[8]={4,5,6,7,8,9,10,11};\n\nint main (void)\n{\t\n\tuint8_t i=0;\n  /*初始化USART 配置模式为 115200 8-N-1，中断接收*/\n  USART_Config();\n\t\n\t/* 发送一个字符串 */\n\tprintf(\"这是一个IIC通讯实验\\n\");\n\t\n\t//初始化IIC\n\tI2C_config();\n\n\t//写入一个字节\n\tI2C_ByteWrite(11,55);\n\t\n\t//等待写入操作完成\n\tEEPROM_WaitForWriteEnd();\n\t\n\t//写入一个字节\n\tI2C_ByteWrite(12,52);\n\t\n\t//等待写入操作完成\n\tEEPROM_WaitForWriteEnd();\n\t\n\t//addr%8 == 0 ,即为地址对齐\n\tI2C_PageWrite(16,writeData,8);\n\t\n\t//等待写入操作完成\n\tEEPROM_WaitForWriteEnd();\n\t\n\t//读取数据\n\tI2C_ByteRead(16,readData,8);\n\t\n\t\n\tfor(i=0;i<8;i++)\n\t{\t\n\t\tprintf(\"%d \",readData[i]);\t\n\t}\n\tprintf(\"111111111111111111\");\n\t\n  while(1)\n\t{\t\n\t\t\n\t}\t\n}\n```\n\n","source":"_posts/STM32的I2C学习.md","raw":"---\ntitle: STM32的I2C通信学习\ntag: I2C\ndate: 2024-08-18\ncategories: STM32\nindex_img: https://s2.loli.net/2024/08/15/LZ7VJDqv4sKMilB.jpg\n---\n\n# STM32的I2C通信学习\n\n## 基本知识\n\nIIC总线上最好接一个4.7k的上拉电阻，可以防止互相干扰，SDL、SCL都接，上拉电阻接3.3v电源\n\nI2C的使用主要有两根总线，一根是SDL，一根是SDA，SDL上面主要连接的是时钟，SDA主要用来发送数据\n\n所有的设备都是连接在这两个总线上面，单次只能实现一个数据通信，因为通信会占用总线\n\n设备的对接基于I2C的地址分配，每个传感器在出厂的时候基本上是固定好I2C的地址，所以我们只需要输入发送这个地址，就能通过I2C找到这个设备，并把数据发给他\n\n在两个设备通信的过程中，其他的设备都处于高阻态状态，也就是等于断路，如果需要发送数据时，将会连接退出高阻态模式\n\nI2C在通信的过程中由于SDA线他发送数据时存在的干扰性比较强，所以其他设备无法知晓其是否发送成功，并且也无法表示什么时候开始发送，什么时候结束\n\n这个时候就需要SCL总线来协助，SCL是时钟线，当时钟线拉高的时候，SDA线也发送标志位，才表示数据开始发送，并且每个发送的位数据都必须在SCL总线有反应的情况下才算是数据，其他情况皆为干扰信号，不进行读取\n\nSTM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。\n\n## I2C系统配置\n\n因为I2C的引脚还是GPIO，所以我们在使用的时候，需要配置GPIO口，如之前配置所示\n\n```\n\tGPIO_InitTypeDef I2C_GPIO_InitStructure;  //初始化GPIO结构体\n\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\t\n\t//配置I2C SCL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n\t\n\t//配置I2C SDL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n```\n\n在选择上需要注意的是，引脚需要所有都改成复用浮空输入，复用代表着这个原先是GPIO的引脚被复用到了IIC所以，需要改成复用浮空输入\n\n在使用I2C引脚，就需要打开I2C的时钟\n\n```\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n```\n\n之后就需要配置I2C引脚的初始化\n\nI2C的配置主要为ACK使能，这个配置会在每次发送单字节数据结束后，发送一个方波，用来给下位机判别字节的结束，这个类似于换行符\n\n```\n\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;//配置i2c的应答使能\n```\n\nI2C的地址通常配置为7位，因为还有一位决定的是读和写，总共加起来8位数据\n\n```\n\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;//配置接收字节为7，还有一位是读写位\n```\n\n时钟的配置上可以直接选择400k，其中的计算过程如下\n\n```\n\tI2C_InitStructure.I2C_ClockSpeed = 400000;//配置配置SCL时钟频率为400k\n```\n\n```\n    标准模式：\n    Thigh=CCR*TPCKL1 Tlow = CCR*TPCLK1\n    快速模式中 Tlow/Thigh=2 时：\n    Thigh = CCR*TPCKL1 Tlow = 2*CCR*TPCKL1\n    快速模式中 Tlow/Thigh=16/9 时：\n    Thigh = 9*CCR*TPCKL1 Tlow = 16*CCR*TPCKL1\n\n    例如，我们的PCLK1=36MHz，想要配置400Kbit/s的速率，计算方式如下：\n\n    PCLK时钟周期： TPCLK1 = 1/36000000\n    目标SCL时钟周期： TSCL = 1/400000\n    SCL时钟周期内的高电平时间： THIGH = TSCL/3\n    SCL时钟周期内的低电平时间： TLOW = 2*TSCL/3\n    计算CCR的值： CCR = THIGH/TPCLK1 = 30\n```\n\n再就是占空比设置，这个影响不大，可以直接默认即可\n\n```\n\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;//配置占空比位2:1\n```\n\n模式采用I2C模式，还有一种SMBA通信，几乎不使用，所以直接配置I2C模式\n\n```\n\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;//配置为I2C模式，其他模式不考虑\n```\n\n我们还需要给MCU分配一个地址，这个是主机地址，可以用来和主机通信的地址\n\n```\n\tI2C_InitStructure.I2C_OwnAddress1 = 0x0A;//给主机一个地址，用于识别，随便定义七位的就行\n```\n\n完成所有结构体值的赋值，就需要对结构配置\n\n```\n\tI2C_Init(I2C1, &I2C_InitStructure);//结构体初始化\n```\n\n配置的最后一步是对I2C进行使能，以供使用\n\n```\n\t// 使能串口\n\tI2C_Cmd (I2C1, ENABLE);\t\n```\n\n## I2C单字节和多字节发送\n\nI2C的发送主要遵循两个图，单字节的和多字节的去别其实在于数据的多次发送\n\n![image.png](https://s2.loli.net/2024/08/18/oAU1rEYX9MjDPp4.png)\n\n我们实验里面采用的是EEPROM的读写，所以还需要发送EEPROM的读写位置，但是这个读写位置并不是他的地址，而是类似数据格式进行发送，由EEPROM自动判断其位置\n\n因此从这个图可以看出来，我们的发送步骤是\n\n1.发送起始位信号\n\n```\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n```\n\n2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功\n\n```\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  \t{\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);//超时等待函数，在最下面有介绍\n  \t}\n```\n\n3.发送设备地址(地址最后一位是是写方向)\n\n```\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Receiver);\n```\n\n4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)\n\n```\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  \t{\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  \t}\n```\n\n5.发送数据\n\n```\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n```\n\n6.（仅限单数据）发送数据，并使用EV8校验TxE是否置1，以此确定数据是否发送成功(在这边可能会出现一个bug，就是EV8和EV8_2的标识符太像了，导致你忘记用EV8_2，就会出现数据无法读取，所以我们有一个妙招，所有的数据位不用EV8校验，全部用EV8_2校验即可)\n\n```\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n\t\n\t//EV8_2最后位数据校验是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(4);\n  }\n```\n\n6.（仅限多数据）使用循环判断，直到数据完全发送成功\n\n```\n\t//循环执行发送函数，直到发送完毕\n\twhile(NumByteToRead--)  \n  {\n\t//发送数据\n    I2C_SendData(I2C1, *data);\n    //指针右移一位准备接收下一个数据\n    data++; \n\t\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(14);\n\t\t}\n  }\n```\n\n7.发送停止位信号\n\n```\n\t//发送结束信号\n\tI2C_GenerateSTOP(I2C1,ENABLE);\n```\n\n## I2C读取数据\n\n读取数据的话，也是遵循一个读取的图表\n\n![image.png](https://s2.loli.net/2024/08/18/ZlPnMOIbRqB52iS.png)\n\n接收的步骤是\n\n1.发送起始位信号\n\n```\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n```\n\n2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功\n\n```\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);\n  }\n```\n\n3.发送设备地址(地址最后一位是是读方向)\n\n```\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Receiver\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Receiver);\n\t\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  }\n```\n\n4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)\n\n```\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  }\n```\n\n5.读取数据，使用循环判断，直到数据接收完成，在最后一位的时候，关闭ACK信号，并且发送停止位\n\n```\n\twhile(NumByteToRead)  \n  \t{\n\t\t//如果只有一位数据，则直接发送结束信号和停止信号\n        if(NumByteToRead == 1)\n        {\n          //读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭\n          I2C_AcknowledgeConfig(I2C1, DISABLE);\n\n          //发送停止位\n          I2C_GenerateSTOP(I2C1, ENABLE);\n        }\n    \n\t\t//EV7校验数据是否接收成功\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))//EV6是检测地址是否发送成功\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(10);\n\t\t}\n        //接收数据到指针\n        *data = I2C_ReceiveData(I2C1);\n\n        //指针右移一位准备接收下一个数据\n        data++; \n\n        //数据长度减少，等到没有数据时，退出函数\n        NumByteToRead--;  \n  \t}\n```\n\n6.重启应答信号，方便下次使用\n\n```\n\t//重启应答信号，防止下次接收失败\n  I2C_AcknowledgeConfig(I2C1, ENABLE);\n```\n\n## I2C发送接收校验\n\n这个主要用于防止数据发送过程中出现死循环情况，出错会返回错误码\n\n```\n\tstatic __IO uint32_t  I2CTimeout = 10*(0x1000); \n\tstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n```\n\n## I2C发送超时等待函数\n\n这个函数主要用在发送或者接收的使用，由于MCU的执行速度很快，可能还没有完全写完或者读完，就执行下一程序，导致数据错误，所以需要编写一个等待函数，使用标志位进行读取，读取到代表已经全部写入或者读取，既可以继续执行其他程序\n\n```\nvoid EEPROM_WaitForWriteEnd(void)\n{\n\tdo\n\t{\n\t\t//产生起始信号\n\t\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\t\n\t\t//判断SB位是否被重置\n\t\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_SB) == RESET);\n\t\t\n\t\t//EV5事件被检测到，发送设备地址\n\t\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\t}  \n\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_ADDR) == RESET );\n\n\t//EEPROM内部时序完成传输完成\n\tI2C_GenerateSTOP(I2C1,ENABLE);\t\n}\n```\n\n## 总程序代码\n\n### I2C.c\n\n```\n#include \"bsp_i2c.h\"\n#include \"bsp_usart.h\"\n\nstatic __IO uint32_t  I2CTimeout = 10*(0x1000); \n\nstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n{\n  /* Block communication and all processes */\n  printf(\"I2C 等待超时!errorCode = %d\",errorCode);\n  \n  return 0;\n}\n\nvoid I2C_config(void)\n{\n\tGPIO_InitTypeDef I2C_GPIO_InitStructure;  //初始化GPIO结构体\n\tI2C_InitTypeDef  I2C_InitStructure;  //初始化I2C结构体\n\t\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\t\n\t//打开I2C的时钟\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);\n\t\n\t//配置I2C SCL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n\t\n\t//配置I2C SDL引脚\n\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOB, &I2C_GPIO_InitStructure);\n\t\n\t//初始化I2C结构体\n\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;//配置i2c的应答使能\n\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;//配置接收字节为7，还有一位是读写位\n\tI2C_InitStructure.I2C_ClockSpeed = 400000;//配置配置SCL时钟频率为400k\n\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;//配置占空比位2:1\n\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;//配置为I2C模式，其他模式不考虑\n\tI2C_InitStructure.I2C_OwnAddress1 = 0x0A;//给主机一个地址，用于识别，随便定义七位的就行\n\tI2C_Init(I2C1, &I2C_InitStructure);//结构体初始化\n\t\n\t// 使能串口\n\tI2C_Cmd (I2C1, ENABLE);\t\n}\n\nuint32_t I2C_ByteWrite(uint8_t addr, uint8_t data)\n{\n\t/************************************************************/\n\t\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }\n\t\n\t/************************************************************/\n\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED ))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(2);\n  }\n\n\t/************************************************************/\n\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n\t\n\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\twhile(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED ))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);\n  }\n\t\n\t/************************************************************/\n\n\t//发送数据\n\tI2C_SendData(I2C1,data);\n\t\n\t//EV8_2最后位数据校验是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(4);\n  }\n\t\n\t/************************************************************/\n\t\n\t//发送结束信号\n\tI2C_GenerateSTOP(I2C1,ENABLE);\n\t\n\treturn 0;\n}\n\nuint32_t I2C_ByteRead(uint8_t addr,uint8_t *data,uint8_t NumByteToRead)\n{\n\t\n\t/************************************************************/\n\t\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);\n  }\n\t\n\t/************************************************************/\n\t\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Receiver);\n\t\n\t//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n  }\n\t\n\t/************************************************************/\n\t\n\twhile(NumByteToRead)  \n  {\n\t\t//如果只有一位数据，则直接发送结束信号和停止信号\n    if(NumByteToRead == 1)\n    {\n      //读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭\n      I2C_AcknowledgeConfig(I2C1, DISABLE);\n      \n      //发送停止位\n      I2C_GenerateSTOP(I2C1, ENABLE);\n    }\n    \n\t\t//EV7校验数据是否接收成功\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))//EV6是检测地址是否发送成功\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(10);\n\t\t}\n    //接收数据到指针\n    *data = I2C_ReceiveData(I2C1);\n\n    //指针右移一位准备接收下一个数据\n    data++; \n      \n    //数据长度减少，等到没有数据时，退出函数\n    NumByteToRead--;  \n  }\n\t\n\t/************************************************************/\n\t\n\t//重启应答信号，防止下次接收失败\n  I2C_AcknowledgeConfig(I2C1, ENABLE);\n  \n  return 0;\n}\n\nuint32_t I2C_PageWrite(uint8_t addr,uint8_t *data,uint8_t NumByteToRead)\n{\n\t/************************************************************/\n\t\n\t//发送起始信号\n\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\n\t//EV5是校验起始信号发送情况\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(11);\n  }\n\t\n\t/************************************************************/\n\t\n\t//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter\n\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\t\n\t//这边跳过ACK位，因为他自动产生脉冲，我们使用EV8对他进行检测，这边选择忽略，不检测\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))//EV6是检测地址是否发送成功\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(12);\n  }\n\t\n\t/************************************************************/\n\t\n\t//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址\n\tI2C_SendData(I2C1,addr);\n\t\n\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(13);\n  }\n\t\n\t/************************************************************/\n\t\n\t//循环执行发送函数，直到发送完毕\n\twhile(NumByteToRead--)  \n  {\n\t\t//发送数据\n    I2C_SendData(I2C1, *data);\n    //指针右移一位准备接收下一个数据\n    data++; \n\t\t//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)\n\t\twhile(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))\n\t\t{\n\t\t\tif((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(14);\n\t\t}\n  }\n\t\n\t/************************************************************/\n\t\n\t//发送结束信号\n\tI2C_GenerateSTOP(I2C1,ENABLE);\n\t\n\treturn 0;\n}\n\nvoid EEPROM_WaitForWriteEnd(void)\n{\n\tdo\n\t{\n\t\t//产生起始信号\n\t\tI2C_GenerateSTART(I2C1,ENABLE);\n\t\t\n\t\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_SB) == RESET);\n\t\t\n\t\t//EV5事件被检测到，发送设备地址\n\t\tI2C_Send7bitAddress(I2C1,0xA0,I2C_Direction_Transmitter);\n\t}  \n\twhile(I2C_GetFlagStatus (I2C1,I2C_FLAG_ADDR) == RESET );\n\n\t//EEPROM内部时序完成传输完成\n\tI2C_GenerateSTOP(I2C1,ENABLE);\t\n}\n```\n\n### I2C.h\n\n```\n#ifndef __BSP_I2C_H\n#define __BSP_I2C_H\n\n#include \"stm32f10x.h\"\n\nvoid I2C_config(void);\nuint32_t I2C_ByteWrite(uint8_t addr, uint8_t data);\nuint32_t I2C_ByteRead(uint8_t addr,uint8_t *data,uint8_t NumByteToRead);\nuint32_t I2C_PageWrite(uint8_t addr,uint8_t *data,uint8_t NumByteToRead);\nvoid EEPROM_WaitForWriteEnd(void);\n\n#endif  /* __BSP_I2C_H */\n```\n\n### main.c\n\n```\n#include \"stm32f10x.h\"//相当于51单片机中的#include <reg51.h>\n#include \"bsp_led.h\"\n#include \"bsp_rccclkconfig.h\"\n#include \"bsp_exti.h\"\n#include \"bsp_systick.h\"\n#include \"bsp_usart.h\"\n#include <stdio.h>\n#include \"bsp_dma.h\"\n#include \"bsp_usart.h\"\n#include \"bsp_i2c.h\"\n\nuint8_t readData[8]={0};\nuint8_t writeData[8]={4,5,6,7,8,9,10,11};\n\nint main (void)\n{\t\n\tuint8_t i=0;\n  /*初始化USART 配置模式为 115200 8-N-1，中断接收*/\n  USART_Config();\n\t\n\t/* 发送一个字符串 */\n\tprintf(\"这是一个IIC通讯实验\\n\");\n\t\n\t//初始化IIC\n\tI2C_config();\n\n\t//写入一个字节\n\tI2C_ByteWrite(11,55);\n\t\n\t//等待写入操作完成\n\tEEPROM_WaitForWriteEnd();\n\t\n\t//写入一个字节\n\tI2C_ByteWrite(12,52);\n\t\n\t//等待写入操作完成\n\tEEPROM_WaitForWriteEnd();\n\t\n\t//addr%8 == 0 ,即为地址对齐\n\tI2C_PageWrite(16,writeData,8);\n\t\n\t//等待写入操作完成\n\tEEPROM_WaitForWriteEnd();\n\t\n\t//读取数据\n\tI2C_ByteRead(16,readData,8);\n\t\n\t\n\tfor(i=0;i<8;i++)\n\t{\t\n\t\tprintf(\"%d \",readData[i]);\t\n\t}\n\tprintf(\"111111111111111111\");\n\t\n  while(1)\n\t{\t\n\t\t\n\t}\t\n}\n```\n\n","slug":"STM32的I2C学习","published":1,"updated":"2024-09-02T02:48:31.650Z","_id":"cm0kedtpm0000psfbglhv2qu0","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"STM32的I2C通信学习\"><a href=\"#STM32的I2C通信学习\" class=\"headerlink\" title=\"STM32的I2C通信学习\"></a>STM32的I2C通信学习</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>IIC总线上最好接一个4.7k的上拉电阻，可以防止互相干扰，SDL、SCL都接，上拉电阻接3.3v电源</p>\n<p>I2C的使用主要有两根总线，一根是SDL，一根是SDA，SDL上面主要连接的是时钟，SDA主要用来发送数据</p>\n<p>所有的设备都是连接在这两个总线上面，单次只能实现一个数据通信，因为通信会占用总线</p>\n<p>设备的对接基于I2C的地址分配，每个传感器在出厂的时候基本上是固定好I2C的地址，所以我们只需要输入发送这个地址，就能通过I2C找到这个设备，并把数据发给他</p>\n<p>在两个设备通信的过程中，其他的设备都处于高阻态状态，也就是等于断路，如果需要发送数据时，将会连接退出高阻态模式</p>\n<p>I2C在通信的过程中由于SDA线他发送数据时存在的干扰性比较强，所以其他设备无法知晓其是否发送成功，并且也无法表示什么时候开始发送，什么时候结束</p>\n<p>这个时候就需要SCL总线来协助，SCL是时钟线，当时钟线拉高的时候，SDA线也发送标志位，才表示数据开始发送，并且每个发送的位数据都必须在SCL总线有反应的情况下才算是数据，其他情况皆为干扰信号，不进行读取</p>\n<p>STM32的I2C外设可用作通讯的主机及从机，支持100Kbit&#x2F;s和400Kbit&#x2F;s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。</p>\n<h2 id=\"I2C系统配置\"><a href=\"#I2C系统配置\" class=\"headerlink\" title=\"I2C系统配置\"></a>I2C系统配置</h2><p>因为I2C的引脚还是GPIO，所以我们在使用的时候，需要配置GPIO口，如之前配置所示</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">GPIO_InitTypeDef I2C_GPIO_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br><br><span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>RCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_GPIOB<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//配置I2C SCL引脚</span><br>I2C_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_OD<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_6<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOB<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;I2C_GPIO_InitStructure);</span><br><br><span class=\"hljs-comment\">//配置I2C SDL引脚</span><br>I2C_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_OD<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_7<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOB<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;I2C_GPIO_InitStructure);</span><br></code></pre></td></tr></table></figure>\n\n<p>在选择上需要注意的是，引脚需要所有都改成复用浮空输入，复用代表着这个原先是GPIO的引脚被复用到了IIC所以，需要改成复用浮空输入</p>\n<p>在使用I2C引脚，就需要打开I2C的时钟</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOB, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<p>之后就需要配置I2C引脚的初始化</p>\n<p>I2C的配置主要为ACK使能，这个配置会在每次发送单字节数据结束后，发送一个方波，用来给下位机判别字节的结束，这个类似于换行符</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_Ack</span> = I2C_Ack_Enable<span class=\"hljs-comment\">;//配置i2c的应答使能</span><br></code></pre></td></tr></table></figure>\n\n<p>I2C的地址通常配置为7位，因为还有一位决定的是读和写，总共加起来8位数据</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_AcknowledgedAddress</span> = I2C_AcknowledgedAddress_7bit<span class=\"hljs-comment\">;//配置接收字节为7，还有一位是读写位</span><br></code></pre></td></tr></table></figure>\n\n<p>时钟的配置上可以直接选择400k，其中的计算过程如下</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_ClockSpeed</span> = <span class=\"hljs-number\">400000</span><span class=\"hljs-comment\">;//配置配置SCL时钟频率为400k</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">标准模式：<br><span class=\"hljs-attribute\">Thigh</span><span class=\"hljs-operator\">=</span>CCR*TPCKL1 Tlow <span class=\"hljs-operator\">=</span> CCR*TPCLK1<br>快速模式中 Tlow/Thigh<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">2</span> 时：<br><span class=\"hljs-attribute\">Thigh</span> <span class=\"hljs-operator\">=</span> CCR*TPCKL1 Tlow <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>*CCR*TPCKL1<br>快速模式中 Tlow/Thigh<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">16</span>/<span class=\"hljs-number\">9</span> 时：<br><span class=\"hljs-attribute\">Thigh</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">9</span>*CCR*TPCKL1 Tlow <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">16</span>*CCR*TPCKL1<br><br>例如，我们的PCLK1<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">36</span>MHz，想要配置<span class=\"hljs-number\">400</span>Kbit/s的速率，计算方式如下：<br><br>PCLK时钟周期： TPCLK1 <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">36000000</span><br>目标SCL时钟周期： TSCL <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">400000</span><br>SCL时钟周期内的高电平时间： THIGH <span class=\"hljs-operator\">=</span> TSCL/<span class=\"hljs-number\">3</span><br>SCL时钟周期内的低电平时间： TLOW <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>*TSCL/<span class=\"hljs-number\">3</span><br>计算CCR的值： CCR <span class=\"hljs-operator\">=</span> THIGH/TPCLK1 <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">30</span><br></code></pre></td></tr></table></figure>\n\n<p>再就是占空比设置，这个影响不大，可以直接默认即可</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_DutyCycle</span> = I2C_DutyCycle_2<span class=\"hljs-comment\">;//配置占空比位2:1</span><br></code></pre></td></tr></table></figure>\n\n<p>模式采用I2C模式，还有一种SMBA通信，几乎不使用，所以直接配置I2C模式</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_Mode</span> = I2C_Mode_I2C<span class=\"hljs-comment\">;//配置为I2C模式，其他模式不考虑</span><br></code></pre></td></tr></table></figure>\n\n<p>我们还需要给MCU分配一个地址，这个是主机地址，可以用来和主机通信的地址</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_OwnAddress1</span> = <span class=\"hljs-number\">0</span>x0A<span class=\"hljs-comment\">;//给主机一个地址，用于识别，随便定义七位的就行</span><br></code></pre></td></tr></table></figure>\n\n<p>完成所有结构体值的赋值，就需要对结构配置</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">I2C_Init</span>(I2C1, &amp;I2C_InitStructure);<span class=\"hljs-comment\">//结构体初始化</span><br></code></pre></td></tr></table></figure>\n\n<p>配置的最后一步是对I2C进行使能，以供使用</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\"><span class=\"hljs-comment\">// 使能串口</span><br><span class=\"hljs-built_in\">I2C_Cmd</span> (I2C1, <span class=\"hljs-keyword\">ENABLE</span>);\t<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C单字节和多字节发送\"><a href=\"#I2C单字节和多字节发送\" class=\"headerlink\" title=\"I2C单字节和多字节发送\"></a>I2C单字节和多字节发送</h2><p>I2C的发送主要遵循两个图，单字节的和多字节的去别其实在于数据的多次发送</p>\n<p><img src=\"https://s2.loli.net/2024/08/18/oAU1rEYX9MjDPp4.png\" alt=\"image.png\"></p>\n<p>我们实验里面采用的是EEPROM的读写，所以还需要发送EEPROM的读写位置，但是这个读写位置并不是他的地址，而是类似数据格式进行发送，由EEPROM自动判断其位置</p>\n<p>因此从这个图可以看出来，我们的发送步骤是</p>\n<p>1.发送起始位信号</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//发送起始信号</span><br><span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br></code></pre></td></tr></table></figure>\n\n<p>2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br> \t&#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">8</span>)</span></span>;<span class=\"hljs-comment\">//超时等待函数，在最下面有介绍</span><br> \t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>3.发送设备地址(地址最后一位是是写方向)</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>I<span class=\"hljs-number\">2</span>C_Se<span class=\"hljs-symbol\">nd7</span>bitAddress<span class=\"hljs-comment\">(I2C1,0xA0,I2C_Direction_Receiver)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br> \t&#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">9</span>)</span></span>;<br> \t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>5.发送数据</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br><span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,addr);<br></code></pre></td></tr></table></figure>\n\n<p>6.（仅限单数据）发送数据，并使用EV8校验TxE是否置1，以此确定数据是否发送成功(在这边可能会出现一个bug，就是EV8和EV8_2的标识符太像了，导致你忘记用EV8_2，就会出现数据无法读取，所以我们有一个妙招，所有的数据位不用EV8校验，全部用EV8_2校验即可)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br>I2C_SendData(I2C1,addr);<br><br><span class=\"hljs-comment\">//EV8_2最后位数据校验是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))<br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>6.（仅限多数据）使用循环判断，直到数据完全发送成功</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-comment\">//循环执行发送函数，直到发送完毕</span><br><span class=\"hljs-keyword\">while</span>(NumByteToRead--)  <br> &#123;<br><span class=\"hljs-comment\">//发送数据</span><br>   I2C_SendData(I2C1, *<span class=\"hljs-keyword\">data</span>);<br>   <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>   <span class=\"hljs-keyword\">data</span>++; <br>\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t<span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">14</span>);<br>\t&#125;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>7.发送停止位信号</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//发送结束信号</span><br><span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C读取数据\"><a href=\"#I2C读取数据\" class=\"headerlink\" title=\"I2C读取数据\"></a>I2C读取数据</h2><p>读取数据的话，也是遵循一个读取的图表</p>\n<p><img src=\"https://s2.loli.net/2024/08/18/ZlPnMOIbRqB52iS.png\" alt=\"image.png\"></p>\n<p>接收的步骤是</p>\n<p>1.发送起始位信号</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//发送起始信号</span><br><span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br></code></pre></td></tr></table></figure>\n\n<p>2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">8</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>3.发送设备地址(地址最后一位是是读方向)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Receiver</span><br>I2C_Send7bitAddress(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Receiver);<br><br><span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">9</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">9</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>5.读取数据，使用循环判断，直到数据接收完成，在最后一位的时候，关闭ACK信号，并且发送停止位</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">while</span>(NumByteToRead)  <br> \t&#123;<br>\t<span class=\"hljs-comment\">//如果只有一位数据，则直接发送结束信号和停止信号</span><br>       <span class=\"hljs-keyword\">if</span>(NumByteToRead == <span class=\"hljs-number\">1</span>)<br>       &#123;<br>         <span class=\"hljs-comment\">//读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭</span><br>         I2C_AcknowledgeConfig(I2C1, DISABLE);<br><br>         <span class=\"hljs-comment\">//发送停止位</span><br>         I2C_GenerateSTOP(I2C1, ENABLE);<br>       &#125;<br>   <br>\t<span class=\"hljs-comment\">//EV7校验数据是否接收成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">10</span>);<br>\t&#125;<br>       <span class=\"hljs-comment\">//接收数据到指针</span><br>       *<span class=\"hljs-keyword\">data</span> = I2C_ReceiveData(I2C1);<br><br>       <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>       <span class=\"hljs-keyword\">data</span>++; <br><br>       <span class=\"hljs-comment\">//数据长度减少，等到没有数据时，退出函数</span><br>       NumByteToRead--;  <br> \t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>6.重启应答信号，方便下次使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//重启应答信号，防止下次接收失败</span><br> <span class=\"hljs-built_in\">I2C_AcknowledgeConfig</span>(I2C1, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C发送接收校验\"><a href=\"#I2C发送接收校验\" class=\"headerlink\" title=\"I2C发送接收校验\"></a>I2C发送接收校验</h2><p>这个主要用于防止数据发送过程中出现死循环情况，出错会返回错误码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">static</span> __IO <span class=\"hljs-type\">uint32_t</span>  I2CTimeout = <span class=\"hljs-number\">10</span>*(<span class=\"hljs-number\">0x1000</span>); <br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> errorCode)</span></span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C发送超时等待函数\"><a href=\"#I2C发送超时等待函数\" class=\"headerlink\" title=\"I2C发送超时等待函数\"></a>I2C发送超时等待函数</h2><p>这个函数主要用在发送或者接收的使用，由于MCU的执行速度很快，可能还没有完全写完或者读完，就执行下一程序，导致数据错误，所以需要编写一个等待函数，使用标志位进行读取，读取到代表已经全部写入或者读取，既可以继续执行其他程序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">EEPROM_WaitForWriteEnd</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">void</span></span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">do</span><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//产生起始信号</span><br>\t\t<span class=\"hljs-title function_\">I2C_GenerateSTART</span>(<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">ENABLE</span>);<br>\t\t<br>\t\t<span class=\"hljs-comment\">//判断SB位是否被重置</span><br>\t\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-title function_\">I2C_GetFlagStatus</span> (<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">I2C_FLAG_SB</span>) == <span class=\"hljs-variable constant_\">RESET</span>);<br>\t\t<br>\t\t<span class=\"hljs-comment\">//EV5事件被检测到，发送设备地址</span><br>\t\t<span class=\"hljs-title function_\">I2C_Send7bitAddress</span>(<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br>\t&#125;  <br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-title function_\">I2C_GetFlagStatus</span> (<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">I2C_FLAG_ADDR</span>) == <span class=\"hljs-variable constant_\">RESET</span> );<br><br>\t<span class=\"hljs-comment\">//EEPROM内部时序完成传输完成</span><br>\t<span class=\"hljs-title function_\">I2C_GenerateSTOP</span>(<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">ENABLE</span>);\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总程序代码\"><a href=\"#总程序代码\" class=\"headerlink\" title=\"总程序代码\"></a>总程序代码</h2><h3 id=\"I2C-c\"><a href=\"#I2C-c\" class=\"headerlink\" title=\"I2C.c\"></a>I2C.c</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_i2c.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><br><span class=\"hljs-type\">static</span> __IO <span class=\"hljs-type\">uint32_t</span>  I2CTimeout = <span class=\"hljs-number\">10</span>*(<span class=\"hljs-number\">0x1000</span>); <br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> errorCode)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">/* Block communication and all processes */</span><br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;I2C 等待超时!errorCode = %d&quot;</span>,errorCode);<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">I2C_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tGPIO_InitTypeDef I2C_GPIO_InitStructure;  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>\tI2C_InitTypeDef  I2C_InitStructure;  <span class=\"hljs-comment\">//初始化I2C结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOB, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//打开I2C的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_I2C1, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SCL引脚</span><br>\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;<br>\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;<br>\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOB, &amp;I2C_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SDL引脚</span><br>\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;<br>\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;<br>\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOB, &amp;I2C_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//初始化I2C结构体</span><br>\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;<span class=\"hljs-comment\">//配置i2c的应答使能</span><br>\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<span class=\"hljs-comment\">//配置接收字节为7，还有一位是读写位</span><br>\tI2C_InitStructure.I2C_ClockSpeed = <span class=\"hljs-number\">400000</span>;<span class=\"hljs-comment\">//配置配置SCL时钟频率为400k</span><br>\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;<span class=\"hljs-comment\">//配置占空比位2:1</span><br>\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;<span class=\"hljs-comment\">//配置为I2C模式，其他模式不考虑</span><br>\tI2C_InitStructure.I2C_OwnAddress1 = <span class=\"hljs-number\">0x0A</span>;<span class=\"hljs-comment\">//给主机一个地址，用于识别，随便定义七位的就行</span><br>\t<span class=\"hljs-built_in\">I2C_Init</span>(I2C1, &amp;I2C_InitStructure);<span class=\"hljs-comment\">//结构体初始化</span><br>\t<br>\t<span class=\"hljs-comment\">// 使能串口</span><br>\t<span class=\"hljs-built_in\">I2C_Cmd</span> (I2C1, ENABLE);\t<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送起始信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br><br>\t<span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">1</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br><br>\t<span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br><br>\t<span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED ))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">2</span>);<br>  &#125;<br><br>\t<span class=\"hljs-comment\">/************************************************************/</span><br><br>\t<span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br>\t<span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,addr);<br>\t<br>\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED ))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">3</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br><br>\t<span class=\"hljs-comment\">//发送数据</span><br>\t<span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,data);<br>\t<br>\t<span class=\"hljs-comment\">//EV8_2最后位数据校验是否发送成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">4</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送结束信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteRead</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送起始信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">8</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Receiver);<br>\t<br>\t<span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">9</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-keyword\">while</span>(NumByteToRead)  <br>  &#123;<br>\t\t<span class=\"hljs-comment\">//如果只有一位数据，则直接发送结束信号和停止信号</span><br>    <span class=\"hljs-keyword\">if</span>(NumByteToRead == <span class=\"hljs-number\">1</span>)<br>    &#123;<br>      <span class=\"hljs-comment\">//读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭</span><br>      <span class=\"hljs-built_in\">I2C_AcknowledgeConfig</span>(I2C1, DISABLE);<br>      <br>      <span class=\"hljs-comment\">//发送停止位</span><br>      <span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1, ENABLE);<br>    &#125;<br>    <br>\t\t<span class=\"hljs-comment\">//EV7校验数据是否接收成功</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">10</span>);<br>\t\t&#125;<br>    <span class=\"hljs-comment\">//接收数据到指针</span><br>    *data = <span class=\"hljs-built_in\">I2C_ReceiveData</span>(I2C1);<br><br>    <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>    data++; <br>      <br>    <span class=\"hljs-comment\">//数据长度减少，等到没有数据时，退出函数</span><br>    NumByteToRead--;  <br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//重启应答信号，防止下次接收失败</span><br>  <span class=\"hljs-built_in\">I2C_AcknowledgeConfig</span>(I2C1, ENABLE);<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_PageWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送起始信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">11</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br>\t<br>\t<span class=\"hljs-comment\">//这边跳过ACK位，因为他自动产生脉冲，我们使用EV8对他进行检测，这边选择忽略，不检测</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">12</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br>\t<span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,addr);<br>\t<br>\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">13</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//循环执行发送函数，直到发送完毕</span><br>\t<span class=\"hljs-keyword\">while</span>(NumByteToRead--)  <br>  &#123;<br>\t\t<span class=\"hljs-comment\">//发送数据</span><br>    <span class=\"hljs-built_in\">I2C_SendData</span>(I2C1, *data);<br>    <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>    data++; <br>\t\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">14</span>);<br>\t\t&#125;<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送结束信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EEPROM_WaitForWriteEnd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">do</span><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//产生起始信号</span><br>\t\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br>\t\t<br>\t\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">I2C_GetFlagStatus</span> (I2C1,I2C_FLAG_SB) == RESET);<br>\t\t<br>\t\t<span class=\"hljs-comment\">//EV5事件被检测到，发送设备地址</span><br>\t\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br>\t&#125;  <br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">I2C_GetFlagStatus</span> (I2C1,I2C_FLAG_ADDR) == RESET );<br><br>\t<span class=\"hljs-comment\">//EEPROM内部时序完成传输完成</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"I2C-h\"><a href=\"#I2C-h\" class=\"headerlink\" title=\"I2C.h\"></a>I2C.h</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> __BSP_I2C_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __BSP_I2C_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stm32f10x.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">I2C_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> data)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteRead</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_PageWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EEPROM_WaitForWriteEnd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span>  <span class=\"hljs-comment\">/* __BSP_I2C_H */</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"main-c\"><a href=\"#main-c\" class=\"headerlink\" title=\"main.c\"></a>main.c</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stm32f10x.h&quot;</span><span class=\"hljs-comment\">//相当于51单片机中的#include &lt;reg51.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_led.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_rccclkconfig.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_exti.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_systick.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_dma.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_i2c.h&quot;</span></span><br><br><span class=\"hljs-type\">uint8_t</span> readData[<span class=\"hljs-number\">8</span>]=&#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-type\">uint8_t</span> writeData[<span class=\"hljs-number\">8</span>]=&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">11</span>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-type\">uint8_t</span> i=<span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-comment\">/*初始化USART 配置模式为 115200 8-N-1，中断接收*/</span><br>  <span class=\"hljs-built_in\">USART_Config</span>();<br>\t<br>\t<span class=\"hljs-comment\">/* 发送一个字符串 */</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;这是一个IIC通讯实验\\n&quot;</span>);<br>\t<br>\t<span class=\"hljs-comment\">//初始化IIC</span><br>\t<span class=\"hljs-built_in\">I2C_config</span>();<br><br>\t<span class=\"hljs-comment\">//写入一个字节</span><br>\t<span class=\"hljs-built_in\">I2C_ByteWrite</span>(<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">55</span>);<br>\t<br>\t<span class=\"hljs-comment\">//等待写入操作完成</span><br>\t<span class=\"hljs-built_in\">EEPROM_WaitForWriteEnd</span>();<br>\t<br>\t<span class=\"hljs-comment\">//写入一个字节</span><br>\t<span class=\"hljs-built_in\">I2C_ByteWrite</span>(<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">52</span>);<br>\t<br>\t<span class=\"hljs-comment\">//等待写入操作完成</span><br>\t<span class=\"hljs-built_in\">EEPROM_WaitForWriteEnd</span>();<br>\t<br>\t<span class=\"hljs-comment\">//addr%8 == 0 ,即为地址对齐</span><br>\t<span class=\"hljs-built_in\">I2C_PageWrite</span>(<span class=\"hljs-number\">16</span>,writeData,<span class=\"hljs-number\">8</span>);<br>\t<br>\t<span class=\"hljs-comment\">//等待写入操作完成</span><br>\t<span class=\"hljs-built_in\">EEPROM_WaitForWriteEnd</span>();<br>\t<br>\t<span class=\"hljs-comment\">//读取数据</span><br>\t<span class=\"hljs-built_in\">I2C_ByteRead</span>(<span class=\"hljs-number\">16</span>,readData,<span class=\"hljs-number\">8</span>);<br>\t<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">8</span>;i++)<br>\t&#123;\t<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,readData[i]);\t<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;111111111111111111&quot;</span>);<br>\t<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)<br>\t&#123;\t<br>\t\t<br>\t&#125;\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"STM32的I2C通信学习\"><a href=\"#STM32的I2C通信学习\" class=\"headerlink\" title=\"STM32的I2C通信学习\"></a>STM32的I2C通信学习</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>IIC总线上最好接一个4.7k的上拉电阻，可以防止互相干扰，SDL、SCL都接，上拉电阻接3.3v电源</p>\n<p>I2C的使用主要有两根总线，一根是SDL，一根是SDA，SDL上面主要连接的是时钟，SDA主要用来发送数据</p>\n<p>所有的设备都是连接在这两个总线上面，单次只能实现一个数据通信，因为通信会占用总线</p>\n<p>设备的对接基于I2C的地址分配，每个传感器在出厂的时候基本上是固定好I2C的地址，所以我们只需要输入发送这个地址，就能通过I2C找到这个设备，并把数据发给他</p>\n<p>在两个设备通信的过程中，其他的设备都处于高阻态状态，也就是等于断路，如果需要发送数据时，将会连接退出高阻态模式</p>\n<p>I2C在通信的过程中由于SDA线他发送数据时存在的干扰性比较强，所以其他设备无法知晓其是否发送成功，并且也无法表示什么时候开始发送，什么时候结束</p>\n<p>这个时候就需要SCL总线来协助，SCL是时钟线，当时钟线拉高的时候，SDA线也发送标志位，才表示数据开始发送，并且每个发送的位数据都必须在SCL总线有反应的情况下才算是数据，其他情况皆为干扰信号，不进行读取</p>\n<p>STM32的I2C外设可用作通讯的主机及从机，支持100Kbit&#x2F;s和400Kbit&#x2F;s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。</p>\n<h2 id=\"I2C系统配置\"><a href=\"#I2C系统配置\" class=\"headerlink\" title=\"I2C系统配置\"></a>I2C系统配置</h2><p>因为I2C的引脚还是GPIO，所以我们在使用的时候，需要配置GPIO口，如之前配置所示</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">GPIO_InitTypeDef I2C_GPIO_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br><br><span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>RCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_GPIOB<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br><br><span class=\"hljs-comment\">//配置I2C SCL引脚</span><br>I2C_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_OD<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_6<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOB<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;I2C_GPIO_InitStructure);</span><br><br><span class=\"hljs-comment\">//配置I2C SDL引脚</span><br>I2C_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_OD<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_7<span class=\"hljs-punctuation\">;</span><br>I2C_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>GPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOB<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;I2C_GPIO_InitStructure);</span><br></code></pre></td></tr></table></figure>\n\n<p>在选择上需要注意的是，引脚需要所有都改成复用浮空输入，复用代表着这个原先是GPIO的引脚被复用到了IIC所以，需要改成复用浮空输入</p>\n<p>在使用I2C引脚，就需要打开I2C的时钟</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOB, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<p>之后就需要配置I2C引脚的初始化</p>\n<p>I2C的配置主要为ACK使能，这个配置会在每次发送单字节数据结束后，发送一个方波，用来给下位机判别字节的结束，这个类似于换行符</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_Ack</span> = I2C_Ack_Enable<span class=\"hljs-comment\">;//配置i2c的应答使能</span><br></code></pre></td></tr></table></figure>\n\n<p>I2C的地址通常配置为7位，因为还有一位决定的是读和写，总共加起来8位数据</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_AcknowledgedAddress</span> = I2C_AcknowledgedAddress_7bit<span class=\"hljs-comment\">;//配置接收字节为7，还有一位是读写位</span><br></code></pre></td></tr></table></figure>\n\n<p>时钟的配置上可以直接选择400k，其中的计算过程如下</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_ClockSpeed</span> = <span class=\"hljs-number\">400000</span><span class=\"hljs-comment\">;//配置配置SCL时钟频率为400k</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">标准模式：<br><span class=\"hljs-attribute\">Thigh</span><span class=\"hljs-operator\">=</span>CCR*TPCKL1 Tlow <span class=\"hljs-operator\">=</span> CCR*TPCLK1<br>快速模式中 Tlow/Thigh<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">2</span> 时：<br><span class=\"hljs-attribute\">Thigh</span> <span class=\"hljs-operator\">=</span> CCR*TPCKL1 Tlow <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>*CCR*TPCKL1<br>快速模式中 Tlow/Thigh<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">16</span>/<span class=\"hljs-number\">9</span> 时：<br><span class=\"hljs-attribute\">Thigh</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">9</span>*CCR*TPCKL1 Tlow <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">16</span>*CCR*TPCKL1<br><br>例如，我们的PCLK1<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">36</span>MHz，想要配置<span class=\"hljs-number\">400</span>Kbit/s的速率，计算方式如下：<br><br>PCLK时钟周期： TPCLK1 <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">36000000</span><br>目标SCL时钟周期： TSCL <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">400000</span><br>SCL时钟周期内的高电平时间： THIGH <span class=\"hljs-operator\">=</span> TSCL/<span class=\"hljs-number\">3</span><br>SCL时钟周期内的低电平时间： TLOW <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>*TSCL/<span class=\"hljs-number\">3</span><br>计算CCR的值： CCR <span class=\"hljs-operator\">=</span> THIGH/TPCLK1 <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">30</span><br></code></pre></td></tr></table></figure>\n\n<p>再就是占空比设置，这个影响不大，可以直接默认即可</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_DutyCycle</span> = I2C_DutyCycle_2<span class=\"hljs-comment\">;//配置占空比位2:1</span><br></code></pre></td></tr></table></figure>\n\n<p>模式采用I2C模式，还有一种SMBA通信，几乎不使用，所以直接配置I2C模式</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_Mode</span> = I2C_Mode_I2C<span class=\"hljs-comment\">;//配置为I2C模式，其他模式不考虑</span><br></code></pre></td></tr></table></figure>\n\n<p>我们还需要给MCU分配一个地址，这个是主机地址，可以用来和主机通信的地址</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">I2C_InitStructure.I2C_OwnAddress1</span> = <span class=\"hljs-number\">0</span>x0A<span class=\"hljs-comment\">;//给主机一个地址，用于识别，随便定义七位的就行</span><br></code></pre></td></tr></table></figure>\n\n<p>完成所有结构体值的赋值，就需要对结构配置</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">I2C_Init</span>(I2C1, &amp;I2C_InitStructure);<span class=\"hljs-comment\">//结构体初始化</span><br></code></pre></td></tr></table></figure>\n\n<p>配置的最后一步是对I2C进行使能，以供使用</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\"><span class=\"hljs-comment\">// 使能串口</span><br><span class=\"hljs-built_in\">I2C_Cmd</span> (I2C1, <span class=\"hljs-keyword\">ENABLE</span>);\t<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C单字节和多字节发送\"><a href=\"#I2C单字节和多字节发送\" class=\"headerlink\" title=\"I2C单字节和多字节发送\"></a>I2C单字节和多字节发送</h2><p>I2C的发送主要遵循两个图，单字节的和多字节的去别其实在于数据的多次发送</p>\n<p><img src=\"https://s2.loli.net/2024/08/18/oAU1rEYX9MjDPp4.png\" alt=\"image.png\"></p>\n<p>我们实验里面采用的是EEPROM的读写，所以还需要发送EEPROM的读写位置，但是这个读写位置并不是他的地址，而是类似数据格式进行发送，由EEPROM自动判断其位置</p>\n<p>因此从这个图可以看出来，我们的发送步骤是</p>\n<p>1.发送起始位信号</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//发送起始信号</span><br><span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br></code></pre></td></tr></table></figure>\n\n<p>2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br> \t&#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">8</span>)</span></span>;<span class=\"hljs-comment\">//超时等待函数，在最下面有介绍</span><br> \t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>3.发送设备地址(地址最后一位是是写方向)</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>I<span class=\"hljs-number\">2</span>C_Se<span class=\"hljs-symbol\">nd7</span>bitAddress<span class=\"hljs-comment\">(I2C1,0xA0,I2C_Direction_Receiver)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br> \t&#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">9</span>)</span></span>;<br> \t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>5.发送数据</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br><span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,addr);<br></code></pre></td></tr></table></figure>\n\n<p>6.（仅限单数据）发送数据，并使用EV8校验TxE是否置1，以此确定数据是否发送成功(在这边可能会出现一个bug，就是EV8和EV8_2的标识符太像了，导致你忘记用EV8_2，就会出现数据无法读取，所以我们有一个妙招，所有的数据位不用EV8校验，全部用EV8_2校验即可)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br>I2C_SendData(I2C1,addr);<br><br><span class=\"hljs-comment\">//EV8_2最后位数据校验是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))<br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>6.（仅限多数据）使用循环判断，直到数据完全发送成功</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-comment\">//循环执行发送函数，直到发送完毕</span><br><span class=\"hljs-keyword\">while</span>(NumByteToRead--)  <br> &#123;<br><span class=\"hljs-comment\">//发送数据</span><br>   I2C_SendData(I2C1, *<span class=\"hljs-keyword\">data</span>);<br>   <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>   <span class=\"hljs-keyword\">data</span>++; <br>\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t<span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">14</span>);<br>\t&#125;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>7.发送停止位信号</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//发送结束信号</span><br><span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C读取数据\"><a href=\"#I2C读取数据\" class=\"headerlink\" title=\"I2C读取数据\"></a>I2C读取数据</h2><p>读取数据的话，也是遵循一个读取的图表</p>\n<p><img src=\"https://s2.loli.net/2024/08/18/ZlPnMOIbRqB52iS.png\" alt=\"image.png\"></p>\n<p>接收的步骤是</p>\n<p>1.发送起始位信号</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//发送起始信号</span><br><span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br></code></pre></td></tr></table></figure>\n\n<p>2.使用EV5校验SB位是否置1，以此确定起始信号是否发送成功</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">8</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>3.发送设备地址(地址最后一位是是读方向)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Receiver</span><br>I2C_Send7bitAddress(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Receiver);<br><br><span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">9</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>4.使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功(这里面我们不对EV8进行校验，他是校验数据是否发送成功的，地址起始也是一个数据，但是我们有专门的数据位进行校验，因此就校验一次即可)</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br><span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br> &#123;<br>   <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-number\">9</span>)</span></span>;<br> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>5.读取数据，使用循环判断，直到数据接收完成，在最后一位的时候，关闭ACK信号，并且发送停止位</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">while</span>(NumByteToRead)  <br> \t&#123;<br>\t<span class=\"hljs-comment\">//如果只有一位数据，则直接发送结束信号和停止信号</span><br>       <span class=\"hljs-keyword\">if</span>(NumByteToRead == <span class=\"hljs-number\">1</span>)<br>       &#123;<br>         <span class=\"hljs-comment\">//读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭</span><br>         I2C_AcknowledgeConfig(I2C1, DISABLE);<br><br>         <span class=\"hljs-comment\">//发送停止位</span><br>         I2C_GenerateSTOP(I2C1, ENABLE);<br>       &#125;<br>   <br>\t<span class=\"hljs-comment\">//EV7校验数据是否接收成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">10</span>);<br>\t&#125;<br>       <span class=\"hljs-comment\">//接收数据到指针</span><br>       *<span class=\"hljs-keyword\">data</span> = I2C_ReceiveData(I2C1);<br><br>       <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>       <span class=\"hljs-keyword\">data</span>++; <br><br>       <span class=\"hljs-comment\">//数据长度减少，等到没有数据时，退出函数</span><br>       NumByteToRead--;  <br> \t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>6.重启应答信号，方便下次使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//重启应答信号，防止下次接收失败</span><br> <span class=\"hljs-built_in\">I2C_AcknowledgeConfig</span>(I2C1, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C发送接收校验\"><a href=\"#I2C发送接收校验\" class=\"headerlink\" title=\"I2C发送接收校验\"></a>I2C发送接收校验</h2><p>这个主要用于防止数据发送过程中出现死循环情况，出错会返回错误码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">static</span> __IO <span class=\"hljs-type\">uint32_t</span>  I2CTimeout = <span class=\"hljs-number\">10</span>*(<span class=\"hljs-number\">0x1000</span>); <br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> errorCode)</span></span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I2C发送超时等待函数\"><a href=\"#I2C发送超时等待函数\" class=\"headerlink\" title=\"I2C发送超时等待函数\"></a>I2C发送超时等待函数</h2><p>这个函数主要用在发送或者接收的使用，由于MCU的执行速度很快，可能还没有完全写完或者读完，就执行下一程序，导致数据错误，所以需要编写一个等待函数，使用标志位进行读取，读取到代表已经全部写入或者读取，既可以继续执行其他程序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">EEPROM_WaitForWriteEnd</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">void</span></span>)<br>&#123;<br>\t<span class=\"hljs-keyword\">do</span><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//产生起始信号</span><br>\t\t<span class=\"hljs-title function_\">I2C_GenerateSTART</span>(<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">ENABLE</span>);<br>\t\t<br>\t\t<span class=\"hljs-comment\">//判断SB位是否被重置</span><br>\t\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-title function_\">I2C_GetFlagStatus</span> (<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">I2C_FLAG_SB</span>) == <span class=\"hljs-variable constant_\">RESET</span>);<br>\t\t<br>\t\t<span class=\"hljs-comment\">//EV5事件被检测到，发送设备地址</span><br>\t\t<span class=\"hljs-title function_\">I2C_Send7bitAddress</span>(<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br>\t&#125;  <br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-title function_\">I2C_GetFlagStatus</span> (<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">I2C_FLAG_ADDR</span>) == <span class=\"hljs-variable constant_\">RESET</span> );<br><br>\t<span class=\"hljs-comment\">//EEPROM内部时序完成传输完成</span><br>\t<span class=\"hljs-title function_\">I2C_GenerateSTOP</span>(<span class=\"hljs-variable constant_\">I2C1</span>,<span class=\"hljs-variable constant_\">ENABLE</span>);\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总程序代码\"><a href=\"#总程序代码\" class=\"headerlink\" title=\"总程序代码\"></a>总程序代码</h2><h3 id=\"I2C-c\"><a href=\"#I2C-c\" class=\"headerlink\" title=\"I2C.c\"></a>I2C.c</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_i2c.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><br><span class=\"hljs-type\">static</span> __IO <span class=\"hljs-type\">uint32_t</span>  I2CTimeout = <span class=\"hljs-number\">10</span>*(<span class=\"hljs-number\">0x1000</span>); <br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> errorCode)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">/* Block communication and all processes */</span><br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;I2C 等待超时!errorCode = %d&quot;</span>,errorCode);<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">I2C_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tGPIO_InitTypeDef I2C_GPIO_InitStructure;  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>\tI2C_InitTypeDef  I2C_InitStructure;  <span class=\"hljs-comment\">//初始化I2C结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOB, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//打开I2C的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_I2C1, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SCL引脚</span><br>\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;<br>\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;<br>\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOB, &amp;I2C_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SDL引脚</span><br>\tI2C_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;<br>\tI2C_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;<br>\tI2C_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOB, &amp;I2C_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//初始化I2C结构体</span><br>\tI2C_InitStructure.I2C_Ack = I2C_Ack_Enable;<span class=\"hljs-comment\">//配置i2c的应答使能</span><br>\tI2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<span class=\"hljs-comment\">//配置接收字节为7，还有一位是读写位</span><br>\tI2C_InitStructure.I2C_ClockSpeed = <span class=\"hljs-number\">400000</span>;<span class=\"hljs-comment\">//配置配置SCL时钟频率为400k</span><br>\tI2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;<span class=\"hljs-comment\">//配置占空比位2:1</span><br>\tI2C_InitStructure.I2C_Mode = I2C_Mode_I2C;<span class=\"hljs-comment\">//配置为I2C模式，其他模式不考虑</span><br>\tI2C_InitStructure.I2C_OwnAddress1 = <span class=\"hljs-number\">0x0A</span>;<span class=\"hljs-comment\">//给主机一个地址，用于识别，随便定义七位的就行</span><br>\t<span class=\"hljs-built_in\">I2C_Init</span>(I2C1, &amp;I2C_InitStructure);<span class=\"hljs-comment\">//结构体初始化</span><br>\t<br>\t<span class=\"hljs-comment\">// 使能串口</span><br>\t<span class=\"hljs-built_in\">I2C_Cmd</span> (I2C1, ENABLE);\t<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送起始信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br><br>\t<span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">1</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br><br>\t<span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br><br>\t<span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED ))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">2</span>);<br>  &#125;<br><br>\t<span class=\"hljs-comment\">/************************************************************/</span><br><br>\t<span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br>\t<span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,addr);<br>\t<br>\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED ))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">3</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br><br>\t<span class=\"hljs-comment\">//发送数据</span><br>\t<span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,data);<br>\t<br>\t<span class=\"hljs-comment\">//EV8_2最后位数据校验是否发送成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">4</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送结束信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteRead</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送起始信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">8</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Receiver);<br>\t<br>\t<span class=\"hljs-comment\">//使用EV6校验ADDR是否置1，以此确定地址数据是否发送成功</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">9</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-keyword\">while</span>(NumByteToRead)  <br>  &#123;<br>\t\t<span class=\"hljs-comment\">//如果只有一位数据，则直接发送结束信号和停止信号</span><br>    <span class=\"hljs-keyword\">if</span>(NumByteToRead == <span class=\"hljs-number\">1</span>)<br>    &#123;<br>      <span class=\"hljs-comment\">//读取数据有个地方比较特殊，就是读到最后一位的时候，会发送NA信号，所以需要将ACK关闭</span><br>      <span class=\"hljs-built_in\">I2C_AcknowledgeConfig</span>(I2C1, DISABLE);<br>      <br>      <span class=\"hljs-comment\">//发送停止位</span><br>      <span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1, ENABLE);<br>    &#125;<br>    <br>\t\t<span class=\"hljs-comment\">//EV7校验数据是否接收成功</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">10</span>);<br>\t\t&#125;<br>    <span class=\"hljs-comment\">//接收数据到指针</span><br>    *data = <span class=\"hljs-built_in\">I2C_ReceiveData</span>(I2C1);<br><br>    <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>    data++; <br>      <br>    <span class=\"hljs-comment\">//数据长度减少，等到没有数据时，退出函数</span><br>    NumByteToRead--;  <br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//重启应答信号，防止下次接收失败</span><br>  <span class=\"hljs-built_in\">I2C_AcknowledgeConfig</span>(I2C1, ENABLE);<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_PageWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送起始信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//EV5是校验起始信号发送情况</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_MODE_SELECT))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">11</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//开始发送七位地址，发送的函数内容包括总线、地址和方向，这个是写入，所以选择I2C_Direction_Transmitter</span><br>\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br>\t<br>\t<span class=\"hljs-comment\">//这边跳过ACK位，因为他自动产生脉冲，我们使用EV8对他进行检测，这边选择忽略，不检测</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))<span class=\"hljs-comment\">//EV6是检测地址是否发送成功</span><br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">12</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//这边发送的也是地址（但是我们使用的还是用数据发送），但是是EEPROM的要写的具体位置地址，而不是EEPROM的整体地址</span><br>\t<span class=\"hljs-built_in\">I2C_SendData</span>(I2C1,addr);<br>\t<br>\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">13</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//循环执行发送函数，直到发送完毕</span><br>\t<span class=\"hljs-keyword\">while</span>(NumByteToRead--)  <br>  &#123;<br>\t\t<span class=\"hljs-comment\">//发送数据</span><br>    <span class=\"hljs-built_in\">I2C_SendData</span>(I2C1, *data);<br>    <span class=\"hljs-comment\">//指针右移一位准备接收下一个数据</span><br>    data++; <br>\t\t<span class=\"hljs-comment\">//EV8是数据是否发送成功(EEPROM的地址以数据形式进行发送)</span><br>\t\t<span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">I2C_CheckEvent</span>(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING))<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">14</span>);<br>\t\t&#125;<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">/************************************************************/</span><br>\t<br>\t<span class=\"hljs-comment\">//发送结束信号</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EEPROM_WaitForWriteEnd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">do</span><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//产生起始信号</span><br>\t\t<span class=\"hljs-built_in\">I2C_GenerateSTART</span>(I2C1,ENABLE);<br>\t\t<br>\t\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">I2C_GetFlagStatus</span> (I2C1,I2C_FLAG_SB) == RESET);<br>\t\t<br>\t\t<span class=\"hljs-comment\">//EV5事件被检测到，发送设备地址</span><br>\t\t<span class=\"hljs-built_in\">I2C_Send7bitAddress</span>(I2C1,<span class=\"hljs-number\">0xA0</span>,I2C_Direction_Transmitter);<br>\t&#125;  <br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">I2C_GetFlagStatus</span> (I2C1,I2C_FLAG_ADDR) == RESET );<br><br>\t<span class=\"hljs-comment\">//EEPROM内部时序完成传输完成</span><br>\t<span class=\"hljs-built_in\">I2C_GenerateSTOP</span>(I2C1,ENABLE);\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"I2C-h\"><a href=\"#I2C-h\" class=\"headerlink\" title=\"I2C.h\"></a>I2C.h</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> __BSP_I2C_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __BSP_I2C_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stm32f10x.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">I2C_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr, <span class=\"hljs-type\">uint8_t</span> data)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_ByteRead</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_PageWrite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> addr,<span class=\"hljs-type\">uint8_t</span> *data,<span class=\"hljs-type\">uint8_t</span> NumByteToRead)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EEPROM_WaitForWriteEnd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span>  <span class=\"hljs-comment\">/* __BSP_I2C_H */</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"main-c\"><a href=\"#main-c\" class=\"headerlink\" title=\"main.c\"></a>main.c</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stm32f10x.h&quot;</span><span class=\"hljs-comment\">//相当于51单片机中的#include &lt;reg51.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_led.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_rccclkconfig.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_exti.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_systick.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_dma.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_i2c.h&quot;</span></span><br><br><span class=\"hljs-type\">uint8_t</span> readData[<span class=\"hljs-number\">8</span>]=&#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-type\">uint8_t</span> writeData[<span class=\"hljs-number\">8</span>]=&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">11</span>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-type\">uint8_t</span> i=<span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-comment\">/*初始化USART 配置模式为 115200 8-N-1，中断接收*/</span><br>  <span class=\"hljs-built_in\">USART_Config</span>();<br>\t<br>\t<span class=\"hljs-comment\">/* 发送一个字符串 */</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;这是一个IIC通讯实验\\n&quot;</span>);<br>\t<br>\t<span class=\"hljs-comment\">//初始化IIC</span><br>\t<span class=\"hljs-built_in\">I2C_config</span>();<br><br>\t<span class=\"hljs-comment\">//写入一个字节</span><br>\t<span class=\"hljs-built_in\">I2C_ByteWrite</span>(<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">55</span>);<br>\t<br>\t<span class=\"hljs-comment\">//等待写入操作完成</span><br>\t<span class=\"hljs-built_in\">EEPROM_WaitForWriteEnd</span>();<br>\t<br>\t<span class=\"hljs-comment\">//写入一个字节</span><br>\t<span class=\"hljs-built_in\">I2C_ByteWrite</span>(<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">52</span>);<br>\t<br>\t<span class=\"hljs-comment\">//等待写入操作完成</span><br>\t<span class=\"hljs-built_in\">EEPROM_WaitForWriteEnd</span>();<br>\t<br>\t<span class=\"hljs-comment\">//addr%8 == 0 ,即为地址对齐</span><br>\t<span class=\"hljs-built_in\">I2C_PageWrite</span>(<span class=\"hljs-number\">16</span>,writeData,<span class=\"hljs-number\">8</span>);<br>\t<br>\t<span class=\"hljs-comment\">//等待写入操作完成</span><br>\t<span class=\"hljs-built_in\">EEPROM_WaitForWriteEnd</span>();<br>\t<br>\t<span class=\"hljs-comment\">//读取数据</span><br>\t<span class=\"hljs-built_in\">I2C_ByteRead</span>(<span class=\"hljs-number\">16</span>,readData,<span class=\"hljs-number\">8</span>);<br>\t<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">8</span>;i++)<br>\t&#123;\t<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,readData[i]);\t<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;111111111111111111&quot;</span>);<br>\t<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)<br>\t&#123;\t<br>\t\t<br>\t&#125;\t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"嵌入式生活小常识","sticky":100,"date":"2024-07-30T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/15/VGghwBmsxZQ56EU.jpg","_content":"\n# 嵌入式生活小常识\n\n## 1.VScode不能使用搜狗输入法\n\nUbuntu的应用市场下载的code，安装的VSCode是snap的削减版本，不支持中文。\n\n阉割版的在Linux里面巨卡，而且还会出现各种bug，拒绝使用\n\n解决办法：卸载后重新安装官方版本。\n\n```\n//首先先卸载vscode\nsudo snap remove code\n\n//从官网下载号deb文件包后，执行下面命令进行安装\nsudo dpkg -i xxxxx\n```\n\n## 2.VM虚拟机和主机无法复制粘贴\n\n安装VM-tools工具，虽然他有时候会坏，如果出现用了一段时间还不行，记得重新来一遍\n\n```\nsudo apt-get autoremove open-vm-tools\nsudo apt-get install open-vm-tools\nsudo apt-get install open-vm-tools-desktop\n```\n\n## 3.尽量少用root模式\n\n使用root模式会出现很多程序无法运行的情况，因为你是在root环境下编译的，你必须使用root权限才可以执行\n\n所以尽量不要进入root模式执行任务和操作各种任务\n\n```\n//权限不够时\nsudo xxxxxxxxx\n\n//进入root模式\nsu -\n```\n\n## 4.vscode自动保存\n\n打开vscode，找到左下角的齿轮，点击之后选择设置\n\n在搜索框中输入`Auto save`，之后会出现`File：Auto save`的选择，后面有四种选项，选择afterDelay就可以了，然后下面会出现多少毫秒进行保存，如果你不是1s中上千行的，500ms足够了。\n\n```\noff\n这个不用多说，就是没有自动保存。\nafterDelay\n这个是在多少毫秒后自动保存。\nonFocusChange\n这个是编辑器失去焦点的时候，才会保存。也就是鼠标在编辑器之外的区域按下左键才会保存。\nonWindowChange\n这个是窗口失去焦点的时候，才会保存。也就是鼠标在整个VScode软件之外的地方点下左键才会保存。\n```\n\n## 5.Linux某个进程卡死\n\n使用CTRL+C是常规的结束进程，但有时候并不能实现，会出现卡死的情况\n\n如果遇到卡死情况可以CTRL+Z，先挂起进程，当然也可以直接从其他地方打开进程，然后在终端输入\n\n```\n//查找所有运行的进程和进程号\nps -aux\n\n//通过进程号杀死这个进程\nkill [process ID]\n```\n\n## 6.Linux系统各进程应用交互\n\n<img src=\"https://s2.loli.net/2024/08/09/9siHtpvEgmK4CI8.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n## 7.如何解决python执行pip出现 File“「stdin」的问题\n\n其主要原因是由于pip是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能\n\npip是在直接在cmd中运行的，不需要进入到python中运行\n\n解决的方法是关闭当前cmd窗口，重新进入，不需要进入python，直接输入pip命令就可以.\n\n## 8.宝藏激活软件\n\n进入该网站：[JETBRA.IN CHECKER | IPFS](https://3.jetbra.in/)\n\n点击ipfs.io进入另一个网站[Some keys for testing - jetbra.in (ipfs.io)](https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/)\n\n然后点击最上面蓝色的jetbra.zip进行下载，下载完之后，进入.\\jetbra\\jetbra\\scripts该目录下，双击执行install-current-user.vbs，点击执行\n\n等待10-20s之后，等到跳出done的弹窗后，再回到[Some keys for testing - jetbra.in (ipfs.io)](https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/)网页，找到所需软件，复制激活码输入\n\n即可完成软件的激活，一般是两年时间，过期了重新激活就行\n\n## 9.Linux系统构建C/C++编译\n\n首先安装vscode的不同环境版本：https://code.visualstudio.com/\n\nVScode官方教程，图文并茂：https://vscode.js.cn/docs/cpp/config-linux\n\n之后在vscode的插件栏安装两个插件：C/C++和Code Runner\n\n代码编辑完成后还不能直接运行。还需要配置两个json文件。\n\n```\ntasks.json 用来是设置指令编译代码。\nlaunch.json 设置执行环境来执行代码。（如果不设置每次点击调试的时候都需要手动选择debugger）\n```\n\n新建.vscode文件夹，在文件夹里面新建两个文件，分别是tasks.json和launch.json，然后填入该代码即可运行c文件了\n\n#### tasks.json\n\n```\n{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"type\": \"shell\",\n      \"label\": \"C/C++: g++ build active file\",\n      \"command\": \"/usr/bin/g++\",\n      \"args\": [\"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\"],\n      \"options\": {\n        \"cwd\": \"/usr/bin\"\n      },\n      \"problemMatcher\": [\"$gcc\"],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      },\n      \"detail\": \"Task generated by Debugger.\"\n    }\n  ]\n}\n```\n\n#### launch.json\n\n```\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"C/C++: g++ build and debug active file\",\n      \"type\": \"cppdbg\",\n      \"request\": \"launch\",\n      \"program\": \"${fileDirname}/${fileBasenameNoExtension}\",\n      \"args\": [],\n      \"stopAtEntry\": false,\n      \"cwd\": \"${workspaceFolder}\",\n      \"environment\": [],\n      \"externalConsole\": false,\n      \"MIMode\": \"gdb\",\n      \"miDebuggerPath\": \"/usr/bin/gdb\",\n      \"setupCommands\": [\n        {\n          \"description\": \"Enable pretty-printing for gdb\",\n          \"text\": \"-enable-pretty-printing\",\n          \"ignoreFailures\": true\n        }\n      ],\n      \"preLaunchTask\": \"C/C++: g++ build active file\"\n    }\n  ]\n}\n```\n\n## 10.CH340和CP2102的区别\n\n我们再使用单片机连接电脑的时候，需要注意芯片的串口转USB协议，而340和CP2102就是两种不同的协议\n\n稳定性与速度上来说，CP2102的要好一些，而CH340，一般的使用是可以的，电路也简单\n\nCP2102支持高速率传输，并且更加稳定，而CH340在高速传输时会有几率出现问题，但是成本低，并且应用范围更广\n\n## 11.结构体指针和结构体变量的区别\n\n结构体指针\n\n```\nstruct Example {\n    int node;\n};\n\nstruct Example *ex;\n\nex->node = 10;\n```\n\n结构体变量\n\n```\nstruct Example {\n    int node;\n};\n\nstruct Example ex;\n\nex.node = 10;\n```\n\n两个的访问形式不同，第一个是动态内存，数据是放在常量区，而指针放在栈上，所占用空间比较小，第二个是全部都在栈上，但是占用空间比较大\n\n如果空间比较大，要求速度比较快，可以定义结构体变量，如果空间小，速度要求不是很快，可以使用指针结构体\n\n## 12.静态函数和动态函数的区别\n\n#### 静态函数\n\n**效率高**：由于内存位置固定，访问速度较快。\n\n**简单**：不需要动态分配和释放内存，管理简单。\n\n#### 动态函数\n\n**灵活性高**：可以在运行时动态加载和卸载函数，适应不同的需求。\n\n**节省资源**：只在需要时加载和使用函数，避免了不必要的内存消耗。\n\n## 13.进程隐藏如何查找\n\n```\nCtrl+Z - 暂停进程并放入后台\n\njobs - 显示当前暂停的进程\n\nbg N 使第N个任务在后台中止\n\nfg N 使第N个任务在前台运行\n\nbg, fg 不带 N 时表示对最后一个进程操作\n```\n\n## 14.进程查找\n\n```\n//根据名字查找\nps -ef | grep XXX\n\n//查看所有静态进程\nps\n\n//查看所有动态进程\ntop\n```\n\n## 15.什么时候分配内存\n\n在写程序的时候，老是遇到有些需要分配内存，有些不需要分配内存，分配内存的都在堆上，不分配的都在栈上，栈是函数结束后自动释放，而堆需要手动释放，否则就会出现内存泄漏\n\n我们常见函数的返回值也是在栈上的，因为返回后直接取值即可，不需要跨函数、跨线程操作\n\n如何区别，啥时候使用呢，其实就看你这个数据在函数结束之后，里面的数据还要不要，会不会保留给其他函数或者线程使用，如果要的话，就需要分配内存，如果不要，则无需分配内存\n\n## 16.内存对齐问题\n\n内存块因为是以字节为单位，所以有时候7位6位，都会被系统认定为8位，所以会导致数据出现问题，因此，在结构体或者一些整块段的一定要考虑内存对齐，否则数据会出现丢失，比如下面的两个结构体\n\n```\ntypedef struct\n{\n    long mtype;             // 消息类型，为正整数。用于区分不同类型的消息\n    uint32_t origin;        // 消息来源的标识\n    uint32_t buffNum;       // 命令标识\n    size_t buffLen;         // 消息数据的实际长度\n    uint8_t buffStr[DATA_LEN]; // 消息数据的缓冲区\n} Msgbuff_t;\n\ntypedef struct\n{\n    long mtype;             // 消息类型，为正整数。用于区分不同类型的消息\n    uint32_t origin;        // 消息来源的标识\n    uint32_t buffNum;       // 命令标识\n    uint8_t buffStr[DATA_LEN]; // 消息数据的缓冲区\n    size_t buffLen;         // 消息数据的实际长度\n} Msgbuff_t;\n```\n\n这两个结构体看似一样，但是输出的时候，就会出现不一样的结果了，第一个是正常输出的，因为内存对齐的时候，以靠近的为主，正好前四个的内存块为8、4、4、8，内存的分布是正常的，但是如果是第二个，假设DATA_LEN是100，那么就会出现buffLen前面会填充其他的字节，从而导致数据错乱\n\n## 17.VScode乱码情况\n\n```\n打开VScode。\n按下快捷键Ctrl+,（或选择菜单栏的“文件”->“首选项”->“设置”）。\n在搜索框中输入“encoding”。\n找到“Files: Encoding”选项，确保它设置为“UTF-8”。\n如果需要，还可以设置“Editor: Detect Indentation”为“false”，以防止VScode自动检测并更改缩进。\n```\n\n## 18.主机可以ping通虚拟机，虚拟机不行\n\n控制面板->系统和安全->防火墙->高级系统设置->入站规则->文件和打印机共享（回显请求 - ICMPv4-In） 专用、公用\n\n将上面的进行启用，主机的防火墙将请求隔断了，如果还不行关闭防火墙\n\n## 19.虚拟机无法使用mobaxtem连接\n\n#### 1.关闭防火墙\n\n```\nsudo ufw disable // 关闭防火墙\nsudo ufw enable  // 开启防火墙\n```\n\n#### 2.安装软件包\n\n```\n(1)apt-get remove openssh-server\n(2)sudo apt install openssh-server\n(3)sudo service ssh start\n(4) ps -aux | grep ssh\n(5)okoksadasdasdsadasdsadasdasd192.168.31.224192.168.31.224192.168.31.224192.，asdasdasdasdasdasdasdqweqw\n```\n\n然后就再连接一下就可以了\n","source":"_posts/嵌入式生活小常识.md","raw":"---\ntitle: 嵌入式生活小常识\nsticky: 100\ntag: 嵌入式\ndate: 2024-07-31\ncategories: 嵌入式\nindex_img: https://s2.loli.net/2024/08/15/VGghwBmsxZQ56EU.jpg\n---\n\n# 嵌入式生活小常识\n\n## 1.VScode不能使用搜狗输入法\n\nUbuntu的应用市场下载的code，安装的VSCode是snap的削减版本，不支持中文。\n\n阉割版的在Linux里面巨卡，而且还会出现各种bug，拒绝使用\n\n解决办法：卸载后重新安装官方版本。\n\n```\n//首先先卸载vscode\nsudo snap remove code\n\n//从官网下载号deb文件包后，执行下面命令进行安装\nsudo dpkg -i xxxxx\n```\n\n## 2.VM虚拟机和主机无法复制粘贴\n\n安装VM-tools工具，虽然他有时候会坏，如果出现用了一段时间还不行，记得重新来一遍\n\n```\nsudo apt-get autoremove open-vm-tools\nsudo apt-get install open-vm-tools\nsudo apt-get install open-vm-tools-desktop\n```\n\n## 3.尽量少用root模式\n\n使用root模式会出现很多程序无法运行的情况，因为你是在root环境下编译的，你必须使用root权限才可以执行\n\n所以尽量不要进入root模式执行任务和操作各种任务\n\n```\n//权限不够时\nsudo xxxxxxxxx\n\n//进入root模式\nsu -\n```\n\n## 4.vscode自动保存\n\n打开vscode，找到左下角的齿轮，点击之后选择设置\n\n在搜索框中输入`Auto save`，之后会出现`File：Auto save`的选择，后面有四种选项，选择afterDelay就可以了，然后下面会出现多少毫秒进行保存，如果你不是1s中上千行的，500ms足够了。\n\n```\noff\n这个不用多说，就是没有自动保存。\nafterDelay\n这个是在多少毫秒后自动保存。\nonFocusChange\n这个是编辑器失去焦点的时候，才会保存。也就是鼠标在编辑器之外的区域按下左键才会保存。\nonWindowChange\n这个是窗口失去焦点的时候，才会保存。也就是鼠标在整个VScode软件之外的地方点下左键才会保存。\n```\n\n## 5.Linux某个进程卡死\n\n使用CTRL+C是常规的结束进程，但有时候并不能实现，会出现卡死的情况\n\n如果遇到卡死情况可以CTRL+Z，先挂起进程，当然也可以直接从其他地方打开进程，然后在终端输入\n\n```\n//查找所有运行的进程和进程号\nps -aux\n\n//通过进程号杀死这个进程\nkill [process ID]\n```\n\n## 6.Linux系统各进程应用交互\n\n<img src=\"https://s2.loli.net/2024/08/09/9siHtpvEgmK4CI8.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n## 7.如何解决python执行pip出现 File“「stdin」的问题\n\n其主要原因是由于pip是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能\n\npip是在直接在cmd中运行的，不需要进入到python中运行\n\n解决的方法是关闭当前cmd窗口，重新进入，不需要进入python，直接输入pip命令就可以.\n\n## 8.宝藏激活软件\n\n进入该网站：[JETBRA.IN CHECKER | IPFS](https://3.jetbra.in/)\n\n点击ipfs.io进入另一个网站[Some keys for testing - jetbra.in (ipfs.io)](https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/)\n\n然后点击最上面蓝色的jetbra.zip进行下载，下载完之后，进入.\\jetbra\\jetbra\\scripts该目录下，双击执行install-current-user.vbs，点击执行\n\n等待10-20s之后，等到跳出done的弹窗后，再回到[Some keys for testing - jetbra.in (ipfs.io)](https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/)网页，找到所需软件，复制激活码输入\n\n即可完成软件的激活，一般是两年时间，过期了重新激活就行\n\n## 9.Linux系统构建C/C++编译\n\n首先安装vscode的不同环境版本：https://code.visualstudio.com/\n\nVScode官方教程，图文并茂：https://vscode.js.cn/docs/cpp/config-linux\n\n之后在vscode的插件栏安装两个插件：C/C++和Code Runner\n\n代码编辑完成后还不能直接运行。还需要配置两个json文件。\n\n```\ntasks.json 用来是设置指令编译代码。\nlaunch.json 设置执行环境来执行代码。（如果不设置每次点击调试的时候都需要手动选择debugger）\n```\n\n新建.vscode文件夹，在文件夹里面新建两个文件，分别是tasks.json和launch.json，然后填入该代码即可运行c文件了\n\n#### tasks.json\n\n```\n{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"type\": \"shell\",\n      \"label\": \"C/C++: g++ build active file\",\n      \"command\": \"/usr/bin/g++\",\n      \"args\": [\"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\"],\n      \"options\": {\n        \"cwd\": \"/usr/bin\"\n      },\n      \"problemMatcher\": [\"$gcc\"],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      },\n      \"detail\": \"Task generated by Debugger.\"\n    }\n  ]\n}\n```\n\n#### launch.json\n\n```\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"C/C++: g++ build and debug active file\",\n      \"type\": \"cppdbg\",\n      \"request\": \"launch\",\n      \"program\": \"${fileDirname}/${fileBasenameNoExtension}\",\n      \"args\": [],\n      \"stopAtEntry\": false,\n      \"cwd\": \"${workspaceFolder}\",\n      \"environment\": [],\n      \"externalConsole\": false,\n      \"MIMode\": \"gdb\",\n      \"miDebuggerPath\": \"/usr/bin/gdb\",\n      \"setupCommands\": [\n        {\n          \"description\": \"Enable pretty-printing for gdb\",\n          \"text\": \"-enable-pretty-printing\",\n          \"ignoreFailures\": true\n        }\n      ],\n      \"preLaunchTask\": \"C/C++: g++ build active file\"\n    }\n  ]\n}\n```\n\n## 10.CH340和CP2102的区别\n\n我们再使用单片机连接电脑的时候，需要注意芯片的串口转USB协议，而340和CP2102就是两种不同的协议\n\n稳定性与速度上来说，CP2102的要好一些，而CH340，一般的使用是可以的，电路也简单\n\nCP2102支持高速率传输，并且更加稳定，而CH340在高速传输时会有几率出现问题，但是成本低，并且应用范围更广\n\n## 11.结构体指针和结构体变量的区别\n\n结构体指针\n\n```\nstruct Example {\n    int node;\n};\n\nstruct Example *ex;\n\nex->node = 10;\n```\n\n结构体变量\n\n```\nstruct Example {\n    int node;\n};\n\nstruct Example ex;\n\nex.node = 10;\n```\n\n两个的访问形式不同，第一个是动态内存，数据是放在常量区，而指针放在栈上，所占用空间比较小，第二个是全部都在栈上，但是占用空间比较大\n\n如果空间比较大，要求速度比较快，可以定义结构体变量，如果空间小，速度要求不是很快，可以使用指针结构体\n\n## 12.静态函数和动态函数的区别\n\n#### 静态函数\n\n**效率高**：由于内存位置固定，访问速度较快。\n\n**简单**：不需要动态分配和释放内存，管理简单。\n\n#### 动态函数\n\n**灵活性高**：可以在运行时动态加载和卸载函数，适应不同的需求。\n\n**节省资源**：只在需要时加载和使用函数，避免了不必要的内存消耗。\n\n## 13.进程隐藏如何查找\n\n```\nCtrl+Z - 暂停进程并放入后台\n\njobs - 显示当前暂停的进程\n\nbg N 使第N个任务在后台中止\n\nfg N 使第N个任务在前台运行\n\nbg, fg 不带 N 时表示对最后一个进程操作\n```\n\n## 14.进程查找\n\n```\n//根据名字查找\nps -ef | grep XXX\n\n//查看所有静态进程\nps\n\n//查看所有动态进程\ntop\n```\n\n## 15.什么时候分配内存\n\n在写程序的时候，老是遇到有些需要分配内存，有些不需要分配内存，分配内存的都在堆上，不分配的都在栈上，栈是函数结束后自动释放，而堆需要手动释放，否则就会出现内存泄漏\n\n我们常见函数的返回值也是在栈上的，因为返回后直接取值即可，不需要跨函数、跨线程操作\n\n如何区别，啥时候使用呢，其实就看你这个数据在函数结束之后，里面的数据还要不要，会不会保留给其他函数或者线程使用，如果要的话，就需要分配内存，如果不要，则无需分配内存\n\n## 16.内存对齐问题\n\n内存块因为是以字节为单位，所以有时候7位6位，都会被系统认定为8位，所以会导致数据出现问题，因此，在结构体或者一些整块段的一定要考虑内存对齐，否则数据会出现丢失，比如下面的两个结构体\n\n```\ntypedef struct\n{\n    long mtype;             // 消息类型，为正整数。用于区分不同类型的消息\n    uint32_t origin;        // 消息来源的标识\n    uint32_t buffNum;       // 命令标识\n    size_t buffLen;         // 消息数据的实际长度\n    uint8_t buffStr[DATA_LEN]; // 消息数据的缓冲区\n} Msgbuff_t;\n\ntypedef struct\n{\n    long mtype;             // 消息类型，为正整数。用于区分不同类型的消息\n    uint32_t origin;        // 消息来源的标识\n    uint32_t buffNum;       // 命令标识\n    uint8_t buffStr[DATA_LEN]; // 消息数据的缓冲区\n    size_t buffLen;         // 消息数据的实际长度\n} Msgbuff_t;\n```\n\n这两个结构体看似一样，但是输出的时候，就会出现不一样的结果了，第一个是正常输出的，因为内存对齐的时候，以靠近的为主，正好前四个的内存块为8、4、4、8，内存的分布是正常的，但是如果是第二个，假设DATA_LEN是100，那么就会出现buffLen前面会填充其他的字节，从而导致数据错乱\n\n## 17.VScode乱码情况\n\n```\n打开VScode。\n按下快捷键Ctrl+,（或选择菜单栏的“文件”->“首选项”->“设置”）。\n在搜索框中输入“encoding”。\n找到“Files: Encoding”选项，确保它设置为“UTF-8”。\n如果需要，还可以设置“Editor: Detect Indentation”为“false”，以防止VScode自动检测并更改缩进。\n```\n\n## 18.主机可以ping通虚拟机，虚拟机不行\n\n控制面板->系统和安全->防火墙->高级系统设置->入站规则->文件和打印机共享（回显请求 - ICMPv4-In） 专用、公用\n\n将上面的进行启用，主机的防火墙将请求隔断了，如果还不行关闭防火墙\n\n## 19.虚拟机无法使用mobaxtem连接\n\n#### 1.关闭防火墙\n\n```\nsudo ufw disable // 关闭防火墙\nsudo ufw enable  // 开启防火墙\n```\n\n#### 2.安装软件包\n\n```\n(1)apt-get remove openssh-server\n(2)sudo apt install openssh-server\n(3)sudo service ssh start\n(4) ps -aux | grep ssh\n(5)okoksadasdasdsadasdsadasdasd192.168.31.224192.168.31.224192.168.31.224192.，asdasdasdasdasdasdasdqweqw\n```\n\n然后就再连接一下就可以了\n","slug":"嵌入式生活小常识","published":1,"updated":"2024-10-04T15:05:02.165Z","_id":"cm0kedtpu0004psfb47f332g3","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"嵌入式生活小常识\"><a href=\"#嵌入式生活小常识\" class=\"headerlink\" title=\"嵌入式生活小常识\"></a>嵌入式生活小常识</h1><h2 id=\"1-VScode不能使用搜狗输入法\"><a href=\"#1-VScode不能使用搜狗输入法\" class=\"headerlink\" title=\"1.VScode不能使用搜狗输入法\"></a>1.VScode不能使用搜狗输入法</h2><p>Ubuntu的应用市场下载的code，安装的VSCode是snap的削减版本，不支持中文。</p>\n<p>阉割版的在Linux里面巨卡，而且还会出现各种bug，拒绝使用</p>\n<p>解决办法：卸载后重新安装官方版本。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-comment\">//首先先卸载vscode</span><br>sudo snap remove <span class=\"hljs-selector-tag\">code</span><br><br><span class=\"hljs-comment\">//从官网下载号deb文件包后，执行下面命令进行安装</span><br>sudo dpkg -<span class=\"hljs-selector-tag\">i</span> xxxxx<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-VM虚拟机和主机无法复制粘贴\"><a href=\"#2-VM虚拟机和主机无法复制粘贴\" class=\"headerlink\" title=\"2.VM虚拟机和主机无法复制粘贴\"></a>2.VM虚拟机和主机无法复制粘贴</h2><p>安装VM-tools工具，虽然他有时候会坏，如果出现用了一段时间还不行，记得重新来一遍</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">sudo apt-<span class=\"hljs-built_in\">get</span> autoremove <span class=\"hljs-keyword\">open</span>-<span class=\"hljs-keyword\">vm</span>-tools<br>sudo apt-<span class=\"hljs-built_in\">get</span> install <span class=\"hljs-keyword\">open</span>-<span class=\"hljs-keyword\">vm</span>-tools<br>sudo apt-<span class=\"hljs-built_in\">get</span> install <span class=\"hljs-keyword\">open</span>-<span class=\"hljs-keyword\">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-尽量少用root模式\"><a href=\"#3-尽量少用root模式\" class=\"headerlink\" title=\"3.尽量少用root模式\"></a>3.尽量少用root模式</h2><p>使用root模式会出现很多程序无法运行的情况，因为你是在root环境下编译的，你必须使用root权限才可以执行</p>\n<p>所以尽量不要进入root模式执行任务和操作各种任务</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-comment\">//权限不够时</span><br>sudo xxxxxxxxx<br><br><span class=\"hljs-comment\">//进入root模式</span><br><span class=\"hljs-keyword\">su</span> -<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-vscode自动保存\"><a href=\"#4-vscode自动保存\" class=\"headerlink\" title=\"4.vscode自动保存\"></a>4.vscode自动保存</h2><p>打开vscode，找到左下角的齿轮，点击之后选择设置</p>\n<p>在搜索框中输入<code>Auto save</code>，之后会出现<code>File：Auto save</code>的选择，后面有四种选项，选择afterDelay就可以了，然后下面会出现多少毫秒进行保存，如果你不是1s中上千行的，500ms足够了。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">off</span><br>这个不用多说，就是没有自动保存。<br>afterDelay<br>这个是在多少毫秒后自动保存。<br><span class=\"hljs-literal\">on</span>FocusChange<br>这个是编辑器失去焦点的时候，才会保存。也就是鼠标在编辑器之外的区域按下左键才会保存。<br><span class=\"hljs-literal\">on</span>WindowChange<br>这个是窗口失去焦点的时候，才会保存。也就是鼠标在整个VScode软件之外的地方点下左键才会保存。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-Linux某个进程卡死\"><a href=\"#5-Linux某个进程卡死\" class=\"headerlink\" title=\"5.Linux某个进程卡死\"></a>5.Linux某个进程卡死</h2><p>使用CTRL+C是常规的结束进程，但有时候并不能实现，会出现卡死的情况</p>\n<p>如果遇到卡死情况可以CTRL+Z，先挂起进程，当然也可以直接从其他地方打开进程，然后在终端输入</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//查找所有运行的进程和进程号</span><br>ps -aux<br><br><span class=\"hljs-comment\">//通过进程号杀死这个进程</span><br>kill [process ID]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-Linux系统各进程应用交互\"><a href=\"#6-Linux系统各进程应用交互\" class=\"headerlink\" title=\"6.Linux系统各进程应用交互\"></a>6.Linux系统各进程应用交互</h2><img src=\"https://s2.loli.net/2024/08/09/9siHtpvEgmK4CI8.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n<h2 id=\"7-如何解决python执行pip出现-File“「stdin」的问题\"><a href=\"#7-如何解决python执行pip出现-File“「stdin」的问题\" class=\"headerlink\" title=\"7.如何解决python执行pip出现 File“「stdin」的问题\"></a>7.如何解决python执行pip出现 File“「stdin」的问题</h2><p>其主要原因是由于pip是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能</p>\n<p>pip是在直接在cmd中运行的，不需要进入到python中运行</p>\n<p>解决的方法是关闭当前cmd窗口，重新进入，不需要进入python，直接输入pip命令就可以.</p>\n<h2 id=\"8-宝藏激活软件\"><a href=\"#8-宝藏激活软件\" class=\"headerlink\" title=\"8.宝藏激活软件\"></a>8.宝藏激活软件</h2><p>进入该网站：<a href=\"https://3.jetbra.in/\">JETBRA.IN CHECKER | IPFS</a></p>\n<p>点击ipfs.io进入另一个网站<a href=\"https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/\">Some keys for testing - jetbra.in (ipfs.io)</a></p>\n<p>然后点击最上面蓝色的jetbra.zip进行下载，下载完之后，进入.\\jetbra\\jetbra\\scripts该目录下，双击执行install-current-user.vbs，点击执行</p>\n<p>等待10-20s之后，等到跳出done的弹窗后，再回到<a href=\"https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/\">Some keys for testing - jetbra.in (ipfs.io)</a>网页，找到所需软件，复制激活码输入</p>\n<p>即可完成软件的激活，一般是两年时间，过期了重新激活就行</p>\n<h2 id=\"9-Linux系统构建C-C-编译\"><a href=\"#9-Linux系统构建C-C-编译\" class=\"headerlink\" title=\"9.Linux系统构建C&#x2F;C++编译\"></a>9.Linux系统构建C&#x2F;C++编译</h2><p>首先安装vscode的不同环境版本：<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a></p>\n<p>VScode官方教程，图文并茂：<a href=\"https://vscode.js.cn/docs/cpp/config-linux\">https://vscode.js.cn/docs/cpp/config-linux</a></p>\n<p>之后在vscode的插件栏安装两个插件：C&#x2F;C++和Code Runner</p>\n<p>代码编辑完成后还不能直接运行。还需要配置两个json文件。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">tasks.<span class=\"hljs-keyword\">json </span>用来是设置指令编译代码。<br>launch.<span class=\"hljs-keyword\">json </span>设置执行环境来执行代码。（如果不设置每次点击调试的时候都需要手动选择debugger）<br></code></pre></td></tr></table></figure>\n\n<p>新建.vscode文件夹，在文件夹里面新建两个文件，分别是tasks.json和launch.json，然后填入该代码即可运行c文件了</p>\n<h4 id=\"tasks-json\"><a href=\"#tasks-json\" class=\"headerlink\" title=\"tasks.json\"></a>tasks.json</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;2.0.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;tasks&quot;</span>: [<br>    &#123;<br>      <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;shell&quot;</span>,<br>      <span class=\"hljs-string\">&quot;label&quot;</span>: <span class=\"hljs-string\">&quot;C/C++: g++ build active file&quot;</span>,<br>      <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;/usr/bin/g++&quot;</span>,<br>      <span class=\"hljs-string\">&quot;args&quot;</span>: [<span class=\"hljs-string\">&quot;-g&quot;</span>, <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;file&#125;</span>&quot;</span>, <span class=\"hljs-string\">&quot;-o&quot;</span>, <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;fileDirname&#125;</span>/<span class=\"hljs-variable\">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>],<br>      <span class=\"hljs-string\">&quot;options&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;/usr/bin&quot;</span><br>      &#125;,<br>      <span class=\"hljs-string\">&quot;problemMatcher&quot;</span>: [<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$gcc</span>&quot;</span>],<br>      <span class=\"hljs-string\">&quot;group&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;build&quot;</span>,<br>        <span class=\"hljs-string\">&quot;isDefault&quot;</span>: <span class=\"hljs-literal\">true</span><br>      &#125;,<br>      <span class=\"hljs-string\">&quot;detail&quot;</span>: <span class=\"hljs-string\">&quot;Task generated by Debugger.&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"launch-json\"><a href=\"#launch-json\" class=\"headerlink\" title=\"launch.json\"></a>launch.json</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.2.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;configurations&quot;</span>: [<br>    &#123;<br>      <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;C/C++: g++ build and debug active file&quot;</span>,<br>      <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;cppdbg&quot;</span>,<br>      <span class=\"hljs-string\">&quot;request&quot;</span>: <span class=\"hljs-string\">&quot;launch&quot;</span>,<br>      <span class=\"hljs-string\">&quot;program&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;fileDirname&#125;</span>/<span class=\"hljs-variable\">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>,<br>      <span class=\"hljs-string\">&quot;args&quot;</span>: [],<br>      <span class=\"hljs-string\">&quot;stopAtEntry&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;workspaceFolder&#125;</span>&quot;</span>,<br>      <span class=\"hljs-string\">&quot;environment&quot;</span>: [],<br>      <span class=\"hljs-string\">&quot;externalConsole&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-string\">&quot;MIMode&quot;</span>: <span class=\"hljs-string\">&quot;gdb&quot;</span>,<br>      <span class=\"hljs-string\">&quot;miDebuggerPath&quot;</span>: <span class=\"hljs-string\">&quot;/usr/bin/gdb&quot;</span>,<br>      <span class=\"hljs-string\">&quot;setupCommands&quot;</span>: [<br>        &#123;<br>          <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;Enable pretty-printing for gdb&quot;</span>,<br>          <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;-enable-pretty-printing&quot;</span>,<br>          <span class=\"hljs-string\">&quot;ignoreFailures&quot;</span>: <span class=\"hljs-literal\">true</span><br>        &#125;<br>      ],<br>      <span class=\"hljs-string\">&quot;preLaunchTask&quot;</span>: <span class=\"hljs-string\">&quot;C/C++: g++ build active file&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"10-CH340和CP2102的区别\"><a href=\"#10-CH340和CP2102的区别\" class=\"headerlink\" title=\"10.CH340和CP2102的区别\"></a>10.CH340和CP2102的区别</h2><p>我们再使用单片机连接电脑的时候，需要注意芯片的串口转USB协议，而340和CP2102就是两种不同的协议</p>\n<p>稳定性与速度上来说，CP2102的要好一些，而CH340，一般的使用是可以的，电路也简单</p>\n<p>CP2102支持高速率传输，并且更加稳定，而CH340在高速传输时会有几率出现问题，但是成本低，并且应用范围更广</p>\n<h2 id=\"11-结构体指针和结构体变量的区别\"><a href=\"#11-结构体指针和结构体变量的区别\" class=\"headerlink\" title=\"11.结构体指针和结构体变量的区别\"></a>11.结构体指针和结构体变量的区别</h2><p>结构体指针</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">struct Example &#123;<br>    int <span class=\"hljs-keyword\">node</span><span class=\"hljs-title\">;</span><br><span class=\"hljs-title\">&#125;;</span><br><span class=\"hljs-title\"></span><br><span class=\"hljs-title\">struct</span> Example *ex;<br><br>ex-&gt;<span class=\"hljs-keyword\">node</span> <span class=\"hljs-title\">= 10</span>;<br></code></pre></td></tr></table></figure>\n\n<p>结构体变量</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">struct Example &#123;<br>    int node<span class=\"hljs-comment\">;</span><br>&#125;<span class=\"hljs-comment\">;</span><br><br>struct Example ex<span class=\"hljs-comment\">;</span><br><br>ex.node <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>两个的访问形式不同，第一个是动态内存，数据是放在常量区，而指针放在栈上，所占用空间比较小，第二个是全部都在栈上，但是占用空间比较大</p>\n<p>如果空间比较大，要求速度比较快，可以定义结构体变量，如果空间小，速度要求不是很快，可以使用指针结构体</p>\n<h2 id=\"12-静态函数和动态函数的区别\"><a href=\"#12-静态函数和动态函数的区别\" class=\"headerlink\" title=\"12.静态函数和动态函数的区别\"></a>12.静态函数和动态函数的区别</h2><h4 id=\"静态函数\"><a href=\"#静态函数\" class=\"headerlink\" title=\"静态函数\"></a>静态函数</h4><p><strong>效率高</strong>：由于内存位置固定，访问速度较快。</p>\n<p><strong>简单</strong>：不需要动态分配和释放内存，管理简单。</p>\n<h4 id=\"动态函数\"><a href=\"#动态函数\" class=\"headerlink\" title=\"动态函数\"></a>动态函数</h4><p><strong>灵活性高</strong>：可以在运行时动态加载和卸载函数，适应不同的需求。</p>\n<p><strong>节省资源</strong>：只在需要时加载和使用函数，避免了不必要的内存消耗。</p>\n<h2 id=\"13-进程隐藏如何查找\"><a href=\"#13-进程隐藏如何查找\" class=\"headerlink\" title=\"13.进程隐藏如何查找\"></a>13.进程隐藏如何查找</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Ctrl+Z - 暂停进程并放入后台<br><br><span class=\"hljs-built_in\">jobs</span> - 显示当前暂停的进程<br><br><span class=\"hljs-built_in\">bg</span> N 使第N个任务在后台中止<br><br><span class=\"hljs-built_in\">fg</span> N 使第N个任务在前台运行<br><br><span class=\"hljs-built_in\">bg</span>, <span class=\"hljs-built_in\">fg</span> 不带 N 时表示对最后一个进程操作<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"14-进程查找\"><a href=\"#14-进程查找\" class=\"headerlink\" title=\"14.进程查找\"></a>14.进程查找</h2><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//根据名字查找</span><br>ps <span class=\"hljs-punctuation\">-</span>ef <span class=\"hljs-string\">| grep XXX</span><br><br><span class=\"hljs-comment\">//查看所有静态进程</span><br>ps<br><br><span class=\"hljs-comment\">//查看所有动态进程</span><br>top<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"15-什么时候分配内存\"><a href=\"#15-什么时候分配内存\" class=\"headerlink\" title=\"15.什么时候分配内存\"></a>15.什么时候分配内存</h2><p>在写程序的时候，老是遇到有些需要分配内存，有些不需要分配内存，分配内存的都在堆上，不分配的都在栈上，栈是函数结束后自动释放，而堆需要手动释放，否则就会出现内存泄漏</p>\n<p>我们常见函数的返回值也是在栈上的，因为返回后直接取值即可，不需要跨函数、跨线程操作</p>\n<p>如何区别，啥时候使用呢，其实就看你这个数据在函数结束之后，里面的数据还要不要，会不会保留给其他函数或者线程使用，如果要的话，就需要分配内存，如果不要，则无需分配内存</p>\n<h2 id=\"16-内存对齐问题\"><a href=\"#16-内存对齐问题\" class=\"headerlink\" title=\"16.内存对齐问题\"></a>16.内存对齐问题</h2><p>内存块因为是以字节为单位，所以有时候7位6位，都会被系统认定为8位，所以会导致数据出现问题，因此，在结构体或者一些整块段的一定要考虑内存对齐，否则数据会出现丢失，比如下面的两个结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span><br>&#123;<br>    <span class=\"hljs-type\">long</span> mtype;             <span class=\"hljs-comment\">// 消息类型，为正整数。用于区分不同类型的消息</span><br>    <span class=\"hljs-type\">uint32_t</span> origin;        <span class=\"hljs-comment\">// 消息来源的标识</span><br>    <span class=\"hljs-type\">uint32_t</span> buffNum;       <span class=\"hljs-comment\">// 命令标识</span><br>    <span class=\"hljs-type\">size_t</span> buffLen;         <span class=\"hljs-comment\">// 消息数据的实际长度</span><br>    <span class=\"hljs-type\">uint8_t</span> buffStr[DATA_LEN]; <span class=\"hljs-comment\">// 消息数据的缓冲区</span><br>&#125; Msgbuff_t;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span><br>&#123;<br>    <span class=\"hljs-type\">long</span> mtype;             <span class=\"hljs-comment\">// 消息类型，为正整数。用于区分不同类型的消息</span><br>    <span class=\"hljs-type\">uint32_t</span> origin;        <span class=\"hljs-comment\">// 消息来源的标识</span><br>    <span class=\"hljs-type\">uint32_t</span> buffNum;       <span class=\"hljs-comment\">// 命令标识</span><br>    <span class=\"hljs-type\">uint8_t</span> buffStr[DATA_LEN]; <span class=\"hljs-comment\">// 消息数据的缓冲区</span><br>    <span class=\"hljs-type\">size_t</span> buffLen;         <span class=\"hljs-comment\">// 消息数据的实际长度</span><br>&#125; Msgbuff_t;<br></code></pre></td></tr></table></figure>\n\n<p>这两个结构体看似一样，但是输出的时候，就会出现不一样的结果了，第一个是正常输出的，因为内存对齐的时候，以靠近的为主，正好前四个的内存块为8、4、4、8，内存的分布是正常的，但是如果是第二个，假设DATA_LEN是100，那么就会出现buffLen前面会填充其他的字节，从而导致数据错乱</p>\n<h2 id=\"17-VScode乱码情况\"><a href=\"#17-VScode乱码情况\" class=\"headerlink\" title=\"17.VScode乱码情况\"></a>17.VScode乱码情况</h2><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\">打开VScode。<br>按下快捷键Ctrl+,（或选择菜单栏的“文件”-&gt;“首选项”-&gt;“设置”）。<br>在搜索框中输入“encoding”。<br>找到“Files: Encoding”选项，确保它设置为“UTF-<span class=\"hljs-number\">8</span>”。<br>如果需要，还可以设置“Editor: Detect Indentation”为“<span class=\"hljs-literal\">false</span>”，以防止VScode自动检测并更改缩进。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"18-主机可以ping通虚拟机，虚拟机不行\"><a href=\"#18-主机可以ping通虚拟机，虚拟机不行\" class=\"headerlink\" title=\"18.主机可以ping通虚拟机，虚拟机不行\"></a>18.主机可以ping通虚拟机，虚拟机不行</h2><p>控制面板-&gt;系统和安全-&gt;防火墙-&gt;高级系统设置-&gt;入站规则-&gt;文件和打印机共享（回显请求 - ICMPv4-In） 专用、公用</p>\n<p>将上面的进行启用，主机的防火墙将请求隔断了，如果还不行关闭防火墙</p>\n<h2 id=\"19-虚拟机无法使用mobaxtem连接\"><a href=\"#19-虚拟机无法使用mobaxtem连接\" class=\"headerlink\" title=\"19.虚拟机无法使用mobaxtem连接\"></a>19.虚拟机无法使用mobaxtem连接</h2><h4 id=\"1-关闭防火墙\"><a href=\"#1-关闭防火墙\" class=\"headerlink\" title=\"1.关闭防火墙\"></a>1.关闭防火墙</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> ufw <span class=\"hljs-built_in\">disable</span> // 关闭防火墙<br><span class=\"hljs-built_in\">sudo</span> ufw <span class=\"hljs-built_in\">enable</span>  // 开启防火墙<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-安装软件包\"><a href=\"#2-安装软件包\" class=\"headerlink\" title=\"2.安装软件包\"></a>2.安装软件包</h4><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">(1)apt-<span class=\"hljs-built_in\">get</span> <span class=\"hljs-built_in\">remove</span> openssh-server<br>(2)sudo apt install openssh-server<br>(3)sudo<span class=\"hljs-built_in\"> service </span>ssh start<br>(4) ps -aux | grep ssh<br>(5)okoksadasdasdsadasdsadasdasd192.168.31.224192.168.31.224192.168.31.224192.，asdasdasdasdasdasdasdqweqw<br></code></pre></td></tr></table></figure>\n\n<p>然后就再连接一下就可以了</p>\n","excerpt":"","more":"<h1 id=\"嵌入式生活小常识\"><a href=\"#嵌入式生活小常识\" class=\"headerlink\" title=\"嵌入式生活小常识\"></a>嵌入式生活小常识</h1><h2 id=\"1-VScode不能使用搜狗输入法\"><a href=\"#1-VScode不能使用搜狗输入法\" class=\"headerlink\" title=\"1.VScode不能使用搜狗输入法\"></a>1.VScode不能使用搜狗输入法</h2><p>Ubuntu的应用市场下载的code，安装的VSCode是snap的削减版本，不支持中文。</p>\n<p>阉割版的在Linux里面巨卡，而且还会出现各种bug，拒绝使用</p>\n<p>解决办法：卸载后重新安装官方版本。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-comment\">//首先先卸载vscode</span><br>sudo snap remove <span class=\"hljs-selector-tag\">code</span><br><br><span class=\"hljs-comment\">//从官网下载号deb文件包后，执行下面命令进行安装</span><br>sudo dpkg -<span class=\"hljs-selector-tag\">i</span> xxxxx<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-VM虚拟机和主机无法复制粘贴\"><a href=\"#2-VM虚拟机和主机无法复制粘贴\" class=\"headerlink\" title=\"2.VM虚拟机和主机无法复制粘贴\"></a>2.VM虚拟机和主机无法复制粘贴</h2><p>安装VM-tools工具，虽然他有时候会坏，如果出现用了一段时间还不行，记得重新来一遍</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">sudo apt-<span class=\"hljs-built_in\">get</span> autoremove <span class=\"hljs-keyword\">open</span>-<span class=\"hljs-keyword\">vm</span>-tools<br>sudo apt-<span class=\"hljs-built_in\">get</span> install <span class=\"hljs-keyword\">open</span>-<span class=\"hljs-keyword\">vm</span>-tools<br>sudo apt-<span class=\"hljs-built_in\">get</span> install <span class=\"hljs-keyword\">open</span>-<span class=\"hljs-keyword\">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-尽量少用root模式\"><a href=\"#3-尽量少用root模式\" class=\"headerlink\" title=\"3.尽量少用root模式\"></a>3.尽量少用root模式</h2><p>使用root模式会出现很多程序无法运行的情况，因为你是在root环境下编译的，你必须使用root权限才可以执行</p>\n<p>所以尽量不要进入root模式执行任务和操作各种任务</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-comment\">//权限不够时</span><br>sudo xxxxxxxxx<br><br><span class=\"hljs-comment\">//进入root模式</span><br><span class=\"hljs-keyword\">su</span> -<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-vscode自动保存\"><a href=\"#4-vscode自动保存\" class=\"headerlink\" title=\"4.vscode自动保存\"></a>4.vscode自动保存</h2><p>打开vscode，找到左下角的齿轮，点击之后选择设置</p>\n<p>在搜索框中输入<code>Auto save</code>，之后会出现<code>File：Auto save</code>的选择，后面有四种选项，选择afterDelay就可以了，然后下面会出现多少毫秒进行保存，如果你不是1s中上千行的，500ms足够了。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">off</span><br>这个不用多说，就是没有自动保存。<br>afterDelay<br>这个是在多少毫秒后自动保存。<br><span class=\"hljs-literal\">on</span>FocusChange<br>这个是编辑器失去焦点的时候，才会保存。也就是鼠标在编辑器之外的区域按下左键才会保存。<br><span class=\"hljs-literal\">on</span>WindowChange<br>这个是窗口失去焦点的时候，才会保存。也就是鼠标在整个VScode软件之外的地方点下左键才会保存。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-Linux某个进程卡死\"><a href=\"#5-Linux某个进程卡死\" class=\"headerlink\" title=\"5.Linux某个进程卡死\"></a>5.Linux某个进程卡死</h2><p>使用CTRL+C是常规的结束进程，但有时候并不能实现，会出现卡死的情况</p>\n<p>如果遇到卡死情况可以CTRL+Z，先挂起进程，当然也可以直接从其他地方打开进程，然后在终端输入</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//查找所有运行的进程和进程号</span><br>ps -aux<br><br><span class=\"hljs-comment\">//通过进程号杀死这个进程</span><br>kill [process ID]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-Linux系统各进程应用交互\"><a href=\"#6-Linux系统各进程应用交互\" class=\"headerlink\" title=\"6.Linux系统各进程应用交互\"></a>6.Linux系统各进程应用交互</h2><img src=\"https://s2.loli.net/2024/08/09/9siHtpvEgmK4CI8.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n<h2 id=\"7-如何解决python执行pip出现-File“「stdin」的问题\"><a href=\"#7-如何解决python执行pip出现-File“「stdin」的问题\" class=\"headerlink\" title=\"7.如何解决python执行pip出现 File“「stdin」的问题\"></a>7.如何解决python执行pip出现 File“「stdin」的问题</h2><p>其主要原因是由于pip是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能</p>\n<p>pip是在直接在cmd中运行的，不需要进入到python中运行</p>\n<p>解决的方法是关闭当前cmd窗口，重新进入，不需要进入python，直接输入pip命令就可以.</p>\n<h2 id=\"8-宝藏激活软件\"><a href=\"#8-宝藏激活软件\" class=\"headerlink\" title=\"8.宝藏激活软件\"></a>8.宝藏激活软件</h2><p>进入该网站：<a href=\"https://3.jetbra.in/\">JETBRA.IN CHECKER | IPFS</a></p>\n<p>点击ipfs.io进入另一个网站<a href=\"https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/\">Some keys for testing - jetbra.in (ipfs.io)</a></p>\n<p>然后点击最上面蓝色的jetbra.zip进行下载，下载完之后，进入.\\jetbra\\jetbra\\scripts该目录下，双击执行install-current-user.vbs，点击执行</p>\n<p>等待10-20s之后，等到跳出done的弹窗后，再回到<a href=\"https://ipfs.io/ipfs/bafybeih65no5dklpqfe346wyeiak6wzemv5d7z2ya7nssdgwdz4xrmdu6i/\">Some keys for testing - jetbra.in (ipfs.io)</a>网页，找到所需软件，复制激活码输入</p>\n<p>即可完成软件的激活，一般是两年时间，过期了重新激活就行</p>\n<h2 id=\"9-Linux系统构建C-C-编译\"><a href=\"#9-Linux系统构建C-C-编译\" class=\"headerlink\" title=\"9.Linux系统构建C&#x2F;C++编译\"></a>9.Linux系统构建C&#x2F;C++编译</h2><p>首先安装vscode的不同环境版本：<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a></p>\n<p>VScode官方教程，图文并茂：<a href=\"https://vscode.js.cn/docs/cpp/config-linux\">https://vscode.js.cn/docs/cpp/config-linux</a></p>\n<p>之后在vscode的插件栏安装两个插件：C&#x2F;C++和Code Runner</p>\n<p>代码编辑完成后还不能直接运行。还需要配置两个json文件。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">tasks.<span class=\"hljs-keyword\">json </span>用来是设置指令编译代码。<br>launch.<span class=\"hljs-keyword\">json </span>设置执行环境来执行代码。（如果不设置每次点击调试的时候都需要手动选择debugger）<br></code></pre></td></tr></table></figure>\n\n<p>新建.vscode文件夹，在文件夹里面新建两个文件，分别是tasks.json和launch.json，然后填入该代码即可运行c文件了</p>\n<h4 id=\"tasks-json\"><a href=\"#tasks-json\" class=\"headerlink\" title=\"tasks.json\"></a>tasks.json</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;2.0.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;tasks&quot;</span>: [<br>    &#123;<br>      <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;shell&quot;</span>,<br>      <span class=\"hljs-string\">&quot;label&quot;</span>: <span class=\"hljs-string\">&quot;C/C++: g++ build active file&quot;</span>,<br>      <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;/usr/bin/g++&quot;</span>,<br>      <span class=\"hljs-string\">&quot;args&quot;</span>: [<span class=\"hljs-string\">&quot;-g&quot;</span>, <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;file&#125;</span>&quot;</span>, <span class=\"hljs-string\">&quot;-o&quot;</span>, <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;fileDirname&#125;</span>/<span class=\"hljs-variable\">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>],<br>      <span class=\"hljs-string\">&quot;options&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;/usr/bin&quot;</span><br>      &#125;,<br>      <span class=\"hljs-string\">&quot;problemMatcher&quot;</span>: [<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$gcc</span>&quot;</span>],<br>      <span class=\"hljs-string\">&quot;group&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;build&quot;</span>,<br>        <span class=\"hljs-string\">&quot;isDefault&quot;</span>: <span class=\"hljs-literal\">true</span><br>      &#125;,<br>      <span class=\"hljs-string\">&quot;detail&quot;</span>: <span class=\"hljs-string\">&quot;Task generated by Debugger.&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"launch-json\"><a href=\"#launch-json\" class=\"headerlink\" title=\"launch.json\"></a>launch.json</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&#123;<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.2.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;configurations&quot;</span>: [<br>    &#123;<br>      <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;C/C++: g++ build and debug active file&quot;</span>,<br>      <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;cppdbg&quot;</span>,<br>      <span class=\"hljs-string\">&quot;request&quot;</span>: <span class=\"hljs-string\">&quot;launch&quot;</span>,<br>      <span class=\"hljs-string\">&quot;program&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;fileDirname&#125;</span>/<span class=\"hljs-variable\">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>,<br>      <span class=\"hljs-string\">&quot;args&quot;</span>: [],<br>      <span class=\"hljs-string\">&quot;stopAtEntry&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;workspaceFolder&#125;</span>&quot;</span>,<br>      <span class=\"hljs-string\">&quot;environment&quot;</span>: [],<br>      <span class=\"hljs-string\">&quot;externalConsole&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-string\">&quot;MIMode&quot;</span>: <span class=\"hljs-string\">&quot;gdb&quot;</span>,<br>      <span class=\"hljs-string\">&quot;miDebuggerPath&quot;</span>: <span class=\"hljs-string\">&quot;/usr/bin/gdb&quot;</span>,<br>      <span class=\"hljs-string\">&quot;setupCommands&quot;</span>: [<br>        &#123;<br>          <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;Enable pretty-printing for gdb&quot;</span>,<br>          <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;-enable-pretty-printing&quot;</span>,<br>          <span class=\"hljs-string\">&quot;ignoreFailures&quot;</span>: <span class=\"hljs-literal\">true</span><br>        &#125;<br>      ],<br>      <span class=\"hljs-string\">&quot;preLaunchTask&quot;</span>: <span class=\"hljs-string\">&quot;C/C++: g++ build active file&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"10-CH340和CP2102的区别\"><a href=\"#10-CH340和CP2102的区别\" class=\"headerlink\" title=\"10.CH340和CP2102的区别\"></a>10.CH340和CP2102的区别</h2><p>我们再使用单片机连接电脑的时候，需要注意芯片的串口转USB协议，而340和CP2102就是两种不同的协议</p>\n<p>稳定性与速度上来说，CP2102的要好一些，而CH340，一般的使用是可以的，电路也简单</p>\n<p>CP2102支持高速率传输，并且更加稳定，而CH340在高速传输时会有几率出现问题，但是成本低，并且应用范围更广</p>\n<h2 id=\"11-结构体指针和结构体变量的区别\"><a href=\"#11-结构体指针和结构体变量的区别\" class=\"headerlink\" title=\"11.结构体指针和结构体变量的区别\"></a>11.结构体指针和结构体变量的区别</h2><p>结构体指针</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">struct Example &#123;<br>    int <span class=\"hljs-keyword\">node</span><span class=\"hljs-title\">;</span><br><span class=\"hljs-title\">&#125;;</span><br><span class=\"hljs-title\"></span><br><span class=\"hljs-title\">struct</span> Example *ex;<br><br>ex-&gt;<span class=\"hljs-keyword\">node</span> <span class=\"hljs-title\">= 10</span>;<br></code></pre></td></tr></table></figure>\n\n<p>结构体变量</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">struct Example &#123;<br>    int node<span class=\"hljs-comment\">;</span><br>&#125;<span class=\"hljs-comment\">;</span><br><br>struct Example ex<span class=\"hljs-comment\">;</span><br><br>ex.node <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>两个的访问形式不同，第一个是动态内存，数据是放在常量区，而指针放在栈上，所占用空间比较小，第二个是全部都在栈上，但是占用空间比较大</p>\n<p>如果空间比较大，要求速度比较快，可以定义结构体变量，如果空间小，速度要求不是很快，可以使用指针结构体</p>\n<h2 id=\"12-静态函数和动态函数的区别\"><a href=\"#12-静态函数和动态函数的区别\" class=\"headerlink\" title=\"12.静态函数和动态函数的区别\"></a>12.静态函数和动态函数的区别</h2><h4 id=\"静态函数\"><a href=\"#静态函数\" class=\"headerlink\" title=\"静态函数\"></a>静态函数</h4><p><strong>效率高</strong>：由于内存位置固定，访问速度较快。</p>\n<p><strong>简单</strong>：不需要动态分配和释放内存，管理简单。</p>\n<h4 id=\"动态函数\"><a href=\"#动态函数\" class=\"headerlink\" title=\"动态函数\"></a>动态函数</h4><p><strong>灵活性高</strong>：可以在运行时动态加载和卸载函数，适应不同的需求。</p>\n<p><strong>节省资源</strong>：只在需要时加载和使用函数，避免了不必要的内存消耗。</p>\n<h2 id=\"13-进程隐藏如何查找\"><a href=\"#13-进程隐藏如何查找\" class=\"headerlink\" title=\"13.进程隐藏如何查找\"></a>13.进程隐藏如何查找</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Ctrl+Z - 暂停进程并放入后台<br><br><span class=\"hljs-built_in\">jobs</span> - 显示当前暂停的进程<br><br><span class=\"hljs-built_in\">bg</span> N 使第N个任务在后台中止<br><br><span class=\"hljs-built_in\">fg</span> N 使第N个任务在前台运行<br><br><span class=\"hljs-built_in\">bg</span>, <span class=\"hljs-built_in\">fg</span> 不带 N 时表示对最后一个进程操作<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"14-进程查找\"><a href=\"#14-进程查找\" class=\"headerlink\" title=\"14.进程查找\"></a>14.进程查找</h2><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//根据名字查找</span><br>ps <span class=\"hljs-punctuation\">-</span>ef <span class=\"hljs-string\">| grep XXX</span><br><br><span class=\"hljs-comment\">//查看所有静态进程</span><br>ps<br><br><span class=\"hljs-comment\">//查看所有动态进程</span><br>top<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"15-什么时候分配内存\"><a href=\"#15-什么时候分配内存\" class=\"headerlink\" title=\"15.什么时候分配内存\"></a>15.什么时候分配内存</h2><p>在写程序的时候，老是遇到有些需要分配内存，有些不需要分配内存，分配内存的都在堆上，不分配的都在栈上，栈是函数结束后自动释放，而堆需要手动释放，否则就会出现内存泄漏</p>\n<p>我们常见函数的返回值也是在栈上的，因为返回后直接取值即可，不需要跨函数、跨线程操作</p>\n<p>如何区别，啥时候使用呢，其实就看你这个数据在函数结束之后，里面的数据还要不要，会不会保留给其他函数或者线程使用，如果要的话，就需要分配内存，如果不要，则无需分配内存</p>\n<h2 id=\"16-内存对齐问题\"><a href=\"#16-内存对齐问题\" class=\"headerlink\" title=\"16.内存对齐问题\"></a>16.内存对齐问题</h2><p>内存块因为是以字节为单位，所以有时候7位6位，都会被系统认定为8位，所以会导致数据出现问题，因此，在结构体或者一些整块段的一定要考虑内存对齐，否则数据会出现丢失，比如下面的两个结构体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span><br>&#123;<br>    <span class=\"hljs-type\">long</span> mtype;             <span class=\"hljs-comment\">// 消息类型，为正整数。用于区分不同类型的消息</span><br>    <span class=\"hljs-type\">uint32_t</span> origin;        <span class=\"hljs-comment\">// 消息来源的标识</span><br>    <span class=\"hljs-type\">uint32_t</span> buffNum;       <span class=\"hljs-comment\">// 命令标识</span><br>    <span class=\"hljs-type\">size_t</span> buffLen;         <span class=\"hljs-comment\">// 消息数据的实际长度</span><br>    <span class=\"hljs-type\">uint8_t</span> buffStr[DATA_LEN]; <span class=\"hljs-comment\">// 消息数据的缓冲区</span><br>&#125; Msgbuff_t;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span><br>&#123;<br>    <span class=\"hljs-type\">long</span> mtype;             <span class=\"hljs-comment\">// 消息类型，为正整数。用于区分不同类型的消息</span><br>    <span class=\"hljs-type\">uint32_t</span> origin;        <span class=\"hljs-comment\">// 消息来源的标识</span><br>    <span class=\"hljs-type\">uint32_t</span> buffNum;       <span class=\"hljs-comment\">// 命令标识</span><br>    <span class=\"hljs-type\">uint8_t</span> buffStr[DATA_LEN]; <span class=\"hljs-comment\">// 消息数据的缓冲区</span><br>    <span class=\"hljs-type\">size_t</span> buffLen;         <span class=\"hljs-comment\">// 消息数据的实际长度</span><br>&#125; Msgbuff_t;<br></code></pre></td></tr></table></figure>\n\n<p>这两个结构体看似一样，但是输出的时候，就会出现不一样的结果了，第一个是正常输出的，因为内存对齐的时候，以靠近的为主，正好前四个的内存块为8、4、4、8，内存的分布是正常的，但是如果是第二个，假设DATA_LEN是100，那么就会出现buffLen前面会填充其他的字节，从而导致数据错乱</p>\n<h2 id=\"17-VScode乱码情况\"><a href=\"#17-VScode乱码情况\" class=\"headerlink\" title=\"17.VScode乱码情况\"></a>17.VScode乱码情况</h2><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\">打开VScode。<br>按下快捷键Ctrl+,（或选择菜单栏的“文件”-&gt;“首选项”-&gt;“设置”）。<br>在搜索框中输入“encoding”。<br>找到“Files: Encoding”选项，确保它设置为“UTF-<span class=\"hljs-number\">8</span>”。<br>如果需要，还可以设置“Editor: Detect Indentation”为“<span class=\"hljs-literal\">false</span>”，以防止VScode自动检测并更改缩进。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"18-主机可以ping通虚拟机，虚拟机不行\"><a href=\"#18-主机可以ping通虚拟机，虚拟机不行\" class=\"headerlink\" title=\"18.主机可以ping通虚拟机，虚拟机不行\"></a>18.主机可以ping通虚拟机，虚拟机不行</h2><p>控制面板-&gt;系统和安全-&gt;防火墙-&gt;高级系统设置-&gt;入站规则-&gt;文件和打印机共享（回显请求 - ICMPv4-In） 专用、公用</p>\n<p>将上面的进行启用，主机的防火墙将请求隔断了，如果还不行关闭防火墙</p>\n<h2 id=\"19-虚拟机无法使用mobaxtem连接\"><a href=\"#19-虚拟机无法使用mobaxtem连接\" class=\"headerlink\" title=\"19.虚拟机无法使用mobaxtem连接\"></a>19.虚拟机无法使用mobaxtem连接</h2><h4 id=\"1-关闭防火墙\"><a href=\"#1-关闭防火墙\" class=\"headerlink\" title=\"1.关闭防火墙\"></a>1.关闭防火墙</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> ufw <span class=\"hljs-built_in\">disable</span> // 关闭防火墙<br><span class=\"hljs-built_in\">sudo</span> ufw <span class=\"hljs-built_in\">enable</span>  // 开启防火墙<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-安装软件包\"><a href=\"#2-安装软件包\" class=\"headerlink\" title=\"2.安装软件包\"></a>2.安装软件包</h4><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">(1)apt-<span class=\"hljs-built_in\">get</span> <span class=\"hljs-built_in\">remove</span> openssh-server<br>(2)sudo apt install openssh-server<br>(3)sudo<span class=\"hljs-built_in\"> service </span>ssh start<br>(4) ps -aux | grep ssh<br>(5)okoksadasdasdsadasdsadasdasd192.168.31.224192.168.31.224192.168.31.224192.，asdasdasdasdasdasdasdqweqw<br></code></pre></td></tr></table></figure>\n\n<p>然后就再连接一下就可以了</p>\n"},{"title":"Socket通信流程","date":"2024-08-14T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/15/qPDXg6Z5IRdjzYO.jpg","_content":"\n# Socket通信流程\n\n## 服务端\n\n#### 1.创建套接字\n\n```\nint sockfd; //创建套接字接收区\nsockfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字\n//判断是否创建成功，成功返回0\nif (sockfd < 0) {\n}\n```\n\n#### 2.配置服务器地址\n\n```\n//配置地址结构体，将端口、地址输入到结构体当中\nstruct sockaddr_in serv_addr; \n//清除结构体内部数据，防止干扰\nmemset(&serv_addr, 0, sizeof(serv_addr));\n//结构体内部成员赋值\nserv_addr.sin_family = AF_INET;\nserv_addr.sin_port = htons(PORT); // 替换PORT为具体的端口号\nserv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // 替换为实际的IP地址\n```\n\n#### 3.绑定套接字（仅用于服务器端）\n\n```\n//将套接字和地址结构体进行绑定\nint socket_bind = bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)\n//判断是否绑定成功，成功返回0\nif (socket_bind < 0) {\n}\n```\n\n#### 4.启动监听（仅限服务端）\n\n```\n//启动对socket的监听，5代表同时监听设备最大数为5个，超出部分直接屏蔽\nint socket_listen = listen(sockfd, 5);.\n//判断是否监听成功，成功返回0\nif (socket_listen < 0) {\n}\n```\n\n#### 5.接受设备（仅限服务端）\n\n```\n//定义一个接受成功返回值储存区\nint new_socket;\n//定义一个连接设备的地址结构体\nstruct sockaddr_in client_addr;\n//计算连接设备结构体的长度\nsocklen_t addr_len = sizeof(client_addr);\n//启动对设备的接受操作\nnew_socket = accept(sockfd, (struct sockaddr *)&client_addr, &addr_len);\n//判断是否接受成功，成功返回0\nif (new_socket < 0) {\n}\n```\n\n#### 6.接收数据\n\n```\n//定义存储数据区\nchar buffer[1024] = {0};\n//启动读取函数，读取并存储\nint valread = read(sockfd, buffer, sizeof(buffer));\n```\n\n#### 7.发送数据\n\n```\n//定义发送字符串\nchar *message = \"Hello, Server\";\n//将字符串发送到下位机\nsend(sockfd, message, strlen(message), 0);\n```\n\n#### 8.关闭设备\n\n```\n//关闭socket通信\nclose(sockfd);\n```\n\n## 客户端\n\n#### 1.创建套接字\n\n```\nint sockfd; //创建套接字接收区\nsockfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字\n//判断是否创建成功，成功返回0\nif (sockfd < 0) {\n}\n```\n\n#### 2.配置服务器地址\n\n```\n//配置地址结构体，将端口、地址输入到结构体当中\nstruct sockaddr_in serv_addr; \n//清除结构体内部数据，防止干扰\nmemset(&serv_addr, 0, sizeof(serv_addr));\n//结构体内部成员赋值\nserv_addr.sin_family = AF_INET;\nserv_addr.sin_port = htons(PORT); // 替换PORT为具体的端口号\nserv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // 替换为实际的IP地址\n```\n\n#### 3.连接客户端（仅限客户端）\n\n```\n//用于连接客户端的设备\nint socket_connect = connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr))\n////判断是否连接成功，成功返回0\n```\n\n#### 4.接收数据\n\n```\n//定义存储数据区\nchar buffer[1024] = {0};\n//启动读取函数，读取并存储\nint valread = read(sockfd, buffer, sizeof(buffer));\n```\n\n#### 5.发送数据\n\n```\n//定义发送字符串\nchar *message = \"Hello, Server\";\n//将字符串发送到下位机\nsend(sockfd, message, strlen(message), 0);\n```\n\n#### 6.关闭设备\n\n```\n//关闭socket通信\nclose(sockfd);\n```\n","source":"_posts/Work No.27.md","raw":"---\ntitle: Socket通信流程\ntag: C/C++\ndate: 2024-08-15\ncategories: Socket通信\nindex_img: https://s2.loli.net/2024/08/15/qPDXg6Z5IRdjzYO.jpg\n---\n\n# Socket通信流程\n\n## 服务端\n\n#### 1.创建套接字\n\n```\nint sockfd; //创建套接字接收区\nsockfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字\n//判断是否创建成功，成功返回0\nif (sockfd < 0) {\n}\n```\n\n#### 2.配置服务器地址\n\n```\n//配置地址结构体，将端口、地址输入到结构体当中\nstruct sockaddr_in serv_addr; \n//清除结构体内部数据，防止干扰\nmemset(&serv_addr, 0, sizeof(serv_addr));\n//结构体内部成员赋值\nserv_addr.sin_family = AF_INET;\nserv_addr.sin_port = htons(PORT); // 替换PORT为具体的端口号\nserv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // 替换为实际的IP地址\n```\n\n#### 3.绑定套接字（仅用于服务器端）\n\n```\n//将套接字和地址结构体进行绑定\nint socket_bind = bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)\n//判断是否绑定成功，成功返回0\nif (socket_bind < 0) {\n}\n```\n\n#### 4.启动监听（仅限服务端）\n\n```\n//启动对socket的监听，5代表同时监听设备最大数为5个，超出部分直接屏蔽\nint socket_listen = listen(sockfd, 5);.\n//判断是否监听成功，成功返回0\nif (socket_listen < 0) {\n}\n```\n\n#### 5.接受设备（仅限服务端）\n\n```\n//定义一个接受成功返回值储存区\nint new_socket;\n//定义一个连接设备的地址结构体\nstruct sockaddr_in client_addr;\n//计算连接设备结构体的长度\nsocklen_t addr_len = sizeof(client_addr);\n//启动对设备的接受操作\nnew_socket = accept(sockfd, (struct sockaddr *)&client_addr, &addr_len);\n//判断是否接受成功，成功返回0\nif (new_socket < 0) {\n}\n```\n\n#### 6.接收数据\n\n```\n//定义存储数据区\nchar buffer[1024] = {0};\n//启动读取函数，读取并存储\nint valread = read(sockfd, buffer, sizeof(buffer));\n```\n\n#### 7.发送数据\n\n```\n//定义发送字符串\nchar *message = \"Hello, Server\";\n//将字符串发送到下位机\nsend(sockfd, message, strlen(message), 0);\n```\n\n#### 8.关闭设备\n\n```\n//关闭socket通信\nclose(sockfd);\n```\n\n## 客户端\n\n#### 1.创建套接字\n\n```\nint sockfd; //创建套接字接收区\nsockfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字\n//判断是否创建成功，成功返回0\nif (sockfd < 0) {\n}\n```\n\n#### 2.配置服务器地址\n\n```\n//配置地址结构体，将端口、地址输入到结构体当中\nstruct sockaddr_in serv_addr; \n//清除结构体内部数据，防止干扰\nmemset(&serv_addr, 0, sizeof(serv_addr));\n//结构体内部成员赋值\nserv_addr.sin_family = AF_INET;\nserv_addr.sin_port = htons(PORT); // 替换PORT为具体的端口号\nserv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // 替换为实际的IP地址\n```\n\n#### 3.连接客户端（仅限客户端）\n\n```\n//用于连接客户端的设备\nint socket_connect = connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr))\n////判断是否连接成功，成功返回0\n```\n\n#### 4.接收数据\n\n```\n//定义存储数据区\nchar buffer[1024] = {0};\n//启动读取函数，读取并存储\nint valread = read(sockfd, buffer, sizeof(buffer));\n```\n\n#### 5.发送数据\n\n```\n//定义发送字符串\nchar *message = \"Hello, Server\";\n//将字符串发送到下位机\nsend(sockfd, message, strlen(message), 0);\n```\n\n#### 6.关闭设备\n\n```\n//关闭socket通信\nclose(sockfd);\n```\n","slug":"Work No.27","published":1,"updated":"2024-09-02T07:24:59.464Z","comments":1,"layout":"post","photos":[],"_id":"cm0koeivp0000z0fbccm5c140","content":"<h1 id=\"Socket通信流程\"><a href=\"#Socket通信流程\" class=\"headerlink\" title=\"Socket通信流程\"></a>Socket通信流程</h1><h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><h4 id=\"1-创建套接字\"><a href=\"#1-创建套接字\" class=\"headerlink\" title=\"1.创建套接字\"></a>1.创建套接字</h4><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-built_in\">int</span> sockfd; <span class=\"hljs-comment\">//创建套接字接收区</span><br>sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//创建套接字</span><br><span class=\"hljs-comment\">//判断是否创建成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (sockfd &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-配置服务器地址\"><a href=\"#2-配置服务器地址\" class=\"headerlink\" title=\"2.配置服务器地址\"></a>2.配置服务器地址</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//配置地址结构体，将端口、地址输入到结构体当中</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> serv_addr; <br><span class=\"hljs-comment\">//清除结构体内部数据，防止干扰</span><br><span class=\"hljs-built_in\">memset</span>(&amp;serv_addr, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(serv_addr));<br><span class=\"hljs-comment\">//结构体内部成员赋值</span><br>serv_addr.sin_family = AF_INET;<br>serv_addr.sin_port = <span class=\"hljs-built_in\">htons</span>(PORT); <span class=\"hljs-comment\">// 替换PORT为具体的端口号</span><br>serv_addr.sin_addr.s_addr = <span class=\"hljs-built_in\">inet_addr</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>); <span class=\"hljs-comment\">// 替换为实际的IP地址</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-绑定套接字（仅用于服务器端）\"><a href=\"#3-绑定套接字（仅用于服务器端）\" class=\"headerlink\" title=\"3.绑定套接字（仅用于服务器端）\"></a>3.绑定套接字（仅用于服务器端）</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//将套接字和地址结构体进行绑定</span><br><span class=\"hljs-built_in\">int</span> socket_bind = bind(sockfd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;serv_addr, <span class=\"hljs-keyword\">sizeof</span>(serv_addr)<br><span class=\"hljs-comment\">//判断是否绑定成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (socket_bind &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-启动监听（仅限服务端）\"><a href=\"#4-启动监听（仅限服务端）\" class=\"headerlink\" title=\"4.启动监听（仅限服务端）\"></a>4.启动监听（仅限服务端）</h4><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-comment\">//启动对socket的监听，5代表同时监听设备最大数为5个，超出部分直接屏蔽</span><br><span class=\"hljs-built_in\">int</span> socket_listen = listen(sockfd, <span class=\"hljs-number\">5</span>);.<br><span class=\"hljs-comment\">//判断是否监听成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (socket_listen &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-接受设备（仅限服务端）\"><a href=\"#5-接受设备（仅限服务端）\" class=\"headerlink\" title=\"5.接受设备（仅限服务端）\"></a>5.接受设备（仅限服务端）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//定义一个接受成功返回值储存区</span><br><span class=\"hljs-type\">int</span> new_socket;<br><span class=\"hljs-comment\">//定义一个连接设备的地址结构体</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> client_addr;<br><span class=\"hljs-comment\">//计算连接设备结构体的长度</span><br><span class=\"hljs-type\">socklen_t</span> addr_len = <span class=\"hljs-built_in\">sizeof</span>(client_addr);<br><span class=\"hljs-comment\">//启动对设备的接受操作</span><br>new_socket = <span class=\"hljs-built_in\">accept</span>(sockfd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len);<br><span class=\"hljs-comment\">//判断是否接受成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (new_socket &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-接收数据\"><a href=\"#6-接收数据\" class=\"headerlink\" title=\"6.接收数据\"></a>6.接收数据</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//定义存储数据区</span><br><span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">1024</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-comment\">//启动读取函数，读取并存储</span><br><span class=\"hljs-type\">int</span> valread = <span class=\"hljs-built_in\">read</span>(sockfd, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-发送数据\"><a href=\"#7-发送数据\" class=\"headerlink\" title=\"7.发送数据\"></a>7.发送数据</h4><figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gml\"><span class=\"hljs-comment\">//定义发送字符串</span><br>char *<span class=\"hljs-variable language_\">message</span> = <span class=\"hljs-string\">&quot;Hello, Server&quot;</span>;<br><span class=\"hljs-comment\">//将字符串发送到下位机</span><br>send(sockfd, <span class=\"hljs-variable language_\">message</span>, strlen(<span class=\"hljs-variable language_\">message</span>), <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"8-关闭设备\"><a href=\"#8-关闭设备\" class=\"headerlink\" title=\"8.关闭设备\"></a>8.关闭设备</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//关闭socket通信</span><br><span class=\"hljs-built_in\">close</span>(sockfd);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h4 id=\"1-创建套接字-1\"><a href=\"#1-创建套接字-1\" class=\"headerlink\" title=\"1.创建套接字\"></a>1.创建套接字</h4><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-built_in\">int</span> sockfd; <span class=\"hljs-comment\">//创建套接字接收区</span><br>sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//创建套接字</span><br><span class=\"hljs-comment\">//判断是否创建成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (sockfd &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-配置服务器地址-1\"><a href=\"#2-配置服务器地址-1\" class=\"headerlink\" title=\"2.配置服务器地址\"></a>2.配置服务器地址</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//配置地址结构体，将端口、地址输入到结构体当中</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> serv_addr; <br><span class=\"hljs-comment\">//清除结构体内部数据，防止干扰</span><br><span class=\"hljs-built_in\">memset</span>(&amp;serv_addr, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(serv_addr));<br><span class=\"hljs-comment\">//结构体内部成员赋值</span><br>serv_addr.sin_family = AF_INET;<br>serv_addr.sin_port = <span class=\"hljs-built_in\">htons</span>(PORT); <span class=\"hljs-comment\">// 替换PORT为具体的端口号</span><br>serv_addr.sin_addr.s_addr = <span class=\"hljs-built_in\">inet_addr</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>); <span class=\"hljs-comment\">// 替换为实际的IP地址</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-连接客户端（仅限客户端）\"><a href=\"#3-连接客户端（仅限客户端）\" class=\"headerlink\" title=\"3.连接客户端（仅限客户端）\"></a>3.连接客户端（仅限客户端）</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//用于连接客户端的设备</span><br><span class=\"hljs-built_in\">int</span> socket_connect = connect(sockfd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;serv_addr, <span class=\"hljs-keyword\">sizeof</span>(serv_addr))<br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>/判断是否连接成功，成功返回0</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-接收数据\"><a href=\"#4-接收数据\" class=\"headerlink\" title=\"4.接收数据\"></a>4.接收数据</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//定义存储数据区</span><br><span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">1024</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-comment\">//启动读取函数，读取并存储</span><br><span class=\"hljs-type\">int</span> valread = <span class=\"hljs-built_in\">read</span>(sockfd, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-发送数据\"><a href=\"#5-发送数据\" class=\"headerlink\" title=\"5.发送数据\"></a>5.发送数据</h4><figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gml\"><span class=\"hljs-comment\">//定义发送字符串</span><br>char *<span class=\"hljs-variable language_\">message</span> = <span class=\"hljs-string\">&quot;Hello, Server&quot;</span>;<br><span class=\"hljs-comment\">//将字符串发送到下位机</span><br>send(sockfd, <span class=\"hljs-variable language_\">message</span>, strlen(<span class=\"hljs-variable language_\">message</span>), <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-关闭设备\"><a href=\"#6-关闭设备\" class=\"headerlink\" title=\"6.关闭设备\"></a>6.关闭设备</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//关闭socket通信</span><br><span class=\"hljs-built_in\">close</span>(sockfd);<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Socket通信流程\"><a href=\"#Socket通信流程\" class=\"headerlink\" title=\"Socket通信流程\"></a>Socket通信流程</h1><h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><h4 id=\"1-创建套接字\"><a href=\"#1-创建套接字\" class=\"headerlink\" title=\"1.创建套接字\"></a>1.创建套接字</h4><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-built_in\">int</span> sockfd; <span class=\"hljs-comment\">//创建套接字接收区</span><br>sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//创建套接字</span><br><span class=\"hljs-comment\">//判断是否创建成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (sockfd &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-配置服务器地址\"><a href=\"#2-配置服务器地址\" class=\"headerlink\" title=\"2.配置服务器地址\"></a>2.配置服务器地址</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//配置地址结构体，将端口、地址输入到结构体当中</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> serv_addr; <br><span class=\"hljs-comment\">//清除结构体内部数据，防止干扰</span><br><span class=\"hljs-built_in\">memset</span>(&amp;serv_addr, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(serv_addr));<br><span class=\"hljs-comment\">//结构体内部成员赋值</span><br>serv_addr.sin_family = AF_INET;<br>serv_addr.sin_port = <span class=\"hljs-built_in\">htons</span>(PORT); <span class=\"hljs-comment\">// 替换PORT为具体的端口号</span><br>serv_addr.sin_addr.s_addr = <span class=\"hljs-built_in\">inet_addr</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>); <span class=\"hljs-comment\">// 替换为实际的IP地址</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-绑定套接字（仅用于服务器端）\"><a href=\"#3-绑定套接字（仅用于服务器端）\" class=\"headerlink\" title=\"3.绑定套接字（仅用于服务器端）\"></a>3.绑定套接字（仅用于服务器端）</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//将套接字和地址结构体进行绑定</span><br><span class=\"hljs-built_in\">int</span> socket_bind = bind(sockfd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;serv_addr, <span class=\"hljs-keyword\">sizeof</span>(serv_addr)<br><span class=\"hljs-comment\">//判断是否绑定成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (socket_bind &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-启动监听（仅限服务端）\"><a href=\"#4-启动监听（仅限服务端）\" class=\"headerlink\" title=\"4.启动监听（仅限服务端）\"></a>4.启动监听（仅限服务端）</h4><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-comment\">//启动对socket的监听，5代表同时监听设备最大数为5个，超出部分直接屏蔽</span><br><span class=\"hljs-built_in\">int</span> socket_listen = listen(sockfd, <span class=\"hljs-number\">5</span>);.<br><span class=\"hljs-comment\">//判断是否监听成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (socket_listen &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-接受设备（仅限服务端）\"><a href=\"#5-接受设备（仅限服务端）\" class=\"headerlink\" title=\"5.接受设备（仅限服务端）\"></a>5.接受设备（仅限服务端）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//定义一个接受成功返回值储存区</span><br><span class=\"hljs-type\">int</span> new_socket;<br><span class=\"hljs-comment\">//定义一个连接设备的地址结构体</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> client_addr;<br><span class=\"hljs-comment\">//计算连接设备结构体的长度</span><br><span class=\"hljs-type\">socklen_t</span> addr_len = <span class=\"hljs-built_in\">sizeof</span>(client_addr);<br><span class=\"hljs-comment\">//启动对设备的接受操作</span><br>new_socket = <span class=\"hljs-built_in\">accept</span>(sockfd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len);<br><span class=\"hljs-comment\">//判断是否接受成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (new_socket &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-接收数据\"><a href=\"#6-接收数据\" class=\"headerlink\" title=\"6.接收数据\"></a>6.接收数据</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//定义存储数据区</span><br><span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">1024</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-comment\">//启动读取函数，读取并存储</span><br><span class=\"hljs-type\">int</span> valread = <span class=\"hljs-built_in\">read</span>(sockfd, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"7-发送数据\"><a href=\"#7-发送数据\" class=\"headerlink\" title=\"7.发送数据\"></a>7.发送数据</h4><figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gml\"><span class=\"hljs-comment\">//定义发送字符串</span><br>char *<span class=\"hljs-variable language_\">message</span> = <span class=\"hljs-string\">&quot;Hello, Server&quot;</span>;<br><span class=\"hljs-comment\">//将字符串发送到下位机</span><br>send(sockfd, <span class=\"hljs-variable language_\">message</span>, strlen(<span class=\"hljs-variable language_\">message</span>), <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"8-关闭设备\"><a href=\"#8-关闭设备\" class=\"headerlink\" title=\"8.关闭设备\"></a>8.关闭设备</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//关闭socket通信</span><br><span class=\"hljs-built_in\">close</span>(sockfd);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h4 id=\"1-创建套接字-1\"><a href=\"#1-创建套接字-1\" class=\"headerlink\" title=\"1.创建套接字\"></a>1.创建套接字</h4><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-built_in\">int</span> sockfd; <span class=\"hljs-comment\">//创建套接字接收区</span><br>sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//创建套接字</span><br><span class=\"hljs-comment\">//判断是否创建成功，成功返回0</span><br><span class=\"hljs-keyword\">if</span> (sockfd &lt; <span class=\"hljs-number\">0</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-配置服务器地址-1\"><a href=\"#2-配置服务器地址-1\" class=\"headerlink\" title=\"2.配置服务器地址\"></a>2.配置服务器地址</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//配置地址结构体，将端口、地址输入到结构体当中</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sockaddr_in</span> serv_addr; <br><span class=\"hljs-comment\">//清除结构体内部数据，防止干扰</span><br><span class=\"hljs-built_in\">memset</span>(&amp;serv_addr, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(serv_addr));<br><span class=\"hljs-comment\">//结构体内部成员赋值</span><br>serv_addr.sin_family = AF_INET;<br>serv_addr.sin_port = <span class=\"hljs-built_in\">htons</span>(PORT); <span class=\"hljs-comment\">// 替换PORT为具体的端口号</span><br>serv_addr.sin_addr.s_addr = <span class=\"hljs-built_in\">inet_addr</span>(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>); <span class=\"hljs-comment\">// 替换为实际的IP地址</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-连接客户端（仅限客户端）\"><a href=\"#3-连接客户端（仅限客户端）\" class=\"headerlink\" title=\"3.连接客户端（仅限客户端）\"></a>3.连接客户端（仅限客户端）</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//用于连接客户端的设备</span><br><span class=\"hljs-built_in\">int</span> socket_connect = connect(sockfd, (<span class=\"hljs-keyword\">struct</span> sockaddr *)&amp;serv_addr, <span class=\"hljs-keyword\">sizeof</span>(serv_addr))<br><span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>/判断是否连接成功，成功返回0</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-接收数据\"><a href=\"#4-接收数据\" class=\"headerlink\" title=\"4.接收数据\"></a>4.接收数据</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">//定义存储数据区</span><br><span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">1024</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-comment\">//启动读取函数，读取并存储</span><br><span class=\"hljs-type\">int</span> valread = <span class=\"hljs-built_in\">read</span>(sockfd, buffer, <span class=\"hljs-built_in\">sizeof</span>(buffer));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-发送数据\"><a href=\"#5-发送数据\" class=\"headerlink\" title=\"5.发送数据\"></a>5.发送数据</h4><figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gml\"><span class=\"hljs-comment\">//定义发送字符串</span><br>char *<span class=\"hljs-variable language_\">message</span> = <span class=\"hljs-string\">&quot;Hello, Server&quot;</span>;<br><span class=\"hljs-comment\">//将字符串发送到下位机</span><br>send(sockfd, <span class=\"hljs-variable language_\">message</span>, strlen(<span class=\"hljs-variable language_\">message</span>), <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-关闭设备\"><a href=\"#6-关闭设备\" class=\"headerlink\" title=\"6.关闭设备\"></a>6.关闭设备</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//关闭socket通信</span><br><span class=\"hljs-built_in\">close</span>(sockfd);<br></code></pre></td></tr></table></figure>\n"},{"title":"Protobuf-c使用","date":"2024-08-27T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/15/fDkGW65qImzX3xi.jpg","_content":"\n# Protobuf-c使用\n\n## Protobuf基本了解\n\nProtobuf是Google提供一个具有高效的协议数据交换格式工具库，类似于JSON，Protobuf和XML、JSON序列化的方式不同，采用了二进制字节的序列化方式，用字段索引和字段类型通过算法计算得到字段之前的关系映射，从而达到更高的时间效率和空间效率，特别适合对数据大小和传输速率比较敏感的场合使用。\n\nprotobuf的字符是二进制，无法直接打印出来，但是解包和传输速率更快，传输大小和速度只有JSON的一半，解包只需要一次性解包即可，但是JSON数据的解包需要层层解包，但是数据可以直接打印出来进行调试查看\n\n## Protobuf使用\n\nprotobuf在使用的时候不需要太多操作，配置完protobuf-c的环境后，在所需放置的文件夹下面新建一个message.proto的文件\n\n```\n//message.proto\n\nsyntax = \"proto2\";  // proto3 必须加此注解\nmessage student\n{\n    required string id = 1;\n    required string name = 2;\n    required string gender = 3;\n    required int32  age = 4;\n    required string object = 5;\n    required string home_address = 6;\n    required string phone = 7;\n}\n\n//实体结构（message）: 代表了实体结构，由多个消息字段组成。\n//消息字段（field）: 包括数据类型、字段名、字段规则、字段唯一标识、默认值\n//数据类型：常见的原子类型都支持(在FieldDescriptor::kTypeToName中有定义)\n//字段规则：(在FieldDescriptor::kLabelToName中定义)\n//required：必须初始化字段，如果没有赋值，在数据序列化时会抛出异常\n//optional：可选字段，可以不必初始化。\n//repeated：数据可以重复(相当于java 中的Array或List)\n//字段唯一标识：序列化和反序列化将会使用到。\n//默认值：在定义消息字段时可以给出默认值。\n```\n\n之后进入该位置终端，输入\n\n```\nprotoc-c --c_cout=.  message.proto\n```\n\n系统会自动生成两个序列文件\n\n```\nmessage.pb-c.c\nmessage.pb-c.h\n```\n\n这两个文件并不需要去认真关注，因为他们只是生成后的文件，如果需要修改数据格式，数据类型等等，要在message.proto文件里面定义好，然后进行生成即可\n\n## protobuf在其他函数中使用\n\n初始化protobuf\n\n```\n// 初始化Protocol Buffer消息\nProtoMsgCmd protobuff = PROTO_MSG_CMD__INIT;\n```\n\n复制消息\n\n```\n// 复制命令字符串到Protocol Buffer消息中\nprotobuff.buffcmd = strdup(cmdStr);\n```\n\n定义存放编码缓存区\n\n```\nuint8_t Bitbuff[BITBUFF_MAX_LEN] = {0}; // 存放编码后的消息数据\n```\n\n进行protobuf序列化\n\n```\n// 将Protocol Buffer消息打包到Bitbuff中\nsize_t Bitbufflen = proto_msg_cmd__pack(&protobuff, Bitbuff);\n```\n\n进行protobuf反序列化\n\n```\n// 初始化反序列化消息结构\nProtoMsgCmd *unpackedMsg;\n\n// 获取消息中序列化的Protocol Buffer数据\nuint8_t *Bitbuff = buffStr; // 假设buffStr是保存序列化数据的字段\nsize_t Bitbufflen = buffLen; // 假设buffLen是保存序列化数据长度的字段\n```\n\n进行解包\n\n```\n// 解包\nprotobuff  = proto_msg_cmd__unpack(NULL, Bitbufflen, Bitbuff);\nif (protobuff  == NULL) {\n\tprintf(\"Error unpacking protocol buffer message %d: %s\\n\", errno, strerror(errno));\n}\n```\n\n输出数据\n\n```\n// 处理解包后的数据，例如输出解包后的命令字符串\nif (protobuff->buffcmd != NULL) {\n\tprintf(\"Received Command: %s\\n\", protobuff->buffcmd);\n} else {\n\tprintf(\"No command string found!\\n\");\n}\n```\n\n释放内存，防止出现内存泄漏\n\n```\n// 完成后释放消息结构内存\nproto_msg_cmd__free_unpacked(protobuff , NULL);\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Work No.28.md","raw":"---\ntitle: Protobuf-c使用\ntag: C/C++\ndate: 2024-08-28\ncategories: protobuf通信\nindex_img: https://s2.loli.net/2024/08/15/fDkGW65qImzX3xi.jpg\n---\n\n# Protobuf-c使用\n\n## Protobuf基本了解\n\nProtobuf是Google提供一个具有高效的协议数据交换格式工具库，类似于JSON，Protobuf和XML、JSON序列化的方式不同，采用了二进制字节的序列化方式，用字段索引和字段类型通过算法计算得到字段之前的关系映射，从而达到更高的时间效率和空间效率，特别适合对数据大小和传输速率比较敏感的场合使用。\n\nprotobuf的字符是二进制，无法直接打印出来，但是解包和传输速率更快，传输大小和速度只有JSON的一半，解包只需要一次性解包即可，但是JSON数据的解包需要层层解包，但是数据可以直接打印出来进行调试查看\n\n## Protobuf使用\n\nprotobuf在使用的时候不需要太多操作，配置完protobuf-c的环境后，在所需放置的文件夹下面新建一个message.proto的文件\n\n```\n//message.proto\n\nsyntax = \"proto2\";  // proto3 必须加此注解\nmessage student\n{\n    required string id = 1;\n    required string name = 2;\n    required string gender = 3;\n    required int32  age = 4;\n    required string object = 5;\n    required string home_address = 6;\n    required string phone = 7;\n}\n\n//实体结构（message）: 代表了实体结构，由多个消息字段组成。\n//消息字段（field）: 包括数据类型、字段名、字段规则、字段唯一标识、默认值\n//数据类型：常见的原子类型都支持(在FieldDescriptor::kTypeToName中有定义)\n//字段规则：(在FieldDescriptor::kLabelToName中定义)\n//required：必须初始化字段，如果没有赋值，在数据序列化时会抛出异常\n//optional：可选字段，可以不必初始化。\n//repeated：数据可以重复(相当于java 中的Array或List)\n//字段唯一标识：序列化和反序列化将会使用到。\n//默认值：在定义消息字段时可以给出默认值。\n```\n\n之后进入该位置终端，输入\n\n```\nprotoc-c --c_cout=.  message.proto\n```\n\n系统会自动生成两个序列文件\n\n```\nmessage.pb-c.c\nmessage.pb-c.h\n```\n\n这两个文件并不需要去认真关注，因为他们只是生成后的文件，如果需要修改数据格式，数据类型等等，要在message.proto文件里面定义好，然后进行生成即可\n\n## protobuf在其他函数中使用\n\n初始化protobuf\n\n```\n// 初始化Protocol Buffer消息\nProtoMsgCmd protobuff = PROTO_MSG_CMD__INIT;\n```\n\n复制消息\n\n```\n// 复制命令字符串到Protocol Buffer消息中\nprotobuff.buffcmd = strdup(cmdStr);\n```\n\n定义存放编码缓存区\n\n```\nuint8_t Bitbuff[BITBUFF_MAX_LEN] = {0}; // 存放编码后的消息数据\n```\n\n进行protobuf序列化\n\n```\n// 将Protocol Buffer消息打包到Bitbuff中\nsize_t Bitbufflen = proto_msg_cmd__pack(&protobuff, Bitbuff);\n```\n\n进行protobuf反序列化\n\n```\n// 初始化反序列化消息结构\nProtoMsgCmd *unpackedMsg;\n\n// 获取消息中序列化的Protocol Buffer数据\nuint8_t *Bitbuff = buffStr; // 假设buffStr是保存序列化数据的字段\nsize_t Bitbufflen = buffLen; // 假设buffLen是保存序列化数据长度的字段\n```\n\n进行解包\n\n```\n// 解包\nprotobuff  = proto_msg_cmd__unpack(NULL, Bitbufflen, Bitbuff);\nif (protobuff  == NULL) {\n\tprintf(\"Error unpacking protocol buffer message %d: %s\\n\", errno, strerror(errno));\n}\n```\n\n输出数据\n\n```\n// 处理解包后的数据，例如输出解包后的命令字符串\nif (protobuff->buffcmd != NULL) {\n\tprintf(\"Received Command: %s\\n\", protobuff->buffcmd);\n} else {\n\tprintf(\"No command string found!\\n\");\n}\n```\n\n释放内存，防止出现内存泄漏\n\n```\n// 完成后释放消息结构内存\nproto_msg_cmd__free_unpacked(protobuff , NULL);\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Work No.28","published":1,"updated":"2024-09-02T07:42:24.052Z","_id":"cm0koeivr0001z0fb4m3527mw","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Protobuf-c使用\"><a href=\"#Protobuf-c使用\" class=\"headerlink\" title=\"Protobuf-c使用\"></a>Protobuf-c使用</h1><h2 id=\"Protobuf基本了解\"><a href=\"#Protobuf基本了解\" class=\"headerlink\" title=\"Protobuf基本了解\"></a>Protobuf基本了解</h2><p>Protobuf是Google提供一个具有高效的协议数据交换格式工具库，类似于JSON，Protobuf和XML、JSON序列化的方式不同，采用了二进制字节的序列化方式，用字段索引和字段类型通过算法计算得到字段之前的关系映射，从而达到更高的时间效率和空间效率，特别适合对数据大小和传输速率比较敏感的场合使用。</p>\n<p>protobuf的字符是二进制，无法直接打印出来，但是解包和传输速率更快，传输大小和速度只有JSON的一半，解包只需要一次性解包即可，但是JSON数据的解包需要层层解包，但是数据可以直接打印出来进行调试查看</p>\n<h2 id=\"Protobuf使用\"><a href=\"#Protobuf使用\" class=\"headerlink\" title=\"Protobuf使用\"></a>Protobuf使用</h2><p>protobuf在使用的时候不需要太多操作，配置完protobuf-c的环境后，在所需放置的文件夹下面新建一个message.proto的文件</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs protobuf\"><span class=\"hljs-comment\">//message.proto</span><br><br>syntax = <span class=\"hljs-string\">&quot;proto2&quot;</span>;  <span class=\"hljs-comment\">// proto3 必须加此注解</span><br><span class=\"hljs-keyword\">message </span><span class=\"hljs-title class_\">student</span><br>&#123;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> id = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> name = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> gender = <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">int32</span>  age = <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> object = <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> home_address = <span class=\"hljs-number\">6</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> phone = <span class=\"hljs-number\">7</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//实体结构（message）: 代表了实体结构，由多个消息字段组成。</span><br><span class=\"hljs-comment\">//消息字段（field）: 包括数据类型、字段名、字段规则、字段唯一标识、默认值</span><br><span class=\"hljs-comment\">//数据类型：常见的原子类型都支持(在FieldDescriptor::kTypeToName中有定义)</span><br><span class=\"hljs-comment\">//字段规则：(在FieldDescriptor::kLabelToName中定义)</span><br><span class=\"hljs-comment\">//required：必须初始化字段，如果没有赋值，在数据序列化时会抛出异常</span><br><span class=\"hljs-comment\">//optional：可选字段，可以不必初始化。</span><br><span class=\"hljs-comment\">//repeated：数据可以重复(相当于java 中的Array或List)</span><br><span class=\"hljs-comment\">//字段唯一标识：序列化和反序列化将会使用到。</span><br><span class=\"hljs-comment\">//默认值：在定义消息字段时可以给出默认值。</span><br></code></pre></td></tr></table></figure>\n\n<p>之后进入该位置终端，输入</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">protoc-c <span class=\"hljs-attribute\">--c_cout</span>=.  message.proto<br></code></pre></td></tr></table></figure>\n\n<p>系统会自动生成两个序列文件</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">message.pb-<span class=\"hljs-keyword\">c</span>.<span class=\"hljs-keyword\">c</span><br>message.pb-<span class=\"hljs-keyword\">c</span>.h<br></code></pre></td></tr></table></figure>\n\n<p>这两个文件并不需要去认真关注，因为他们只是生成后的文件，如果需要修改数据格式，数据类型等等，要在message.proto文件里面定义好，然后进行生成即可</p>\n<h2 id=\"protobuf在其他函数中使用\"><a href=\"#protobuf在其他函数中使用\" class=\"headerlink\" title=\"protobuf在其他函数中使用\"></a>protobuf在其他函数中使用</h2><p>初始化protobuf</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">// 初始化Protocol Buffer消息<br>ProtoMsgCmd protobuff <span class=\"hljs-operator\">=</span> PROTO_MSG_CMD__INIT<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>复制消息</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">// 复制命令字符串到Protocol Buffer消息中<br>protobuff.buffcmd <span class=\"hljs-operator\">=</span> strdup(cmdStr)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>定义存放编码缓存区</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">uint8_t Bitbuff[BITBUFF_MAX_LEN] <span class=\"hljs-operator\">=</span> &#123;<span class=\"hljs-number\">0</span>&#125;<span class=\"hljs-comment\">; // 存放编码后的消息数据</span><br></code></pre></td></tr></table></figure>\n\n<p>进行protobuf序列化</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">// 将Protocol Buffer消息打包到Bitbuff中</span><br>size_t Bitbufflen <span class=\"hljs-punctuation\">=</span> proto_msg_cmd__pack<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;protobuff, Bitbuff);</span><br></code></pre></td></tr></table></figure>\n\n<p>进行protobuf反序列化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 初始化反序列化消息结构</span><br>ProtoMsgCmd *unpackedMsg;<br><br><span class=\"hljs-comment\">// 获取消息中序列化的Protocol Buffer数据</span><br><span class=\"hljs-type\">uint8_t</span> *Bitbuff = buffStr; <span class=\"hljs-comment\">// 假设buffStr是保存序列化数据的字段</span><br><span class=\"hljs-type\">size_t</span> Bitbufflen = buffLen; <span class=\"hljs-comment\">// 假设buffLen是保存序列化数据长度的字段</span><br></code></pre></td></tr></table></figure>\n\n<p>进行解包</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 解包</span><br>protobuff  = <span class=\"hljs-built_in\">proto_msg_cmd__unpack</span>(<span class=\"hljs-literal\">NULL</span>, Bitbufflen, Bitbuff);<br><span class=\"hljs-keyword\">if</span> (protobuff  == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Error unpacking protocol buffer message %d: %s\\n&quot;</span>, errno, <span class=\"hljs-built_in\">strerror</span>(errno));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 处理解包后的数据，例如输出解包后的命令字符串</span><br><span class=\"hljs-keyword\">if</span> (protobuff-&gt;buffcmd != <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Received Command: %s\\n&quot;</span>, protobuff-&gt;buffcmd);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;No command string found!\\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>释放内存，防止出现内存泄漏</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 完成后释放消息结构内存</span><br><span class=\"hljs-built_in\">proto_msg_cmd__free_unpacked</span>(protobuff , NULL);<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"","more":"<h1 id=\"Protobuf-c使用\"><a href=\"#Protobuf-c使用\" class=\"headerlink\" title=\"Protobuf-c使用\"></a>Protobuf-c使用</h1><h2 id=\"Protobuf基本了解\"><a href=\"#Protobuf基本了解\" class=\"headerlink\" title=\"Protobuf基本了解\"></a>Protobuf基本了解</h2><p>Protobuf是Google提供一个具有高效的协议数据交换格式工具库，类似于JSON，Protobuf和XML、JSON序列化的方式不同，采用了二进制字节的序列化方式，用字段索引和字段类型通过算法计算得到字段之前的关系映射，从而达到更高的时间效率和空间效率，特别适合对数据大小和传输速率比较敏感的场合使用。</p>\n<p>protobuf的字符是二进制，无法直接打印出来，但是解包和传输速率更快，传输大小和速度只有JSON的一半，解包只需要一次性解包即可，但是JSON数据的解包需要层层解包，但是数据可以直接打印出来进行调试查看</p>\n<h2 id=\"Protobuf使用\"><a href=\"#Protobuf使用\" class=\"headerlink\" title=\"Protobuf使用\"></a>Protobuf使用</h2><p>protobuf在使用的时候不需要太多操作，配置完protobuf-c的环境后，在所需放置的文件夹下面新建一个message.proto的文件</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs protobuf\"><span class=\"hljs-comment\">//message.proto</span><br><br>syntax = <span class=\"hljs-string\">&quot;proto2&quot;</span>;  <span class=\"hljs-comment\">// proto3 必须加此注解</span><br><span class=\"hljs-keyword\">message </span><span class=\"hljs-title class_\">student</span><br>&#123;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> id = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> name = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> gender = <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">int32</span>  age = <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> object = <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> home_address = <span class=\"hljs-number\">6</span>;<br>    <span class=\"hljs-keyword\">required</span> <span class=\"hljs-type\">string</span> phone = <span class=\"hljs-number\">7</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//实体结构（message）: 代表了实体结构，由多个消息字段组成。</span><br><span class=\"hljs-comment\">//消息字段（field）: 包括数据类型、字段名、字段规则、字段唯一标识、默认值</span><br><span class=\"hljs-comment\">//数据类型：常见的原子类型都支持(在FieldDescriptor::kTypeToName中有定义)</span><br><span class=\"hljs-comment\">//字段规则：(在FieldDescriptor::kLabelToName中定义)</span><br><span class=\"hljs-comment\">//required：必须初始化字段，如果没有赋值，在数据序列化时会抛出异常</span><br><span class=\"hljs-comment\">//optional：可选字段，可以不必初始化。</span><br><span class=\"hljs-comment\">//repeated：数据可以重复(相当于java 中的Array或List)</span><br><span class=\"hljs-comment\">//字段唯一标识：序列化和反序列化将会使用到。</span><br><span class=\"hljs-comment\">//默认值：在定义消息字段时可以给出默认值。</span><br></code></pre></td></tr></table></figure>\n\n<p>之后进入该位置终端，输入</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">protoc-c <span class=\"hljs-attribute\">--c_cout</span>=.  message.proto<br></code></pre></td></tr></table></figure>\n\n<p>系统会自动生成两个序列文件</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">message.pb-<span class=\"hljs-keyword\">c</span>.<span class=\"hljs-keyword\">c</span><br>message.pb-<span class=\"hljs-keyword\">c</span>.h<br></code></pre></td></tr></table></figure>\n\n<p>这两个文件并不需要去认真关注，因为他们只是生成后的文件，如果需要修改数据格式，数据类型等等，要在message.proto文件里面定义好，然后进行生成即可</p>\n<h2 id=\"protobuf在其他函数中使用\"><a href=\"#protobuf在其他函数中使用\" class=\"headerlink\" title=\"protobuf在其他函数中使用\"></a>protobuf在其他函数中使用</h2><p>初始化protobuf</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">// 初始化Protocol Buffer消息<br>ProtoMsgCmd protobuff <span class=\"hljs-operator\">=</span> PROTO_MSG_CMD__INIT<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>复制消息</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">// 复制命令字符串到Protocol Buffer消息中<br>protobuff.buffcmd <span class=\"hljs-operator\">=</span> strdup(cmdStr)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>定义存放编码缓存区</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">uint8_t Bitbuff[BITBUFF_MAX_LEN] <span class=\"hljs-operator\">=</span> &#123;<span class=\"hljs-number\">0</span>&#125;<span class=\"hljs-comment\">; // 存放编码后的消息数据</span><br></code></pre></td></tr></table></figure>\n\n<p>进行protobuf序列化</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">// 将Protocol Buffer消息打包到Bitbuff中</span><br>size_t Bitbufflen <span class=\"hljs-punctuation\">=</span> proto_msg_cmd__pack<span class=\"hljs-punctuation\">(</span><span class=\"hljs-meta\">&amp;protobuff, Bitbuff);</span><br></code></pre></td></tr></table></figure>\n\n<p>进行protobuf反序列化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 初始化反序列化消息结构</span><br>ProtoMsgCmd *unpackedMsg;<br><br><span class=\"hljs-comment\">// 获取消息中序列化的Protocol Buffer数据</span><br><span class=\"hljs-type\">uint8_t</span> *Bitbuff = buffStr; <span class=\"hljs-comment\">// 假设buffStr是保存序列化数据的字段</span><br><span class=\"hljs-type\">size_t</span> Bitbufflen = buffLen; <span class=\"hljs-comment\">// 假设buffLen是保存序列化数据长度的字段</span><br></code></pre></td></tr></table></figure>\n\n<p>进行解包</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 解包</span><br>protobuff  = <span class=\"hljs-built_in\">proto_msg_cmd__unpack</span>(<span class=\"hljs-literal\">NULL</span>, Bitbufflen, Bitbuff);<br><span class=\"hljs-keyword\">if</span> (protobuff  == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Error unpacking protocol buffer message %d: %s\\n&quot;</span>, errno, <span class=\"hljs-built_in\">strerror</span>(errno));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出数据</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 处理解包后的数据，例如输出解包后的命令字符串</span><br><span class=\"hljs-keyword\">if</span> (protobuff-&gt;buffcmd != <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Received Command: %s\\n&quot;</span>, protobuff-&gt;buffcmd);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;No command string found!\\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>释放内存，防止出现内存泄漏</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 完成后释放消息结构内存</span><br><span class=\"hljs-built_in\">proto_msg_cmd__free_unpacked</span>(protobuff , NULL);<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"STM32的SPI学习","date":"2024-08-29T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/15/b89FBs1i47y5VDI.jpg","_content":"\n# STM32的SPI学习\n\n## SPI基本知识\n\nSPI协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口， 是一种高速全双工的通信总线。它被广泛地使用在ADC、LCD等设备与MCU间，要求通讯速率较高的场合。\n\nSPI通讯使用3条总线及片选线，3条总线分别为SCK、MOSI、MISO，片选线为SS\n\nSCK：时钟线，用于同步消息和检测消息，传输速率也跟时钟线有关\n\nMOSI：Master Output， Slave Input，以主机为主，所以是主机是输出端，传感器的输入端\n\nMISO：Master Input,，Slave Output，以主机为主，所以是主机是输入端，传感器的输出端\n\nSS：片选线，也称为NSS、CS，主要用于识别设备的标志，可以用自带的片选线，也可以随便找一个GPIO口作为片选线\n\n## 通信流程图\n\n![image.png](https://s2.loli.net/2024/08/26/MhngUwW54dCKuEy.png)\n\n通讯的时候需要将片选线拉低，标志SPI通信开始，这个也是主机告诉某个选定的从机开始通信，如果信号线被拉高，标志停止通信， MOSI与MISO的信号只在NSS为低电平的时候才有效，在SCK的每个时钟周期MOSI和MISO传输一位数据。\n\nSPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据， 且数据输入输出是同时进行的。\n\n## SPI初始化结构体\n\nSPI的使用主要有6个步骤，定义GPIO和SPI的结构体，初始化GPIO和SPI的时钟，设置GPIO配置，设置SPI配置，使能SPI，拉高片选线\n\n这几个步骤跟其他的也很类似，所以就不需要过多描述，其中有个点，就是GPIO引脚的设置，可以查阅STM32官方手册中文版111页，有推荐的GPIO口的配置，例如复用推挽、浮空输入等等模式\n\n![image.png](https://s2.loli.net/2024/09/01/CTVcqPOJjdlEIAr.png)\n\n根据这个表格我们就知道NSS、SCK、MOSI、MISO的GPIO模式设置应该如何设置\n\n```\nvoid SPI_config(void)\n{\n\tGPIO_InitTypeDef SPI_GPIO_InitStructure;  //初始化GPIO结构体\n\tSPI_InitTypeDef  SPI_InitStructure;  //初始化I2C结构体\n\t\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n\t//打开SPI的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);\n\t\n\t//配置I2C NSS引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C SCK引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MOSI引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MISO引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置SPI 结构体设置\n\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2; //设置波特率为72/4=36MHz\n\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; //设置为偶数边沿采集\n\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High; //设置为上升沿采集数据\n\tSPI_InitStructure.SPI_CRCPolynomial = 0; //不进行校验，所以可以随便设置\n\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; //配置数据传输大小为8字节\n\tSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //SPI模式为双线全双工模式\n\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; //配置为高位先行\n\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master; //配置主机主发送\n\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft; //片选线配置为软件设置\n\tSPI_Init(SPI1, &SPI_InitStructure); //初始化SPI1的结构体\n\t\n\t//使能SPI\n\tSPI_Cmd(SPI1, ENABLE);\n\t\n\t//直接拉高片选线，等到需要的时候进行拉低\n\tSPI_CS_GPIO_HIGH;\n}\n```\n\n在代码的SPI结构体部分，一共有10个步骤\n\n1.设置波特率，最大波特率是40MHz，SPI1是挂载在APB2上面，所以最大是72MHz，选择2分频\n\n2.设置CPHA，选择位偶数边沿采集，还有一个是奇数边沿采集，主要为时钟的奇偶段进行数据的检测校验，两种选项都可以，没太大区别\n\n3.设置CPOL，选择是上升沿检测还是下降沿检测，主要就是引脚低变高或者高变低的时候去检测数据\n\n4.设置校验位，不进行设置，这边可以写校验逻辑，对数据进行按特定方法进行计算校验\n\n5.设置数据的传输字节，是要一次性8位或者16位\n\n6.设置SPI的模式，主要有单线双线，还有全双工或者只发送，只接收等模式\n\n7.设置SPI数据的高八位或者低八位先进行发送，这个得依照读取的设备要求进行配置，有些存储设备只能先读高八位或者低八位\n\n8.设置以什么设备为主，是主机或者从机，默认以主机单片机为主\n\n9.设置片选线的方式，有硬件或者软件方式，硬件方式是单片机写好的，无法更改，软件方式可以随便挑一个GPIO口进行设置\n\n10.初始化结构体，将配置写入初始化中\n\n## SPI传输\n\nSPI传输的话单次是一个字节进行发送，共发送八位数据，采用固件库定义的函数进行发送，传输的过程需要依照时序图进行判断\n\n![image.png](https://s2.loli.net/2024/09/01/2oCk65Rb8BeZJx1.png)\n\n首先要拉低片选线NSS，标志SPI传输开始，之后进行TXE标志位的校验，校验是否将数据放入移位寄存器进行准备发送\n\n再利用函数，将八位数据通过SPI进行发送\n\n发送后，需要校验是否完成发送，但是这个不能使用TXE进行校验，因为数据的在移到移位寄存器的时候TXE会发生变化，会导致标志位识别不对，所以我们直接使用RXNE标志位进行校验，因为必须是发送成功了，才能读取到数据\n\n```\nuint8_t SPI_Send_Byte_Data(uint8_t data)\n{\n\t// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(0);\n  }\n\t\n\t//如果清空，则发送8位数据\n\tSPI_I2S_SendData(SPI1, data);\n\t\n\t// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }\n\t\n\t// 返回接收到的数据\n\treturn SPI_I2S_ReceiveData(SPI1);\n}\n```\n\n而且，因为SPI是全双工模式，我们每发送一个数据，就可以同时接收一个数据，因此我们将读写程序放到一个函数中\n\n当然，如果你不想放到一起也是不行的，因为SPI传输也是依靠时钟的频率进行识别，而时钟的频率只有在主机发送的时候才会产生，所以单独发送可以实现，但是单独读取是不行的\n\n因此我们可以定义一个空值，用于接收时的发送，这个空值没有任何的作用，只是进行启动时钟用于读取\n\n下面是进行FLASH的读取，获取他的ID值\n\n```\n#define DUMMY 0x00\n\nuint32_t SPI_Receive_Flash_ID(void)\n{\n\t// 定义将要接收的缓存区\n\tuint32_t flash_id;\n\t\n\t// 将片选信号拉低，标志开始启用SPI传输\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 发送flash标志数据，以此来获取flash的地址信息\t\n\tSPI_Send_Byte_Data(0x9f);\n\t\n\t// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef\n\tflash_id = SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00\n\tflash_id <<= 8;\n\t\n\t// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00\n\tflash_id <<= 8;\n\t\n\t// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将片选信号拉高，标志SPI传输结束\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 返回ID值\n\treturn flash_id;\n}\n```\n\n## 总代码如下\n\n```\nbsp_spi.h\n\n#ifndef _BSP_SPI_H\n#define _BSP_SPI_H\n\n#include \"STM32F10x.h\"\n#include \"bsp_usart.h\"\n\n#define DUMMY 0x00\n\n#define  SPI_CS_GPIO_HIGH         GPIO_SetBits( GPIOA, GPIO_Pin_4 )\n#define  SPI_CS_GPIO_LOW          GPIO_ResetBits( GPIOA, GPIO_Pin_4 )\n\nstatic __IO uint32_t  I2CTimeout = 10*(0x1000); \n\nvoid SPI_config(void);\nuint8_t SPI_Send_Byte_Data(uint8_t data);\nuint8_t SPI_Receive_Byte_Data(void);\nuint32_t SPI_Receive_Flash_ID(void);\n\n#endif /* _BSP_SPI_H */\n\n```\n\n```\nbsp_spi.c\n\n#include \"bsp_spi.h\"\n\nstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n{\n  /* Block communication and all processes */\n  printf(\"I2C 等待超时!errorCode = %d\",errorCode);\n  \n  return 0;\n}\n\nvoid SPI_config(void)\n{\n\tGPIO_InitTypeDef SPI_GPIO_InitStructure;  //初始化GPIO结构体\n\tSPI_InitTypeDef  SPI_InitStructure;  //初始化I2C结构体\n\t\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n\t//打开SPI的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);\n\t\n\t//配置I2C NSS引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C SCK引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MOSI引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MISO引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置SPI 结构体设置\n\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; //设置波特率为72/4=18MHz\n\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; //设置为偶数边沿采集\n\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High; //设置为上升沿采集数据\n\tSPI_InitStructure.SPI_CRCPolynomial = 0; //不进行校验，所以可以随便设置\n\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; //配置数据传输大小为8字节\n\tSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //SPI模式为双线全双工模式\n\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; //配置为高位先行\n\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master; //配置主机主发送\n\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft; //片选线配置为软件设置\n\tSPI_Init(SPI1, &SPI_InitStructure); //初始化SPI1的结构体\n\t\n\t//使能SPI\n\tSPI_Cmd(SPI1, ENABLE);\n\t\n\t//直接拉高片选线，等到需要的时候进行拉低\n\tSPI_CS_GPIO_HIGH;\n}\n\nuint8_t SPI_Send_Byte_Data(uint8_t data)\n{\n\t// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(0);\n  }\n\t\n\t//如果清空，则发送8位数据\n\tSPI_I2S_SendData(SPI1, data);\n\t\n\t// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }\n\t\n\t// 返回接收到的数据\n\treturn SPI_I2S_ReceiveData(SPI1);\n}\n\n// 读取数据和发送数据一致\n// 因为时钟是由主机产生，如果主机没有发送，就不会产生时钟信号，也就无法读取，所以直接在发送的过程进行读取数据\nuint8_t SPI_Receive_Byte_Data(void)\n{\n\t// 直接返回读取值\n\treturn SPI_Send_Byte_Data(DUMMY);\n}\n\nuint32_t SPI_Receive_Flash_ID(void)\n{\n\t// 定义将要接收的缓存区\n\tuint32_t flash_id;\n\t\n\t// 将片选信号拉低，标志开始启用SPI传输\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 发送flash标志数据，以此来获取flash的地址信息\t\n\tSPI_Send_Byte_Data(0x9f);\n\t\n\t// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef\n\tflash_id = SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00\n\tflash_id <<= 8;\n\t\n\t// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00\n\tflash_id <<= 8;\n\t\n\t// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将片选信号拉高，标志SPI传输结束\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 返回ID值\n\treturn flash_id;\n}\n```\n\n","source":"_posts/STM32的SPI学习.md","raw":"---\ntitle: STM32的SPI学习\ntag: SPI\ndate: 2024-08-30\ncategories: STM32\nindex_img: https://s2.loli.net/2024/08/15/b89FBs1i47y5VDI.jpg\n---\n\n# STM32的SPI学习\n\n## SPI基本知识\n\nSPI协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口， 是一种高速全双工的通信总线。它被广泛地使用在ADC、LCD等设备与MCU间，要求通讯速率较高的场合。\n\nSPI通讯使用3条总线及片选线，3条总线分别为SCK、MOSI、MISO，片选线为SS\n\nSCK：时钟线，用于同步消息和检测消息，传输速率也跟时钟线有关\n\nMOSI：Master Output， Slave Input，以主机为主，所以是主机是输出端，传感器的输入端\n\nMISO：Master Input,，Slave Output，以主机为主，所以是主机是输入端，传感器的输出端\n\nSS：片选线，也称为NSS、CS，主要用于识别设备的标志，可以用自带的片选线，也可以随便找一个GPIO口作为片选线\n\n## 通信流程图\n\n![image.png](https://s2.loli.net/2024/08/26/MhngUwW54dCKuEy.png)\n\n通讯的时候需要将片选线拉低，标志SPI通信开始，这个也是主机告诉某个选定的从机开始通信，如果信号线被拉高，标志停止通信， MOSI与MISO的信号只在NSS为低电平的时候才有效，在SCK的每个时钟周期MOSI和MISO传输一位数据。\n\nSPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据， 且数据输入输出是同时进行的。\n\n## SPI初始化结构体\n\nSPI的使用主要有6个步骤，定义GPIO和SPI的结构体，初始化GPIO和SPI的时钟，设置GPIO配置，设置SPI配置，使能SPI，拉高片选线\n\n这几个步骤跟其他的也很类似，所以就不需要过多描述，其中有个点，就是GPIO引脚的设置，可以查阅STM32官方手册中文版111页，有推荐的GPIO口的配置，例如复用推挽、浮空输入等等模式\n\n![image.png](https://s2.loli.net/2024/09/01/CTVcqPOJjdlEIAr.png)\n\n根据这个表格我们就知道NSS、SCK、MOSI、MISO的GPIO模式设置应该如何设置\n\n```\nvoid SPI_config(void)\n{\n\tGPIO_InitTypeDef SPI_GPIO_InitStructure;  //初始化GPIO结构体\n\tSPI_InitTypeDef  SPI_InitStructure;  //初始化I2C结构体\n\t\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n\t//打开SPI的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);\n\t\n\t//配置I2C NSS引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C SCK引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MOSI引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MISO引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置SPI 结构体设置\n\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2; //设置波特率为72/4=36MHz\n\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; //设置为偶数边沿采集\n\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High; //设置为上升沿采集数据\n\tSPI_InitStructure.SPI_CRCPolynomial = 0; //不进行校验，所以可以随便设置\n\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; //配置数据传输大小为8字节\n\tSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //SPI模式为双线全双工模式\n\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; //配置为高位先行\n\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master; //配置主机主发送\n\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft; //片选线配置为软件设置\n\tSPI_Init(SPI1, &SPI_InitStructure); //初始化SPI1的结构体\n\t\n\t//使能SPI\n\tSPI_Cmd(SPI1, ENABLE);\n\t\n\t//直接拉高片选线，等到需要的时候进行拉低\n\tSPI_CS_GPIO_HIGH;\n}\n```\n\n在代码的SPI结构体部分，一共有10个步骤\n\n1.设置波特率，最大波特率是40MHz，SPI1是挂载在APB2上面，所以最大是72MHz，选择2分频\n\n2.设置CPHA，选择位偶数边沿采集，还有一个是奇数边沿采集，主要为时钟的奇偶段进行数据的检测校验，两种选项都可以，没太大区别\n\n3.设置CPOL，选择是上升沿检测还是下降沿检测，主要就是引脚低变高或者高变低的时候去检测数据\n\n4.设置校验位，不进行设置，这边可以写校验逻辑，对数据进行按特定方法进行计算校验\n\n5.设置数据的传输字节，是要一次性8位或者16位\n\n6.设置SPI的模式，主要有单线双线，还有全双工或者只发送，只接收等模式\n\n7.设置SPI数据的高八位或者低八位先进行发送，这个得依照读取的设备要求进行配置，有些存储设备只能先读高八位或者低八位\n\n8.设置以什么设备为主，是主机或者从机，默认以主机单片机为主\n\n9.设置片选线的方式，有硬件或者软件方式，硬件方式是单片机写好的，无法更改，软件方式可以随便挑一个GPIO口进行设置\n\n10.初始化结构体，将配置写入初始化中\n\n## SPI传输\n\nSPI传输的话单次是一个字节进行发送，共发送八位数据，采用固件库定义的函数进行发送，传输的过程需要依照时序图进行判断\n\n![image.png](https://s2.loli.net/2024/09/01/2oCk65Rb8BeZJx1.png)\n\n首先要拉低片选线NSS，标志SPI传输开始，之后进行TXE标志位的校验，校验是否将数据放入移位寄存器进行准备发送\n\n再利用函数，将八位数据通过SPI进行发送\n\n发送后，需要校验是否完成发送，但是这个不能使用TXE进行校验，因为数据的在移到移位寄存器的时候TXE会发生变化，会导致标志位识别不对，所以我们直接使用RXNE标志位进行校验，因为必须是发送成功了，才能读取到数据\n\n```\nuint8_t SPI_Send_Byte_Data(uint8_t data)\n{\n\t// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(0);\n  }\n\t\n\t//如果清空，则发送8位数据\n\tSPI_I2S_SendData(SPI1, data);\n\t\n\t// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }\n\t\n\t// 返回接收到的数据\n\treturn SPI_I2S_ReceiveData(SPI1);\n}\n```\n\n而且，因为SPI是全双工模式，我们每发送一个数据，就可以同时接收一个数据，因此我们将读写程序放到一个函数中\n\n当然，如果你不想放到一起也是不行的，因为SPI传输也是依靠时钟的频率进行识别，而时钟的频率只有在主机发送的时候才会产生，所以单独发送可以实现，但是单独读取是不行的\n\n因此我们可以定义一个空值，用于接收时的发送，这个空值没有任何的作用，只是进行启动时钟用于读取\n\n下面是进行FLASH的读取，获取他的ID值\n\n```\n#define DUMMY 0x00\n\nuint32_t SPI_Receive_Flash_ID(void)\n{\n\t// 定义将要接收的缓存区\n\tuint32_t flash_id;\n\t\n\t// 将片选信号拉低，标志开始启用SPI传输\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 发送flash标志数据，以此来获取flash的地址信息\t\n\tSPI_Send_Byte_Data(0x9f);\n\t\n\t// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef\n\tflash_id = SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00\n\tflash_id <<= 8;\n\t\n\t// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00\n\tflash_id <<= 8;\n\t\n\t// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将片选信号拉高，标志SPI传输结束\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 返回ID值\n\treturn flash_id;\n}\n```\n\n## 总代码如下\n\n```\nbsp_spi.h\n\n#ifndef _BSP_SPI_H\n#define _BSP_SPI_H\n\n#include \"STM32F10x.h\"\n#include \"bsp_usart.h\"\n\n#define DUMMY 0x00\n\n#define  SPI_CS_GPIO_HIGH         GPIO_SetBits( GPIOA, GPIO_Pin_4 )\n#define  SPI_CS_GPIO_LOW          GPIO_ResetBits( GPIOA, GPIO_Pin_4 )\n\nstatic __IO uint32_t  I2CTimeout = 10*(0x1000); \n\nvoid SPI_config(void);\nuint8_t SPI_Send_Byte_Data(uint8_t data);\nuint8_t SPI_Receive_Byte_Data(void);\nuint32_t SPI_Receive_Flash_ID(void);\n\n#endif /* _BSP_SPI_H */\n\n```\n\n```\nbsp_spi.c\n\n#include \"bsp_spi.h\"\n\nstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n{\n  /* Block communication and all processes */\n  printf(\"I2C 等待超时!errorCode = %d\",errorCode);\n  \n  return 0;\n}\n\nvoid SPI_config(void)\n{\n\tGPIO_InitTypeDef SPI_GPIO_InitStructure;  //初始化GPIO结构体\n\tSPI_InitTypeDef  SPI_InitStructure;  //初始化I2C结构体\n\t\n\t//打开GPIOB的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n\t//打开SPI的时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);\n\t\n\t//配置I2C NSS引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C SCK引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MOSI引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置I2C MISO引脚\n\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;\n\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(GPIOA, &SPI_GPIO_InitStructure);\n\t\n\t//配置SPI 结构体设置\n\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; //设置波特率为72/4=18MHz\n\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; //设置为偶数边沿采集\n\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High; //设置为上升沿采集数据\n\tSPI_InitStructure.SPI_CRCPolynomial = 0; //不进行校验，所以可以随便设置\n\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; //配置数据传输大小为8字节\n\tSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //SPI模式为双线全双工模式\n\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; //配置为高位先行\n\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master; //配置主机主发送\n\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft; //片选线配置为软件设置\n\tSPI_Init(SPI1, &SPI_InitStructure); //初始化SPI1的结构体\n\t\n\t//使能SPI\n\tSPI_Cmd(SPI1, ENABLE);\n\t\n\t//直接拉高片选线，等到需要的时候进行拉低\n\tSPI_CS_GPIO_HIGH;\n}\n\nuint8_t SPI_Send_Byte_Data(uint8_t data)\n{\n\t// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(0);\n  }\n\t\n\t//如果清空，则发送8位数据\n\tSPI_I2S_SendData(SPI1, data);\n\t\n\t// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据\n\twhile(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }\n\t\n\t// 返回接收到的数据\n\treturn SPI_I2S_ReceiveData(SPI1);\n}\n\n// 读取数据和发送数据一致\n// 因为时钟是由主机产生，如果主机没有发送，就不会产生时钟信号，也就无法读取，所以直接在发送的过程进行读取数据\nuint8_t SPI_Receive_Byte_Data(void)\n{\n\t// 直接返回读取值\n\treturn SPI_Send_Byte_Data(DUMMY);\n}\n\nuint32_t SPI_Receive_Flash_ID(void)\n{\n\t// 定义将要接收的缓存区\n\tuint32_t flash_id;\n\t\n\t// 将片选信号拉低，标志开始启用SPI传输\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 发送flash标志数据，以此来获取flash的地址信息\t\n\tSPI_Send_Byte_Data(0x9f);\n\t\n\t// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef\n\tflash_id = SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00\n\tflash_id <<= 8;\n\t\n\t// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00\n\tflash_id <<= 8;\n\t\n\t// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17\n\tflash_id |= SPI_Send_Byte_Data(DUMMY);\n\t\n\t// 将片选信号拉高，标志SPI传输结束\n\tSPI_CS_GPIO_LOW;\n\t\n\t// 返回ID值\n\treturn flash_id;\n}\n```\n\n","slug":"STM32的SPI学习","published":1,"updated":"2024-09-04T09:32:52.857Z","comments":1,"layout":"post","photos":[],"_id":"cm0nnusxl0000ckfbgdhkf5c1","content":"<h1 id=\"STM32的SPI学习\"><a href=\"#STM32的SPI学习\" class=\"headerlink\" title=\"STM32的SPI学习\"></a>STM32的SPI学习</h1><h2 id=\"SPI基本知识\"><a href=\"#SPI基本知识\" class=\"headerlink\" title=\"SPI基本知识\"></a>SPI基本知识</h2><p>SPI协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口， 是一种高速全双工的通信总线。它被广泛地使用在ADC、LCD等设备与MCU间，要求通讯速率较高的场合。</p>\n<p>SPI通讯使用3条总线及片选线，3条总线分别为SCK、MOSI、MISO，片选线为SS</p>\n<p>SCK：时钟线，用于同步消息和检测消息，传输速率也跟时钟线有关</p>\n<p>MOSI：Master Output， Slave Input，以主机为主，所以是主机是输出端，传感器的输入端</p>\n<p>MISO：Master Input,，Slave Output，以主机为主，所以是主机是输入端，传感器的输出端</p>\n<p>SS：片选线，也称为NSS、CS，主要用于识别设备的标志，可以用自带的片选线，也可以随便找一个GPIO口作为片选线</p>\n<h2 id=\"通信流程图\"><a href=\"#通信流程图\" class=\"headerlink\" title=\"通信流程图\"></a>通信流程图</h2><p><img src=\"https://s2.loli.net/2024/08/26/MhngUwW54dCKuEy.png\" alt=\"image.png\"></p>\n<p>通讯的时候需要将片选线拉低，标志SPI通信开始，这个也是主机告诉某个选定的从机开始通信，如果信号线被拉高，标志停止通信， MOSI与MISO的信号只在NSS为低电平的时候才有效，在SCK的每个时钟周期MOSI和MISO传输一位数据。</p>\n<p>SPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据， 且数据输入输出是同时进行的。</p>\n<h2 id=\"SPI初始化结构体\"><a href=\"#SPI初始化结构体\" class=\"headerlink\" title=\"SPI初始化结构体\"></a>SPI初始化结构体</h2><p>SPI的使用主要有6个步骤，定义GPIO和SPI的结构体，初始化GPIO和SPI的时钟，设置GPIO配置，设置SPI配置，使能SPI，拉高片选线</p>\n<p>这几个步骤跟其他的也很类似，所以就不需要过多描述，其中有个点，就是GPIO引脚的设置，可以查阅STM32官方手册中文版111页，有推荐的GPIO口的配置，例如复用推挽、浮空输入等等模式</p>\n<p><img src=\"https://s2.loli.net/2024/09/01/CTVcqPOJjdlEIAr.png\" alt=\"image.png\"></p>\n<p>根据这个表格我们就知道NSS、SCK、MOSI、MISO的GPIO模式设置应该如何设置</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">void SPI_config<span class=\"hljs-punctuation\">(</span>void<span class=\"hljs-punctuation\">)</span><br>&#123;<br>\tGPIO_InitTypeDef SPI_GPIO_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>\tSPI_InitTypeDef  SPI_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化I2C结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_GPIOA<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//打开SPI的时钟</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_SPI1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C NSS引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_Out_PP<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_4<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SCK引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_PP<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_5<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MOSI引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_PP<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_7<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MISO引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_IN_FLOATING<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_6<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置SPI 结构体设置</span><br>\tSPI_InitStructure.SPI_BaudRatePrescaler <span class=\"hljs-punctuation\">=</span> SPI_BaudRatePrescaler_2<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//设置波特率为72/4=36MHz</span><br>\tSPI_InitStructure.SPI_CPHA <span class=\"hljs-punctuation\">=</span> SPI_CPHA_2Edge<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//设置为偶数边沿采集</span><br>\tSPI_InitStructure.SPI_CPOL <span class=\"hljs-punctuation\">=</span> SPI_CPOL_High<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//设置为上升沿采集数据</span><br>\tSPI_InitStructure.SPI_CRCPolynomial <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//不进行校验，所以可以随便设置</span><br>\tSPI_InitStructure.SPI_DataSize <span class=\"hljs-punctuation\">=</span> SPI_DataSize_8b<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//配置数据传输大小为8字节</span><br>\tSPI_InitStructure.SPI_Direction <span class=\"hljs-punctuation\">=</span> SPI_Direction_2Lines_FullDuplex<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//SPI模式为双线全双工模式</span><br>\tSPI_InitStructure.SPI_FirstBit <span class=\"hljs-punctuation\">=</span> SPI_FirstBit_MSB<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//配置为高位先行</span><br>\tSPI_InitStructure.SPI_Mode <span class=\"hljs-punctuation\">=</span> SPI_Mode_Master<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//配置主机主发送</span><br>\tSPI_InitStructure.SPI_NSS <span class=\"hljs-punctuation\">=</span> SPI_NSS_Soft<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//片选线配置为软件设置</span><br>\tSPI_Init<span class=\"hljs-punctuation\">(</span>SPI1<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_InitStructure); <span class=\"hljs-comment\">//初始化SPI1的结构体</span></span><br>\t<br>\t<span class=\"hljs-comment\">//使能SPI</span><br>\tSPI_Cmd<span class=\"hljs-punctuation\">(</span>SPI1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//直接拉高片选线，等到需要的时候进行拉低</span><br>\tSPI_CS_GPIO_HIGH<span class=\"hljs-punctuation\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在代码的SPI结构体部分，一共有10个步骤</p>\n<p>1.设置波特率，最大波特率是40MHz，SPI1是挂载在APB2上面，所以最大是72MHz，选择2分频</p>\n<p>2.设置CPHA，选择位偶数边沿采集，还有一个是奇数边沿采集，主要为时钟的奇偶段进行数据的检测校验，两种选项都可以，没太大区别</p>\n<p>3.设置CPOL，选择是上升沿检测还是下降沿检测，主要就是引脚低变高或者高变低的时候去检测数据</p>\n<p>4.设置校验位，不进行设置，这边可以写校验逻辑，对数据进行按特定方法进行计算校验</p>\n<p>5.设置数据的传输字节，是要一次性8位或者16位</p>\n<p>6.设置SPI的模式，主要有单线双线，还有全双工或者只发送，只接收等模式</p>\n<p>7.设置SPI数据的高八位或者低八位先进行发送，这个得依照读取的设备要求进行配置，有些存储设备只能先读高八位或者低八位</p>\n<p>8.设置以什么设备为主，是主机或者从机，默认以主机单片机为主</p>\n<p>9.设置片选线的方式，有硬件或者软件方式，硬件方式是单片机写好的，无法更改，软件方式可以随便挑一个GPIO口进行设置</p>\n<p>10.初始化结构体，将配置写入初始化中</p>\n<h2 id=\"SPI传输\"><a href=\"#SPI传输\" class=\"headerlink\" title=\"SPI传输\"></a>SPI传输</h2><p>SPI传输的话单次是一个字节进行发送，共发送八位数据，采用固件库定义的函数进行发送，传输的过程需要依照时序图进行判断</p>\n<p><img src=\"https://s2.loli.net/2024/09/01/2oCk65Rb8BeZJx1.png\" alt=\"image.png\"></p>\n<p>首先要拉低片选线NSS，标志SPI传输开始，之后进行TXE标志位的校验，校验是否将数据放入移位寄存器进行准备发送</p>\n<p>再利用函数，将八位数据通过SPI进行发送</p>\n<p>发送后，需要校验是否完成发送，但是这个不能使用TXE进行校验，因为数据的在移到移位寄存器的时候TXE会发生变化，会导致标志位识别不对，所以我们直接使用RXNE标志位进行校验，因为必须是发送成功了，才能读取到数据</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">uint8_t SPI_Send_Byte_Data(uint8_t <span class=\"hljs-keyword\">data</span>)<br>&#123;<br>\t<span class=\"hljs-comment\">// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器</span><br>\t<span class=\"hljs-keyword\">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">0</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">//如果清空，则发送8位数据</span><br>\tSPI_I2S_SendData(SPI1, <span class=\"hljs-keyword\">data</span>);<br>\t<br>\t<span class=\"hljs-comment\">// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据</span><br>\t<span class=\"hljs-keyword\">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">1</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">// 返回接收到的数据</span><br>\t<span class=\"hljs-keyword\">return</span> SPI_I2S_ReceiveData(SPI1);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>而且，因为SPI是全双工模式，我们每发送一个数据，就可以同时接收一个数据，因此我们将读写程序放到一个函数中</p>\n<p>当然，如果你不想放到一起也是不行的，因为SPI传输也是依靠时钟的频率进行识别，而时钟的频率只有在主机发送的时候才会产生，所以单独发送可以实现，但是单独读取是不行的</p>\n<p>因此我们可以定义一个空值，用于接收时的发送，这个空值没有任何的作用，只是进行启动时钟用于读取</p>\n<p>下面是进行FLASH的读取，获取他的ID值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DUMMY 0x00</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SPI_Receive_Flash_ID</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义将要接收的缓存区</span><br>\t<span class=\"hljs-type\">uint32_t</span> flash_id;<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉低，标志开始启用SPI传输</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 发送flash标志数据，以此来获取flash的地址信息\t</span><br>\t<span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(<span class=\"hljs-number\">0x9f</span>);<br>\t<br>\t<span class=\"hljs-comment\">// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef</span><br>\tflash_id = <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉高，标志SPI传输结束</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 返回ID值</span><br>\t<span class=\"hljs-keyword\">return</span> flash_id;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总代码如下\"><a href=\"#总代码如下\" class=\"headerlink\" title=\"总代码如下\"></a>总代码如下</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">bsp_spi.h<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> _BSP_SPI_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _BSP_SPI_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;STM32F10x.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DUMMY 0x00</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  SPI_CS_GPIO_HIGH         GPIO_SetBits( GPIOA, GPIO_Pin_4 )</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  SPI_CS_GPIO_LOW          GPIO_ResetBits( GPIOA, GPIO_Pin_4 )</span><br><br><span class=\"hljs-type\">static</span> __IO <span class=\"hljs-type\">uint32_t</span>  I2CTimeout = <span class=\"hljs-number\">10</span>*(<span class=\"hljs-number\">0x1000</span>); <br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SPI_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Send_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Receive_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SPI_Receive_Flash_ID</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* _BSP_SPI_H */</span></span><br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">bsp_spi.c<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_spi.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> errorCode)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">/* Block communication and all processes */</span><br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;I2C 等待超时!errorCode = %d&quot;</span>,errorCode);<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SPI_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tGPIO_InitTypeDef SPI_GPIO_InitStructure;  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>\tSPI_InitTypeDef  SPI_InitStructure;  <span class=\"hljs-comment\">//初始化I2C结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOA, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//打开SPI的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_SPI1, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C NSS引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SCK引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MOSI引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MISO引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置SPI 结构体设置</span><br>\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; <span class=\"hljs-comment\">//设置波特率为72/4=18MHz</span><br>\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; <span class=\"hljs-comment\">//设置为偶数边沿采集</span><br>\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High; <span class=\"hljs-comment\">//设置为上升沿采集数据</span><br>\tSPI_InitStructure.SPI_CRCPolynomial = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//不进行校验，所以可以随便设置</span><br>\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; <span class=\"hljs-comment\">//配置数据传输大小为8字节</span><br>\tSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; <span class=\"hljs-comment\">//SPI模式为双线全双工模式</span><br>\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; <span class=\"hljs-comment\">//配置为高位先行</span><br>\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master; <span class=\"hljs-comment\">//配置主机主发送</span><br>\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft; <span class=\"hljs-comment\">//片选线配置为软件设置</span><br>\t<span class=\"hljs-built_in\">SPI_Init</span>(SPI1, &amp;SPI_InitStructure); <span class=\"hljs-comment\">//初始化SPI1的结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//使能SPI</span><br>\t<span class=\"hljs-built_in\">SPI_Cmd</span>(SPI1, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//直接拉高片选线，等到需要的时候进行拉低</span><br>\tSPI_CS_GPIO_HIGH;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Send_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器</span><br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">SPI_I2S_GetFlagStatus</span>(SPI1, SPI_I2S_FLAG_TXE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">0</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">//如果清空，则发送8位数据</span><br>\t<span class=\"hljs-built_in\">SPI_I2S_SendData</span>(SPI1, data);<br>\t<br>\t<span class=\"hljs-comment\">// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据</span><br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">SPI_I2S_GetFlagStatus</span>(SPI1, SPI_I2S_FLAG_RXNE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">1</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">// 返回接收到的数据</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">SPI_I2S_ReceiveData</span>(SPI1);<br>&#125;<br><br><span class=\"hljs-comment\">// 读取数据和发送数据一致</span><br><span class=\"hljs-comment\">// 因为时钟是由主机产生，如果主机没有发送，就不会产生时钟信号，也就无法读取，所以直接在发送的过程进行读取数据</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Receive_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 直接返回读取值</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SPI_Receive_Flash_ID</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义将要接收的缓存区</span><br>\t<span class=\"hljs-type\">uint32_t</span> flash_id;<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉低，标志开始启用SPI传输</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 发送flash标志数据，以此来获取flash的地址信息\t</span><br>\t<span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(<span class=\"hljs-number\">0x9f</span>);<br>\t<br>\t<span class=\"hljs-comment\">// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef</span><br>\tflash_id = <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉高，标志SPI传输结束</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 返回ID值</span><br>\t<span class=\"hljs-keyword\">return</span> flash_id;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"STM32的SPI学习\"><a href=\"#STM32的SPI学习\" class=\"headerlink\" title=\"STM32的SPI学习\"></a>STM32的SPI学习</h1><h2 id=\"SPI基本知识\"><a href=\"#SPI基本知识\" class=\"headerlink\" title=\"SPI基本知识\"></a>SPI基本知识</h2><p>SPI协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口， 是一种高速全双工的通信总线。它被广泛地使用在ADC、LCD等设备与MCU间，要求通讯速率较高的场合。</p>\n<p>SPI通讯使用3条总线及片选线，3条总线分别为SCK、MOSI、MISO，片选线为SS</p>\n<p>SCK：时钟线，用于同步消息和检测消息，传输速率也跟时钟线有关</p>\n<p>MOSI：Master Output， Slave Input，以主机为主，所以是主机是输出端，传感器的输入端</p>\n<p>MISO：Master Input,，Slave Output，以主机为主，所以是主机是输入端，传感器的输出端</p>\n<p>SS：片选线，也称为NSS、CS，主要用于识别设备的标志，可以用自带的片选线，也可以随便找一个GPIO口作为片选线</p>\n<h2 id=\"通信流程图\"><a href=\"#通信流程图\" class=\"headerlink\" title=\"通信流程图\"></a>通信流程图</h2><p><img src=\"https://s2.loli.net/2024/08/26/MhngUwW54dCKuEy.png\" alt=\"image.png\"></p>\n<p>通讯的时候需要将片选线拉低，标志SPI通信开始，这个也是主机告诉某个选定的从机开始通信，如果信号线被拉高，标志停止通信， MOSI与MISO的信号只在NSS为低电平的时候才有效，在SCK的每个时钟周期MOSI和MISO传输一位数据。</p>\n<p>SPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据， 且数据输入输出是同时进行的。</p>\n<h2 id=\"SPI初始化结构体\"><a href=\"#SPI初始化结构体\" class=\"headerlink\" title=\"SPI初始化结构体\"></a>SPI初始化结构体</h2><p>SPI的使用主要有6个步骤，定义GPIO和SPI的结构体，初始化GPIO和SPI的时钟，设置GPIO配置，设置SPI配置，使能SPI，拉高片选线</p>\n<p>这几个步骤跟其他的也很类似，所以就不需要过多描述，其中有个点，就是GPIO引脚的设置，可以查阅STM32官方手册中文版111页，有推荐的GPIO口的配置，例如复用推挽、浮空输入等等模式</p>\n<p><img src=\"https://s2.loli.net/2024/09/01/CTVcqPOJjdlEIAr.png\" alt=\"image.png\"></p>\n<p>根据这个表格我们就知道NSS、SCK、MOSI、MISO的GPIO模式设置应该如何设置</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">void SPI_config<span class=\"hljs-punctuation\">(</span>void<span class=\"hljs-punctuation\">)</span><br>&#123;<br>\tGPIO_InitTypeDef SPI_GPIO_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>\tSPI_InitTypeDef  SPI_InitStructure<span class=\"hljs-punctuation\">;</span>  <span class=\"hljs-comment\">//初始化I2C结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_GPIOA<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//打开SPI的时钟</span><br>\tRCC_APB2PeriphClockCmd<span class=\"hljs-punctuation\">(</span>RCC_APB2Periph_SPI1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C NSS引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_Out_PP<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_4<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SCK引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_PP<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_5<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MOSI引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_AF_PP<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_7<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MISO引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode <span class=\"hljs-punctuation\">=</span> GPIO_Mode_IN_FLOATING<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Pin <span class=\"hljs-punctuation\">=</span> GPIO_Pin_6<span class=\"hljs-punctuation\">;</span><br>\tSPI_GPIO_InitStructure.GPIO_Speed <span class=\"hljs-punctuation\">=</span> GPIO_Speed_50MHz<span class=\"hljs-punctuation\">;</span><br>\tGPIO_Init<span class=\"hljs-punctuation\">(</span>GPIOA<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_GPIO_InitStructure);</span><br>\t<br>\t<span class=\"hljs-comment\">//配置SPI 结构体设置</span><br>\tSPI_InitStructure.SPI_BaudRatePrescaler <span class=\"hljs-punctuation\">=</span> SPI_BaudRatePrescaler_2<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//设置波特率为72/4=36MHz</span><br>\tSPI_InitStructure.SPI_CPHA <span class=\"hljs-punctuation\">=</span> SPI_CPHA_2Edge<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//设置为偶数边沿采集</span><br>\tSPI_InitStructure.SPI_CPOL <span class=\"hljs-punctuation\">=</span> SPI_CPOL_High<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//设置为上升沿采集数据</span><br>\tSPI_InitStructure.SPI_CRCPolynomial <span class=\"hljs-punctuation\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//不进行校验，所以可以随便设置</span><br>\tSPI_InitStructure.SPI_DataSize <span class=\"hljs-punctuation\">=</span> SPI_DataSize_8b<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//配置数据传输大小为8字节</span><br>\tSPI_InitStructure.SPI_Direction <span class=\"hljs-punctuation\">=</span> SPI_Direction_2Lines_FullDuplex<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//SPI模式为双线全双工模式</span><br>\tSPI_InitStructure.SPI_FirstBit <span class=\"hljs-punctuation\">=</span> SPI_FirstBit_MSB<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//配置为高位先行</span><br>\tSPI_InitStructure.SPI_Mode <span class=\"hljs-punctuation\">=</span> SPI_Mode_Master<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//配置主机主发送</span><br>\tSPI_InitStructure.SPI_NSS <span class=\"hljs-punctuation\">=</span> SPI_NSS_Soft<span class=\"hljs-punctuation\">;</span> <span class=\"hljs-comment\">//片选线配置为软件设置</span><br>\tSPI_Init<span class=\"hljs-punctuation\">(</span>SPI1<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-meta\">&amp;SPI_InitStructure); <span class=\"hljs-comment\">//初始化SPI1的结构体</span></span><br>\t<br>\t<span class=\"hljs-comment\">//使能SPI</span><br>\tSPI_Cmd<span class=\"hljs-punctuation\">(</span>SPI1<span class=\"hljs-punctuation\">,</span> ENABLE<span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">;</span><br>\t<br>\t<span class=\"hljs-comment\">//直接拉高片选线，等到需要的时候进行拉低</span><br>\tSPI_CS_GPIO_HIGH<span class=\"hljs-punctuation\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在代码的SPI结构体部分，一共有10个步骤</p>\n<p>1.设置波特率，最大波特率是40MHz，SPI1是挂载在APB2上面，所以最大是72MHz，选择2分频</p>\n<p>2.设置CPHA，选择位偶数边沿采集，还有一个是奇数边沿采集，主要为时钟的奇偶段进行数据的检测校验，两种选项都可以，没太大区别</p>\n<p>3.设置CPOL，选择是上升沿检测还是下降沿检测，主要就是引脚低变高或者高变低的时候去检测数据</p>\n<p>4.设置校验位，不进行设置，这边可以写校验逻辑，对数据进行按特定方法进行计算校验</p>\n<p>5.设置数据的传输字节，是要一次性8位或者16位</p>\n<p>6.设置SPI的模式，主要有单线双线，还有全双工或者只发送，只接收等模式</p>\n<p>7.设置SPI数据的高八位或者低八位先进行发送，这个得依照读取的设备要求进行配置，有些存储设备只能先读高八位或者低八位</p>\n<p>8.设置以什么设备为主，是主机或者从机，默认以主机单片机为主</p>\n<p>9.设置片选线的方式，有硬件或者软件方式，硬件方式是单片机写好的，无法更改，软件方式可以随便挑一个GPIO口进行设置</p>\n<p>10.初始化结构体，将配置写入初始化中</p>\n<h2 id=\"SPI传输\"><a href=\"#SPI传输\" class=\"headerlink\" title=\"SPI传输\"></a>SPI传输</h2><p>SPI传输的话单次是一个字节进行发送，共发送八位数据，采用固件库定义的函数进行发送，传输的过程需要依照时序图进行判断</p>\n<p><img src=\"https://s2.loli.net/2024/09/01/2oCk65Rb8BeZJx1.png\" alt=\"image.png\"></p>\n<p>首先要拉低片选线NSS，标志SPI传输开始，之后进行TXE标志位的校验，校验是否将数据放入移位寄存器进行准备发送</p>\n<p>再利用函数，将八位数据通过SPI进行发送</p>\n<p>发送后，需要校验是否完成发送，但是这个不能使用TXE进行校验，因为数据的在移到移位寄存器的时候TXE会发生变化，会导致标志位识别不对，所以我们直接使用RXNE标志位进行校验，因为必须是发送成功了，才能读取到数据</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">uint8_t SPI_Send_Byte_Data(uint8_t <span class=\"hljs-keyword\">data</span>)<br>&#123;<br>\t<span class=\"hljs-comment\">// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器</span><br>\t<span class=\"hljs-keyword\">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">0</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">//如果清空，则发送8位数据</span><br>\tSPI_I2S_SendData(SPI1, <span class=\"hljs-keyword\">data</span>);<br>\t<br>\t<span class=\"hljs-comment\">// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据</span><br>\t<span class=\"hljs-keyword\">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"hljs-number\">1</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">// 返回接收到的数据</span><br>\t<span class=\"hljs-keyword\">return</span> SPI_I2S_ReceiveData(SPI1);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>而且，因为SPI是全双工模式，我们每发送一个数据，就可以同时接收一个数据，因此我们将读写程序放到一个函数中</p>\n<p>当然，如果你不想放到一起也是不行的，因为SPI传输也是依靠时钟的频率进行识别，而时钟的频率只有在主机发送的时候才会产生，所以单独发送可以实现，但是单独读取是不行的</p>\n<p>因此我们可以定义一个空值，用于接收时的发送，这个空值没有任何的作用，只是进行启动时钟用于读取</p>\n<p>下面是进行FLASH的读取，获取他的ID值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DUMMY 0x00</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SPI_Receive_Flash_ID</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义将要接收的缓存区</span><br>\t<span class=\"hljs-type\">uint32_t</span> flash_id;<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉低，标志开始启用SPI传输</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 发送flash标志数据，以此来获取flash的地址信息\t</span><br>\t<span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(<span class=\"hljs-number\">0x9f</span>);<br>\t<br>\t<span class=\"hljs-comment\">// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef</span><br>\tflash_id = <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉高，标志SPI传输结束</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 返回ID值</span><br>\t<span class=\"hljs-keyword\">return</span> flash_id;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总代码如下\"><a href=\"#总代码如下\" class=\"headerlink\" title=\"总代码如下\"></a>总代码如下</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">bsp_spi.h<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> _BSP_SPI_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _BSP_SPI_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;STM32F10x.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_usart.h&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> DUMMY 0x00</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  SPI_CS_GPIO_HIGH         GPIO_SetBits( GPIOA, GPIO_Pin_4 )</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  SPI_CS_GPIO_LOW          GPIO_ResetBits( GPIOA, GPIO_Pin_4 )</span><br><br><span class=\"hljs-type\">static</span> __IO <span class=\"hljs-type\">uint32_t</span>  I2CTimeout = <span class=\"hljs-number\">10</span>*(<span class=\"hljs-number\">0x1000</span>); <br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SPI_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Send_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Receive_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SPI_Receive_Flash_ID</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">/* _BSP_SPI_H */</span></span><br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">bsp_spi.c<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;bsp_spi.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">I2C_TIMEOUT_UserCallback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> errorCode)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">/* Block communication and all processes */</span><br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;I2C 等待超时!errorCode = %d&quot;</span>,errorCode);<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SPI_config</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tGPIO_InitTypeDef SPI_GPIO_InitStructure;  <span class=\"hljs-comment\">//初始化GPIO结构体</span><br>\tSPI_InitTypeDef  SPI_InitStructure;  <span class=\"hljs-comment\">//初始化I2C结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//打开GPIOB的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOA, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//打开SPI的时钟</span><br>\t<span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_SPI1, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C NSS引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C SCK引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MOSI引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置I2C MISO引脚</span><br>\tSPI_GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>\tSPI_GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;<br>\tSPI_GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>\t<span class=\"hljs-built_in\">GPIO_Init</span>(GPIOA, &amp;SPI_GPIO_InitStructure);<br>\t<br>\t<span class=\"hljs-comment\">//配置SPI 结构体设置</span><br>\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; <span class=\"hljs-comment\">//设置波特率为72/4=18MHz</span><br>\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; <span class=\"hljs-comment\">//设置为偶数边沿采集</span><br>\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High; <span class=\"hljs-comment\">//设置为上升沿采集数据</span><br>\tSPI_InitStructure.SPI_CRCPolynomial = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//不进行校验，所以可以随便设置</span><br>\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; <span class=\"hljs-comment\">//配置数据传输大小为8字节</span><br>\tSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; <span class=\"hljs-comment\">//SPI模式为双线全双工模式</span><br>\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; <span class=\"hljs-comment\">//配置为高位先行</span><br>\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master; <span class=\"hljs-comment\">//配置主机主发送</span><br>\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft; <span class=\"hljs-comment\">//片选线配置为软件设置</span><br>\t<span class=\"hljs-built_in\">SPI_Init</span>(SPI1, &amp;SPI_InitStructure); <span class=\"hljs-comment\">//初始化SPI1的结构体</span><br>\t<br>\t<span class=\"hljs-comment\">//使能SPI</span><br>\t<span class=\"hljs-built_in\">SPI_Cmd</span>(SPI1, ENABLE);<br>\t<br>\t<span class=\"hljs-comment\">//直接拉高片选线，等到需要的时候进行拉低</span><br>\tSPI_CS_GPIO_HIGH;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Send_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint8_t</span> data)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 校验TXE标志位是否复位，也就是数据发送寄存器是否将数据放置移位寄存器</span><br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">SPI_I2S_GetFlagStatus</span>(SPI1, SPI_I2S_FLAG_TXE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">0</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">//如果清空，则发送8位数据</span><br>\t<span class=\"hljs-built_in\">SPI_I2S_SendData</span>(SPI1, data);<br>\t<br>\t<span class=\"hljs-comment\">// 校验RXNE标志位是否复位，校验该位置可以准确知晓是否发送成功，因为只有发送成功，才会接收到数据</span><br>\t<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">SPI_I2S_GetFlagStatus</span>(SPI1, SPI_I2S_FLAG_RXNE) == RESET)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span>((I2CTimeout--) == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">I2C_TIMEOUT_UserCallback</span>(<span class=\"hljs-number\">1</span>);<br>  &#125;<br>\t<br>\t<span class=\"hljs-comment\">// 返回接收到的数据</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">SPI_I2S_ReceiveData</span>(SPI1);<br>&#125;<br><br><span class=\"hljs-comment\">// 读取数据和发送数据一致</span><br><span class=\"hljs-comment\">// 因为时钟是由主机产生，如果主机没有发送，就不会产生时钟信号，也就无法读取，所以直接在发送的过程进行读取数据</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">SPI_Receive_Byte_Data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 直接返回读取值</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">SPI_Receive_Flash_ID</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义将要接收的缓存区</span><br>\t<span class=\"hljs-type\">uint32_t</span> flash_id;<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉低，标志开始启用SPI传输</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 发送flash标志数据，以此来获取flash的地址信息\t</span><br>\t<span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(<span class=\"hljs-number\">0x9f</span>);<br>\t<br>\t<span class=\"hljs-comment\">// 接收第一个第一个8位地址数据，flash_id = 0x00 00 00 ef</span><br>\tflash_id = <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 00 ef 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第二个第一个8位地址数据，flash_id = 0x00 00 ef 40</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将地址左移八位，空置后两位用于再次接收，flash_id = 0x00 ef 40 00</span><br>\tflash_id &lt;&lt;= <span class=\"hljs-number\">8</span>;<br>\t<br>\t<span class=\"hljs-comment\">// 接收第三个第一个8位地址数据，flash_id = 0x00 ef 40 17</span><br>\tflash_id |= <span class=\"hljs-built_in\">SPI_Send_Byte_Data</span>(DUMMY);<br>\t<br>\t<span class=\"hljs-comment\">// 将片选信号拉高，标志SPI传输结束</span><br>\tSPI_CS_GPIO_LOW;<br>\t<br>\t<span class=\"hljs-comment\">// 返回ID值</span><br>\t<span class=\"hljs-keyword\">return</span> flash_id;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"VScode+platformIO编译STM32标准库","date":"2024-09-03T16:00:00.000Z","index_img":"https://s2.loli.net/2024/08/15/GtV85YzoJU9NnjI.jpg","_content":"\n# VScode+platformIO编译STM32标准库\n\n## 参考博主\n\nhttps://juejin.cn/post/7393313322210426915\n\nhttps://blog.csdn.net/maomaochong666/article/details/129240827\n\n## 配置主要有四个步骤：\n\n#### 1.创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\n\n![image.png](https://s2.loli.net/2024/09/04/xN5agDtl6RfTYI9.png)\n\n#### 2.拷录文件放入STM32项目中\n\n以野火为模板，将library文件user文件拷入到项目当中的src文件夹下，不要分开使用，直接全部拷入，方便使用，删除start启动文件和system_stm32f10x.c文件，因为在初始化的时候已经自动生成\n\n<img src=\"https://s2.loli.net/2024/09/04/ItUnakMPEJAlwrW.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n#### 3.修改platformIO.ini文件\n\n```\n//烧录和调试配置\nupload_protocol = cmsis-dap\ndebug_tool = cmsis-dap\n\n// 添加头文件链接\nbuild_flags = \n    -Wl,-u,_printf_float\n    -Wl,-Map,output.map\n    -O0\n    -Isrc/Libraries\n    -Isrc/Libraries/CMSIS\n    -Isrc/Libraries/FWlib/inc\n    -Isrc/User\n    -Isrc/User/DMA\n    -Isrc/User/EXTI\n    -Isrc/User/I2C\n    -Isrc/User/LED\n    -Isrc/User/RCC\n    -Isrc/User/SPI\n    -Isrc/User/Systick\n    -Isrc/User/USART\n\n    -D STM32F10X_HD\n    -D USE_STDPERIPH_DRIVER\n\n// 定义串口通信，使用motion进行串口调试\nmonitor_speed = 115200\nmonitor_echo = yes\nmonitor_rts = 0\nmonitor_dtr = 0\n\n// 将烧录文件转为hex格式\nextra_scripts = export_hex.py\n```\n\n#### 4.修改core_cm3.c文件内容\n\n修改core_cm3.c里面的内容（736、753行）\n\n![image.png](https://s2.loli.net/2024/09/04/AiZRHY1Kd4wjWnb.png)\n\n#### 5.创建烧录文件hex转换脚本\n\nexport_hex.py\n\n```\nImport(\"env\")\n \n# # Custom HEX from ELF\n \nenv.AddPostAction(\n \n    \"$BUILD_DIR/${PROGNAME}.elf\",\n \n    env.VerboseAction(\" \".join([\n \n        \"$OBJCOPY\", \"-O\", \"ihex\", \"-R\", \".eeprom\",\n \n        '\"$BUILD_DIR/${PROGNAME}.elf\"', '\"$BUILD_DIR/${PROGNAME}.hex\"'  # 加个单引号\n \n    ]), \"Building $BUILD_DIR/${PROGNAME}.hex\")\n \n)\n```\n\n然后就可以编译并且烧录到单片机中，烧录过程查看博主内容\n","source":"_posts/VScode+platformIO编译STM32标准库.md","raw":"---\ntitle: VScode+platformIO编译STM32标准库\ntag: VScode\ndate: 2024-09-04\ncategories: STM32\nindex_img: https://s2.loli.net/2024/08/15/GtV85YzoJU9NnjI.jpg\n---\n\n# VScode+platformIO编译STM32标准库\n\n## 参考博主\n\nhttps://juejin.cn/post/7393313322210426915\n\nhttps://blog.csdn.net/maomaochong666/article/details/129240827\n\n## 配置主要有四个步骤：\n\n#### 1.创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\n\n![image.png](https://s2.loli.net/2024/09/04/xN5agDtl6RfTYI9.png)\n\n#### 2.拷录文件放入STM32项目中\n\n以野火为模板，将library文件user文件拷入到项目当中的src文件夹下，不要分开使用，直接全部拷入，方便使用，删除start启动文件和system_stm32f10x.c文件，因为在初始化的时候已经自动生成\n\n<img src=\"https://s2.loli.net/2024/09/04/ItUnakMPEJAlwrW.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n#### 3.修改platformIO.ini文件\n\n```\n//烧录和调试配置\nupload_protocol = cmsis-dap\ndebug_tool = cmsis-dap\n\n// 添加头文件链接\nbuild_flags = \n    -Wl,-u,_printf_float\n    -Wl,-Map,output.map\n    -O0\n    -Isrc/Libraries\n    -Isrc/Libraries/CMSIS\n    -Isrc/Libraries/FWlib/inc\n    -Isrc/User\n    -Isrc/User/DMA\n    -Isrc/User/EXTI\n    -Isrc/User/I2C\n    -Isrc/User/LED\n    -Isrc/User/RCC\n    -Isrc/User/SPI\n    -Isrc/User/Systick\n    -Isrc/User/USART\n\n    -D STM32F10X_HD\n    -D USE_STDPERIPH_DRIVER\n\n// 定义串口通信，使用motion进行串口调试\nmonitor_speed = 115200\nmonitor_echo = yes\nmonitor_rts = 0\nmonitor_dtr = 0\n\n// 将烧录文件转为hex格式\nextra_scripts = export_hex.py\n```\n\n#### 4.修改core_cm3.c文件内容\n\n修改core_cm3.c里面的内容（736、753行）\n\n![image.png](https://s2.loli.net/2024/09/04/AiZRHY1Kd4wjWnb.png)\n\n#### 5.创建烧录文件hex转换脚本\n\nexport_hex.py\n\n```\nImport(\"env\")\n \n# # Custom HEX from ELF\n \nenv.AddPostAction(\n \n    \"$BUILD_DIR/${PROGNAME}.elf\",\n \n    env.VerboseAction(\" \".join([\n \n        \"$OBJCOPY\", \"-O\", \"ihex\", \"-R\", \".eeprom\",\n \n        '\"$BUILD_DIR/${PROGNAME}.elf\"', '\"$BUILD_DIR/${PROGNAME}.hex\"'  # 加个单引号\n \n    ]), \"Building $BUILD_DIR/${PROGNAME}.hex\")\n \n)\n```\n\n然后就可以编译并且烧录到单片机中，烧录过程查看博主内容\n","slug":"VScode+platformIO编译STM32标准库","published":1,"updated":"2024-09-04T09:30:41.260Z","comments":1,"layout":"post","photos":[],"_id":"cm0nnusxn0001ckfbfsbibjof","content":"<h1 id=\"VScode-platformIO编译STM32标准库\"><a href=\"#VScode-platformIO编译STM32标准库\" class=\"headerlink\" title=\"VScode+platformIO编译STM32标准库\"></a>VScode+platformIO编译STM32标准库</h1><h2 id=\"参考博主\"><a href=\"#参考博主\" class=\"headerlink\" title=\"参考博主\"></a>参考博主</h2><p><a href=\"https://juejin.cn/post/7393313322210426915\">https://juejin.cn/post/7393313322210426915</a></p>\n<p><a href=\"https://blog.csdn.net/maomaochong666/article/details/129240827\">https://blog.csdn.net/maomaochong666/article/details/129240827</a></p>\n<h2 id=\"配置主要有四个步骤：\"><a href=\"#配置主要有四个步骤：\" class=\"headerlink\" title=\"配置主要有四个步骤：\"></a>配置主要有四个步骤：</h2><h4 id=\"1-创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\"><a href=\"#1-创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\" class=\"headerlink\" title=\"1.创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\"></a>1.创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架</h4><p><img src=\"https://s2.loli.net/2024/09/04/xN5agDtl6RfTYI9.png\" alt=\"image.png\"></p>\n<h4 id=\"2-拷录文件放入STM32项目中\"><a href=\"#2-拷录文件放入STM32项目中\" class=\"headerlink\" title=\"2.拷录文件放入STM32项目中\"></a>2.拷录文件放入STM32项目中</h4><p>以野火为模板，将library文件user文件拷入到项目当中的src文件夹下，不要分开使用，直接全部拷入，方便使用，删除start启动文件和system_stm32f10x.c文件，因为在初始化的时候已经自动生成</p>\n<img src=\"https://s2.loli.net/2024/09/04/ItUnakMPEJAlwrW.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"3-修改platformIO-ini文件\"><a href=\"#3-修改platformIO-ini文件\" class=\"headerlink\" title=\"3.修改platformIO.ini文件\"></a>3.修改platformIO.ini文件</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">//烧录和调试配置</span><br>upload_protocol <span class=\"hljs-operator\">=</span> cmsis<span class=\"hljs-operator\">-</span>dap<br>debug_tool <span class=\"hljs-operator\">=</span> cmsis<span class=\"hljs-operator\">-</span>dap<br><br><span class=\"hljs-comment\">// 添加头文件链接</span><br>build_flags <span class=\"hljs-operator\">=</span> <br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Wl</span>,<span class=\"hljs-operator\">-</span>u,_printf_float<br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Wl</span>,<span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Map</span>,output.map<br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">O0</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-operator\">/</span><span class=\"hljs-type\">Libraries</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/Libraries/</span><span class=\"hljs-type\">CMSIS</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/Libraries/</span><span class=\"hljs-type\">FWlib</span><span class=\"hljs-operator\">/</span>inc<br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-operator\">/</span><span class=\"hljs-type\">User</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">DMA</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">EXTI</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">I2C</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">LED</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">RCC</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">SPI</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">Systick</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">USART</span><br><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">D</span> <span class=\"hljs-type\">STM32F10X_HD</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">D</span> <span class=\"hljs-type\">USE_STDPERIPH_DRIVER</span><br><br><span class=\"hljs-comment\">// 定义串口通信，使用motion进行串口调试</span><br>monitor_speed <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">115200</span><br>monitor_echo <span class=\"hljs-operator\">=</span> yes<br>monitor_rts <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>monitor_dtr <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-comment\">// 将烧录文件转为hex格式</span><br>extra_scripts <span class=\"hljs-operator\">=</span> export_hex.py<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-修改core-cm3-c文件内容\"><a href=\"#4-修改core-cm3-c文件内容\" class=\"headerlink\" title=\"4.修改core_cm3.c文件内容\"></a>4.修改core_cm3.c文件内容</h4><p>修改core_cm3.c里面的内容（736、753行）</p>\n<p><img src=\"https://s2.loli.net/2024/09/04/AiZRHY1Kd4wjWnb.png\" alt=\"image.png\"></p>\n<h4 id=\"5-创建烧录文件hex转换脚本\"><a href=\"#5-创建烧录文件hex转换脚本\" class=\"headerlink\" title=\"5.创建烧录文件hex转换脚本\"></a>5.创建烧录文件hex转换脚本</h4><p>export_hex.py</p>\n<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\">Import(<span class=\"hljs-string\">&quot;env&quot;</span>)<br> <br><span class=\"hljs-comment\"># # Custom HEX from ELF</span><br> <br>env.AddPostAction(<br> <br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.elf&quot;</span>,<br> <br>    env.VerboseAction(<span class=\"hljs-string\">&quot; &quot;</span>.join([<br> <br>        <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$OBJCOPY</span>&quot;</span>, <span class=\"hljs-string\">&quot;-O&quot;</span>, <span class=\"hljs-string\">&quot;ihex&quot;</span>, <span class=\"hljs-string\">&quot;-R&quot;</span>, <span class=\"hljs-string\">&quot;.eeprom&quot;</span>,<br> <br>        <span class=\"hljs-string\">&#x27;&quot;<span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.elf&quot;&#x27;</span>, <span class=\"hljs-string\">&#x27;&quot;<span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.hex&quot;&#x27;</span>  <span class=\"hljs-comment\"># 加个单引号</span><br> <br>    ]), <span class=\"hljs-string\">&quot;Building <span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.hex&quot;</span>)<br> <br>)<br></code></pre></td></tr></table></figure>\n\n<p>然后就可以编译并且烧录到单片机中，烧录过程查看博主内容</p>\n","excerpt":"","more":"<h1 id=\"VScode-platformIO编译STM32标准库\"><a href=\"#VScode-platformIO编译STM32标准库\" class=\"headerlink\" title=\"VScode+platformIO编译STM32标准库\"></a>VScode+platformIO编译STM32标准库</h1><h2 id=\"参考博主\"><a href=\"#参考博主\" class=\"headerlink\" title=\"参考博主\"></a>参考博主</h2><p><a href=\"https://juejin.cn/post/7393313322210426915\">https://juejin.cn/post/7393313322210426915</a></p>\n<p><a href=\"https://blog.csdn.net/maomaochong666/article/details/129240827\">https://blog.csdn.net/maomaochong666/article/details/129240827</a></p>\n<h2 id=\"配置主要有四个步骤：\"><a href=\"#配置主要有四个步骤：\" class=\"headerlink\" title=\"配置主要有四个步骤：\"></a>配置主要有四个步骤：</h2><h4 id=\"1-创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\"><a href=\"#1-创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\" class=\"headerlink\" title=\"1.创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架\"></a>1.创建STM32项目，创建的芯片后缀带Generic的即可，选择CMSIS框架</h4><p><img src=\"https://s2.loli.net/2024/09/04/xN5agDtl6RfTYI9.png\" alt=\"image.png\"></p>\n<h4 id=\"2-拷录文件放入STM32项目中\"><a href=\"#2-拷录文件放入STM32项目中\" class=\"headerlink\" title=\"2.拷录文件放入STM32项目中\"></a>2.拷录文件放入STM32项目中</h4><p>以野火为模板，将library文件user文件拷入到项目当中的src文件夹下，不要分开使用，直接全部拷入，方便使用，删除start启动文件和system_stm32f10x.c文件，因为在初始化的时候已经自动生成</p>\n<img src=\"https://s2.loli.net/2024/09/04/ItUnakMPEJAlwrW.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"3-修改platformIO-ini文件\"><a href=\"#3-修改platformIO-ini文件\" class=\"headerlink\" title=\"3.修改platformIO.ini文件\"></a>3.修改platformIO.ini文件</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-comment\">//烧录和调试配置</span><br>upload_protocol <span class=\"hljs-operator\">=</span> cmsis<span class=\"hljs-operator\">-</span>dap<br>debug_tool <span class=\"hljs-operator\">=</span> cmsis<span class=\"hljs-operator\">-</span>dap<br><br><span class=\"hljs-comment\">// 添加头文件链接</span><br>build_flags <span class=\"hljs-operator\">=</span> <br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Wl</span>,<span class=\"hljs-operator\">-</span>u,_printf_float<br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Wl</span>,<span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Map</span>,output.map<br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">O0</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-operator\">/</span><span class=\"hljs-type\">Libraries</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/Libraries/</span><span class=\"hljs-type\">CMSIS</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/Libraries/</span><span class=\"hljs-type\">FWlib</span><span class=\"hljs-operator\">/</span>inc<br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-operator\">/</span><span class=\"hljs-type\">User</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">DMA</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">EXTI</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">I2C</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">LED</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">RCC</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">SPI</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">Systick</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">Isrc</span><span class=\"hljs-regexp\">/User/</span><span class=\"hljs-type\">USART</span><br><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">D</span> <span class=\"hljs-type\">STM32F10X_HD</span><br>    <span class=\"hljs-operator\">-</span><span class=\"hljs-type\">D</span> <span class=\"hljs-type\">USE_STDPERIPH_DRIVER</span><br><br><span class=\"hljs-comment\">// 定义串口通信，使用motion进行串口调试</span><br>monitor_speed <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">115200</span><br>monitor_echo <span class=\"hljs-operator\">=</span> yes<br>monitor_rts <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br>monitor_dtr <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-comment\">// 将烧录文件转为hex格式</span><br>extra_scripts <span class=\"hljs-operator\">=</span> export_hex.py<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-修改core-cm3-c文件内容\"><a href=\"#4-修改core-cm3-c文件内容\" class=\"headerlink\" title=\"4.修改core_cm3.c文件内容\"></a>4.修改core_cm3.c文件内容</h4><p>修改core_cm3.c里面的内容（736、753行）</p>\n<p><img src=\"https://s2.loli.net/2024/09/04/AiZRHY1Kd4wjWnb.png\" alt=\"image.png\"></p>\n<h4 id=\"5-创建烧录文件hex转换脚本\"><a href=\"#5-创建烧录文件hex转换脚本\" class=\"headerlink\" title=\"5.创建烧录文件hex转换脚本\"></a>5.创建烧录文件hex转换脚本</h4><p>export_hex.py</p>\n<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\">Import(<span class=\"hljs-string\">&quot;env&quot;</span>)<br> <br><span class=\"hljs-comment\"># # Custom HEX from ELF</span><br> <br>env.AddPostAction(<br> <br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.elf&quot;</span>,<br> <br>    env.VerboseAction(<span class=\"hljs-string\">&quot; &quot;</span>.join([<br> <br>        <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$OBJCOPY</span>&quot;</span>, <span class=\"hljs-string\">&quot;-O&quot;</span>, <span class=\"hljs-string\">&quot;ihex&quot;</span>, <span class=\"hljs-string\">&quot;-R&quot;</span>, <span class=\"hljs-string\">&quot;.eeprom&quot;</span>,<br> <br>        <span class=\"hljs-string\">&#x27;&quot;<span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.elf&quot;&#x27;</span>, <span class=\"hljs-string\">&#x27;&quot;<span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.hex&quot;&#x27;</span>  <span class=\"hljs-comment\"># 加个单引号</span><br> <br>    ]), <span class=\"hljs-string\">&quot;Building <span class=\"hljs-variable\">$BUILD_DIR</span>/<span class=\"hljs-variable\">$&#123;PROGNAME&#125;</span>.hex&quot;</span>)<br> <br>)<br></code></pre></td></tr></table></figure>\n\n<p>然后就可以编译并且烧录到单片机中，烧录过程查看博主内容</p>\n"},{"title":"DShot协议","date":"2024-09-28T16:00:00.000Z","index_img":null,"_content":"\n# DShot协议\n\n## 感谢博主\n\nhttps://blog.csdn.net/weixin_39939185/article/details/132066139\n\n## DShot协议的时间长短\n\n在Dshot中，**1的高电平时长是0的两倍**。帧的实际持续时长、位的周期时长和帧长度取决于Dshot版本：\n\n| Dshot | 比特率     | T1H   | T0H   | 位(μs) | 帧(μs) |\n| ----- | ---------- | ----- | ----- | ------ | ------ |\n| 150   | 150kbit/s  | 5.00  | 2.50  | 6.67   | 106.72 |\n| 300   | 300kbit/s  | 2.50  | 1.25  | 3.33   | 53.28  |\n| 600   | 600kbit/s  | 1.25  | 0.625 | 1.67   | 26.72  |\n| 1200  | 1200kbit/s | 0.625 | 0.313 | 0.83   | 13.28  |\n\n## 帧的表示情况\n\n11位油门信号：共有2048个不同的值。0保留为上锁命令，1-47被保留为特殊命令。剩下的48-2047（共2000步）用于实际的油门值\n\n1位回传请求：如果设置了这一位，那么遥测数据将通过另外一根专线（电调回传线）单独发回飞控\n\n4位CRC(Cyclic Redundancy Checksum，循环冗余校验)：检验数据的有效性（包括油门数据以及回传请求位）\n\n![image.png](https://s2.loli.net/2024/09/29/v3jhNAL8yuH7rFM.png)\n\n#### 1-47特殊命令\n\n```\n1-5：beep（1= low freq. 5 = high freq）\n6： esc信息请求（fw版本和通过tlm线发送的SN）\n7：一个方向旋转\n8：另一个方向旋转\n9：3d模式关闭\n10：3d模式打开\n11：esc设置请求（saved settings over the TLM wire）\n12：保存设置\n```\n\n### 计算CRC\n\n校验和是根据油门数据和遥测位来计算的，因此，下面中的value表示的是前12位数据。\n\n```\ncrc = (value ^ (value >> 4) ^ (value >>8)) & 0x0f;\n```\n\n假设我们正在发送一个1046的油门值（正好是全油门的一半），并且遥测位为0：\n\n```\nvalue  = 100000101100\n(>>4)  = 000010000010 # right shift value by 4\n(^)    = 100010101110 # XOR with value\n(>>8)  = 000000001000 # right shift value by 8\n(^)    = 100010100110 # XOR with previous XOR\n(0x0F) = 000000001111 # Mask 0x0F\n(&)    = 000000000110 # CRC\n```\n\n所以，从飞控传输到电调的两个字节的数据是：\n\n```\n1000001011000110\n```\n\n帧的长度很重要，因为它表示的是电调的更新速率。帧的长度越短，那么每秒发送数据帧的频率就越高。换句话说，比特率越高，我们每秒钟可以发送的数据就越多。","source":"_posts/20240529ZYY-DShot协议.md","raw":"---\ntitle: DShot协议\ntag: DShot协议\ndate: 2024-09-29\ncategories: Fly\nindex_img: \n\n---\n\n# DShot协议\n\n## 感谢博主\n\nhttps://blog.csdn.net/weixin_39939185/article/details/132066139\n\n## DShot协议的时间长短\n\n在Dshot中，**1的高电平时长是0的两倍**。帧的实际持续时长、位的周期时长和帧长度取决于Dshot版本：\n\n| Dshot | 比特率     | T1H   | T0H   | 位(μs) | 帧(μs) |\n| ----- | ---------- | ----- | ----- | ------ | ------ |\n| 150   | 150kbit/s  | 5.00  | 2.50  | 6.67   | 106.72 |\n| 300   | 300kbit/s  | 2.50  | 1.25  | 3.33   | 53.28  |\n| 600   | 600kbit/s  | 1.25  | 0.625 | 1.67   | 26.72  |\n| 1200  | 1200kbit/s | 0.625 | 0.313 | 0.83   | 13.28  |\n\n## 帧的表示情况\n\n11位油门信号：共有2048个不同的值。0保留为上锁命令，1-47被保留为特殊命令。剩下的48-2047（共2000步）用于实际的油门值\n\n1位回传请求：如果设置了这一位，那么遥测数据将通过另外一根专线（电调回传线）单独发回飞控\n\n4位CRC(Cyclic Redundancy Checksum，循环冗余校验)：检验数据的有效性（包括油门数据以及回传请求位）\n\n![image.png](https://s2.loli.net/2024/09/29/v3jhNAL8yuH7rFM.png)\n\n#### 1-47特殊命令\n\n```\n1-5：beep（1= low freq. 5 = high freq）\n6： esc信息请求（fw版本和通过tlm线发送的SN）\n7：一个方向旋转\n8：另一个方向旋转\n9：3d模式关闭\n10：3d模式打开\n11：esc设置请求（saved settings over the TLM wire）\n12：保存设置\n```\n\n### 计算CRC\n\n校验和是根据油门数据和遥测位来计算的，因此，下面中的value表示的是前12位数据。\n\n```\ncrc = (value ^ (value >> 4) ^ (value >>8)) & 0x0f;\n```\n\n假设我们正在发送一个1046的油门值（正好是全油门的一半），并且遥测位为0：\n\n```\nvalue  = 100000101100\n(>>4)  = 000010000010 # right shift value by 4\n(^)    = 100010101110 # XOR with value\n(>>8)  = 000000001000 # right shift value by 8\n(^)    = 100010100110 # XOR with previous XOR\n(0x0F) = 000000001111 # Mask 0x0F\n(&)    = 000000000110 # CRC\n```\n\n所以，从飞控传输到电调的两个字节的数据是：\n\n```\n1000001011000110\n```\n\n帧的长度很重要，因为它表示的是电调的更新速率。帧的长度越短，那么每秒发送数据帧的频率就越高。换句话说，比特率越高，我们每秒钟可以发送的数据就越多。","slug":"20240529ZYY-DShot协议","published":1,"updated":"2024-09-30T01:03:11.046Z","comments":1,"layout":"post","photos":[],"_id":"cm1zrdyqb0000p8fb2fexh518","content":"<h1 id=\"DShot协议\"><a href=\"#DShot协议\" class=\"headerlink\" title=\"DShot协议\"></a>DShot协议</h1><h2 id=\"感谢博主\"><a href=\"#感谢博主\" class=\"headerlink\" title=\"感谢博主\"></a>感谢博主</h2><p><a href=\"https://blog.csdn.net/weixin_39939185/article/details/132066139\">https://blog.csdn.net/weixin_39939185/article/details/132066139</a></p>\n<h2 id=\"DShot协议的时间长短\"><a href=\"#DShot协议的时间长短\" class=\"headerlink\" title=\"DShot协议的时间长短\"></a>DShot协议的时间长短</h2><p>在Dshot中，<strong>1的高电平时长是0的两倍</strong>。帧的实际持续时长、位的周期时长和帧长度取决于Dshot版本：</p>\n<table>\n<thead>\n<tr>\n<th>Dshot</th>\n<th>比特率</th>\n<th>T1H</th>\n<th>T0H</th>\n<th>位(μs)</th>\n<th>帧(μs)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>150</td>\n<td>150kbit&#x2F;s</td>\n<td>5.00</td>\n<td>2.50</td>\n<td>6.67</td>\n<td>106.72</td>\n</tr>\n<tr>\n<td>300</td>\n<td>300kbit&#x2F;s</td>\n<td>2.50</td>\n<td>1.25</td>\n<td>3.33</td>\n<td>53.28</td>\n</tr>\n<tr>\n<td>600</td>\n<td>600kbit&#x2F;s</td>\n<td>1.25</td>\n<td>0.625</td>\n<td>1.67</td>\n<td>26.72</td>\n</tr>\n<tr>\n<td>1200</td>\n<td>1200kbit&#x2F;s</td>\n<td>0.625</td>\n<td>0.313</td>\n<td>0.83</td>\n<td>13.28</td>\n</tr>\n</tbody></table>\n<h2 id=\"帧的表示情况\"><a href=\"#帧的表示情况\" class=\"headerlink\" title=\"帧的表示情况\"></a>帧的表示情况</h2><p>11位油门信号：共有2048个不同的值。0保留为上锁命令，1-47被保留为特殊命令。剩下的48-2047（共2000步）用于实际的油门值</p>\n<p>1位回传请求：如果设置了这一位，那么遥测数据将通过另外一根专线（电调回传线）单独发回飞控</p>\n<p>4位CRC(Cyclic Redundancy Checksum，循环冗余校验)：检验数据的有效性（包括油门数据以及回传请求位）</p>\n<p><img src=\"https://s2.loli.net/2024/09/29/v3jhNAL8yuH7rFM.png\" alt=\"image.png\"></p>\n<h4 id=\"1-47特殊命令\"><a href=\"#1-47特殊命令\" class=\"headerlink\" title=\"1-47特殊命令\"></a>1-47特殊命令</h4><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">1</span>-<span class=\"hljs-number\">5</span>：beep（<span class=\"hljs-number\">1</span>= low freq. <span class=\"hljs-number\">5</span> = high freq）<br><span class=\"hljs-attribute\">6</span>： esc信息请求（fw版本和通过tlm线发送的SN）<br><span class=\"hljs-attribute\">7</span>：一个方向旋转<br><span class=\"hljs-attribute\">8</span>：另一个方向旋转<br><span class=\"hljs-attribute\">9</span>：<span class=\"hljs-number\">3</span>d模式关闭<br><span class=\"hljs-attribute\">10</span>：<span class=\"hljs-number\">3</span>d模式打开<br><span class=\"hljs-attribute\">11</span>：esc设置请求（saved settings over the TLM wire）<br><span class=\"hljs-attribute\">12</span>：保存设置<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"计算CRC\"><a href=\"#计算CRC\" class=\"headerlink\" title=\"计算CRC\"></a>计算CRC</h3><p>校验和是根据油门数据和遥测位来计算的，因此，下面中的value表示的是前12位数据。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">crc</span> = (value ^ (value &gt;&gt; <span class=\"hljs-number\">4</span>) ^ (value &gt;&gt;<span class=\"hljs-number\">8</span>)) &amp; <span class=\"hljs-number\">0</span>x0f;<br></code></pre></td></tr></table></figure>\n\n<p>假设我们正在发送一个1046的油门值（正好是全油门的一半），并且遥测位为0：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">value  = 100000101100<br>(&gt;&gt;4)  =<span class=\"hljs-number\"> 000010000010 </span><span class=\"hljs-comment\"># right shift value by 4</span><br>(^)    =<span class=\"hljs-number\"> 100010101110 </span><span class=\"hljs-comment\"># XOR with value</span><br>(&gt;&gt;8)  =<span class=\"hljs-number\"> 000000001000 </span><span class=\"hljs-comment\"># right shift value by 8</span><br>(^)    =<span class=\"hljs-number\"> 100010100110 </span><span class=\"hljs-comment\"># XOR with previous XOR</span><br>(0x0F) =<span class=\"hljs-number\"> 000000001111 </span><span class=\"hljs-comment\"># Mask 0x0F</span><br>(&amp;)    =<span class=\"hljs-number\"> 000000000110 </span><span class=\"hljs-comment\"># CRC</span><br></code></pre></td></tr></table></figure>\n\n<p>所以，从飞控传输到电调的两个字节的数据是：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">1000001011000110<br></code></pre></td></tr></table></figure>\n\n<p>帧的长度很重要，因为它表示的是电调的更新速率。帧的长度越短，那么每秒发送数据帧的频率就越高。换句话说，比特率越高，我们每秒钟可以发送的数据就越多。</p>\n","excerpt":"","more":"<h1 id=\"DShot协议\"><a href=\"#DShot协议\" class=\"headerlink\" title=\"DShot协议\"></a>DShot协议</h1><h2 id=\"感谢博主\"><a href=\"#感谢博主\" class=\"headerlink\" title=\"感谢博主\"></a>感谢博主</h2><p><a href=\"https://blog.csdn.net/weixin_39939185/article/details/132066139\">https://blog.csdn.net/weixin_39939185/article/details/132066139</a></p>\n<h2 id=\"DShot协议的时间长短\"><a href=\"#DShot协议的时间长短\" class=\"headerlink\" title=\"DShot协议的时间长短\"></a>DShot协议的时间长短</h2><p>在Dshot中，<strong>1的高电平时长是0的两倍</strong>。帧的实际持续时长、位的周期时长和帧长度取决于Dshot版本：</p>\n<table>\n<thead>\n<tr>\n<th>Dshot</th>\n<th>比特率</th>\n<th>T1H</th>\n<th>T0H</th>\n<th>位(μs)</th>\n<th>帧(μs)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>150</td>\n<td>150kbit&#x2F;s</td>\n<td>5.00</td>\n<td>2.50</td>\n<td>6.67</td>\n<td>106.72</td>\n</tr>\n<tr>\n<td>300</td>\n<td>300kbit&#x2F;s</td>\n<td>2.50</td>\n<td>1.25</td>\n<td>3.33</td>\n<td>53.28</td>\n</tr>\n<tr>\n<td>600</td>\n<td>600kbit&#x2F;s</td>\n<td>1.25</td>\n<td>0.625</td>\n<td>1.67</td>\n<td>26.72</td>\n</tr>\n<tr>\n<td>1200</td>\n<td>1200kbit&#x2F;s</td>\n<td>0.625</td>\n<td>0.313</td>\n<td>0.83</td>\n<td>13.28</td>\n</tr>\n</tbody></table>\n<h2 id=\"帧的表示情况\"><a href=\"#帧的表示情况\" class=\"headerlink\" title=\"帧的表示情况\"></a>帧的表示情况</h2><p>11位油门信号：共有2048个不同的值。0保留为上锁命令，1-47被保留为特殊命令。剩下的48-2047（共2000步）用于实际的油门值</p>\n<p>1位回传请求：如果设置了这一位，那么遥测数据将通过另外一根专线（电调回传线）单独发回飞控</p>\n<p>4位CRC(Cyclic Redundancy Checksum，循环冗余校验)：检验数据的有效性（包括油门数据以及回传请求位）</p>\n<p><img src=\"https://s2.loli.net/2024/09/29/v3jhNAL8yuH7rFM.png\" alt=\"image.png\"></p>\n<h4 id=\"1-47特殊命令\"><a href=\"#1-47特殊命令\" class=\"headerlink\" title=\"1-47特殊命令\"></a>1-47特殊命令</h4><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">1</span>-<span class=\"hljs-number\">5</span>：beep（<span class=\"hljs-number\">1</span>= low freq. <span class=\"hljs-number\">5</span> = high freq）<br><span class=\"hljs-attribute\">6</span>： esc信息请求（fw版本和通过tlm线发送的SN）<br><span class=\"hljs-attribute\">7</span>：一个方向旋转<br><span class=\"hljs-attribute\">8</span>：另一个方向旋转<br><span class=\"hljs-attribute\">9</span>：<span class=\"hljs-number\">3</span>d模式关闭<br><span class=\"hljs-attribute\">10</span>：<span class=\"hljs-number\">3</span>d模式打开<br><span class=\"hljs-attribute\">11</span>：esc设置请求（saved settings over the TLM wire）<br><span class=\"hljs-attribute\">12</span>：保存设置<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"计算CRC\"><a href=\"#计算CRC\" class=\"headerlink\" title=\"计算CRC\"></a>计算CRC</h3><p>校验和是根据油门数据和遥测位来计算的，因此，下面中的value表示的是前12位数据。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">crc</span> = (value ^ (value &gt;&gt; <span class=\"hljs-number\">4</span>) ^ (value &gt;&gt;<span class=\"hljs-number\">8</span>)) &amp; <span class=\"hljs-number\">0</span>x0f;<br></code></pre></td></tr></table></figure>\n\n<p>假设我们正在发送一个1046的油门值（正好是全油门的一半），并且遥测位为0：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">value  = 100000101100<br>(&gt;&gt;4)  =<span class=\"hljs-number\"> 000010000010 </span><span class=\"hljs-comment\"># right shift value by 4</span><br>(^)    =<span class=\"hljs-number\"> 100010101110 </span><span class=\"hljs-comment\"># XOR with value</span><br>(&gt;&gt;8)  =<span class=\"hljs-number\"> 000000001000 </span><span class=\"hljs-comment\"># right shift value by 8</span><br>(^)    =<span class=\"hljs-number\"> 100010100110 </span><span class=\"hljs-comment\"># XOR with previous XOR</span><br>(0x0F) =<span class=\"hljs-number\"> 000000001111 </span><span class=\"hljs-comment\"># Mask 0x0F</span><br>(&amp;)    =<span class=\"hljs-number\"> 000000000110 </span><span class=\"hljs-comment\"># CRC</span><br></code></pre></td></tr></table></figure>\n\n<p>所以，从飞控传输到电调的两个字节的数据是：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">1000001011000110<br></code></pre></td></tr></table></figure>\n\n<p>帧的长度很重要，因为它表示的是电调的更新速率。帧的长度越短，那么每秒发送数据帧的频率就越高。换句话说，比特率越高，我们每秒钟可以发送的数据就越多。</p>\n"},{"title":"STM32的ADC学习","date":"2024-09-11T16:00:00.000Z","index_img":null,"_content":"\n# STM32的ADC学习\n\n## 基本知识\n\nADC一共有三个ADC设备，这三个设备可以看成三个不一样的工人，他们可以同时，做各自的事情，当然如果他们三个人一起做一件事情，这件事情也会做的更快，做的更好，然后每个工人身上又有十几个通道，这十几个通道可以看出十几件不同的事情，干完这件事情才能干下一件事情，所以通道之间需要排队完成。\n\n## ADC的配置内容\n\nADC的配置分为共同配置和ADC个体配置，在配置完ADC硬件后，还需要针对每个通道进行配置\n\n共同配置主要配置所有ADC的采集模式、采集频率、传输模式和采集间隔时间，共同配置是在使用两个ADC硬件以上的才会选择进行配置，如果是单ADC的话，是不进行配置的\n\n```\n\t/* adc共同配置 ADC_CommonInitTypeDef */\n\t\n\t// 初始化结构体\n\tADC_CommonInitTypeDef ADC_CommonInitStructure;\n\t// 双ADC模式，常规的交替转换\n\tADC_CommonInitStructure.ADC_Mode = ADC_DualMode_Interl;\n\t// AHB2的时钟是168MHz，四分频是42MHz，ADC最大为36MHz\n\tADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;\n\t// 选择DMA的传输方式，ADC_DMAAccessMode_1、2、3三种模式，1适用于单通道，2和3适用于多通道，3适用于更高速、更大的传输，比如图片、视频等\n\tADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_2;\n\t// 两个ADC采样的间隔时间\n\tADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles;\n```\n\n个体配置主要配置ADC的采集精度、是否扫描、是否连续读取、是否外部触发、外部触发边沿选择、外部触发模式、采集通道数、数据对齐方式，不管是单ADC，还是多ADC，都需要配置每个ADC的个体配置\n\n```\n\t/* adc额外配置 ADC_CommonInitTypeDef */\n\t\n\t// 定义结构体\n\tADC_InitTypeDef ADC_InitStructure;\n\t// ADC读取为是12位，处理的时间也是12个ADC时钟\n\tADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;\n\t// 使能扫描模式，如果是多通道的，就需要扫描模式\n\tADC_InitStructure.ADC_ScanConvMode = ENABLE;\n\t// 连续读取模式，可以连续不停而不需要软硬件触发就可以采样ADC\n\tADC_InitStructure.ADC_ContinuousConvMode = ENABLE;\n\t// 外部边沿触发\n\tADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;\n\t// 外部触发的模式，定时器或者中断\n\tADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;\n\t// 采样的通道数量\n\tADC_InitStructure.ADC_NbrOfConversion = 1;\n\t// 数据右对齐，就是先写入右边数据，多通道的话就是右八位为第一个检测到的数据\n\tADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;\n\t// 写入配置\n\tADC_Init(ADC1, &ADC_InitStructure);\n```\n\n最后还需要选择所需通道和采样时长，并使能所有ADC\n\n```\n\t// 配置通道和采样的时长\n\tADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_3Cycles);  \n\t\n\t// 使能ADC\n\tADC_Cmd(ADC1, ENABLE);\n\t\n\t// 使能ADC-DMA\n\tADC_DMACmd(ADC1, ENABLE);\n```\n\n## ADC配置顺序\n\nADC的使用方式有很多种，如果比较简单的话就直接进行单ADC和单通道直接使用，也可以多通道单ADC使用，或者多通道多ADC使用，这几种方法可以根据不同的配置进行实现\n\n### 单ADC单通道\n\n1.初始化结构体和启用ADC时钟\n\n```\n\t// 初始化结构体\n\tADC_CommonInitTypeDef ADC_CommonInitStructure;\n\t\n\t// 使能ADC时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);\n\n\n```\n\n2.初始化ADC个体配置，单ADC不需要分频，因为系统会自动分频到36MHz\n\n3.选择ADC的通道和采样时间\n\n4.使能ADC\n\n5.启用ADC\n\n6.如果单ADC单通道传输的话想要启用DMA，就需要使能ADC和DMA通道\n\n7.如果软件触发ADC的话，那就需要将外部触发的不配置为使能，如果外部触发配置使能，那么软件触发将不生效\n\n### 单ADC多通道\n\n\n\n\n\n## DMA传输流程图\n\n![image.png](https://s2.loli.net/2024/09/15/lQoOgFdmNfSWJ8P.png)\n\n![image.png](https://s2.loli.net/2024/09/15/Bw6jIWZN8kOYtiD.png)\n\n\n\nADC_Resolution\n\nSTM32F407的ADC读取精度是12位（即 12-bit）。ADC 分辨率决定了转换结果的精度，12 位分辨率意味着 ADC 可以将模拟信号转换为 4096 个不同的数字值（2^12）。当然也就是说处理的时间是12个ADC时钟。\n\nADC_ScanConvMode\n\n扫描模式的作用是可以针对多个通道进行扫描，如果不开启的话只能在同一个通道上面进行读取\n\nADC_ContinuousConvMode\n\n连续转换模式。连续转换模式使得 ADC 在完成一个转换后自动开始下一个转换，而无需额外的触发信号。这样可以实现不断更新的 ADC 值。\n\nADC_ExternalTrigConvEdge\n\n外部触发转换的边缘，设置外部触发信号的边缘，以控制 ADC 转换的启动时机。主要就是上升沿、下降沿、两个都用或者不启用\n\nADC_ExternalTrigConv\n\n选择外部触发信号，外部触发的信号主要有定时器、中断触发，并且这些触发的话每个设备都是固定的，在头文件中宏定义会全部定义完全。内部触发意味着 ADC 转换的启动由微控制器内部的触发源控制，例如内部定时器、软件触发或其他内部事件，内部触发的话是比较快，比较简单，而且可以根据软件触发的方式进行随意检测，但是硬件检测的方式对于周期的控制比较精确，但是比较麻烦。\n\nADC_NbrOfConversion\n\n设置要进行的转换通道数，如果启用扫描模式，则可以启用更多的通道\n\nADC_DataAlign\n\n设置 ADC 转换结果的数据对齐方式。`ADC_DataAlign_Right` 表示转换结果右对齐，即数据的低位在数据寄存器的低位部分，高位在高位部分。另一种对齐方式是左对齐\n\nADC_RegularChannelConfig\n\n配置 ADC 的常规（非扫描模式）通道。这个是配置ADC通道和设置采样事件\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/STM32的ADC学习.md","raw":"---\ntitle: STM32的ADC学习\ntag: SPI\ndate: 2024-09-12\ncategories: STM32\nindex_img: \n---\n\n# STM32的ADC学习\n\n## 基本知识\n\nADC一共有三个ADC设备，这三个设备可以看成三个不一样的工人，他们可以同时，做各自的事情，当然如果他们三个人一起做一件事情，这件事情也会做的更快，做的更好，然后每个工人身上又有十几个通道，这十几个通道可以看出十几件不同的事情，干完这件事情才能干下一件事情，所以通道之间需要排队完成。\n\n## ADC的配置内容\n\nADC的配置分为共同配置和ADC个体配置，在配置完ADC硬件后，还需要针对每个通道进行配置\n\n共同配置主要配置所有ADC的采集模式、采集频率、传输模式和采集间隔时间，共同配置是在使用两个ADC硬件以上的才会选择进行配置，如果是单ADC的话，是不进行配置的\n\n```\n\t/* adc共同配置 ADC_CommonInitTypeDef */\n\t\n\t// 初始化结构体\n\tADC_CommonInitTypeDef ADC_CommonInitStructure;\n\t// 双ADC模式，常规的交替转换\n\tADC_CommonInitStructure.ADC_Mode = ADC_DualMode_Interl;\n\t// AHB2的时钟是168MHz，四分频是42MHz，ADC最大为36MHz\n\tADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;\n\t// 选择DMA的传输方式，ADC_DMAAccessMode_1、2、3三种模式，1适用于单通道，2和3适用于多通道，3适用于更高速、更大的传输，比如图片、视频等\n\tADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_2;\n\t// 两个ADC采样的间隔时间\n\tADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles;\n```\n\n个体配置主要配置ADC的采集精度、是否扫描、是否连续读取、是否外部触发、外部触发边沿选择、外部触发模式、采集通道数、数据对齐方式，不管是单ADC，还是多ADC，都需要配置每个ADC的个体配置\n\n```\n\t/* adc额外配置 ADC_CommonInitTypeDef */\n\t\n\t// 定义结构体\n\tADC_InitTypeDef ADC_InitStructure;\n\t// ADC读取为是12位，处理的时间也是12个ADC时钟\n\tADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;\n\t// 使能扫描模式，如果是多通道的，就需要扫描模式\n\tADC_InitStructure.ADC_ScanConvMode = ENABLE;\n\t// 连续读取模式，可以连续不停而不需要软硬件触发就可以采样ADC\n\tADC_InitStructure.ADC_ContinuousConvMode = ENABLE;\n\t// 外部边沿触发\n\tADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;\n\t// 外部触发的模式，定时器或者中断\n\tADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;\n\t// 采样的通道数量\n\tADC_InitStructure.ADC_NbrOfConversion = 1;\n\t// 数据右对齐，就是先写入右边数据，多通道的话就是右八位为第一个检测到的数据\n\tADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;\n\t// 写入配置\n\tADC_Init(ADC1, &ADC_InitStructure);\n```\n\n最后还需要选择所需通道和采样时长，并使能所有ADC\n\n```\n\t// 配置通道和采样的时长\n\tADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_3Cycles);  \n\t\n\t// 使能ADC\n\tADC_Cmd(ADC1, ENABLE);\n\t\n\t// 使能ADC-DMA\n\tADC_DMACmd(ADC1, ENABLE);\n```\n\n## ADC配置顺序\n\nADC的使用方式有很多种，如果比较简单的话就直接进行单ADC和单通道直接使用，也可以多通道单ADC使用，或者多通道多ADC使用，这几种方法可以根据不同的配置进行实现\n\n### 单ADC单通道\n\n1.初始化结构体和启用ADC时钟\n\n```\n\t// 初始化结构体\n\tADC_CommonInitTypeDef ADC_CommonInitStructure;\n\t\n\t// 使能ADC时钟\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);\n\n\n```\n\n2.初始化ADC个体配置，单ADC不需要分频，因为系统会自动分频到36MHz\n\n3.选择ADC的通道和采样时间\n\n4.使能ADC\n\n5.启用ADC\n\n6.如果单ADC单通道传输的话想要启用DMA，就需要使能ADC和DMA通道\n\n7.如果软件触发ADC的话，那就需要将外部触发的不配置为使能，如果外部触发配置使能，那么软件触发将不生效\n\n### 单ADC多通道\n\n\n\n\n\n## DMA传输流程图\n\n![image.png](https://s2.loli.net/2024/09/15/lQoOgFdmNfSWJ8P.png)\n\n![image.png](https://s2.loli.net/2024/09/15/Bw6jIWZN8kOYtiD.png)\n\n\n\nADC_Resolution\n\nSTM32F407的ADC读取精度是12位（即 12-bit）。ADC 分辨率决定了转换结果的精度，12 位分辨率意味着 ADC 可以将模拟信号转换为 4096 个不同的数字值（2^12）。当然也就是说处理的时间是12个ADC时钟。\n\nADC_ScanConvMode\n\n扫描模式的作用是可以针对多个通道进行扫描，如果不开启的话只能在同一个通道上面进行读取\n\nADC_ContinuousConvMode\n\n连续转换模式。连续转换模式使得 ADC 在完成一个转换后自动开始下一个转换，而无需额外的触发信号。这样可以实现不断更新的 ADC 值。\n\nADC_ExternalTrigConvEdge\n\n外部触发转换的边缘，设置外部触发信号的边缘，以控制 ADC 转换的启动时机。主要就是上升沿、下降沿、两个都用或者不启用\n\nADC_ExternalTrigConv\n\n选择外部触发信号，外部触发的信号主要有定时器、中断触发，并且这些触发的话每个设备都是固定的，在头文件中宏定义会全部定义完全。内部触发意味着 ADC 转换的启动由微控制器内部的触发源控制，例如内部定时器、软件触发或其他内部事件，内部触发的话是比较快，比较简单，而且可以根据软件触发的方式进行随意检测，但是硬件检测的方式对于周期的控制比较精确，但是比较麻烦。\n\nADC_NbrOfConversion\n\n设置要进行的转换通道数，如果启用扫描模式，则可以启用更多的通道\n\nADC_DataAlign\n\n设置 ADC 转换结果的数据对齐方式。`ADC_DataAlign_Right` 表示转换结果右对齐，即数据的低位在数据寄存器的低位部分，高位在高位部分。另一种对齐方式是左对齐\n\nADC_RegularChannelConfig\n\n配置 ADC 的常规（非扫描模式）通道。这个是配置ADC通道和设置采样事件\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"STM32的ADC学习","published":1,"updated":"2024-09-15T08:29:25.672Z","comments":1,"layout":"post","photos":[],"_id":"cm1zrdyqe0001p8fb859b6knp","content":"<h1 id=\"STM32的ADC学习\"><a href=\"#STM32的ADC学习\" class=\"headerlink\" title=\"STM32的ADC学习\"></a>STM32的ADC学习</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>ADC一共有三个ADC设备，这三个设备可以看成三个不一样的工人，他们可以同时，做各自的事情，当然如果他们三个人一起做一件事情，这件事情也会做的更快，做的更好，然后每个工人身上又有十几个通道，这十几个通道可以看出十几件不同的事情，干完这件事情才能干下一件事情，所以通道之间需要排队完成。</p>\n<h2 id=\"ADC的配置内容\"><a href=\"#ADC的配置内容\" class=\"headerlink\" title=\"ADC的配置内容\"></a>ADC的配置内容</h2><p>ADC的配置分为共同配置和ADC个体配置，在配置完ADC硬件后，还需要针对每个通道进行配置</p>\n<p>共同配置主要配置所有ADC的采集模式、采集频率、传输模式和采集间隔时间，共同配置是在使用两个ADC硬件以上的才会选择进行配置，如果是单ADC的话，是不进行配置的</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">/* adc共同配置 ADC_CommonInitTypeDef */<br><br>// 初始化结构体<br>ADC_CommonInitTypeDef ADC_CommonInitStructure<span class=\"hljs-comment\">;</span><br>// 双ADC模式，常规的交替转换<br>ADC_CommonInitStructure.ADC_Mode <span class=\"hljs-operator\">=</span> ADC_DualMode_Interl<span class=\"hljs-comment\">;</span><br>// AHB2的时钟是<span class=\"hljs-number\">168</span>MHz，四分频是<span class=\"hljs-number\">42</span>MHz，ADC最大为<span class=\"hljs-number\">36</span>MHz<br>ADC_CommonInitStructure.ADC_Prescaler <span class=\"hljs-operator\">=</span> ADC_Prescaler_Div4<span class=\"hljs-comment\">;</span><br>// 选择DMA的传输方式，ADC_DMAAccessMode_1、<span class=\"hljs-number\">2</span>、<span class=\"hljs-number\">3</span>三种模式，<span class=\"hljs-number\">1</span>适用于单通道，<span class=\"hljs-number\">2</span>和<span class=\"hljs-number\">3</span>适用于多通道，<span class=\"hljs-number\">3</span>适用于更高速、更大的传输，比如图片、视频等<br>ADC_CommonInitStructure.ADC_DMAAccessMode <span class=\"hljs-operator\">=</span> ADC_DMAAccessMode_2<span class=\"hljs-comment\">;</span><br>// 两个ADC采样的间隔时间<br>ADC_CommonInitStructure.ADC_TwoSamplingDelay <span class=\"hljs-operator\">=</span> ADC_TwoSamplingDelay_20Cycles<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>个体配置主要配置ADC的采集精度、是否扫描、是否连续读取、是否外部触发、外部触发边沿选择、外部触发模式、采集通道数、数据对齐方式，不管是单ADC，还是多ADC，都需要配置每个ADC的个体配置</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\"><span class=\"hljs-comment\">/* adc额外配置 ADC_CommonInitTypeDef */</span><br><br><span class=\"hljs-comment\">// 定义结构体</span><br>ADC_InitTypeDef ADC_InitStructure;<br><span class=\"hljs-comment\">// ADC读取为是12位，处理的时间也是12个ADC时钟</span><br>ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;<br><span class=\"hljs-comment\">// 使能扫描模式，如果是多通道的，就需要扫描模式</span><br>ADC_InitStructure.ADC_ScanConvMode = <span class=\"hljs-keyword\">ENABLE</span>;<br><span class=\"hljs-comment\">// 连续读取模式，可以连续不停而不需要软硬件触发就可以采样ADC</span><br>ADC_InitStructure.ADC_ContinuousConvMode = <span class=\"hljs-keyword\">ENABLE</span>;<br><span class=\"hljs-comment\">// 外部边沿触发</span><br>ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;<br><span class=\"hljs-comment\">// 外部触发的模式，定时器或者中断</span><br>ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;<br><span class=\"hljs-comment\">// 采样的通道数量</span><br>ADC_InitStructure.ADC_NbrOfConversion = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-comment\">// 数据右对齐，就是先写入右边数据，多通道的话就是右八位为第一个检测到的数据</span><br>ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<br><span class=\"hljs-comment\">// 写入配置</span><br><span class=\"hljs-built_in\">ADC_Init</span>(ADC1, &amp;ADC_InitStructure);<br></code></pre></td></tr></table></figure>\n\n<p>最后还需要选择所需通道和采样时长，并使能所有ADC</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 配置通道和采样的时长</span><br><span class=\"hljs-built_in\">ADC_RegularChannelConfig</span>(ADC1, ADC_Channel_0, <span class=\"hljs-number\">1</span>, ADC_SampleTime_3Cycles);  <br><br><span class=\"hljs-comment\">// 使能ADC</span><br><span class=\"hljs-built_in\">ADC_Cmd</span>(ADC1, ENABLE);<br><br><span class=\"hljs-comment\">// 使能ADC-DMA</span><br><span class=\"hljs-built_in\">ADC_DMACmd</span>(ADC1, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"ADC配置顺序\"><a href=\"#ADC配置顺序\" class=\"headerlink\" title=\"ADC配置顺序\"></a>ADC配置顺序</h2><p>ADC的使用方式有很多种，如果比较简单的话就直接进行单ADC和单通道直接使用，也可以多通道单ADC使用，或者多通道多ADC使用，这几种方法可以根据不同的配置进行实现</p>\n<h3 id=\"单ADC单通道\"><a href=\"#单ADC单通道\" class=\"headerlink\" title=\"单ADC单通道\"></a>单ADC单通道</h3><p>1.初始化结构体和启用ADC时钟</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 初始化结构体</span><br>ADC_CommonInitTypeDef ADC_CommonInitStructure;<br><br><span class=\"hljs-comment\">// 使能ADC时钟</span><br><span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_ADC1, ENABLE);<br><br><br></code></pre></td></tr></table></figure>\n\n<p>2.初始化ADC个体配置，单ADC不需要分频，因为系统会自动分频到36MHz</p>\n<p>3.选择ADC的通道和采样时间</p>\n<p>4.使能ADC</p>\n<p>5.启用ADC</p>\n<p>6.如果单ADC单通道传输的话想要启用DMA，就需要使能ADC和DMA通道</p>\n<p>7.如果软件触发ADC的话，那就需要将外部触发的不配置为使能，如果外部触发配置使能，那么软件触发将不生效</p>\n<h3 id=\"单ADC多通道\"><a href=\"#单ADC多通道\" class=\"headerlink\" title=\"单ADC多通道\"></a>单ADC多通道</h3><h2 id=\"DMA传输流程图\"><a href=\"#DMA传输流程图\" class=\"headerlink\" title=\"DMA传输流程图\"></a>DMA传输流程图</h2><p><img src=\"https://s2.loli.net/2024/09/15/lQoOgFdmNfSWJ8P.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/09/15/Bw6jIWZN8kOYtiD.png\" alt=\"image.png\"></p>\n<p>ADC_Resolution</p>\n<p>STM32F407的ADC读取精度是12位（即 12-bit）。ADC 分辨率决定了转换结果的精度，12 位分辨率意味着 ADC 可以将模拟信号转换为 4096 个不同的数字值（2^12）。当然也就是说处理的时间是12个ADC时钟。</p>\n<p>ADC_ScanConvMode</p>\n<p>扫描模式的作用是可以针对多个通道进行扫描，如果不开启的话只能在同一个通道上面进行读取</p>\n<p>ADC_ContinuousConvMode</p>\n<p>连续转换模式。连续转换模式使得 ADC 在完成一个转换后自动开始下一个转换，而无需额外的触发信号。这样可以实现不断更新的 ADC 值。</p>\n<p>ADC_ExternalTrigConvEdge</p>\n<p>外部触发转换的边缘，设置外部触发信号的边缘，以控制 ADC 转换的启动时机。主要就是上升沿、下降沿、两个都用或者不启用</p>\n<p>ADC_ExternalTrigConv</p>\n<p>选择外部触发信号，外部触发的信号主要有定时器、中断触发，并且这些触发的话每个设备都是固定的，在头文件中宏定义会全部定义完全。内部触发意味着 ADC 转换的启动由微控制器内部的触发源控制，例如内部定时器、软件触发或其他内部事件，内部触发的话是比较快，比较简单，而且可以根据软件触发的方式进行随意检测，但是硬件检测的方式对于周期的控制比较精确，但是比较麻烦。</p>\n<p>ADC_NbrOfConversion</p>\n<p>设置要进行的转换通道数，如果启用扫描模式，则可以启用更多的通道</p>\n<p>ADC_DataAlign</p>\n<p>设置 ADC 转换结果的数据对齐方式。<code>ADC_DataAlign_Right</code> 表示转换结果右对齐，即数据的低位在数据寄存器的低位部分，高位在高位部分。另一种对齐方式是左对齐</p>\n<p>ADC_RegularChannelConfig</p>\n<p>配置 ADC 的常规（非扫描模式）通道。这个是配置ADC通道和设置采样事件</p>\n","excerpt":"","more":"<h1 id=\"STM32的ADC学习\"><a href=\"#STM32的ADC学习\" class=\"headerlink\" title=\"STM32的ADC学习\"></a>STM32的ADC学习</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>ADC一共有三个ADC设备，这三个设备可以看成三个不一样的工人，他们可以同时，做各自的事情，当然如果他们三个人一起做一件事情，这件事情也会做的更快，做的更好，然后每个工人身上又有十几个通道，这十几个通道可以看出十几件不同的事情，干完这件事情才能干下一件事情，所以通道之间需要排队完成。</p>\n<h2 id=\"ADC的配置内容\"><a href=\"#ADC的配置内容\" class=\"headerlink\" title=\"ADC的配置内容\"></a>ADC的配置内容</h2><p>ADC的配置分为共同配置和ADC个体配置，在配置完ADC硬件后，还需要针对每个通道进行配置</p>\n<p>共同配置主要配置所有ADC的采集模式、采集频率、传输模式和采集间隔时间，共同配置是在使用两个ADC硬件以上的才会选择进行配置，如果是单ADC的话，是不进行配置的</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">/* adc共同配置 ADC_CommonInitTypeDef */<br><br>// 初始化结构体<br>ADC_CommonInitTypeDef ADC_CommonInitStructure<span class=\"hljs-comment\">;</span><br>// 双ADC模式，常规的交替转换<br>ADC_CommonInitStructure.ADC_Mode <span class=\"hljs-operator\">=</span> ADC_DualMode_Interl<span class=\"hljs-comment\">;</span><br>// AHB2的时钟是<span class=\"hljs-number\">168</span>MHz，四分频是<span class=\"hljs-number\">42</span>MHz，ADC最大为<span class=\"hljs-number\">36</span>MHz<br>ADC_CommonInitStructure.ADC_Prescaler <span class=\"hljs-operator\">=</span> ADC_Prescaler_Div4<span class=\"hljs-comment\">;</span><br>// 选择DMA的传输方式，ADC_DMAAccessMode_1、<span class=\"hljs-number\">2</span>、<span class=\"hljs-number\">3</span>三种模式，<span class=\"hljs-number\">1</span>适用于单通道，<span class=\"hljs-number\">2</span>和<span class=\"hljs-number\">3</span>适用于多通道，<span class=\"hljs-number\">3</span>适用于更高速、更大的传输，比如图片、视频等<br>ADC_CommonInitStructure.ADC_DMAAccessMode <span class=\"hljs-operator\">=</span> ADC_DMAAccessMode_2<span class=\"hljs-comment\">;</span><br>// 两个ADC采样的间隔时间<br>ADC_CommonInitStructure.ADC_TwoSamplingDelay <span class=\"hljs-operator\">=</span> ADC_TwoSamplingDelay_20Cycles<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>个体配置主要配置ADC的采集精度、是否扫描、是否连续读取、是否外部触发、外部触发边沿选择、外部触发模式、采集通道数、数据对齐方式，不管是单ADC，还是多ADC，都需要配置每个ADC的个体配置</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\"><span class=\"hljs-comment\">/* adc额外配置 ADC_CommonInitTypeDef */</span><br><br><span class=\"hljs-comment\">// 定义结构体</span><br>ADC_InitTypeDef ADC_InitStructure;<br><span class=\"hljs-comment\">// ADC读取为是12位，处理的时间也是12个ADC时钟</span><br>ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;<br><span class=\"hljs-comment\">// 使能扫描模式，如果是多通道的，就需要扫描模式</span><br>ADC_InitStructure.ADC_ScanConvMode = <span class=\"hljs-keyword\">ENABLE</span>;<br><span class=\"hljs-comment\">// 连续读取模式，可以连续不停而不需要软硬件触发就可以采样ADC</span><br>ADC_InitStructure.ADC_ContinuousConvMode = <span class=\"hljs-keyword\">ENABLE</span>;<br><span class=\"hljs-comment\">// 外部边沿触发</span><br>ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;<br><span class=\"hljs-comment\">// 外部触发的模式，定时器或者中断</span><br>ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;<br><span class=\"hljs-comment\">// 采样的通道数量</span><br>ADC_InitStructure.ADC_NbrOfConversion = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-comment\">// 数据右对齐，就是先写入右边数据，多通道的话就是右八位为第一个检测到的数据</span><br>ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<br><span class=\"hljs-comment\">// 写入配置</span><br><span class=\"hljs-built_in\">ADC_Init</span>(ADC1, &amp;ADC_InitStructure);<br></code></pre></td></tr></table></figure>\n\n<p>最后还需要选择所需通道和采样时长，并使能所有ADC</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 配置通道和采样的时长</span><br><span class=\"hljs-built_in\">ADC_RegularChannelConfig</span>(ADC1, ADC_Channel_0, <span class=\"hljs-number\">1</span>, ADC_SampleTime_3Cycles);  <br><br><span class=\"hljs-comment\">// 使能ADC</span><br><span class=\"hljs-built_in\">ADC_Cmd</span>(ADC1, ENABLE);<br><br><span class=\"hljs-comment\">// 使能ADC-DMA</span><br><span class=\"hljs-built_in\">ADC_DMACmd</span>(ADC1, ENABLE);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"ADC配置顺序\"><a href=\"#ADC配置顺序\" class=\"headerlink\" title=\"ADC配置顺序\"></a>ADC配置顺序</h2><p>ADC的使用方式有很多种，如果比较简单的话就直接进行单ADC和单通道直接使用，也可以多通道单ADC使用，或者多通道多ADC使用，这几种方法可以根据不同的配置进行实现</p>\n<h3 id=\"单ADC单通道\"><a href=\"#单ADC单通道\" class=\"headerlink\" title=\"单ADC单通道\"></a>单ADC单通道</h3><p>1.初始化结构体和启用ADC时钟</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">// 初始化结构体</span><br>ADC_CommonInitTypeDef ADC_CommonInitStructure;<br><br><span class=\"hljs-comment\">// 使能ADC时钟</span><br><span class=\"hljs-built_in\">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_ADC1, ENABLE);<br><br><br></code></pre></td></tr></table></figure>\n\n<p>2.初始化ADC个体配置，单ADC不需要分频，因为系统会自动分频到36MHz</p>\n<p>3.选择ADC的通道和采样时间</p>\n<p>4.使能ADC</p>\n<p>5.启用ADC</p>\n<p>6.如果单ADC单通道传输的话想要启用DMA，就需要使能ADC和DMA通道</p>\n<p>7.如果软件触发ADC的话，那就需要将外部触发的不配置为使能，如果外部触发配置使能，那么软件触发将不生效</p>\n<h3 id=\"单ADC多通道\"><a href=\"#单ADC多通道\" class=\"headerlink\" title=\"单ADC多通道\"></a>单ADC多通道</h3><h2 id=\"DMA传输流程图\"><a href=\"#DMA传输流程图\" class=\"headerlink\" title=\"DMA传输流程图\"></a>DMA传输流程图</h2><p><img src=\"https://s2.loli.net/2024/09/15/lQoOgFdmNfSWJ8P.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/09/15/Bw6jIWZN8kOYtiD.png\" alt=\"image.png\"></p>\n<p>ADC_Resolution</p>\n<p>STM32F407的ADC读取精度是12位（即 12-bit）。ADC 分辨率决定了转换结果的精度，12 位分辨率意味着 ADC 可以将模拟信号转换为 4096 个不同的数字值（2^12）。当然也就是说处理的时间是12个ADC时钟。</p>\n<p>ADC_ScanConvMode</p>\n<p>扫描模式的作用是可以针对多个通道进行扫描，如果不开启的话只能在同一个通道上面进行读取</p>\n<p>ADC_ContinuousConvMode</p>\n<p>连续转换模式。连续转换模式使得 ADC 在完成一个转换后自动开始下一个转换，而无需额外的触发信号。这样可以实现不断更新的 ADC 值。</p>\n<p>ADC_ExternalTrigConvEdge</p>\n<p>外部触发转换的边缘，设置外部触发信号的边缘，以控制 ADC 转换的启动时机。主要就是上升沿、下降沿、两个都用或者不启用</p>\n<p>ADC_ExternalTrigConv</p>\n<p>选择外部触发信号，外部触发的信号主要有定时器、中断触发，并且这些触发的话每个设备都是固定的，在头文件中宏定义会全部定义完全。内部触发意味着 ADC 转换的启动由微控制器内部的触发源控制，例如内部定时器、软件触发或其他内部事件，内部触发的话是比较快，比较简单，而且可以根据软件触发的方式进行随意检测，但是硬件检测的方式对于周期的控制比较精确，但是比较麻烦。</p>\n<p>ADC_NbrOfConversion</p>\n<p>设置要进行的转换通道数，如果启用扫描模式，则可以启用更多的通道</p>\n<p>ADC_DataAlign</p>\n<p>设置 ADC 转换结果的数据对齐方式。<code>ADC_DataAlign_Right</code> 表示转换结果右对齐，即数据的低位在数据寄存器的低位部分，高位在高位部分。另一种对齐方式是左对齐</p>\n<p>ADC_RegularChannelConfig</p>\n<p>配置 ADC 的常规（非扫描模式）通道。这个是配置ADC通道和设置采样事件</p>\n"},{"title":"Python","date":"2024-09-13T16:00:00.000Z","index_img":null,"_content":"\n# Python\n\n## split()\n\n分割函数，可以将字符串分割成列表\n\n```\nsection  = \"module1 module2 module3\"\nsection.split() = ['module1', 'module2', 'module3']\n```\n\n","source":"_posts/Work No.29.md","raw":"---\ntitle: Python\ntag: Python\ndate: 2024-09-14\ncategories: Python\nindex_img: \n---\n\n# Python\n\n## split()\n\n分割函数，可以将字符串分割成列表\n\n```\nsection  = \"module1 module2 module3\"\nsection.split() = ['module1', 'module2', 'module3']\n```\n\n","slug":"Work No.29","published":1,"updated":"2024-09-15T04:13:42.623Z","comments":1,"layout":"post","photos":[],"_id":"cm1zrdyqi0004p8fbcnxrbtzn","content":"<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h2><p>分割函数，可以将字符串分割成列表</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">section</span>  = <span class=\"hljs-string\">&quot;module1 module2 module3&quot;</span><br><span class=\"hljs-selector-tag\">section</span><span class=\"hljs-selector-class\">.split</span>() = <span class=\"hljs-selector-attr\">[<span class=\"hljs-string\">&#x27;module1&#x27;</span>, <span class=\"hljs-string\">&#x27;module2&#x27;</span>, <span class=\"hljs-string\">&#x27;module3&#x27;</span>]</span><br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h2><p>分割函数，可以将字符串分割成列表</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">section</span>  = <span class=\"hljs-string\">&quot;module1 module2 module3&quot;</span><br><span class=\"hljs-selector-tag\">section</span><span class=\"hljs-selector-class\">.split</span>() = <span class=\"hljs-selector-attr\">[<span class=\"hljs-string\">&#x27;module1&#x27;</span>, <span class=\"hljs-string\">&#x27;module2&#x27;</span>, <span class=\"hljs-string\">&#x27;module3&#x27;</span>]</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"STM32的TIM学习","date":"2024-09-11T16:00:00.000Z","index_img":null,"_content":"\n# STM32的TIM学习\n\n## 基本知识\n\n高级控制定时器(TIM1和TIM8)和通用定时器在基本定时器的基础上引入了外部引脚，可以输入捕获和输出比较功能。\n\n高级控制定时器比通用定时器增加了可编程死区互补输出、 重复计数器、带刹车(断路)功能，这些功能都是针对工业电机控制方面。\n\n高级控制定时器时基单元包含一个16位自动重载计数器ARR，一个16位的计数器CNT，可向上/下计数，一个16位可编程预分频器PSC，预分频器时钟源有多种可选， 有内部的时钟、外部时钟。还有一个8位的重复计数器RCR，这样最高可实现40位的可编程定时。\n\n高级控制定时器有四个时钟源可选：\n\n- 内部时钟源CK_INT，内部时钟CK_INT即来自于芯片内部，等于168M\n\n**一个高级定时器的多个输出通道**（如 `TIM1_CH1`、`TIM1_CH2`、`TIM1_CH3`）并**不等同于多个定时器**。每个通道可以产生不同的PWM占空比（但频率相同，因为它们共享计数器）。\n\n**多个通道之间可以实现同步输出**，因为它们依赖同一个计数器。\n\n在输入捕获时，定时器时钟频率越高，捕获的时间精度越高。\n\n定时器的计数周期（`Period`）应足够大，以便记录下信号的变化。如果信号周期非常长，而定时器周期设置得太短，可能会导致计数器溢出。\n\n### TIM_OCMode\n\n```\nTIM_OCMode_Timing (0x0000)\n作用：这是一个时间模式。在此模式下，定时器仅比较计数器和捕获比较寄存器（CCR）中的值，不产生任何外部信号变化。\n应用场景：用于定时、计数功能，不影响输出管脚。\n\nTIM_OCMode_Active (0x0010)\n作用：当计数器值与CCR中的值匹配时，输出变为高电平。\n应用场景：用于激活外设或者作为标志信号触发。\n\nTIM_OCMode_Inactive (0x0020)\n作用：当计数器值与CCR中的值匹配时，输出变为低电平。\n应用场景：用于关闭外设或者表示事件结束。\n\nTIM_OCMode_Toggle (0x0030)\n作用：当计数器值与CCR中的值匹配时，输出电平翻转（从高变低或从低变高）。\n应用场景：用于产生方波或周期性信号输出。\n\nTIM_OCMode_PWM1 (0x0060)\n作用：这是标准的PWM（脉宽调制）模式1。当计数器值小于CCR中的值时，输出为高电平；当计数器值大于或等于CCR中的值时，输出为低电平。\n应用场景：用于产生PWM信号，用于电机控制、LED调光等场景。\n\nTIM_OCMode_PWM2 (0x0070)\n作用：这是PWM模式2，与模式1相反。当计数器值小于CCR中的值时，输出为低电平；当计数器值大于或等于CCR中的值时，输出为高电平。\n应用场景：用于产生相反极性的PWM信号。\n\nTIM_ForcedAction_Active\n作用：强制输出高电平，忽略计数器的比较操作。\n应用场景：用于强制将输出设为高电平，通常用于紧急停止或强制触发信号。\n\nTIM_ForcedAction_InActive\n作用：强制输出低电平，忽略计数器的比较操作。\n应用场景：用于强制将输出设为低电平，例如复位某些信号或设备。\n```\n\n","source":"_posts/STM32的TIM学习.md","raw":"---\ntitle: STM32的TIM学习\ntag: TIM\ndate: 2024-09-12\ncategories: STM32\nindex_img: \n---\n\n# STM32的TIM学习\n\n## 基本知识\n\n高级控制定时器(TIM1和TIM8)和通用定时器在基本定时器的基础上引入了外部引脚，可以输入捕获和输出比较功能。\n\n高级控制定时器比通用定时器增加了可编程死区互补输出、 重复计数器、带刹车(断路)功能，这些功能都是针对工业电机控制方面。\n\n高级控制定时器时基单元包含一个16位自动重载计数器ARR，一个16位的计数器CNT，可向上/下计数，一个16位可编程预分频器PSC，预分频器时钟源有多种可选， 有内部的时钟、外部时钟。还有一个8位的重复计数器RCR，这样最高可实现40位的可编程定时。\n\n高级控制定时器有四个时钟源可选：\n\n- 内部时钟源CK_INT，内部时钟CK_INT即来自于芯片内部，等于168M\n\n**一个高级定时器的多个输出通道**（如 `TIM1_CH1`、`TIM1_CH2`、`TIM1_CH3`）并**不等同于多个定时器**。每个通道可以产生不同的PWM占空比（但频率相同，因为它们共享计数器）。\n\n**多个通道之间可以实现同步输出**，因为它们依赖同一个计数器。\n\n在输入捕获时，定时器时钟频率越高，捕获的时间精度越高。\n\n定时器的计数周期（`Period`）应足够大，以便记录下信号的变化。如果信号周期非常长，而定时器周期设置得太短，可能会导致计数器溢出。\n\n### TIM_OCMode\n\n```\nTIM_OCMode_Timing (0x0000)\n作用：这是一个时间模式。在此模式下，定时器仅比较计数器和捕获比较寄存器（CCR）中的值，不产生任何外部信号变化。\n应用场景：用于定时、计数功能，不影响输出管脚。\n\nTIM_OCMode_Active (0x0010)\n作用：当计数器值与CCR中的值匹配时，输出变为高电平。\n应用场景：用于激活外设或者作为标志信号触发。\n\nTIM_OCMode_Inactive (0x0020)\n作用：当计数器值与CCR中的值匹配时，输出变为低电平。\n应用场景：用于关闭外设或者表示事件结束。\n\nTIM_OCMode_Toggle (0x0030)\n作用：当计数器值与CCR中的值匹配时，输出电平翻转（从高变低或从低变高）。\n应用场景：用于产生方波或周期性信号输出。\n\nTIM_OCMode_PWM1 (0x0060)\n作用：这是标准的PWM（脉宽调制）模式1。当计数器值小于CCR中的值时，输出为高电平；当计数器值大于或等于CCR中的值时，输出为低电平。\n应用场景：用于产生PWM信号，用于电机控制、LED调光等场景。\n\nTIM_OCMode_PWM2 (0x0070)\n作用：这是PWM模式2，与模式1相反。当计数器值小于CCR中的值时，输出为低电平；当计数器值大于或等于CCR中的值时，输出为高电平。\n应用场景：用于产生相反极性的PWM信号。\n\nTIM_ForcedAction_Active\n作用：强制输出高电平，忽略计数器的比较操作。\n应用场景：用于强制将输出设为高电平，通常用于紧急停止或强制触发信号。\n\nTIM_ForcedAction_InActive\n作用：强制输出低电平，忽略计数器的比较操作。\n应用场景：用于强制将输出设为低电平，例如复位某些信号或设备。\n```\n\n","slug":"STM32的TIM学习","published":1,"updated":"2024-10-08T01:20:46.563Z","comments":1,"layout":"post","photos":[],"_id":"cm1zrdyqj0006p8fbdw4a7dwz","content":"<h1 id=\"STM32的TIM学习\"><a href=\"#STM32的TIM学习\" class=\"headerlink\" title=\"STM32的TIM学习\"></a>STM32的TIM学习</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>高级控制定时器(TIM1和TIM8)和通用定时器在基本定时器的基础上引入了外部引脚，可以输入捕获和输出比较功能。</p>\n<p>高级控制定时器比通用定时器增加了可编程死区互补输出、 重复计数器、带刹车(断路)功能，这些功能都是针对工业电机控制方面。</p>\n<p>高级控制定时器时基单元包含一个16位自动重载计数器ARR，一个16位的计数器CNT，可向上&#x2F;下计数，一个16位可编程预分频器PSC，预分频器时钟源有多种可选， 有内部的时钟、外部时钟。还有一个8位的重复计数器RCR，这样最高可实现40位的可编程定时。</p>\n<p>高级控制定时器有四个时钟源可选：</p>\n<ul>\n<li>内部时钟源CK_INT，内部时钟CK_INT即来自于芯片内部，等于168M</li>\n</ul>\n<p><strong>一个高级定时器的多个输出通道</strong>（如 <code>TIM1_CH1</code>、<code>TIM1_CH2</code>、<code>TIM1_CH3</code>）并<strong>不等同于多个定时器</strong>。每个通道可以产生不同的PWM占空比（但频率相同，因为它们共享计数器）。</p>\n<p><strong>多个通道之间可以实现同步输出</strong>，因为它们依赖同一个计数器。</p>\n<p>在输入捕获时，定时器时钟频率越高，捕获的时间精度越高。</p>\n<p>定时器的计数周期（<code>Period</code>）应足够大，以便记录下信号的变化。如果信号周期非常长，而定时器周期设置得太短，可能会导致计数器溢出。</p>\n<h3 id=\"TIM-OCMode\"><a href=\"#TIM-OCMode\" class=\"headerlink\" title=\"TIM_OCMode\"></a>TIM_OCMode</h3><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">TIM_OCMode_Timing (<span class=\"hljs-number\">0</span>x0000)<br>作用：这是一个时间模式。在此模式下，定时器仅比较计数器和捕获比较寄存器（CCR）中的值，不产生任何外部信号变化。<br>应用场景：用于定时、计数功能，不影响输出管脚。<br><br>TIM_OCMode_Active (<span class=\"hljs-number\">0</span>x0010)<br>作用：当计数器值与CCR中的值匹配时，输出变为高电平。<br>应用场景：用于激活外设或者作为标志信号触发。<br><br>TIM_OCMode_Inactive (<span class=\"hljs-number\">0</span>x0020)<br>作用：当计数器值与CCR中的值匹配时，输出变为低电平。<br>应用场景：用于关闭外设或者表示事件结束。<br><br>TIM_OCMode_Toggle (<span class=\"hljs-number\">0</span>x0030)<br>作用：当计数器值与CCR中的值匹配时，输出电平翻转（从高变低或从低变高）。<br>应用场景：用于产生方波或周期性信号输出。<br><br>TIM_OCMode_PWM1 (<span class=\"hljs-number\">0</span>x0060)<br>作用：这是标准的PWM（脉宽调制）模式<span class=\"hljs-number\">1</span>。当计数器值小于CCR中的值时，输出为高电平；当计数器值大于或等于CCR中的值时，输出为低电平。<br>应用场景：用于产生PWM信号，用于电机控制、LED调光等场景。<br><br>TIM_OCMode_PWM2 (<span class=\"hljs-number\">0</span>x0070)<br>作用：这是PWM模式<span class=\"hljs-number\">2</span>，与模式<span class=\"hljs-number\">1</span>相反。当计数器值小于CCR中的值时，输出为低电平；当计数器值大于或等于CCR中的值时，输出为高电平。<br>应用场景：用于产生相反极性的PWM信号。<br><br>TIM_ForcedAction_Active<br>作用：强制输出高电平，忽略计数器的比较操作。<br>应用场景：用于强制将输出设为高电平，通常用于紧急停止或强制触发信号。<br><br>TIM_ForcedAction_InActive<br>作用：强制输出低电平，忽略计数器的比较操作。<br>应用场景：用于强制将输出设为低电平，例如复位某些信号或设备。<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"STM32的TIM学习\"><a href=\"#STM32的TIM学习\" class=\"headerlink\" title=\"STM32的TIM学习\"></a>STM32的TIM学习</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>高级控制定时器(TIM1和TIM8)和通用定时器在基本定时器的基础上引入了外部引脚，可以输入捕获和输出比较功能。</p>\n<p>高级控制定时器比通用定时器增加了可编程死区互补输出、 重复计数器、带刹车(断路)功能，这些功能都是针对工业电机控制方面。</p>\n<p>高级控制定时器时基单元包含一个16位自动重载计数器ARR，一个16位的计数器CNT，可向上&#x2F;下计数，一个16位可编程预分频器PSC，预分频器时钟源有多种可选， 有内部的时钟、外部时钟。还有一个8位的重复计数器RCR，这样最高可实现40位的可编程定时。</p>\n<p>高级控制定时器有四个时钟源可选：</p>\n<ul>\n<li>内部时钟源CK_INT，内部时钟CK_INT即来自于芯片内部，等于168M</li>\n</ul>\n<p><strong>一个高级定时器的多个输出通道</strong>（如 <code>TIM1_CH1</code>、<code>TIM1_CH2</code>、<code>TIM1_CH3</code>）并<strong>不等同于多个定时器</strong>。每个通道可以产生不同的PWM占空比（但频率相同，因为它们共享计数器）。</p>\n<p><strong>多个通道之间可以实现同步输出</strong>，因为它们依赖同一个计数器。</p>\n<p>在输入捕获时，定时器时钟频率越高，捕获的时间精度越高。</p>\n<p>定时器的计数周期（<code>Period</code>）应足够大，以便记录下信号的变化。如果信号周期非常长，而定时器周期设置得太短，可能会导致计数器溢出。</p>\n<h3 id=\"TIM-OCMode\"><a href=\"#TIM-OCMode\" class=\"headerlink\" title=\"TIM_OCMode\"></a>TIM_OCMode</h3><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">TIM_OCMode_Timing (<span class=\"hljs-number\">0</span>x0000)<br>作用：这是一个时间模式。在此模式下，定时器仅比较计数器和捕获比较寄存器（CCR）中的值，不产生任何外部信号变化。<br>应用场景：用于定时、计数功能，不影响输出管脚。<br><br>TIM_OCMode_Active (<span class=\"hljs-number\">0</span>x0010)<br>作用：当计数器值与CCR中的值匹配时，输出变为高电平。<br>应用场景：用于激活外设或者作为标志信号触发。<br><br>TIM_OCMode_Inactive (<span class=\"hljs-number\">0</span>x0020)<br>作用：当计数器值与CCR中的值匹配时，输出变为低电平。<br>应用场景：用于关闭外设或者表示事件结束。<br><br>TIM_OCMode_Toggle (<span class=\"hljs-number\">0</span>x0030)<br>作用：当计数器值与CCR中的值匹配时，输出电平翻转（从高变低或从低变高）。<br>应用场景：用于产生方波或周期性信号输出。<br><br>TIM_OCMode_PWM1 (<span class=\"hljs-number\">0</span>x0060)<br>作用：这是标准的PWM（脉宽调制）模式<span class=\"hljs-number\">1</span>。当计数器值小于CCR中的值时，输出为高电平；当计数器值大于或等于CCR中的值时，输出为低电平。<br>应用场景：用于产生PWM信号，用于电机控制、LED调光等场景。<br><br>TIM_OCMode_PWM2 (<span class=\"hljs-number\">0</span>x0070)<br>作用：这是PWM模式<span class=\"hljs-number\">2</span>，与模式<span class=\"hljs-number\">1</span>相反。当计数器值小于CCR中的值时，输出为低电平；当计数器值大于或等于CCR中的值时，输出为高电平。<br>应用场景：用于产生相反极性的PWM信号。<br><br>TIM_ForcedAction_Active<br>作用：强制输出高电平，忽略计数器的比较操作。<br>应用场景：用于强制将输出设为高电平，通常用于紧急停止或强制触发信号。<br><br>TIM_ForcedAction_InActive<br>作用：强制输出低电平，忽略计数器的比较操作。<br>应用场景：用于强制将输出设为低电平，例如复位某些信号或设备。<br></code></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clz9aaxq20001ygfbdiol74ia","category_id":"clz9aaxq50003ygfb6efwbudn","_id":"clz9aaxqa000dygfb6j14cbym"},{"post_id":"clz9aaxq40002ygfbgdx5dy2c","category_id":"clz9aaxq80008ygfbenqlgo2s","_id":"clz9aaxqb000jygfbf9aac9um"},{"post_id":"clz9aaxqa000gygfb0bl52r8x","category_id":"clz9aaxq80008ygfbenqlgo2s","_id":"clz9aaxqd000pygfb6jco5ue5"},{"post_id":"clz9aaxq60005ygfbaq7s29hk","category_id":"clz9aaxqa000eygfb56ry3lxo","_id":"clz9aaxqe000tygfb5mslaowl"},{"post_id":"clz9aaxq70006ygfbh18o74eb","category_id":"clz9aaxqb000kygfb41n4ajve","_id":"clz9aaxqf000xygfb3fyobphe"},{"post_id":"clz9aaxq80007ygfbg5z5gi1j","category_id":"clz9aaxqa000eygfb56ry3lxo","_id":"clz9aaxqg0012ygfbctjp12bx"},{"post_id":"clz9aaxqf000vygfbdgmgalz0","category_id":"clz9aaxqb000kygfb41n4ajve","_id":"clz9aaxqh0016ygfb6wjxcb8g"},{"post_id":"clz9aaxq9000bygfb67xc7t64","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"clz9aaxqi001bygfb8o8b5skk"},{"post_id":"clz9aaxqh0013ygfb4xoogc9a","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"clz9aaxqj001dygfb4fj6c347"},{"post_id":"clz9aaxqa000cygfb5imo9s6d","category_id":"clz9aaxqa000eygfb56ry3lxo","_id":"clz9aaxqj001gygfb0cvt3pw5"},{"post_id":"clz9aaxqb000iygfbhawhdwgo","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"clz9aaxqj001jygfb5qyg7ogw"},{"post_id":"clz9aaxqc000mygfb55nsep1j","category_id":"clz9aaxqj001fygfbbrxwgas1","_id":"clz9aaxqk001oygfb4crr20r5"},{"post_id":"clz9aaxqd000sygfb7jibdf8e","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"clz9aaxql001uygfb57qa4pv8"},{"post_id":"clz9aaxqf000yygfb23s47znj","category_id":"clz9aaxqk001rygfbdugqgdz2","_id":"clz9aaxql001yygfbgg8r8tug"},{"post_id":"clz9aaxqg0011ygfbcoxve78n","category_id":"clz9aaxql001wygfb7cxggv0j","_id":"clz9aaxqm0023ygfbhwro78n3"},{"post_id":"clz9aaxqh0017ygfb6zza06ch","category_id":"clz9aaxql001wygfb7cxggv0j","_id":"clz9aaxqm0026ygfbbzjtan82"},{"post_id":"clz9aaxqi0019ygfb1w411dit","category_id":"clz9aaxqm0022ygfb7asbbzjh","_id":"clz9aaxqm0029ygfb5uf59k62"},{"post_id":"clz9aaxqp002gygfb7ahub0e1","category_id":"clz9aaxqp002hygfb2yep95qw","_id":"clz9aaxqq002kygfb0y8818e3"},{"post_id":"clzb8b8u90000tofb7hr06cac","category_id":"clz9aaxqp002hygfb2yep95qw","_id":"clzb8b8ud0002tofbfisr5lzb"},{"post_id":"clzc67ewo0000xofb63g641zq","category_id":"clz9aaxqp002hygfb2yep95qw","_id":"clzc67ewr0002xofb5ebqab4g"},{"post_id":"clzgwz9520000e0fb5yql89z8","category_id":"clz9aaxqp002hygfb2yep95qw","_id":"clzgwz9540003e0fbcazd8qq1"},{"post_id":"clzgwz9530002e0fb5wrj4o0f","category_id":"clz9aaxqp002hygfb2yep95qw","_id":"clzgwz9540005e0fbcw2p9lj2"},{"post_id":"clzl8eduf0000p4fbaoai3ohg","category_id":"clz9aaxqp002hygfb2yep95qw","_id":"clzl8edug0002p4fb72t8duqj"},{"post_id":"clzl8m0vz0000hsfb4m29cfoz","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"clzl8m0w30004hsfb3lxj7nk9"},{"post_id":"clzl8m0w10001hsfbfkc59sky","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"clzl8m0w30005hsfb86rh5nak"},{"post_id":"clzmh9t9t0000gsfbgtxabhdk","category_id":"clz9aaxqb000kygfb41n4ajve","_id":"clzmh9t9x0004gsfb8kj98psy"},{"post_id":"clzmh9t9w0002gsfb26xydqdu","category_id":"clz9aaxqp002hygfb2yep95qw","_id":"clzmh9t9y0009gsfbbvvjgg5d"},{"post_id":"clzmh9t9x0003gsfbf9cldd4v","category_id":"clz9aaxqb000kygfb41n4ajve","_id":"clzmh9t9y000agsfb847804sh"},{"post_id":"clzmh9t9x0006gsfbfr9md9j1","category_id":"clz9aaxqb000kygfb41n4ajve","_id":"clzmh9t9y000cgsfb3mr3hdz3"},{"post_id":"clzqyyajg0000b0fbh6a3hox1","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"clzqyyajm0004b0fb9dge3rgm"},{"post_id":"clzqyyaji0001b0fb9hu7euj0","category_id":"clzqyyajl0003b0fbhrqzav53","_id":"clzqyyajm0007b0fbe3q1dmpm"},{"post_id":"clzqyyajo0009b0fb1nj61y2l","category_id":"clzqyyajl0003b0fbhrqzav53","_id":"clzqyyajo000bb0fbfypier1n"},{"post_id":"clzrvyz0z0000kofbap828q5f","category_id":"clzqyyajl0003b0fbhrqzav53","_id":"clzrvyz120004kofb5smlgk85"},{"post_id":"clzrvyz110001kofbax5a7o8r","category_id":"clzqyyajl0003b0fbhrqzav53","_id":"clzrvyz120005kofbffq6g39a"},{"post_id":"clztv1uia0000sgfb3smg063r","category_id":"clztv1uid0001sgfb5uqah2gy","_id":"clztv1uif0003sgfbbl7ogg0v"},{"post_id":"cm0kedtpm0000psfbglhv2qu0","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"cm0kedtpt0002psfb5o3i6ehd"},{"post_id":"cm0kedtpu0004psfb47f332g3","category_id":"cm0kedtpv0005psfbdcxkctwu","_id":"cm0kedtpw0008psfbf8quefw8"},{"post_id":"cm0koeivp0000z0fbccm5c140","category_id":"cm0koeivs0002z0fb4aiw8tdv","_id":"cm0koeivv0006z0fbhukd4n63"},{"post_id":"cm0koeivr0001z0fb4m3527mw","category_id":"cm0koeivv0005z0fbg1jj91d1","_id":"cm0koeivv0007z0fb8py0aghk"},{"post_id":"cm0nnusxl0000ckfbgdhkf5c1","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"cm0nnusxs0003ckfbfbjtcx0t"},{"post_id":"cm0nnusxn0001ckfbfsbibjof","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"cm0nnusxs0004ckfb7xklg0gj"},{"post_id":"cm1zrdyqe0001p8fb859b6knp","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"cm1zrdyqk0008p8fb3i3qftu7"},{"post_id":"cm1zrdyqi0004p8fbcnxrbtzn","category_id":"clzqyyajl0003b0fbhrqzav53","_id":"cm1zrdyql000bp8fbhjma8z2s"},{"post_id":"cm1zrdyqj0006p8fbdw4a7dwz","category_id":"clz9aaxqf000wygfbfa6o0ea7","_id":"cm1zrdyql000cp8fbg3pz1bd2"},{"post_id":"cm1zrdyqb0000p8fb2fexh518","category_id":"cm1zrdyqf0002p8fba8sq0h26","_id":"cm1zrdyql000dp8fbast3hk72"}],"PostTag":[{"post_id":"clz9aaxq20001ygfbdiol74ia","tag_id":"clz9aaxq60004ygfbcqbn6erw","_id":"clz9aaxq9000aygfb4h6wb2jl"},{"post_id":"clz9aaxq40002ygfbgdx5dy2c","tag_id":"clz9aaxq80009ygfb1oswhtgw","_id":"clz9aaxqb000hygfb72718omb"},{"post_id":"clz9aaxq60005ygfbaq7s29hk","tag_id":"clz9aaxqa000fygfb6dqve2xr","_id":"clz9aaxqc000nygfbhmbp7gqa"},{"post_id":"clz9aaxq70006ygfbh18o74eb","tag_id":"clz9aaxqc000lygfb61tr5ctx","_id":"clz9aaxqf000uygfbb1f14395"},{"post_id":"clz9aaxq80007ygfbg5z5gi1j","tag_id":"clz9aaxqd000rygfbemoa2gv3","_id":"clz9aaxqg0010ygfbh79md4wz"},{"post_id":"clz9aaxq9000bygfb67xc7t64","tag_id":"clz9aaxqg000zygfb0hm2gxjm","_id":"clz9aaxqi0018ygfb1xcvc46t"},{"post_id":"clz9aaxqa000cygfb5imo9s6d","tag_id":"clz9aaxqh0015ygfb531r0dvm","_id":"clz9aaxqj001eygfb8yn833ur"},{"post_id":"clz9aaxqa000gygfb0bl52r8x","tag_id":"clz9aaxqi001cygfb9wy08x5t","_id":"clz9aaxqj001iygfbf1mdbfyx"},{"post_id":"clz9aaxqb000iygfbhawhdwgo","tag_id":"clz9aaxqj001hygfb4enmducj","_id":"clz9aaxqk001mygfb7itbdy8z"},{"post_id":"clz9aaxqc000mygfb55nsep1j","tag_id":"clz9aaxqk001lygfb8b02a909","_id":"clz9aaxqk001qygfb7thad026"},{"post_id":"clz9aaxqd000sygfb7jibdf8e","tag_id":"clz9aaxql001tygfb6k162gmt","_id":"clz9aaxql001zygfb82o61d32"},{"post_id":"clz9aaxqf000vygfbdgmgalz0","tag_id":"clz9aaxql001xygfb7bxi1xk3","_id":"clz9aaxqm0024ygfb4s4q5tob"},{"post_id":"clz9aaxqf000yygfb23s47znj","tag_id":"clz9aaxql0021ygfb3m5h2hp9","_id":"clz9aaxqm0027ygfbgha58j0f"},{"post_id":"clz9aaxqg0011ygfbcoxve78n","tag_id":"clz9aaxqm0025ygfb53xxdgb3","_id":"clz9aaxqm002aygfbekxd96th"},{"post_id":"clz9aaxqh0013ygfb4xoogc9a","tag_id":"clz9aaxqm0028ygfb9gmp9zhl","_id":"clz9aaxqm002cygfb1lky4md5"},{"post_id":"clz9aaxqh0017ygfb6zza06ch","tag_id":"clz9aaxqm002bygfbh14ddlrf","_id":"clz9aaxqn002eygfbbnya0t9f"},{"post_id":"clz9aaxqi0019ygfb1w411dit","tag_id":"clz9aaxqn002dygfbbh4wa1md","_id":"clz9aaxqn002fygfb1b6f6ifc"},{"post_id":"clz9aaxqp002gygfb7ahub0e1","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"clz9aaxqq002jygfbbswq4wgq"},{"post_id":"clzb8b8u90000tofb7hr06cac","tag_id":"clzb8b8ub0001tofb2tdn5yxm","_id":"clzb8b8ud0003tofb0lj0d8og"},{"post_id":"clzc67ewo0000xofb63g641zq","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"clzc67ewq0001xofb1p8y1clp"},{"post_id":"clzgwz9520000e0fb5yql89z8","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"clzgwz9530001e0fb6ausayic"},{"post_id":"clzgwz9530002e0fb5wrj4o0f","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"clzgwz9540004e0fb182n3qh8"},{"post_id":"clzl8eduf0000p4fbaoai3ohg","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"clzl8edug0001p4fbhwpk0zky"},{"post_id":"clzl8m0vz0000hsfb4m29cfoz","tag_id":"clz9aaxqk001pygfb0m7956q2","_id":"clzl8m0w30002hsfbaut85tfc"},{"post_id":"clzl8m0w10001hsfbfkc59sky","tag_id":"clz9aaxqk001pygfb0m7956q2","_id":"clzl8m0w30003hsfbdz15aut5"},{"post_id":"clzmh9t9w0002gsfb26xydqdu","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"clzmh9t9x0005gsfb19su07jt"},{"post_id":"clzmh9t9t0000gsfbgtxabhdk","tag_id":"clzmh9t9v0001gsfb8ew4hb27","_id":"clzmh9t9y0008gsfb4wa0f0d6"},{"post_id":"clzmh9t9x0003gsfbf9cldd4v","tag_id":"clzmh9t9y0007gsfb7rdy7i4b","_id":"clzmh9t9y000dgsfbemrd8npg"},{"post_id":"clzmh9t9x0006gsfbfr9md9j1","tag_id":"clzmh9t9y000bgsfbh9mi5qve","_id":"clzmh9t9y000egsfbg08uaxfv"},{"post_id":"clzqyyajg0000b0fbh6a3hox1","tag_id":"clzqyyajj0002b0fbcpidakdh","_id":"clzqyyajm0006b0fb18mrf2k3"},{"post_id":"clzqyyaji0001b0fb9hu7euj0","tag_id":"clzqyyajm0005b0fb7cp88gj7","_id":"clzqyyajm0008b0fb986jevf7"},{"post_id":"clzqyyajo0009b0fb1nj61y2l","tag_id":"clzqyyajm0005b0fb7cp88gj7","_id":"clzqyyajo000ab0fb0dmt4si2"},{"post_id":"clzrvyz0z0000kofbap828q5f","tag_id":"clzqyyajm0005b0fb7cp88gj7","_id":"clzrvyz120002kofb5gg59b8d"},{"post_id":"clzrvyz110001kofbax5a7o8r","tag_id":"clzqyyajm0005b0fb7cp88gj7","_id":"clzrvyz120003kofb2pa9aj86"},{"post_id":"clztv1uia0000sgfb3smg063r","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"clztv1uif0002sgfbagdah0df"},{"post_id":"cm0kedtpm0000psfbglhv2qu0","tag_id":"cm0kedtpq0001psfb51kn9268","_id":"cm0kedtpt0003psfb8k0w8a68"},{"post_id":"cm0kedtpu0004psfb47f332g3","tag_id":"cm0kedtpv0006psfbf4yy2icg","_id":"cm0kedtpv0007psfbcl889fik"},{"post_id":"cm0koeivp0000z0fbccm5c140","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"cm0koeivu0003z0fb3upcggxv"},{"post_id":"cm0koeivr0001z0fb4m3527mw","tag_id":"clz9aaxqp002iygfb1lykbnr9","_id":"cm0koeivv0004z0fbdtfh98pu"},{"post_id":"cm0nnusxl0000ckfbgdhkf5c1","tag_id":"cm0nnusxo0002ckfb746158ps","_id":"cm0nnusxs0006ckfbgjonhts0"},{"post_id":"cm0nnusxn0001ckfbfsbibjof","tag_id":"cm0nnusxs0005ckfb109ue9fo","_id":"cm0nnusxs0007ckfb3jowhc1y"},{"post_id":"cm1zrdyqe0001p8fb859b6knp","tag_id":"cm0nnusxo0002ckfb746158ps","_id":"cm1zrdyqj0005p8fbcdk52pn0"},{"post_id":"cm1zrdyqi0004p8fbcnxrbtzn","tag_id":"clzqyyajm0005b0fb7cp88gj7","_id":"cm1zrdyqj0007p8fbfe5yfdvh"},{"post_id":"cm1zrdyqb0000p8fb2fexh518","tag_id":"cm1zrdyqi0003p8fb20a4cl2r","_id":"cm1zrdyql000ap8fb15am59g5"},{"post_id":"cm1zrdyqj0006p8fbdw4a7dwz","tag_id":"cm1zrdyqk0009p8fb3buz36ch","_id":"cm1zrdyql000ep8fbhix9hyg4"}],"Tag":[{"name":"文献检索","_id":"clz9aaxq60004ygfbcqbn6erw"},{"name":"Markdown","_id":"clz9aaxq80009ygfb1oswhtgw"},{"name":"控制工程","_id":"clz9aaxqa000fygfb6dqve2xr"},{"name":"TCP","_id":"clz9aaxqc000lygfb61tr5ctx"},{"name":"无刷电机控制","_id":"clz9aaxqd000rygfbemoa2gv3"},{"name":"固件库","_id":"clz9aaxqg000zygfb0hm2gxjm"},{"name":"控制设计","_id":"clz9aaxqh0015ygfb531r0dvm"},{"name":"PPT","_id":"clz9aaxqi001cygfb9wy08x5t"},{"name":"中断函数","_id":"clz9aaxqj001hygfb4enmducj"},{"name":"Hi3861","_id":"clz9aaxqk001lygfb8b02a909"},{"name":"USART","_id":"clz9aaxqk001pygfb0m7956q2"},{"name":"Systick","_id":"clz9aaxql001tygfb6k162gmt"},{"name":"Linux","_id":"clz9aaxql001xygfb7bxi1xk3"},{"name":"Github_Pages","_id":"clz9aaxql0021ygfb3m5h2hp9"},{"name":"Gcode","_id":"clz9aaxqm0025ygfb53xxdgb3"},{"name":"GPIO","_id":"clz9aaxqm0028ygfb9gmp9zhl"},{"name":"3D打印机","_id":"clz9aaxqm002bygfbh14ddlrf"},{"name":"git","_id":"clz9aaxqn002dygfbbh4wa1md"},{"name":"C/C++","_id":"clz9aaxqp002iygfb1lykbnr9"},{"name":"Json","_id":"clzb8b8ub0001tofb2tdn5yxm"},{"name":"进程和线程","_id":"clzmh9t9v0001gsfb8ew4hb27"},{"name":"信号signal","_id":"clzmh9t9y0007gsfb7rdy7i4b"},{"name":"消息队列","_id":"clzmh9t9y000bgsfbh9mi5qve"},{"name":"DMA数据传输","_id":"clzqyyajj0002b0fbcpidakdh"},{"name":"Python","_id":"clzqyyajm0005b0fb7cp88gj7"},{"name":"I2C","_id":"cm0kedtpq0001psfb51kn9268"},{"name":"嵌入式","_id":"cm0kedtpv0006psfbf4yy2icg"},{"name":"SPI","_id":"cm0nnusxo0002ckfb746158ps"},{"name":"VScode","_id":"cm0nnusxs0005ckfb109ue9fo"},{"name":"DShot协议","_id":"cm1zrdyqi0003p8fb20a4cl2r"},{"name":"TIM","_id":"cm1zrdyqk0009p8fb3buz36ch"}]}}